Source,Name,Label,type
"contract CON1 {
address VAR1;
function FUN1(address VAR2, uint VAR3) {
require(VAR1==msg.sender);
VAR2.delegatecall(bytes4(keccak256(""setN(uint256)"")), VAR3);
}
}",50061.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1() {
VAR1 = msg.sender;
}
}
contract CON2 {
CON1 VAR2;
function FUN2() {
if(!VAR2.delegatecall(msg.data)) { throw; }
}
}",317.sol,1,delegatecall
"contract CON1 {
address public VAR1;
function FUN1() {
VAR1 = msg.sender;
}
}
contract CON2 {
CON1 VAR2;
function FUN2() {
if (msg.data.length > 0)
VAR2.delegatecall(msg.data);
}
}",51001.sol,1,delegatecall
"contract CON1{
function CON1(address VAR1) public {
uint256 VAR2 = 3 * 32;
uint256 VAR3 = 4 + VAR2;
bytes memory VAR4 = new bytes(VAR3);
require(VAR1.delegatecall(VAR4));
}
}",13012.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) {
VAR1.delegatecall(bytes4(keccak256(""setN(uint256)"")), VAR2);
}
}",50023.sol,1,delegatecall
"contract CON1 {
enum States {Closed}
struct Crowdsale {
uint256 VAR1;
bool VAR2;
States VAR3;
}
mapping(address => Crowdsale) public VAR4;
function FUN1(address VAR5) external {
require(block.timestamp >= VAR4[VAR5].VAR1);
VAR4[VAR5].VAR3 = States.Closed;
}
}",16.sol,0,delegatecall
"contract CON1 {
uint64 VAR1;
function FUN1() public {
uint64 VAR2 = uint64(block.timestamp);
require(VAR2 >= VAR1);
}
}",48.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1() {
VAR1 = msg.sender;
}
}
contract CON2 {
CON1 VAR2;
function FUN2() {
require(VAR2.delegatecall(msg.data));
}
}",51000.sol,1,delegatecall
"contract CON1 {
function FUN1() public {
assembly {
let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)
returndatacopy(0, 0, returndatasize)
}
}
}",1518.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public {
require(!VAR1.delegatecall(msg.data));
}
}",652.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes memory VAR2) public payable {
VAR1.delegatecall(VAR2);
}
}",50005.sol,1,delegatecall
"contract CON1 {
uint public VAR1;
function FUN1() external constant returns (uint256) {
if(VAR1 > block.timestamp)
return VAR1;
else
return 0;
}
}",38.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) external returns (bool VAR2) {
VAR2 = VAR1.delegatecall(bytes4(sha3(""address)"")), this);
return VAR2;
}
}",1138.sol,1,delegatecall
"contract CON1 {
function FUN1(bytes32 VAR1, uint VAR2) public returns(bytes32 VAR3) {
bool VAR4;
address VAR5 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR3 = bytes32(0x00);
assembly {
VAR4 := iszero(delegatecall(sub(gas, 10000), VAR5, VAR1, VAR2, VAR3, 0x20))
}
require(!VAR4);
}
}",22229.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() external FUN1 returns (uint) {
uint VAR2 = block.timestamp;
return VAR2;
}
}",77.sol,0,delegatecall
"contract CON1 {
uint VAR1 = 0;
function FUN1(uint256 VAR2) public returns (bool) {
require(VAR2 >= block.timestamp);
VAR1 = VAR2;
return true;
}
}",45.sol,0,delegatecall
"contract CON1 {
uint public VAR1 = 1499436000;
address public VAR2;
function FUN1() {
if (block.timestamp < VAR1) throw;
if (!VAR2.call.value(this.balance)()) throw;
}
}",42.sol,0,delegatecall
"contract CON1 {
function CON1(address VAR1) public {
VAR1.delegatecall(msg.data);
}
}",8304.sol,1,delegatecall
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (msg.sender.call.value(VAR2)()) {
return true;
} else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",14.sol,0,delegatecall
"contract CON1 {
function FUN1(bytes VAR1) external returns (bool VAR2) {
if (!address(this).delegatecall(VAR1)) {
return false;
}
return true;
}
}",50045.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes32 VAR2) {
if (VAR2=='') { throw; }
if (!VAR1.delegatecall(VAR2)){ throw; }
}
}",40204.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) public returns (bool){
bytes4 VAR2 = bytes4(keccak256(""inc(uint256)""));
return VAR1.delegatecall(VAR2, 2);
}
}",16372.sol,1,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2) FUN1 {
VAR2.delegatecall(msg.data);
}
}",50032.sol,0,delegatecall
"contract CON1 {
address VAR1 = 0x29999;
function FUN1(address VAR2) external {
require(VAR1 == msg.sender);
require(VAR2.delegatecall(bytes4(keccak256(""initialize()""))));
}
}",50033.sol,0,delegatecall
"contract CON1 {
address public VAR1;
uint public VAR2;
uint public VAR3;
bytes4 constant VAR4 = bytes4(sha3(""setFibonacci(uint256)""));
function FUN1() {
VAR3 += 1;
require(VAR1.delegatecall(VAR4, VAR3));
msg.sender.transfer(VAR2 * 1 ether);
}
}",50007.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}",4.sol,0,delegatecall
"contract CON1 {
address VAR1;
function FUN1(address VAR2) public returns (bool VAR3) {
require(VAR1==msg.sender);
if(VAR2.delegatecall(bytes4(keccak256(""execute(address)"")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}",50042.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public {
VAR1 = VAR2;
}
function FUN2() public {
VAR1.delegatecall(bytes4(keccak256(""callMeMaybe()"")));
}
}",50020.sol,1,delegatecall
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR2 = true;
}
}",31.sol,0,delegatecall
"contract CON1 {
struct Holder {
uint VAR1;
}
mapping (address => Holder) VAR2;
function FUN1() {
require(VAR2[msg.sender].VAR1 < block.timestamp);
VAR2[msg.sender].VAR1 = 0;
}
}",73.sol,0,delegatecall
"contract CON1 {
struct balanceData {
uint VAR1;
}
mapping(address => balanceData) VAR2;
function FUN1(address VAR3, uint VAR4) public constant returns (bool VAR5) {
if (block.timestamp < 1569974400) {
return false;
}
return true;
}
}",49.sol,0,delegatecall
"contract CON1{
mapping (address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3,uint256 VAR4) FUN1 public returns (bool) {
if(VAR4 > block.timestamp) {
VAR1[VAR3] = VAR4;
return true;
}
return false;
}
}",59.sol,0,delegatecall
"contract CON1{
address VAR1;
modifier FUN1{
require(VAR1 == msg.sender);
_;
}
function FUN2(address VAR2) external FUN1 {
assembly {
calldatacopy(0, 0, calldatasize())
let success := delegatecall(not(0), VAR2, 0, calldatasize, 0, 0)
returndatacopy(0, 0, returndatasize)
}
}
}",7066.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2, bytes VAR3) public {
require(VAR1==msg.sender);
assembly {
let result := delegatecall(sub(gas, 10000), VAR2, add(VAR3, 0x20), mload(VAR3), 0, 0)
switch result
case 0 { revert(0, returndatasize) }
default { return(0, returndatasize) }
}
}
}",50043.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) external {
bytes4 VAR2 = bytes4(keccak256(""setData()""));
require(VAR1.delegatecall(VAR2));
}
}",23694.sol,1,delegatecall
"contract CON1 {
mapping(address => bool) VAR1;
uint256 public VAR2;
function FUN1(address VAR3) external {
VAR1[VAR3] = true;
VAR2 = block.timestamp;
}
}",6.sol,0,delegatecall
"contract CON1 {
address VAR1;
modifier FUN1 {
require(msg.sender==VAR1);
_;
}
function FUN2(address VAR2, bytes VAR3) payable public FUN1 {
require(VAR2.delegatecall(VAR3));
}
}",50040.sol,0,delegatecall
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() public{
assert(msg.sender.call.value(VAR1[msg.sender])()) ;
VAR1[msg.sender] = 0;
}
}",56.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public {
require(VAR1.delegatecall(bytes4(keccak256(""callMeMaybe()""))));
}
}",22943.sol,1,delegatecall
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR2);
}
}",13.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1;
}",85.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public {
if( !VAR1.delegatecall(bytes4(sha3(""init()""))) ){ revert(); }
}
}",27767.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1,uint256 VAR2) public returns (bool) {
require(VAR1.delegatecall(bytes4(keccak256(""swap(uint256)"")), VAR2));
return true;
}
}",50041.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) public payable returns (bool) {
require(VAR1.call.value(msg.value)(VAR2));
return true;
}
}",7.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
function FUN1(address VAR3) {
require(VAR1==msg.sender);
VAR2=VAR3;
}
function FUN2(uint256 VAR4, uint256 VAR5) public {
VAR2.delegatecall(abi.encodeWithSignature(""add(uint256,uint256)"", VAR4, VAR5));
}
}",50034.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) {
VAR1.delegatecall.gas(VAR2)(VAR3);
}
}",26920.sol,1,delegatecall
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1() public payable {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.call.value(VAR2);
}
}",66.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1,bytes32 VAR2) public {
require(VAR1.delegatecall(VAR2));
}
}",50056.sol,1,delegatecall
"contract CON1{
mapping(address => uint) VAR1;
function FUN1(address VAR2) public {
require(VAR1[VAR2] >= msg.value);
VAR2.delegatecall(msg.value);
}
}",22139.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1,uint256 VAR2) public returns (bool) {
require(VAR1.delegatecall(bytes4(keccak256(""swap(uint256)"")), VAR2));
return true;
}
}",10674.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3) public returns (uint256) {
VAR1.delegatecall(abi.encodeWithSignature(""add(uint256,uint256)"", VAR2, VAR3));
}
}",50021.sol,1,delegatecall
"interface CON1 {
}
contract CON2 {
CON1 VAR1;
function FUN1() public {
if (VAR1.getTimeLeft() > 50) { revert(); }
address(VAR1).call.value(VAR1.getBuyPrice())();
}
}",57.sol,0,delegatecall
"contract CON1 {
function CON1(address VAR1, bytes32 VAR2) public {
require(VAR1 != address(0));
require(VAR1.delegatecall(VAR2));
}
}",13013.sol,1,delegatecall
"contract CON1 {
address VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, bytes calldata) public FUN1 returns (bool VAR3) {
return VAR2.delegatecall(calldata);
}
}",23089.sol,0,delegatecall
"contract CON1 {
function FUN1() public {
address VAR1;
bytes memory VAR2 = msg.data;
assembly {
let functionCallSize := mload(VAR2)
let functionCallDataAddress := add(VAR2, 0x20)
let functionCallResult := delegatecall(gas, VAR1, functionCallDataAddress, functionCallSize, 0, 0)
}
}
}",6044.sol,1,delegatecall
"contract CON1 {
}
contract CON2 {
uint256 public VAR1;
function FUN1 (address VAR2) external returns (uint256) {
VAR1 = block.timestamp;
return VAR1;
}
}",41.sol,0,delegatecall
"contract CON1 {
function FUN1() public {
address VAR1;
bytes memory VAR2 = msg.data;
assembly {
let functionCallSize := mload(VAR2)
let functionCallDataAddress := add(VAR2, 0x20)
let functionCallResult := delegatecall(gas, VAR1, functionCallDataAddress, functionCallSize, 0, 0)
let freeMemAddress := mload(0x40)
switch functionCallResult
case 0 {
revert(freeMemAddress, 0)
}
default {
return (freeMemAddress, returndatasize)
}
}
}
}",6043.sol,1,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
VAR1 = VAR3;
}
function FUN2() {
if(!VAR1.delegatecall(msg.data)) throw;
}
}",50028.sol,0,delegatecall
"contract CON1 {
address VAR1;
modifier FUN1 {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2,bytes VAR3) FUN1 {
require(VAR2.delegatecall(VAR3));
}
}",50067.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1() {
if (!VAR1.call.value(this.balance)()) throw;
}
}",81.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2) FUN1 {
if(!VAR2.delegatecall(msg.data)) { throw; }
}
}",50024.sol,0,delegatecall
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable {
require(block.timestamp < VAR2 && VAR1 > 0);
}
}",28.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public returns (bool) {
return VAR1.delegatecall(VAR2);
}
}",50038.sol,1,delegatecall
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public returns (uint256) {
uint64 VAR2 = uint64(block.VAR2);
require(VAR2 >= 1546300801);
return 0;
}
}",52.sol,0,delegatecall
"contract CON1 {
address VAR1 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR1.call.value(msg.value)());
}
}",19.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1 = 0;
}",74.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4) external payable returns (bool) {
return VAR1.call.value(VAR2).gas(VAR3)(VAR4);
}
}",79.sol,0,delegatecall
"contract CON1 {
address public VAR1;
mapping(address => uint256) public VAR2;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() public FUN1 returns (uint256) {
uint64 VAR3 = uint64(block.VAR3);
require(VAR3 >= 1546300801);
return VAR2[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}",69.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public {
assert(VAR1.call.value(this.balance)());
}
}",64.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes memory VAR2) public payable {
if(VAR2.length > 0) {
bool VAR3 = VAR1.delegatecall(VAR2);
require(VAR3);
}
}
}",33741.sol,1,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) payable {
if(!VAR1.call.value(msg.value)()) revert();
}
}",39.sol,0,delegatecall
"contract CON1 {
uint VAR1;
function FUN1() public returns (uint VAR2) {
while (VAR1 > block.timestamp) {
msg.sender.call.value(VAR2);
}
return VAR2;
}
}",46.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
if (msg.sender != VAR2) { throw; }
_;
}
function FUN2(address VAR3) public FUN1 {
VAR1 = VAR3;
}
function FUN3() {
if(!VAR1.delegatecall(msg.data)) throw;
}
}",653.sol,0,delegatecall
"contract CON1{
address public VAR1;
address public VAR2;
uint256 public VAR3 = 111111;
function FUN1(address VAR4) payable {
require(VAR1==msg.sender);
VAR2 = VAR4;
}
function FUN2() payable {
if(msg.value > VAR3) {
VAR2.delegatecall(bytes4(keccak256(""AddToWangDB(address)"")), msg.sender);
}
}
}",50065.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2) private returns(bool) {
if (VAR1 < VAR2) {
uint256 VAR3 = uint256(keccak256(abi.encodePacked((block.timestamp))));
return VAR3 > 0;
}
}
}",3.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2, bytes32 VAR3) {
require(VAR1==msg.sender);
if (VAR3=='') { throw; }
if (!VAR2.delegatecall(VAR3)){ throw; }
}
}",50068.sol,0,delegatecall
"contract CON1{
address public VAR1;
modifier FUN1 {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2)external payable FUN1 {
require(VAR2.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));
}
}",50035.sol,0,delegatecall
"contract CON1{
address public VAR1;
enum HowToCall { Call, DelegateCall }
function FUN1(address VAR2, HowToCall VAR3, bytes calldata) public returns (bool VAR4) {
require(VAR1==msg.sender);
if (VAR3 == HowToCall.DelegateCall) {
VAR4 = VAR2.delegatecall(calldata);
}
return VAR4;
}
}",50039.sol,0,delegatecall
"contract CON1 {
address VAR1;
modifier FUN1 {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2, bytes VAR3) external FUN1 returns (bool VAR4){
if (VAR2.delegatecall(VAR3)) {
return false;
}
return true;
}
}",50055.sol,0,delegatecall
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}",82.sol,0,delegatecall
"contract CON1{
address public VAR1;
address public VAR2;
function FUN1(address VAR3) {
require(VAR1 == msg.sender);
VAR2 = VAR3;
}
function FUN2() external {
bytes memory VAR4 = msg.VAR4;
VAR2.delegatecall(VAR4);
}
}",50022.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) payable {
require(VAR1==msg.sender);
if (msg.data.length > 0)
VAR2.delegatecall(msg.data);
}
}",50051.sol,0,delegatecall
"contract CON1 {
address VAR1;
address VAR2;
function FUN1(address VAR3) public {
require(msg.sender == VAR2);
VAR1 = VAR3;
}
function FUN2(bytes VAR4) public {
require(VAR1.delegatecall(VAR4));
}
}",12692.sol,0,delegatecall
"contract CON1 {
uint public VAR1 = 0;
function FUN1() public returns(uint){
VAR1 = block.timestamp;
return VAR1;
}
}",33.sol,0,delegatecall
"contract CON1{
uint256 public VAR1= 1000000000000000001;
function FUN1(address VAR2) payable public {
if(msg.value > VAR1){
VAR2.delegatecall(bytes4(sha3(""logEvent()"")));
}
}
}",50054.sol,1,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2, bytes32 VAR3) {
require(VAR1 == msg.sender);
VAR2.delegatecall(VAR3);
}
}",592.sol,0,delegatecall
"contract CON1 {
}
contract CON2 {
mapping (address => uint) VAR1;
function FUN1() public payable {
CON1 VAR2 = CON1(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR1[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}",58.sol,0,delegatecall
"contract CON1 {
uint public VAR1 = 10;
function FUN1(uint256 VAR2) public returns (uint) {
if(VAR1 > 1) {
require(VAR1 == 1);
} else {
VAR1 = block.timestamp;
}
return VAR1;
}
}",75.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, address VAR3) external returns(uint256) {
VAR1.delegatecall(abi.encodeWithSignature(""sellRewardForWeth(address,uint256,address)"", VAR1, VAR2, VAR3));
}
}",50003.sol,1,delegatecall
"contract CON1{
address VAR1;
function FUN1(address VAR2) external payable{
VAR1 = VAR2;
VAR1.delegatecall(msg.data);
}
}",9326.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) external {
assembly {
let results := delegatecall(gas, VAR1, 0, calldatasize, 0, 0)
returndatacopy(0, 0, returndatasize)
}
}
}",50006.sol,1,delegatecall
"contract CON1 {
mapping(bytes4 => address) public VAR1;
function FUN1() {
if (!VAR1[msg.sig].delegatecall(msg.data)) { throw; }
}
}",2025.sol,1,delegatecall
"contract CON1 {
uint64 public VAR1;
function FUN1() payable public {
if (VAR1 > 1514764800) {
require(VAR1 > block.timestamp);
}
}
}",1.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) {
require(VAR1.delegatecall(VAR2));
}
}",33930.sol,1,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender==VAR1);
_;
}
function FUN2(address VAR2) payable FUN1 {
if (msg.data.length > 0)
VAR2.delegatecall(msg.data);
}
}",50058.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public returns (bool) {
return VAR1.delegatecall(msg.data);
}
}",7003.sol,1,delegatecall
"contract CON1{
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
delete VAR1[VAR2];
if(!(VAR2.call.value(VAR3)())) throw;
}
}",36.sol,0,delegatecall
"contract CON1 {
address VAR1;
function FUN1(uint256 VAR2) public returns (bool) {
require(VAR1.delegatecall(bytes4(keccak256(""swap(uint256)"")), VAR2));
return true;
}
}",10675.sol,1,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2, bytes memory VAR3) public payable {
require(VAR1==msg.sender);
if(VAR3.length > 0) {
bool VAR4 = VAR2.delegatecall(VAR3);
require(VAR4);
}
}
}",50066.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external {
require(VAR1.call.VAR2(VAR2)(VAR3));
}
}",24.sol,0,delegatecall
"contract CON1 {
bytes4 constant VAR1 = bytes4(sha3(""set_start(uint256)""));
function FUN1(address VAR2, uint VAR3) {
VAR2.delegatecall(VAR1, VAR3);
}
}",50019.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) external {
require(VAR1.delegatecall(bytes4(keccak256(""initialize()""))));
}
}",2349.sol,1,delegatecall
"contract CON1 {
address VAR1;
address VAR2;
modifier FUN1 {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) public FUN1 {
VAR1 = VAR3;
}
function FUN3(bytes VAR4) public {
require(VAR1.delegatecall(VAR4));
}
}",510.sol,0,delegatecall
"contract CON1 {
mapping(address => TimeEnvoy) internal VAR1;
struct TimeEnvoy {
uint VAR2;
uint VAR3;
}
}",27.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public returns (bool){
require(VAR1==msg.sender);
bytes4 VAR3 = bytes4(keccak256(""inc(uint256)""));
return VAR2.delegatecall(VAR3, 2);
}
}",50049.sol,0,delegatecall
"contract CON1{
mapping(uint => address) VAR1;
function FUN1(uint VAR2, bytes32 VAR3) public {
VAR1[VAR2].delegatecall(VAR3);
}
}",3541.sol,1,delegatecall
"contract CON1 {
uint256 public VAR1;
}",23.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) payable public {
require(VAR1.delegatecall(VAR2));
}
}",10615.sol,1,delegatecall
"contract CON1 {
address VAR1;
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (msg.sender != VAR1) {
return false;
}
if (!address(this).delegatecall(VAR2)) {
return false;
}
return true;
}
}",13000.sol,0,delegatecall
"contract CON1 {
struct Crowdsale {
uint256 VAR1;
}
mapping(address => Crowdsale) public VAR2;
function FUN1(address VAR3) external {
require((block.timestamp >= VAR2[VAR3].VAR1));
}
}",11.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public payable {
VAR1.delegatecall(abi.encodeWithSignature(""setVars(uint256)"", VAR2));
}
}",50008.sol,1,delegatecall
"contract CON1 {
uint public VAR1 = 0;
function FUN1() external returns(bool){
assert(block.timestamp >= VAR1);
return true;
}
}",37.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2, bytes VAR3) public FUN1 {
assembly {
let result := delegatecall(sub(gas, 10000), VAR2, add(VAR3, 0x20), mload(VAR3), 0, 0)
}
}
}",50044.sol,0,delegatecall
"contract CON1 {
function FUN1(uint VAR1) public {
if (!address(this).delegatecall(0x21835af6, VAR1 - 1)) throw;
}
}",40433.sol,1,delegatecall
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns(uint256) {
assert(block.timestamp >= VAR1);
return VAR1;
}
}",54.sol,0,delegatecall
"contract CON1 {
function FUN1() public {
assembly {
let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)
switch result
case 0 { revert(0, returndatasize) }
default { return(0, returndatasize) }
}
}
}",1517.sol,0,delegatecall
"contract CON1 {
uint64 public VAR1 = 0;
function FUN1(uint256 VAR2) private {
if (block.timestamp <= VAR1) {
require(VAR2 == 0.64 ether);
}
else {
require(VAR2 == 0.99 ether);
}
}
}",55.sol,0,delegatecall
"contract CON1 {
address VAR1;
modifier FUN1 {
require(msg.sender==VAR1);
_;
}
function FUN2(address VAR2) public FUN1 {
require(VAR2.delegatecall(msg.data));
}
}",50026.sol,0,delegatecall
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable returns (bool){
require(block.timestamp < VAR2 && VAR1 > 0);
return true;
}
}",50.sol,0,delegatecall
"contract CON1 {
mapping (address => address) private VAR1;
modifier FUN1(){
require(VAR1[address(this)] != 0);
_;
}
function FUN2(address VAR2) FUN1 {
VAR1[address(this)] = VAR2;
}
function FUN3(address VAR3) public {
VAR1[VAR3] = VAR1[address(this)];
VAR1[VAR3].delegatecall(msg.data);
}
}",50012.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1 = 0;
function FUN1(uint256 VAR2) external returns (bool){
require(block.timestamp > VAR1);
require(VAR2 > 0);
return true;
}
}",71.sol,0,delegatecall
"contract CON1{
address public VAR1;
function FUN1(address VAR2) public {
require(VAR1==msg.sender);
if (msg.value > 0){
VAR2.delegatecall(msg.value);
} else {
revert();
}
}
}",50052.sol,0,delegatecall
"contract CON1 {
uint256 private VAR1;
function FUN1() public {
require(VAR1 < block.timestamp);
}
}",32.sol,0,delegatecall
"contract CON1 {
address VAR1 = msg.sender;
function FUN1(uint VAR2, address VAR3) payable {
if(msg.sender != address(this)) throw;
if(!VAR3.call.value(VAR2)()) { throw; }
}
}",34.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
uint256 public VAR3 = 10;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR4) payable FUN1 {
VAR2 = VAR4;
}
function FUN3(address VAR5) payable {
VAR5 = VAR2;
if(msg.value > VAR3) {
VAR5.delegatecall(bytes4(keccak256(""AddToWangDB(address)"")), msg.sender);
}
}
}",33425.sol,0,delegatecall
"contract CON1 {
function FUN1(uint VAR1) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ VAR1;
}
}",61.sol,0,delegatecall
"contract CON1{
function FUN1(address VAR1, bytes memory VAR2) public {
require(VAR1.delegatecall(VAR2));
}
}",22370.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) public returns (bool VAR2) {
if(VAR1.delegatecall(bytes4(keccak256(""execute(address)"")), VAR1)) {
VAR2 = true;
} else {
VAR2 = false;
}
}
}",10726.sol,1,delegatecall
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
require(block.timestamp >= VAR1);
return true;
}
}",67.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint256 VAR3, bytes VAR4) external FUN1 returns (bool){
return VAR2.call.value(VAR3)(VAR4);
}
}",30.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR3) public FUN1 {
VAR2 = VAR3;
}
function FUN3() public payable {
if(!VAR2.delegatecall(msg.data)) revert();
}
}",14070.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR2 = VAR1 <= block.timestamp;
return VAR2;
}
}",22.sol,0,delegatecall
"contract CON1 {
function FUN1() external payable {
address VAR1;
assembly {
let success := delegatecall(not(0), VAR1, 0, calldatasize, 0, 0)
switch success
case 0 { revert(0, returndatasize) }
default { return(0, returndatasize) }
}
}
}",2004.sol,1,delegatecall
"contract CON1{
uint256 public VAR1;
}",9.sol,0,delegatecall
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",51.sol,0,delegatecall
"contract CON1 {
struct Vesting {
uint256 VAR1;
}
mapping(address => Vesting) public VAR2;
}",80.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes memory VAR2) public payable {
if(VAR2.length > 0) {
bool VAR3 = VAR1.delegatecall(VAR2);
require(VAR3);
}
}
}",50000.sol,1,delegatecall
"contract CON1{
address VAR1;
function FUN1(address VAR2) external returns (bool VAR3) {
require(msg.sender==VAR1);
VAR3 = VAR2.delegatecall(bytes4(sha3(""address)"")), this);
return VAR3;
}
}",50029.sol,0,delegatecall
"contract CON1 {
enum HowToCall { DelegateCall }
function FUN1(address VAR1, HowToCall VAR2, bytes calldata) public returns (bool VAR3) {
if (VAR2 == HowToCall.DelegateCall) {
VAR3 = VAR1.delegatecall(calldata);
}
return VAR3;
}
}",9950.sol,1,delegatecall
"contract CON1 {
address public VAR1;
function FUN1() {
require(VAR1.call.value(this.balance)());
}
}",18.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) payable public {
require(address(this).balance >= VAR2);
require(address(this) != VAR1);
require(VAR1.call.value(VAR2)());
}
}",17.sol,0,delegatecall
"contract CON1 {
mapping (address=>uint256) public VAR1;
function FUN1() public payable {
if(VAR1[msg.sender] != 0) {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}
}",53.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) public {
if (msg.value > 0) {
VAR1.delegatecall(msg.value);
} else {
revert();
}
}
}",50059.sol,1,delegatecall
"contract CON1 {
uint256 public VAR1;
}",26.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public {
VAR1 = VAR2;
VAR1.delegatecall(bytes4(keccak256(""test()"")));
}
}",24277.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) {
VAR1.delegatecall(bytes4(keccak256(""setN(uint256)"")), VAR2);
}
}",22364.sol,1,delegatecall
"contract CON1 {
mapping (uint256 => address) public VAR1;
function FUN1() public payable{
if(msg.sender != VAR1[0]){
VAR1[0].call.value(msg.value).gas(600000)();
}
}
}",29.sol,0,delegatecall
"contract CON1 {
address VAR1;
function FUN1(address VAR2) {
require(VAR2 == msg.sender);
require(VAR2.delegatecall(msg.data));
}
}",50027.sol,0,delegatecall
"contract CON1 {
mapping (address => uint256) public VAR1;
uint256 public VAR2;
function FUN1 () external {
uint256 VAR3 = uint256(block.timestamp);
require (VAR3 > VAR2);
VAR1[msg.sender] = 0;
}
}",12.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) public {
require(VAR1.delegatecall(VAR2));
}
}",19032.sol,1,delegatecall
"contract CON1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.data.length > 0)
msg.sender.delegatecall(msg.data);
}
}",16637.sol,1,delegatecall
"contract CON1 {
uint256 constant public VAR1 = 1533686401;
function FUN1() public payable returns (bool VAR2) {
assert(block.timestamp >= VAR1);
return true;
}
}",76.sol,0,delegatecall
"contract CON1{
address public VAR1;
modifier FUN1 {
require(VAR1==msg.sender);
_;
}
function FUN2(address VAR2,bytes32 VAR3) public FUN1 {
require(VAR2.delegatecall(VAR3));
}
}",50047.sol,0,delegatecall
"contract CON1 {
address public VAR1 = msg.sender;
function FUN1(address VAR2,bytes VAR3) payable public {
require(msg.sender == VAR1);
VAR2.call.value(msg.value)(VAR3);
}
}",83.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
function FUN1(address VAR3) {
require(msg.sender==VAR1);
VAR2 = VAR3;
}
function FUN2() public returns (bool) {
bytes4 VAR4 = bytes4(keccak256(""inc(uint256)""));
return VAR2.delegatecall(VAR4,2);
}
}",50050.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender==VAR1);
_;
}
function FUN2(address VAR2, bool VAR3) external FUN1 {
if (VAR3) {
bytes memory VAR4 = abi.encodeWithSelector(0x4a99e3a1, VAR2);
VAR2.delegatecall(VAR4);
}
}
}",50017.sol,0,delegatecall
"contract CON1{
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",72.sol,0,delegatecall
"contract CON1 {
bool public VAR1;
address VAR2;
function FUN1() public payable {
if (!VAR2.call.value(msg.value)()) {
VAR1 = false;
} else {
VAR1 = true;
}
}
}",70.sol,0,delegatecall
"contract CON1 {
uint constant VAR1 = 1514402746;
function FUN1(address VAR2) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > VAR1);
return true;
}
}",5.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) external {
bytes4 VAR2 = bytes4(keccak256(""setData()""));
require(!VAR1.delegatecall(VAR2));
}
}",22613.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) internal {
require(VAR1.delegatecall(0xc4d66de8, VAR1), ""Proxiable::FUN1: failed"");
}
}",5732.sol,1,delegatecall
"contract CON1 {
uint256 public VAR1;
}",40.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) {
if (VAR1 != 0) {
VAR1.delegatecall(VAR2);
}
}
}",39979.sol,1,delegatecall
"contract CON1 {
struct Proposal{
uint256 VAR1;
uint256 VAR2;
}
Proposal public VAR3;
bool public VAR4 = false;
function FUN1(uint256 VAR2) external {
VAR3.VAR1 = block.VAR1;
VAR3.VAR2 = VAR2;
VAR4 = true;
}
}",65.sol,0,delegatecall
"contract CON1 {
}",35.sol,0,delegatecall
"contract CON1 {
mapping (address => uint256) public VAR1;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
function FUN1() public returns (bool) {
uint256 VAR4 = block.timestamp / (60*60*24*30*3);
if (VAR4 >= VAR3) {
VAR2 = VAR1[msg.sender];
}
return true;
}
}",20.sol,0,delegatecall
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
bool VAR3 = msg.sender.call.value(VAR2)();
require(VAR3);
}
}",43.sol,0,delegatecall
"contract CON1 {
address public VAR1;
mapping(uint=>address) VAR2;
function FUN1(uint VAR3, address VAR4) {
require(VAR1==msg.sender);
VAR2[VAR3]=VAR4;
}
function FUN2(uint VAR5, bytes32 VAR6) public {
VAR2[VAR5].delegatecall(VAR6);
}
}",50036.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public {
if (! VAR1.delegatecall(bytes4(keccak256(""setN(uint256)"")), VAR2)) revert();
}
}",50010.sol,1,delegatecall
"contract CON1 {
function FUN1() public payable {
address VAR1;
assembly {
let m := mload(0x40)
calldatacopy(m, 0, calldatasize)
let success := delegatecall(gas, VAR1, m, calldatasize, m, 0)
}
}
}",3124.sol,1,delegatecall
"contract CON1 {
uint256[2] internal VAR1;
address VAR2 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR3) public returns (bool) {
uint256 VAR4 = block.timestamp;
if (msg.sender == VAR2) {
VAR1[0] = VAR4;
}
return true;
}
}",62.sol,0,delegatecall
"contract CON1 {
address VAR1;
function FUN1(bytes VAR2) public {
require(VAR1.delegatecall(VAR2));
}
}",50025.sol,1,delegatecall
"contract CON1 {
uint256 constant public VAR1 = 1514764800;
function FUN1() public returns (uint16) {
if (block.timestamp < VAR1)
return 1000;
return 500;
}
}",84.sol,0,delegatecall
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
function FUN1(uint256 VAR3) external {
VAR2.VAR1 = block.VAR1;
}
}",60.sol,0,delegatecall
"contract CON1 {
function FUN1() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}",78.sol,0,delegatecall
"contract CON1{
function FUN1(address VAR1, uint VAR2) returns (bool) {
if (!VAR1.call.value(VAR2)()) revert();
return true;
}
}",25.sol,0,delegatecall
"contract CON1{
function FUN1(address VAR1) external {
bytes memory VAR2 = msg.VAR2;
VAR1.delegatecall(VAR2);
}
}",1831.sol,1,delegatecall
"contract CON1 {
function FUN1() public payable {
address VAR1;
assembly {
let m := mload(0x40)
let success := delegatecall(gas, VAR1, m, calldatasize, m, 0)
switch success
case 0 { revert(0, 0) }
default { return(m, 0) }
}
}
}",3123.sol,1,delegatecall
"contract CON1 {
uint public constant VAR1 = 1559347200;
function FUN1() constant returns (bool) {
return (block.timestamp < VAR1);
}
}",63.sol,0,delegatecall
"contract CON1 {
address VAR1;
bytes4 constant VAR2 = bytes4(keccak256(""setTime(uint256)""));
function FUN1(uint VAR3) public {
VAR1.delegatecall(VAR2, VAR3);
}
}",33727.sol,1,delegatecall
"contract CON1 {
function FUN1(bytes32 VAR1, uint VAR2, address VAR3) public {
VAR3.call.value(VAR2)(VAR1);
}
}",8.sol,0,delegatecall
"contract CON1 {
address public VAR1;
modifier FUN1{
require(VAR1==msg.sender);
_;
}
function FUN2() public FUN1 {
address VAR2;
bytes memory VAR3 = msg.data;
assembly {
let functionCallSize := mload(VAR3)
let functionCallDataAddress := add(VAR3, 0x20)
let functionCallResult := delegatecall(gas, VAR2, functionCallDataAddress, functionCallSize, 0, 0)
}
}
}",50037.sol,0,delegatecall
"contract CON1 {
address public VAR1;
address public VAR2;
function FUN1(address VAR3) {
require(VAR1==msg.sender);
VAR2 = VAR3;
}
function FUN2() public {
VAR2.delegatecall(bytes4(keccak256(""test()"")));
}
}",50069.sol,0,delegatecall
"contract CON1 {
address VAR1 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR2 = 1111;
function FUN1() payable public {
if(msg.value > VAR2) {
VAR1.delegatecall(bytes4(sha3(""logEvent()"")));
}
}
}",30357.sol,0,delegatecall
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint) {
require(block.timestamp > VAR1);
require(VAR2 > 0);
return VAR2;
}
}",10.sol,0,delegatecall
"contract CON1{
address public VAR1;
function FUN1(address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5, uint256 VAR6) public returns (bool VAR7) {
require(VAR1==msg.sender);
return VAR2.delegatecall(bytes4(sha3(""functionOne(uint256,uint256,uint256,uint256)"")), VAR3, VAR4, VAR5, VAR6);
}
}",50062.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public payable {
require(VAR1==msg.sender);
if(!VAR2.delegatecall(msg.data)) revert();
}
}",50048.sol,0,delegatecall
"contract CON1 {
mapping (address => bool) VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint256) public VAR3;
function FUN1(address VAR4) external returns (bool){
require(block.timestamp >= VAR3[VAR4]);
VAR2[VAR4] = 0;
VAR3[VAR4] = 0;
return true;
}
}",2.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1) external payable{
require(VAR1.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));
}
}",5438.sol,1,delegatecall
"contract CON1 {
mapping (address => uint) VAR1;
uint constant VAR2 = 1596067200;
function FUN1() {
if (block.timestamp < VAR2) throw;
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
}
}",68.sol,0,delegatecall
"contract CON1{
address public VAR1;
function FUN1(address VAR2) external {
require(VAR1==msg.sender);
bytes memory VAR3 = msg.VAR3;
VAR2.delegatecall(VAR3);
}
}",50031.sol,0,delegatecall
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public {
require(msg.sender==VAR1);
if(!VAR2.delegatecall(bytes4(sha3(""init()""))) ){ revert(); }
}
}",50063.sol,0,delegatecall
"contract CON1 {
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if(!(VAR2.call.value(VAR3)())) throw;
}
}",21.sol,0,delegatecall
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3) public {
VAR1.delegatecall(abi.encodeWithSignature(""add(uint256,uint256)"", VAR2, VAR3));
}
}",2350.sol,1,delegatecall
"contract CON1 {
function FUN1(address VAR1) public payable returns(bool){
if(!VAR1.delegatecall(msg.data)){
return false;
}
else{
return true;
}
}
}",50057.sol,1,delegatecall
"contract CON1 {
uint public VAR1;
enum State { PreFunding, Funding}
function FUN1() public constant returns (State) {
if (block.timestamp < VAR1) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}",47.sol,0,delegatecall
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
}",50445.sol,0,Integeroverflow
"contract CON1{
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",39151.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1,bytes VAR2) payable public {
VAR1.call.value(msg.value)(VAR2);
}
}",50001.sol,0,Integeroverflow
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
function FUN1() public returns (uint256) {
uint256 VAR3 = VAR1 + block.timestamp;
VAR2 = VAR3 + VAR1;
return VAR2;
}
}",2253.sol,1,Integeroverflow
"contract CON1 {
bool public VAR1;
address VAR2;
function FUN1() public payable {
if (!VAR2.call.value(msg.value)()) {
VAR1 = false;
} else {
VAR1 = true;
}
}
}",3211.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable {
require(block.timestamp < VAR2 && VAR1 > 0);
}
}",3654.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
mapping (address => uint256) public VAR2;
function FUN1() public {
require(block.timestamp >= 60);
VAR2[msg.sender] -= VAR1;
}
}",35358.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint256) VAR1;
uint256 public VAR2;
function FUN1() {
if (msg.sender.call.value(VAR1[msg.sender])()) {
VAR2 -= VAR1[msg.sender];
VAR1[msg.sender] = 0;
}
}
}",40770.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) payable public {
require(VAR2.call.value(VAR3)(VAR4));
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
}
}",40748.sol,1,Integeroverflow
"contract CON1 {
}
contract CON2 {
mapping (address => uint) VAR1;
function FUN1() public payable {
CON1 VAR2 = CON1(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR1[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}",5629.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
if (msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] = 0;
return true;
} else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",50013.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) payable public {
require(address(this).balance >= VAR2);
require(address(this) != VAR1);
require(VAR1.call.value(VAR2)());
}
}",14620.sol,0,Integeroverflow
"contract CON1 {
uint256 VAR1;
address VAR2;
uint256 VAR3;
function FUN1(uint256 VAR4) {
uint256 VAR5 = VAR4 * VAR3;
VAR1 -= VAR5;
if(!VAR2.call.value(VAR5)()) throw;
}
}",40249.sol,1,Integeroverflow
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
uint VAR3;
function FUN1() returns (uint256) {
for (VAR3 = 0; VAR3 < VAR2 % 5; VAR3++){
VAR1 = VAR1 - block.timestamp;
}
return VAR1;
}
}",40005.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint256){
uint VAR3 = block.timestamp;
VAR2 = VAR3 + VAR1;
return VAR2;
}
}",9230.sol,1,Integeroverflow
"contract CON1 {
address public VAR1 = msg.sender;
function FUN1(address VAR2,bytes VAR3) payable public {
require(msg.sender == VAR1);
VAR2.call.value(msg.value)(VAR3);
}
}",31497.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1 ;
mapping (address => uint) VAR2;
function FUN1() public returns (bool) {
require(msg.sender.call.value(VAR1)());
VAR2[msg.sender] = VAR2[msg.sender].sub(VAR1);
return true;
}
}",50660.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint VAR1 = 0;
function FUN1(uint VAR2) returns (uint){
VAR1 = VAR1.FUN1(VAR2);
return VAR1;
}
}",50337.sol,0,Integeroverflow
"contract CON1{
uint public VAR1 = 1533364469;
function FUN1(uint256 VAR2, uint256 VAR3) returns (uint256) {
require(block.timestamp <= VAR1);
return VAR3 - VAR2;
}
}",1825.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
uint public VAR2;
uint constant public VAR3 = 3 hours;
uint public VAR4;
uint public VAR5 = 8 days;
function FUN1() internal returns (uint){
VAR1 = block.timestamp;
VAR2 = VAR1 + VAR3;
VAR4 = VAR2 + VAR5;
return VAR4;
}
}",14711.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
enum State {PreFunding, Failure}
function FUN1() public constant returns (State) {
if (block.timestamp < VAR1)
return State.PreFunding;
else
return State.Failure;
}
}",44.sol,0,Integeroverflow
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) { revert(); }
}
}",38057.sol,1,Integeroverflow
"contract CON1 {
function FUN1(bytes32 VAR1, uint VAR2, address VAR3) public {
VAR3.call.value(VAR2)(VAR1);
}
}",2307.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
require(block.timestamp >= VAR1);
return true;
}
}",650.sol,0,Integeroverflow
"interface CON1 {
}
contract CON2 {
CON1 VAR1;
function FUN1() public {
if (VAR1.getTimeLeft() > 50) { revert(); }
address(VAR1).call.value(VAR1.getBuyPrice())();
}
}",3270.sol,0,Integeroverflow
"contract CON1 {
mapping(address => TimeLock[2]) public VAR1;
struct TimeLock {
uint256 VAR2;
uint256 VAR3;
}
uint VAR4 = 100;
uint VAR5 = 100;
function FUN1(address VAR6) private {
if (VAR1[VAR6][0].VAR2 < block.timestamp) {
VAR5 = VAR5 + (VAR1[VAR6][0].VAR3);
}
else {
VAR4 = VAR4 + (VAR1[VAR6][1].VAR3);
}
}
}",211.sol,1,Integeroverflow
"contract CON1 {
struct Vesting {
uint256 VAR1;
}
mapping(address => Vesting) public VAR2;
}",625.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) external returns (uint) {
VAR1 = VAR1 + VAR2;
return VAR1;
}
}",42.sol,1,Integeroverflow
"contract CON1 {
uint256 private VAR1 = 0;
function FUN1() public {
if (VAR1 > 0) {
uint256 VAR2 = VAR1;
VAR1 = 0;
if (!msg.sender.call.value(VAR2)()) { throw; }
}
}
}",40425.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public returns (bool VAR5) {
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
msg.sender.call.value(VAR3)(VAR4);
return true;
}
}",19925.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1(uint VAR2) public {
if(!msg.sender.call.value(VAR2)()) { throw; }
VAR1[msg.sender] -= VAR2;
}
}",40746.sol,1,Integeroverflow
"contract CON1 {
uint256 VAR1;
address VAR2;
address VAR3;
modifier FUN1() {
if (VAR3 != msg.sender) throw;
_;
}
function FUN2(uint256 VAR4) FUN1 {
VAR1 -= VAR4;
if(!VAR2.call.value(VAR4)()) throw;
}
}",40353.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() public{
assert(msg.sender.call.value(VAR1[msg.sender])()) ;
VAR1[msg.sender] = 0;
}
}",16925.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3, byte VAR4) returns (bool) {
if (VAR1[VAR2] != 0) {
VAR2.call.VAR3(VAR3)(VAR4);
VAR1[VAR2] -= VAR3;
return true;
}
}
}",40499.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2 = 0;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public FUN1 returns (uint) {
uint VAR4 = VAR1[msg.sender] / 100;
require(msg.sender.call.value(VAR4)());
VAR1[msg.sender] -= VAR4;
VAR2 += VAR4;
return VAR2;
}
}",50007.sol,1,Integeroverflow
"contract CON1{
mapping (address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3,uint256 VAR4) FUN1 public returns (bool) {
if(VAR4 > block.timestamp) {
VAR1[VAR3] = VAR4;
return true;
}
return false;
}
}",4523.sol,0,Integeroverflow
"contract CON1 {
function FUN1() returns (uint256 VAR1) {
uint256 VAR2 = 0;
return VAR2 - 1;
}
}",4.sol,1,Integeroverflow
"contract CON1 {
uint constant VAR1 = 1514402746;
function FUN1(address VAR2) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > VAR1);
return true;
}
}",30815.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
function FUN1() public {
require(block.timestamp >= VAR1);
msg.sender.transfer(this.balance);
}
}",50221.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint VAR3, bytes VAR4) public returns (bool) {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
assert(msg.sender.call.value(VAR3)());
return true;
}
}",6603.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 1 ether;
mapping(address => uint256) public VAR2;
function FUN1 (uint256 VAR3) public {
require(VAR3 <= VAR1);
require(msg.sender.call.value(VAR3)());
VAR2[msg.sender] -= VAR3;
}
}",40754.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
}",170.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 10;
}",948.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
mapping (address => uint) VAR2;
function FUN1( address VAR3, uint256 VAR4) public {
require(VAR3.call.value(VAR4)());
VAR2[VAR3] -= VAR4;
}
}",18509.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1 = 20120;
uint VAR2 = 86400;
}",1319.sol,1,Integeroverflow
"contract CON1 {
mapping(address => mapping (address => uint32)) VAR1;
function FUN1(address VAR2, address VAR3) {
uint32 VAR4 = VAR1[VAR2][VAR3];
VAR1[VAR2][VAR3] = 0;
if (!VAR3.call.value(VAR4).gas(23000)()) { throw; }
}
}",39644.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1() public payable {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.call.value(VAR2);
}
}",26188.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public payable {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR2);
}
}
}
}",50779.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 0;
function FUN1() public returns(uint){
VAR1 = block.timestamp;
return VAR1;
}
}",11931.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint256) public VAR1;
function FUN1(uint VAR2) public {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}",40780.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2) returns (bool) {
if (VAR1[msg.sender] == 0){ throw; }
if (VAR2.call.value(VAR1[msg.sender])()) {
VAR1[msg.sender] = 0;
return true;
}
}
}",40753.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(uint256 VAR2) public returns (bool) {
VAR1[msg.sender] = VAR1[msg.sender] - VAR2;
return true;
}
}",29409.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
uint public VAR2;
uint constant public VAR3 = 3 hours;
uint public VAR4;
uint public VAR5 = 8 days;
function FUN1() internal returns (uint){
VAR1 = block.timestamp;
VAR2 = VAR1.add(VAR3);
VAR4 = VAR2.add(VAR5);
return VAR4;
}
}",50770.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
uint constant VAR2 = 1596067200;
function FUN1() {
if (block.timestamp < VAR2) throw;
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
}
}",39095.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 8;
uint256 public VAR2 = 0;
}",10369.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1.add(VAR3);
return VAR2;
}
}",50550.sol,0,Integeroverflow
"contract CON1 {
mapping (address => address) public VAR1;
function () payable {
if (VAR1[msg.sender] != 0) {
if (!VAR1[msg.sender].call.value(msg.value)()) throw;
}
}
}",39684.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint) public VAR1;
uint public VAR2;
function FUN1() {
uint VAR3 = VAR1[msg.sender];
if (msg.sender.call.value(VAR3)()) {
VAR2 = VAR2.sub(VAR3);
VAR1[msg.sender] = 0;
}
}
}",50786.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}",17043.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) public payable {
if(VAR1[VAR2] >= VAR3) {
VAR2.call.value(VAR3)();
VAR1[VAR2] -= VAR3;
}
}
}",26742.sol,0,Integeroverflow
"contract CON1 {
uint256[2] internal VAR1;
address VAR2 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR3) public returns (bool) {
uint256 VAR4 = block.timestamp;
if (msg.sender == VAR2) {
VAR1[0] = VAR4;
}
return true;
}
}",2397.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
function FUN1() {
require(VAR1.call.value(this.balance)());
}
}",14353.sol,0,Integeroverflow
"contract CON1 {
address VAR1 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR1.call.value(msg.value)());
}
}",4598.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
mapping(address => uint256) public VAR2;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() public FUN1 returns (uint256) {
uint64 VAR3 = uint64(block.VAR3);
require(VAR3 >= 1546300801);
return VAR2[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}",738.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() public returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1.add(60);
VAR3 = VAR1.add(120);
return VAR3.add(VAR2).add(VAR1);
}
}",50558.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 1 ether;
mapping(address => uint256) public VAR2;
function FUN1 (uint256 VAR3) public {
require(msg.sender.call.value(VAR3)());
VAR2[msg.sender] -= VAR3;
}
}",40736.sol,1,Integeroverflow
"contract CON1 {
struct Holder {
uint VAR1;
}
mapping (address => Holder) VAR2;
function FUN1() {
require(VAR2[msg.sender].VAR1 < block.timestamp);
VAR2[msg.sender].VAR1 = 0;
}
}",38925.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
function FUN1() {
if (!VAR1.call.value(this.balance)()) throw;
}
}",6192.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR2 = true;
}
}",30337.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
function FUN1(uint VAR1, uint VAR2) public returns (uint) {
uint VAR3 = block.timestamp.add(VAR1);
uint VAR4 = VAR3.add(VAR2);
return VAR4;
}
}",50666.sol,0,Integeroverflow
"contract CON1 {
uint VAR1;
function FUN1() public returns (uint VAR2) {
while (VAR1 > block.timestamp) {
msg.sender.call.value(VAR2);
}
return VAR2;
}
}",318.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) payable {
if(!VAR1.call.value(msg.value)()) revert();
}
}",35713.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public returns (uint256) {
uint256 VAR4 = uint256(VAR1[VAR3]);
uint256 VAR5 = uint256(block.timestamp).sub(uint256(VAR2[VAR3]));
if (VAR5 > VAR4) {
VAR5 = VAR4;
}
return 0;
}
}",50557.sol,0,Integeroverflow
"contract CON1 {
uint64 public VAR1 = 0;
function FUN1(uint256 VAR2) private {
if (block.timestamp <= VAR1) {
require(VAR2 == 0.64 ether);
}
else {
require(VAR2 == 0.99 ether);
}
}
}",124.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
mapping (address => uint) VAR2;
function FUN1( address VAR3, uint256 VAR4) public {
require(VAR4 <= VAR1);
require(VAR3.call.value(VAR4)());
VAR2[VAR3] = VAR2[VAR3].sub(VAR4);
}
}",50774.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 4000;
uint256 public VAR2 = 1539129600;
}",12292.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
require(VAR2 > 0);
bool VAR3 = msg.sender.call.value(VAR2)();
VAR1[msg.sender] = 0;
}
}",50021.sol,0,Integeroverflow
"contract CON1 {
mapping (uint256 => address) public VAR1;
function FUN1() public payable{
if(msg.sender != VAR1[0]){
VAR1[0].call.value(msg.value).gas(600000)();
}
}
}",16643.sol,0,Integeroverflow
"contract CON1 {
uint256 constant public VAR1 = 1532260800;
uint256 VAR2 = 100;
}",7570.sol,0,Integeroverflow
"contract CON1 {
function FUN1() public {
uint256 VAR1 = address(this).balance * 40;
uint256 VAR2 = address(this).balance - VAR1;
assert(address(this).call.value(VAR2)());
}
}",21241.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4 + 365*24*60*60;
assert(VAR5 > VAR4);
VAR1[VAR2] = VAR5;
}
}",34442.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(msg.sender.call.value(VAR2)()){
VAR1[msg.sender] -= VAR2;
}
}
}",29089.sol,1,Integeroverflow
"contract CON1 {
uint256 constant public VAR1 = 1514764800;
function FUN1() public returns (uint16) {
if (block.timestamp < VAR1)
return 1000;
return 500;
}
}",32175.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable returns (bool){
require(block.timestamp < VAR2 && VAR1 > 0);
return true;
}
}",496.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint) public VAR3;
function FUN1(address VAR4, address VAR5) public {
require(VAR3[msg.sender] == 1 || block.timestamp >= 60);
VAR2[msg.sender] = VAR2[msg.sender].sub(VAR1);
}
}",50785.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint256){
uint VAR3 = block.timestamp;
VAR2 = VAR3.add(VAR1);
return VAR2;
}
}",50665.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() public returns (uint256){
uint256 VAR3 = block.timestamp - VAR1;
if (VAR3 > 10) {
VAR3 = 10;
}
VAR2 = VAR3;
return VAR2;
}
}",5142.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint) {
require(block.timestamp > VAR1);
require(VAR2 > 0);
return VAR2;
}
}",4993.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 ;
mapping (address => uint) VAR2;
function FUN1() public returns (bool) {
require(msg.sender.call.value(VAR1)());
VAR2[msg.sender] = VAR2[msg.sender] - VAR1;
return true;
}
}",4832.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3) returns (bool) {
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
VAR1[VAR2] = VAR1[VAR2].add(VAR3);
if (!msg.sender.call.value(VAR3)()) revert();
return true;
}
}",50782.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
}",538.sol,0,Integeroverflow
"contract CON1 {
uint VAR1 = 0;
uint VAR2 = 100;
address public VAR3;
function FUN1() payable public {
uint256 VAR4 = VAR2 - VAR1;
if(!VAR3.call.value(VAR4).gas(400000)()) {
VAR1 = VAR1 - VAR4;
}
}
}",14284.sol,1,Integeroverflow
"contract CON1 {
}
contract CON2 {
uint256 public VAR1;
function FUN1 (address VAR2) external returns (uint256) {
VAR1 = block.timestamp;
return VAR1;
}
}",666.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) public payable returns (bool) {
require(VAR1.call.value(msg.value)(VAR2));
return true;
}
}",1430.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2) public FUN1 returns(uint){
uint VAR3 = (block.timestamp % 100) + 55566600;
return VAR3;
}
}",3554.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if(!(VAR2.call.value(VAR3)())) throw;
}
}",35661.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
uint public constant VAR2 = 1 days;
uint256 public VAR3;
function FUN1() public constant returns(uint) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4.sub(VAR1);
uint VAR6 = (VAR5 / (VAR2)).add(1);
return VAR6.mul(2);
}
}",50668.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) internal {
require(VAR2.call.value(VAR3)(VAR4));
VAR1[VAR2] = VAR1[VAR2] - VAR3;
}
}",6606.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
enum State { PreFunding, Funding}
function FUN1() public constant returns (State) {
if (block.timestamp < VAR1) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}",1288.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint) public VAR1;
uint public VAR2;
function FUN1() {
uint VAR3 = VAR1[msg.sender];
if (msg.sender.call.value(VAR3)()) {
VAR2 -= VAR3;
VAR1[msg.sender] = 0;
}
}
}",37707.sol,1,Integeroverflow
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
uint256 constant VAR3 = 7 days;
function FUN1(bool VAR4) external {
require((block.VAR1 - VAR2.VAR1) <= VAR3);
}
}",136.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
mapping (address => bool) VAR2;
function FUN1(uint VAR3) public {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] -= VAR3;
msg.sender.call.value(VAR3)();
}
}",17829.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR2 = true;
}
}",40089.sol,0,Integeroverflow
"contract CON1{
using SafeMath for uint;
uint public VAR1 = 1533364469;
function FUN1(uint256 VAR2, uint256 VAR3) returns (uint256) {
require(block.timestamp <= VAR1);
return VAR3.sub(VAR2);
}
}",50554.sol,0,Integeroverflow
"contract CON1 {
}",1813.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
function FUN1() external constant returns (uint256) {
if(VAR1 > block.timestamp)
return VAR1;
else
return 0;
}
}",21404.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
uint public VAR2 = 1 ether;
function FUN1(uint VAR3) public payable {
if(VAR1[msg.sender] >= VAR2) {
msg.sender.call.value(VAR3);
VAR1[msg.sender] -= VAR3;
}
}
}",22074.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
mapping (address => uint) public VAR2;
}",50449.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public payable {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}
}",22247.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint256;
mapping(address => uint256) VAR1;
function FUN1(address VAR2, uint256 VAR3) public returns (bool){
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
VAR1[VAR2] = VAR1[VAR2].add(VAR3);
return true;
}
}",2000.sol,0,Integeroverflow
"contract CON1 {
function FUN1() returns (uint256 VAR1) {
uint256 VAR2 = 2**256 - 1;
return VAR2 + 1;
}
}",3.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) public payable {
if(VAR1[VAR2] > 0) {
if(VAR2.call.value(VAR3)()) {
VAR1[VAR2] -= VAR3;
}
}
}
}",22416.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
function FUN1() public constant returns (uint) {
uint VAR2 = block.timestamp - VAR1;
uint VAR3 = VAR2 + 1;
if (VAR3 < 1000) {
return VAR3 * 5000 * 10;
}
return 0;
}
}",9208.sol,1,Integeroverflow
"contract CON1 {
struct Energy {
uint VAR1;
}
mapping(address => Energy) VAR2;
uint public VAR3 = 60 * 20;
function FUN1(address VAR4) constant external returns(uint) {
Energy storage VAR5 = VAR2[VAR4];
uint VAR6 = block.timestamp + VAR5.VAR1;
uint VAR7 = VAR6 * VAR3;
if (VAR7 > VAR3)
VAR7 = VAR3;
return VAR7;
}
}",7593.sol,1,Integeroverflow
"contract CON1 {
uint64 VAR1;
function FUN1() external returns (uint64){
uint64 VAR2 = uint64(block.timestamp);
VAR1 = VAR2 + 21600;
return VAR1;
}
}",12894.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) external returns (bool){
VAR2[VAR3] = block.timestamp;
VAR1[VAR3] = VAR1[VAR3].add(66666666);
return true;
}
}",50661.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping (address => uint) public VAR4;
function FUN1() {
if (VAR3 <= VAR2) throw;
uint256 VAR5 = VAR3 - VAR2;
if (!VAR1.call.value(VAR5)()) throw;
VAR3 -= VAR5;
VAR4[VAR1] -= VAR5;
}
}",39778.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public returns (uint256) {
int256 VAR4 = int256(VAR1[VAR3]);
int256 VAR5 = int256(block.timestamp) - int256(VAR2[VAR3]);
if (VAR5 > VAR4) {
VAR5 = VAR4;
}
return 0;
}
}",2399.sol,1,Integeroverflow
"contract CON1 {
mapping (address=>uint256) public VAR1;
function FUN1() public payable {
if(VAR1[msg.sender] != 0) {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}
}",24161.sol,0,Integeroverflow
"contract CON1 {
function FUN1(uint256 VAR1) {
bool VAR2 = msg.sender.call.value(VAR1)();
if (!VAR2) { throw; }
}
}",40413.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 0;
function FUN1() external returns(bool){
assert(block.timestamp >= VAR1);
return true;
}
}",1668.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3) returns (bool) {
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
if (!msg.sender.call.value(VAR3)()) revert();
return true;
}
}",24648.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",30101.sol,0,Integeroverflow
"contract CON1 {
mapping(address => TimeEnvoy) internal VAR1;
struct TimeEnvoy {
uint VAR2;
uint VAR3;
}
}",4926.sol,0,Integeroverflow
"contract CON1 {
function FUN1(uint VAR1, uint VAR2) public returns (uint) {
uint VAR3 = block.timestamp + VAR1;
uint VAR4 = VAR3 + VAR2;
return VAR4;
}
}",9850.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 private VAR1;
uint256 private VAR2;
function FUN1() public returns (uint256) {
uint256 VAR3 = VAR1.add(block.timestamp);
VAR2 = VAR3.add(VAR1);
return VAR2;
}
}",50555.sol,0,Integeroverflow
"contract CON1 {
function FUN1() public returns (uint){
uint VAR1 = block.timestamp - 202110;
return VAR1;
}
}",21162.sol,1,Integeroverflow
"contract CON1{
function FUN1(address VAR1, uint VAR2) returns (bool) {
if (!VAR1.call.value(VAR2)()) revert();
return true;
}
}",32522.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => TimeLock[2]) public VAR1;
struct TimeLock {
uint256 VAR2;
uint256 VAR3;
}
uint VAR4 = 100;
uint VAR5 = 100;
function FUN1(address VAR6) private {
if (VAR1[VAR6][0].VAR2 < block.timestamp) {
VAR5 = VAR5.add(VAR1[VAR6][0].VAR3);
}
else {
VAR4 = VAR4.add(VAR1[VAR6][1].VAR3);
}
}
}",50442.sol,0,Integeroverflow
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",8872.sol,0,Integeroverflow
"contract CON1 {
enum States {Closed}
struct Crowdsale {
uint256 VAR1;
bool VAR2;
States VAR3;
}
mapping(address => Crowdsale) public VAR4;
function FUN1(address VAR5) external {
require(block.timestamp >= VAR4[VAR5].VAR1);
VAR4[VAR5].VAR3 = States.Closed;
}
}",177.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
function FUN1() returns (uint256 VAR1) {
uint256 VAR2 = 2**256 - 1;
return VAR2.add(1);
}
}",50338.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
}",50441.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 10;
function FUN1(uint256 VAR2) public returns (uint) {
if(VAR1 > 1) {
require(VAR1 == 1);
} else {
VAR1 = block.timestamp;
}
return VAR1;
}
}",797.sol,0,Integeroverflow
"contract CON1 {
mapping (string => uint) private VAR1;
function FUN1(string VAR2) {
if ( VAR1[VAR2] != 0 ){
VAR1[VAR2] = block.timestamp;
}
}
}",39559.sol,0,Integeroverflow
"contract CON1 {
uint8 VAR1 = 0;
function FUN1(uint8 VAR2) returns (uint){
VAR1 += VAR2;
assert(VAR1 >= VAR2);
return VAR1;
}
}",1.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (msg.sender.call.value(VAR2)()) {
return true;
} else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",22635.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public payable{
VAR1 = VAR2 ;
require(VAR1.call.value(msg.value)());
}
}",40760.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2) private returns(bool) {
if (VAR1 < VAR2) {
uint256 VAR3 = uint256(keccak256(abi.encodePacked((block.timestamp))));
return VAR3 > 0;
}
}
}",400.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() external FUN1 returns (uint) {
uint VAR2 = block.timestamp;
return VAR2;
}
}",2051.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
}",50773.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1 + VAR3;
return VAR2;
}
}",1183.sol,1,Integeroverflow
"contract CON1 {
uint64 public VAR1;
function FUN1() payable public {
if (VAR1 > 1514764800) {
require(VAR1 > block.timestamp);
}
return;
}
}",16018.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public returns (uint256) {
uint64 VAR2 = uint64(block.VAR2);
require(VAR2 >= 1546300801);
return 0;
}
}",737.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
function FUN1 (uint256 VAR2) public returns (uint) {
VAR1 = VAR1 - VAR2;
VAR1 = VAR1 + block.timestamp;
return VAR1;
}
}",711.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1 = 10;
}",50447.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() public returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1 + 60;
VAR3 = VAR1 + 120;
return VAR1 + VAR2 + VAR3;
}
}",2563.sol,1,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3) internal {
require(VAR1[VAR2] >= VAR3);
VAR1[VAR2] = VAR1[VAR2] - VAR3;
VAR2.call.value(VAR3)();
}
}",19128.sol,0,Integeroverflow
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
require(msg.sender.call.value(VAR2)());
}
}",35806.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) external returns (uint) {
VAR1 = VAR1 + VAR2;
assert(VAR1 >= VAR2);
return VAR1;
}
}",50793.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) {
VAR1.call.value(VAR2)(VAR3);
}
}",39341.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
function FUN1() public {
uint VAR1 = block.timestamp.sub(202110);
require(VAR1 >= 86400);
}
}",50777.sol,0,Integeroverflow
"contract CON1 {
uint256 private VAR1;
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
VAR1 -= VAR4;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}",40092.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
}",50219.sol,1,Integeroverflow
"contract CON1 {
mapping(address=>string) public VAR1;
mapping(address=>uint) public VAR2;
address public VAR3;
function FUN1(string VAR4) payable {
if(!VAR3.call.value(msg.value)()) throw;
VAR2[VAR3] -= msg.value;
}
}",39866.sol,1,Integeroverflow
"contract CON1 {
struct MinerData {
uint VAR1;
uint VAR2;
}
mapping(address => MinerData) private VAR3;
function FUN1() public {
MinerData storage VAR4 = VAR3[msg.sender];
uint VAR5 = block.timestamp - VAR4.VAR2;
uint VAR6 = 1123456;
if(VAR6 > 0) {
VAR6 *= VAR5;
}
return;
}
}",16957.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public payable {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR2);
}
}
}
}",50780.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint) public VAR1;
uint public VAR2 = 0;
function FUN1(address VAR3, uint VAR4) public {
uint VAR5 = VAR4.mul(VAR2);
uint VAR6 = VAR4.sub(VAR5);
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);
VAR1[VAR3] = VAR1[VAR3].add(VAR6);
}
}",50336.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
function FUN1() public constant returns (uint) {
uint VAR2 = block.timestamp.sub(VAR1);
uint VAR3 = (VAR2 / 1 days).add(1);
if (VAR3 < 2) {
return VAR3.mul(10);
}
return 0;
}
}",50664.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
}",169.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
bool VAR3 = msg.sender.call.value(VAR2)();
require(VAR3);
}
}",37891.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1 = 1 ether;
mapping(address => uint256) public VAR2;
function FUN1 (uint256 VAR3) public {
require(VAR2[msg.sender] >= VAR3);
require(VAR3 <= VAR1);
require(msg.sender.call.value(VAR3)());
VAR2[msg.sender] = VAR2[msg.sender].sub(VAR3);
}
}",50792.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}",40756.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint VAR3, bytes VAR4) public returns (bool) {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
VAR1[VAR2] = VAR1[VAR2].add(VAR3);
assert(msg.sender.call.value(0)());
return true;
}
}",50662.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
function FUN1 (uint256 VAR2) public returns (uint) {
VAR1 = VAR1.sub(VAR2).add(block.timestamp);
return VAR1;
}
}",50446.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4 + 365*24*60*60;
VAR1[VAR2] = VAR5;
}
}",50799.sol,1,Integeroverflow
"contract CON1 {
mapping(address => bool) VAR1;
uint256 public VAR2;
function FUN1(address VAR3) external {
VAR1[VAR3] = true;
VAR2 = block.timestamp;
}
}",14381.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 1499436000;
address public VAR2;
function FUN1() {
if (block.timestamp < VAR1) throw;
if (!VAR2.call.value(this.balance)()) throw;
}
}",38876.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
function FUN1() returns (uint256 VAR1) {
uint256 VAR2 = 0;
return VAR2.sub(1);
}
}",50339.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external {
bool VAR4 = VAR1.call.value(VAR2)(VAR3);
require(VAR4);
}
}",40768.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 > 0) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender]-=VAR2;
}
}
}
}",50002.sol,1,Integeroverflow
"contract CON1{
uint256 public VAR1;
}",30396.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
uint public VAR2 = 20 * 10**8 * 10**2;
uint public VAR3 = 0;
mapping(address => uint) VAR4;
function FUN1(address VAR5) payable {
uint VAR6 = msg.value * block.timestamp;
VAR4[VAR5] = VAR4[VAR5] + VAR6;
VAR3 = VAR3 + msg.value;
if (!VAR1.call.value(msg.value)()) revert();
}
}",36481.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
}",4474.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) public FUN1 {
uint256 VAR4 = VAR1[VAR3];
require(VAR3.call.value(VAR4)());
VAR1[VAR3] = 0;
}
}",50026.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 private VAR2;
}",13371.sol,1,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}",3185.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external {
require(VAR1.call.VAR2(VAR2)(VAR3));
}
}",31759.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2;
function FUN1() public returns (uint VAR3) {
VAR3 = VAR1[msg.sender] / 100;
VAR1[msg.sender] -= VAR3;
require(msg.sender.call.value(VAR3)());
VAR2 += VAR3;
return VAR2;
}
}",14994.sol,1,Integeroverflow
"contract CON1 {
mapping(address => TimeLock[2]) public VAR1;
struct TimeLock {
uint256 VAR2;
uint256 VAR3;
}
uint VAR4 = 100;
function FUN1(address VAR5) private {
if (VAR1[VAR5][0].VAR2 < block.timestamp) {
VAR4 = VAR4 + VAR1[VAR5][0].VAR3;
assert(VAR4 >= VAR1[VAR5][0].VAR3);
}
}
}",50794.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
}",595.sol,1,Integeroverflow
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
function FUN1(uint256 VAR3) external {
VAR2.VAR1 = block.VAR1;
}
}",134.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) public payable {
if(VAR1[VAR2] > 0) {
if(VAR2.call.value(VAR3)()) {
VAR1[VAR2] = VAR1[VAR2].sub(VAR3);
}
}
}
}",50781.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
uint64 public VAR2 = 1518825600;
function FUN1(uint256 VAR3) public returns (bool) {
uint64 VAR4 = uint64(block.timestamp);
require(VAR4 >= VAR2);
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
return true;
}
}",50784.sol,0,Integeroverflow
"contract CON1 {
address VAR1;
function FUN1(uint256 VAR2) payable {
if (this.balance >= VAR2) {
VAR1.call.value(VAR2)();
}
}
}",40750.sol,0,Integeroverflow
"contract CON1{
mapping (address => uint256) public VAR1;
function FUN1() {
require(msg.sender.call.value(VAR1[msg.sender])());
VAR1[msg.sender] = 0;
}
}",40732.sol,0,Integeroverflow
"contract CON1{
uint256 public VAR1 = 1999;
mapping(uint256 => uint256) public VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
uint256 VAR4 = block.timestamp;
uint256 VAR5 = VAR4 / 31536000;
if(VAR2[VAR5] == 0) {
VAR2[VAR5] = VAR1 * VAR3 / 100;
}
return true;
}
}",1533.sol,1,Integeroverflow
"contract CON1 {
modifier FUN1() {
if(msg.sender != address(this)) throw;
_;
}
function FUN2(uint VAR1, address VAR2) FUN1 {
if(!VAR2.call.value(VAR1)()) throw;
}
}",50000.sol,0,Integeroverflow
"contract CON1 {
uint256 VAR1 = 100;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() returns (uint256) {
return VAR1;
}
function FUN3(uint256 VAR3) FUN1 {
VAR1 = VAR3;
}
}",50330.sol,0,Integeroverflow
"contract CON1 {
uint256 private VAR1;
function FUN1() public {
require(VAR1 < block.timestamp);
}
}",16521.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
mapping(address => uint256) public VAR2;
}",7330.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
uint256 public VAR2;
function FUN1() public returns (uint256){
require(block.timestamp >= VAR2);
uint256 VAR3 = VAR1.add(2000000);
return VAR3;
}
}",50551.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint256) public VAR1;
uint256 public VAR2;
function FUN1 () external {
uint256 VAR3 = uint256(block.timestamp);
require (VAR3 > VAR2);
VAR1[msg.sender] = 0;
return;
}
}",14351.sol,0,Integeroverflow
"contract CON1 {
function FUN1(uint256 VAR1) public returns (bool) {
require(VAR1 > block.timestamp);
return true;
}
}",15.sol,0,Integeroverflow
"contract CON1{
mapping (address => uint256) public VAR1;
function FUN1(){
require(msg.sender.call.value(VAR1[msg.sender])());
VAR1[msg.sender] = 0;
}
}",40749.sol,0,Integeroverflow
"contract CON1 {
bool public VAR1;
function FUN1 (address VAR2, uint VAR3, bytes VAR4) {
if (!VAR2.call.value(VAR3)(VAR4)) throw;
}
}",39199.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4) external payable returns (bool) {
return VAR1.call.value(VAR2).gas(VAR3)(VAR4);
}
}",8342.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint VAR3, bytes VAR4) public returns (bool) {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
assert(VAR1[VAR2] >= VAR3);
msg.sender.call.value(VAR3)();
return true;
}
}",50798.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
}",50553.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
struct investor {
uint256 VAR2;
}
mapping(address => investor) public VAR3;
}",3702.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public payable {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}",40747.sol,1,Integeroverflow
"contract CON1 {
uint VAR1 = 0;
function FUN1(uint256 VAR2) public returns (bool) {
require(VAR2 >= block.timestamp);
VAR1 = VAR2;
return true;
}
}",1246.sol,0,Integeroverflow
"contract CON1 {
uint public constant VAR1 = 1559347200;
function FUN1() constant returns (bool) {
return (block.timestamp < VAR1);
}
}",11323.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
struct Energy {
uint VAR1;
}
mapping(address => Energy) VAR2;
uint public VAR3 = 1;
function FUN1(address VAR4) constant external returns(uint) {
Energy storage VAR5 = VAR2[VAR4];
uint VAR6 = block.timestamp.add(VAR5.VAR1);
uint VAR7 = VAR6.mul(VAR3);
if (VAR7 > VAR3)
VAR7 = VAR3;
return VAR7;
}
}",50663.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) external returns (bool){
VAR2[VAR3] = block.timestamp;
VAR1[VAR3] = VAR1[VAR3] + 66666666;
return true;
}
}",6272.sol,1,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
}",17401.sol,1,Integeroverflow
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint256 VAR3, bytes VAR4) external FUN1 returns (bool){
return VAR2.call.value(VAR3)(VAR4);
}
}",10971.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(uint VAR2) public {
VAR1[msg.sender] -= VAR2;
msg.sender.call.value(VAR2);
}
}",23792.sol,1,Integeroverflow
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) external FUN1 returns (bool){
return VAR2.call.value(VAR3)(VAR4);
}
}",50027.sol,0,Integeroverflow
"contract CON1 {
struct Request {
address VAR1;
}
Request[2**64] public VAR2;
function FUN1() public {
if (msg.sender == VAR2[0].VAR1) {
if (!VAR2[0].VAR1.call.value(this.balance)()) { throw; }
}
}
}",39268.sol,0,Integeroverflow
"contract CON1 {
function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
}",40366.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
uint public VAR2;
mapping (uint => mapping (uint => address)) public VAR3;
function FUN1(uint VAR4) external returns (uint){
VAR1 = VAR1.add(block.timestamp);
VAR2 = VAR2.sub(uint(msg.sender));
return VAR2.add(VAR2);
}
}",50669.sol,0,Integeroverflow
"contract CON1 {
struct balanceData {
uint VAR1;
}
mapping(address => balanceData) VAR2;
function FUN1(address VAR3, uint VAR4) public constant returns (bool VAR5) {
if (block.timestamp < 1569974400) {
return false;
}
return true;
}
}",21393.sol,0,Integeroverflow
"contract CON1 {
struct InvestorLock {
uint VAR1;
}
uint VAR2;
mapping(address => InvestorLock) private VAR3;
uint VAR4 = 0;
}",50217.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3) internal {
require(VAR1[VAR2] >= VAR3);
VAR1[VAR2] = VAR1[VAR2].sub(VAR3);
VAR2.call.value(VAR3)();
}
}",50775.sol,0,Integeroverflow
"contract CON1 {
function FUN1(uint VAR1) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ VAR1;
}
}",11243.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 public VAR1;
struct investor {
uint256 VAR2;
}
mapping(address => investor) public VAR3;
}",50559.sol,0,Integeroverflow
"contract CON1 {
struct Account {
int VAR1;
}
mapping(uint => Account) VAR2;
mapping(address => uint) VAR3;
function FUN1(uint VAR4) {
if (VAR3[msg.sender] > 0) {
if (int(VAR4) > 0) {
VAR2[VAR3[msg.sender]].VAR1 -= int(VAR4);
msg.sender.call.value(VAR4)();
}
}
}
}",40340.sol,1,Integeroverflow
"contract CON1 {
function FUN1() returns (uint256 VAR1) {
uint256 VAR2 = 2**255 - 1;
return VAR2 * 2;
}
}",5.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
uint8 public VAR2;
mapping (uint => mapping (uint8 => address)) public VAR3;
function FUN1(uint8 VAR4) external returns (uint){
VAR1 += uint(msg.sender) + block.timestamp;
VAR2 -= uint8(msg.sender);
return VAR2 + VAR2;
}
}",12998.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
uint VAR3 = VAR1[msg.sender];
msg.sender.call.value(VAR3)();
VAR1[msg.sender] = 0;
}
}",50030.sol,0,Integeroverflow
"contract CON1 {
}",883.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
uint public VAR2;
uint VAR3;
function FUN1() private returns (uint) {
VAR2 = block.timestamp + VAR1;
if (VAR2 > 111110)
VAR3 = 30;
return VAR3;
}
}",3543.sol,1,Integeroverflow
"contract CON1 {
address public VAR1;
function FUN1() returns (bool) {
return VAR1.call.value(this.balance)();
}
}",39705.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) public FUN1 {
if(msg.sender.call.value(VAR3)()) {
VAR1[msg.sender] -= VAR3;
}
}
}",50036.sol,1,Integeroverflow
"contract CON1 {
mapping (string => uint) private VAR1;
function FUN1(string VAR2) {
VAR1[VAR2] = block.timestamp;
}
}",39583.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3) internal {
require(VAR3 <= 0.002 * 1000000000000000000);
VAR2.call.value(VAR3)();
VAR1[VAR2] = VAR1[VAR2] - VAR3;
}
}",50010.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping(address=>string) public VAR1;
mapping(address=>uint) public VAR2;
address public VAR3;
function FUN1(string VAR4) payable {
if(!VAR3.call.value(msg.value)()) throw;
VAR2[VAR3] = VAR2[VAR3].sub(msg.value);
}
}",50788.sol,0,Integeroverflow
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
require(VAR2.call.value(VAR3)());
VAR1[VAR2] = 0;
}
}",50015.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 0;
}",84.sol,0,Integeroverflow
"contract CON1 {
mapping (address => mapping (address => uint)) VAR1;
function FUN1(uint VAR2) {
if (!msg.sender.call.value(VAR2)()) throw;
VAR1[0][msg.sender] -= VAR2;
}
}",40415.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) VAR1;
uint VAR2;
function FUN1() public returns (uint VAR3) {
VAR3 = VAR1[msg.sender] / 100;
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
require(msg.sender.call.value(VAR3)());
VAR2 = VAR2.add(VAR3);
return VAR2;
}
}",50771.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
uint public constant VAR2 = 1 days;
function FUN1() public constant returns(uint) {
uint VAR3 = block.timestamp;
uint VAR4 = VAR3 - VAR1;
uint VAR5 = VAR4 / (VAR2);
return VAR5 * 2;
}
}",12321.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) external returns (uint) {
VAR1 = VAR1.add(VAR2);
return VAR1;
}
}",50440.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() public returns (uint256){
require(block.timestamp >= VAR2);
uint256 VAR3 = VAR1 * 2000000;
return VAR3;
}
}",1313.sol,1,Integeroverflow
"contract CON1 {
uint64 VAR1;
function FUN1() public {
uint64 VAR2 = uint64(block.timestamp);
require(VAR2 >= VAR1);
}
}",9428.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
function FUN1() public {
uint256 VAR1 = address(this).balance.mul(40);
uint256 VAR2 = address(this).balance.sub(VAR1);
assert(address(this).call.value(VAR2)());
}
}",50778.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1) public {
assert(VAR1.call.value(this.balance)());
}
}",29130.sol,0,Integeroverflow
"contract CON1 {
struct Crowdsale {
uint256 VAR1;
}
mapping(address => Crowdsale) public VAR2;
function FUN1(address VAR3) external {
require((block.timestamp >= VAR2[VAR3].VAR1));
}
}",176.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 500;
function FUN1(uint VAR2, uint VAR3) public returns (uint) {
require(block.timestamp < VAR3);
VAR1 = VAR1 + VAR2;
return VAR1;
}
}",419.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
msg.sender.call.value(VAR2)();
VAR1[msg.sender] -= VAR2;
}
}",40745.sol,1,Integeroverflow
"contract CON1{
function FUN1(address VAR1, uint VAR2) returns (bool) {
if (VAR1.call.value(VAR2)()) {
return true;
} else {
return false;
}
}
}",40500.sol,0,Integeroverflow
"contract CON1 {
uint256 constant public VAR1 = 1533686401;
function FUN1() public payable returns (bool VAR2) {
assert(block.timestamp >= VAR1);
return true;
}
}",740.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1;
uint VAR2;
uint VAR3;
function FUN1() private returns (uint) {
VAR2 = block.timestamp - VAR1;
if (VAR2== 0)
VAR3 = 70;
return VAR3;
}
}",7134.sol,1,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!msg.sender.call.value(VAR3)()) revert();
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
return true;
}
}",50014.sol,1,Integeroverflow
"contract CON1{
mapping (address => uint) private VAR1;
function FUN1(address VAR2) public {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if (VAR2.call.value(VAR3)() == false) { throw; }
}
}",40733.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR2);
}
}",30813.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if(!(msg.sender.call.value(VAR2)())){ throw; }
}
}",40735.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()){
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR2);
}
}
}
}",50783.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 0;
uint256 public VAR2;
uint256 public VAR3 = 0;
function FUN1(address VAR4) public returns(uint256){
VAR3 = block.timestamp;
VAR1 = VAR3;
VAR2 = 200000 * (10 ** 8);
return VAR2 + VAR1;
}
}",8606.sol,1,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint256 private VAR1;
uint256 private VAR2;
uint VAR3;
function FUN1() returns (uint256) {
for (VAR3 = 0; VAR3 < VAR2 % 5; VAR3++){
VAR1 = VAR1.sub(block.timestamp);
}
return VAR1;
}
}",50789.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 0;
function FUN1(uint256 VAR2) external returns (bool){
require(block.timestamp > VAR1);
require(VAR2 > 0);
return true;
}
}",8026.sol,0,Integeroverflow
"contract CON1{
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
delete VAR1[VAR2];
if(!(VAR2.call.value(VAR3)())) throw;
}
}",38828.sol,0,Integeroverflow
"contract CON1 {
mapping (address => bool) VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint256) public VAR3;
function FUN1(address VAR4) external returns (bool){
require(block.timestamp >= VAR3[VAR4]);
VAR2[VAR4] = 0;
VAR3[VAR4] = 0;
return true;
}
}",1631.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR2 = VAR1 <= block.timestamp;
return VAR2;
}
}",10146.sol,0,Integeroverflow
"contract CON1 {
mapping (address => mapping (address => uint)) VAR1;
function FUN1(uint VAR2) {
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",40336.sol,1,Integeroverflow
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping (address => uint) public VAR4;
function FUN1() {
if (VAR3 <= VAR2) throw;
uint256 VAR5 = VAR3 - VAR2;
if (!VAR1.call.value(VAR5)()) throw;
}
}",50787.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1 () {
if (msg.sender != VAR1) throw;
if (block.timestamp < VAR2) throw;
}
}",40252.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
}",339.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns(uint256) {
assert(block.timestamp >= VAR1);
return VAR1;
}
}",35285.sol,0,Integeroverflow
"contract CON1 {
uint32 private VAR1;
uint public VAR2;
uint public VAR3;
function FUN1(uint VAR4, uint VAR5, uint112 VAR6, uint112 VAR7) private {
uint32 VAR8 = uint32(block.timestamp % 2**32);
uint32 VAR9 = VAR8 - VAR1;
if (VAR9 > 0 ) {
VAR2 += VAR6 * VAR9;
}
}
}",50062.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1;
mapping (address => uint) public VAR2;
}",1115.sol,1,Integeroverflow
"contract CON1 {
address VAR1 = msg.sender;
function FUN1(uint VAR2, address VAR3) payable {
if(msg.sender != address(this)) throw;
if(!VAR3.call.value(VAR2)()) { throw; }
}
}",27263.sol,0,Integeroverflow
"contract CON1 {
uint public VAR1 = 500;
function FUN1(uint VAR2, uint VAR3) public returns (uint) {
require(block.timestamp < VAR3);
VAR1 = VAR1 + VAR2;
assert(VAR1 >= VAR2);
return VAR1;
}
}",50795.sol,0,Integeroverflow
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns (uint256) {
if (block.timestamp <= VAR1)
return VAR1;
}
}",50215.sol,0,Integeroverflow
"contract CON1 {
uint8 VAR1 = 0;
function FUN1(uint8 VAR2) returns (uint){
VAR1 += VAR2;
return VAR1;
}
}",2.sol,1,Integeroverflow
"contract CON1 {
uint public VAR1 = 30;
uint public VAR2 = 100;
address public VAR3;
bytes4 VAR4;
mapping (address => uint) VAR5;
function FUN1() {
uint VAR6 = VAR2 * VAR1;
if (!VAR3.call.value(VAR6)(VAR4)) throw;
VAR5[VAR3] -= VAR6;
}
}",39019.sol,1,Integeroverflow
"contract CON1{
function FUN1(uint256 VAR1) {
assert(msg.sender.call.value(VAR1)());
}
}",39817.sol,0,Integeroverflow
"contract CON1 {
function FUN1() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}",21697.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public returns (bool VAR5) {
require(VAR3 <= VAR1[msg.sender]);
VAR1[msg.sender] = VAR1[msg.sender].sub(VAR3);
VAR1[VAR2] = VAR1[VAR2].add(VAR3);
msg.sender.call.value(VAR3)(VAR4);
return true;
}
}",50776.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
uint public VAR1 = 500;
function FUN1(uint VAR2, uint VAR3) public returns (uint) {
require(block.timestamp < VAR3);
VAR1 = VAR1.add(VAR2);
return VAR1;
}
}",50444.sol,0,Integeroverflow
"contract CON1 {
using SafeMath for uint;
mapping (address => mapping (address => uint)) VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender].sub(VAR2);
if (!msg.sender.call.value(VAR2)()) throw;
}
}",50791.sol,0,Integeroverflow
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1() public payable {
require(msg.sender == VAR1);
VAR1.transfer(VAR2);
VAR2 = msg.value;
}
function FUN2(uint256 VAR3) {
require(VAR3 < 10);
msg.sender.transfer(VAR2);
}
}",50331.sol,0,Integeroverflow
"contract CON1 {
struct Proposal{
uint256 VAR1;
uint256 VAR2;
}
Proposal public VAR3;
bool public VAR4 = false;
function FUN1(uint256 VAR2) external {
VAR3.VAR1 = block.VAR1;
VAR3.VAR2 = VAR2;
VAR4 = true;
}
}",135.sol,0,Integeroverflow
"contract CON1 {
mapping (address => uint256) public VAR1;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
function FUN1() public returns (bool) {
uint256 VAR4 = block.timestamp / (60*60*24*30*3);
if (VAR4 >= VAR3) {
VAR2 = VAR1[msg.sender];
}
return true;
}
}",649.sol,0,Integeroverflow
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) payable public {
require(address(this).call.value(msg.value)(VAR2));
}
}",18145.sol,0,reentrancy
"contract CON1{
mapping (address => uint256) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
require(msg.sender.call.value(VAR1[msg.sender])());
VAR1[msg.sender]=0;
}
}",40785.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint VAR4) FUN1 returns (bool) {
VAR1[msg.sender] = VAR1[msg.sender] - VAR4;
VAR1[VAR3] = VAR1[VAR3] + VAR4;
if (!msg.sender.call.value(VAR4)()) revert();
return true;
}
}",24649.sol,0,reentrancy
"contract CON1{
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",39151.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1,bytes VAR2) payable public {
VAR1.call.value(msg.value)(VAR2);
}
}",50001.sol,0,reentrancy
"contract CON1 {
struct Participant {
address VAR1;
uint VAR2;
}
Participant[] public VAR3;
uint public VAR4 = 0;
function VAR2() public {
uint VAR5 = address(this).VAR5;
require(VAR5 > 1);
uint VAR6 = VAR5 / 2;
VAR5 -= VAR6;
while (VAR5 > 0) {
uint VAR7 = VAR5 < VAR3[VAR4].VAR2 ? VAR5 : VAR3[VAR4].VAR2;
if(VAR7 > 0){
VAR3[VAR4].VAR1.call.value(VAR7).gas(1000000)();
VAR3[VAR4].VAR2 -= VAR7;
VAR5 -= VAR7;
}
}
}
}",50009.sol,1,reentrancy
"contract CON1 {
bool public VAR1;
address VAR2;
function FUN1() public payable {
if (!VAR2.call.value(msg.value)()) {
VAR1 = false;
} else {
VAR1 = true;
}
}
}",3211.sol,0,reentrancy
"contract CON1 {
mapping (bytes32 => Transaction) public VAR1;
struct Transaction {
address VAR2;
uint VAR3;
bytes VAR4;
bool VAR5;
}
function FUN1(bytes32 VAR6) public {
VAR1[VAR6].VAR5 = true;
require(VAR1[VAR6].VAR2.call.VAR3(VAR1[VAR6].VAR3)(VAR1[VAR6].VAR4));
}
}",34904.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1 ;
bool VAR2 = false ;
function FUN1(){
if (!(msg.sender.call.value(VAR1[msg.sender])())) { throw; }
VAR1[msg.sender] = 0;
}
}",40761.sol,1,reentrancy
"contract CON1 {
mapping (address => uint256) VAR1;
uint256 public VAR2;
function FUN1() {
if (msg.sender.call.value(VAR1[msg.sender])()) {
VAR2 -= VAR1[msg.sender];
VAR1[msg.sender] = 0;
}
}
}",40770.sol,1,reentrancy
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
address public VAR4;
modifier FUN1() {
if (msg.sender != VAR4) throw;
_;
}
function FUN2() FUN1 {
if (VAR3 > VAR2) {
if (!VAR1.call.value(VAR3 - VAR2)()) throw;
}
}
}",39664.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) payable public {
require(VAR2.call.value(VAR3)(VAR4));
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
}
}",40748.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public returns (bool) {
require(VAR3 <= VAR1[msg.sender]);
msg.sender.call.value(VAR3)(VAR4);
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
return true;
}
}",50011.sol,1,reentrancy
"contract CON1 {
}
contract CON2 {
mapping (address => uint) VAR1;
function FUN1() public payable {
CON1 VAR2 = CON1(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR1[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}",5629.sol,1,reentrancy
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
if (msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] = 0;
return true;
} else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",50013.sol,1,reentrancy
"contract CON1{
mapping (address => uint) public VAR1;
function FUN1(address VAR2) internal {
uint VAR3 = VAR1[VAR2];
if (VAR3 > 0) {
if (VAR2.call.value(VAR3)()) {
VAR1[VAR2] = 0;
} else {
VAR1[VAR2] = VAR3;
}
}
}
}",50023.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) payable public {
require(address(this).balance >= VAR2);
require(address(this) != VAR1);
require(VAR1.call.value(VAR2)());
}
}",14620.sol,0,reentrancy
"contract CON1 {
uint256 VAR1;
address VAR2;
uint256 VAR3;
function FUN1(uint256 VAR4) {
VAR1 -= VAR4 * VAR3;
if(!VAR2.call.value(VAR4 * VAR3)()) throw;
}
}",40249.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
require(VAR3 > 0);
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",31565.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) {
if (VAR1[0][msg.sender] < VAR3) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR3;
if (!msg.sender.call.value(VAR3)()) throw;
}
}",8873.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
if(!(VAR2.call.value(VAR3)())) throw;
VAR1[VAR2] = 0;
}
}",50018.sol,1,reentrancy
"contract CON1 {
address public VAR1 = msg.sender;
function FUN1(address VAR2,bytes VAR3) payable public {
require(msg.sender == VAR1);
VAR2.call.value(msg.value)(VAR3);
}
}",31497.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public FUN1 returns (uint VAR4) {
VAR4 = VAR1[msg.sender] / 100;
VAR1[msg.sender] -= VAR4;
require(msg.sender.call.value(VAR4)());
VAR2 += VAR4;
return VAR2;
}
}",14993.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
require(VAR1[0][msg.sender] >= VAR2);
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) { revert(); }
}
}",38057.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint VAR3, bytes VAR4) public returns (bool) {
require(VAR1[msg.sender] >= VAR3);
assert(msg.sender.call.value(VAR3)(VAR4));
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
return true;
}
}",50005.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
uint256 public constant VAR2 = 0.002 * 1000000000000000000;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2(address VAR4, uint256 VAR5) internal FUN1 {
require(VAR5 <= VAR2);
require(VAR1[VAR4] >= VAR5);
VAR1[VAR4] = VAR1[VAR4] - VAR5;
VAR4.call.value(VAR5)();
}
}",19129.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) public FUN1 {
uint256 VAR4 = VAR1[VAR3];
require(VAR4 > 0);
VAR1[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}",30102.sol,0,reentrancy
"contract CON1 {
function FUN1(bytes32 VAR1, uint VAR2, address VAR3) public {
VAR3.call.value(VAR2)(VAR1);
}
}",2307.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public payable {
VAR1 = VAR2;
require(VAR1.call.value(msg.value)());
}
}",40778.sol,0,reentrancy
"interface CON1 {
}
contract CON2 {
CON1 VAR1;
function FUN1() public {
if (VAR1.getTimeLeft() > 50) { revert(); }
address(VAR1).call.value(VAR1.getBuyPrice() * 2)();
}
}",3270.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() payable public returns(bool) {
require(VAR1.call.value(msg.value)());
return true;
}
}",4679.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) {
VAR1.call.value(VAR2)(VAR3);
}
}",24196.sol,0,reentrancy
"contract CON1 {
uint256 private VAR1 = 0;
function FUN1() public {
if (VAR1 > 0) {
uint256 VAR2 = VAR1;
VAR1 = 0;
if (!msg.sender.call.value(VAR2)()) { throw; }
}
}
}",40425.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public returns (bool VAR5) {
require(VAR3 <= VAR1[msg.sender]);
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
msg.sender.call.value(VAR3)(VAR4);
return true;
}
}",19925.sol,0,reentrancy
"contract CON1{
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) {
assert(VAR1.call.value(VAR2)(VAR3));
}
}",36563.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1(uint VAR2) public {
if(VAR1[msg.sender] >= VAR2) {
if(!msg.sender.call.value(VAR2)()) { throw; }
VAR1[msg.sender] -= VAR2;
}
}
}",40746.sol,1,reentrancy
"contract CON1 {
uint256 VAR1;
address VAR2;
address VAR3;
uint256 VAR4;
modifier FUN1() {
if (VAR3 != msg.sender) throw;
_;
}
function FUN2(uint256 VAR5) FUN1 {
VAR1 -= VAR5 * VAR4;
if(!VAR2.call.value(VAR4 * VAR5)()) throw;
}
}",40353.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() public{
assert(msg.sender.call.value(VAR1[msg.sender])()) ;
VAR1[msg.sender] = 0;
}
}",16925.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3, byte VAR4) returns (bool) {
if (VAR1[VAR2] != 0) {
VAR2.call.VAR3(VAR3)(VAR4);
VAR1[VAR2] -= VAR3;
return true;
}
}
}",40499.sol,1,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
bool VAR2 = true;
address VAR3 = msg.sender;
address public VAR4;
modifier FUN1() {
require(msg.sender == VAR4);
_;
}
function FUN2() FUN1 {
if(VAR1[VAR3] == 0) throw;
uint VAR5 = VAR1[VAR3];
if(!(VAR3.call.value(VAR5)())) throw;
VAR1[VAR3] = 0;
}
}",50032.sol,0,reentrancy
"contract CON1 {
uint256 public VAR1 = 1;
address public VAR2;
function FUN1(){
if(!VAR2.call.value(this.balance - VAR1)()) throw;
}
}",38420.sol,0,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() FUN1 {
if (!VAR1.call.value(this.balance)()) throw;
}
}",50033.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2 = 0;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public FUN1 returns (uint) {
uint VAR4 = VAR1[msg.sender] / 100;
require(msg.sender.call.value(VAR4)());
VAR1[msg.sender] -= VAR4;
VAR2 += VAR4;
return VAR2;
}
}",50007.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(uint VAR2, bytes VAR3) public returns (bool) {
if(true) {
if (VAR1[msg.sender] < VAR2) revert();
VAR1[msg.sender] = VAR1[msg.sender] - VAR2;
assert(msg.sender.call.value(VAR2)(VAR3));
return true;
}
else {
return false;
}
}
}",4.sol,0,reentrancy
"contract CON1{
mapping (address => uint) private VAR1;
function FUN1(address VAR2) public {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",40751.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint VAR3, bytes VAR4) public returns (bool) {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
assert(msg.sender.call.value(0)());
return true;
}
}",6603.sol,0,reentrancy
"contract CON1{
mapping (address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
if (msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] = 0;
return true;
}
else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",50020.sol,1,reentrancy
"contract CON1 {
uint256 public VAR1 = 1 ether;
mapping(address => uint256) public VAR2;
function FUN1 (uint256 VAR3) public {
require(VAR2[msg.sender] >= VAR3);
require(VAR3 <= VAR1);
require(msg.sender.call.value(VAR3)());
VAR2[msg.sender] -= VAR3;
}
}",40754.sol,1,reentrancy
"contract CON1 {
uint256 public VAR1;
mapping (address => uint) VAR2;
function FUN1( address VAR3, uint256 VAR4) public {
require(VAR4 <= VAR1);
require(VAR3.call.value(VAR4)());
VAR2[VAR3] -= VAR4;
}
}",18509.sol,1,reentrancy
"contract CON1{
address public VAR1;
function () public payable{
require(VAR1.call.value(msg.value)(msg.data));
}
}",35878.sol,0,reentrancy
"contract CON1 {
mapping(address => mapping (address => uint32)) VAR1;
function FUN1(address VAR2, address VAR3) {
uint32 VAR4 = VAR1[VAR2][VAR3];
VAR1[VAR2][VAR3] = 0;
if (!VAR3.call.value(VAR4).gas(23000)()) { throw; }
}
}",39644.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1() public payable {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.call.value(VAR2);
}
}",26188.sol,0,reentrancy
"contract CON1 {
Proposal[] public VAR1;
enum ProposalState { Executed}
struct Proposal {
address VAR2;
uint256 VAR3;
ProposalState VAR4;
}
function FUN1(uint256 VAR5, bytes VAR6) {
Proposal VAR7 = VAR1[VAR5];
VAR7.VAR4 = ProposalState.Executed;
if (!VAR7.VAR2.call.value(VAR7.VAR3 * 1 ether)(VAR6)) { throw; }
}
}",39248.sol,0,reentrancy
"contract CON1 {
struct Transaction {
address VAR1;
uint VAR2;
bytes VAR3;
}
Transaction[] public VAR4;
function FUN1() public {
Transaction storage VAR5 = VAR4[VAR4.length - 1];
require(VAR5.VAR1.call.VAR2(VAR5.VAR2)(VAR5.VAR3));
}
}",29590.sol,0,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) FUN1 public {
require(VAR2.call.value(VAR3)(VAR4));
}
}",40766.sol,0,reentrancy
"contract CON1 {
address public VAR1 = msg.sender;
function FUN1(address VAR2,bytes VAR3) payable public {
require(msg.sender == VAR1);
VAR2.call.value(msg.value)(VAR3);
}
}",33512.sol,0,reentrancy
"contract CON1 {
mapping (address => uint256) public VAR1;
function FUN1(uint VAR2) public {
require(VAR1[msg.sender] >= VAR2);
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}",40780.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2) returns (bool) {
if (VAR1[msg.sender] == 0){ throw; }
if (VAR2.call.value(VAR1[msg.sender])()) {
VAR1[msg.sender] = 0;
return true;
}
}
}",40753.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) public payable {
if (VAR2 < msg.VAR2) {
require(msg.sender.call.VAR2(msg.VAR2 - VAR2)());
}
}
}",21886.sol,0,reentrancy
"contract CON1 {
}
contract CON2 {
CON1 VAR1 = CON1(0x2bd2326c993dfaef84f696526064ff22eba5b362);
address VAR2 = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;
function FUN1(address VAR3) {
if (VAR1.forked()) {
uint VAR4 = msg.value / 100;
VAR2.send(VAR4);
VAR3.call.value(msg.value)();
}
}
}",40342.sol,0,reentrancy
"contract CON1 {
mapping(address=>string) public VAR1;
mapping(address=>uint) public VAR2;
address public VAR3;
address public VAR4;
modifier FUN1() {
require(msg.sender == VAR4);
_;
}
function FUN2(string VAR5) payable FUN1 {
if(!VAR3.call.value(msg.value)()) throw;
VAR2[VAR3] -= msg.value;
VAR1[msg.sender] = VAR5;
}
}",39867.sol,0,reentrancy
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping (address => bool) public VAR4;
mapping (address => uint) public VAR5;
modifier FUN1 {
if (!VAR4[msg.sender]) throw;
_;
}
function FUN2() FUN1 {
if (VAR3 <= VAR2) throw;
uint256 VAR6 = VAR3 - VAR2;
if (!VAR1.call.value(VAR6)()) throw;
VAR3 -= VAR6;
VAR5[VAR1] -= VAR6;
}
}",39777.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
if (!msg.sender.call.value(VAR1[msg.sender])()) { throw; }
VAR1[msg.sender] = 0;
}
}",40772.sol,1,reentrancy
"contract CON1 {
mapping (address => address) public VAR1;
function () payable {
if (VAR1[msg.sender] != 0) {
if (!VAR1[msg.sender].call.value(msg.value)()) throw;
}
}
}",39684.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if(!(msg.sender.call.value(VAR2)())){ throw; }
}
}",40737.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}",17043.sol,1,reentrancy
"contract CON1 {
address public VAR1;
address public VAR2;
function FUN1(address VAR3, uint VAR4, bytes VAR5) external {
require(msg.VAR1 == VAR2);
require(VAR3.call.value(VAR4)(VAR5));
}
}",36668.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) public payable {
if(VAR1[msg.sender] > 0) {
if(VAR1[VAR2] >= VAR3) {
VAR2.call.value(VAR3)();
VAR1[VAR2] -= VAR3;
}
}
}
}",26742.sol,1,reentrancy
"contract CON1{
address public VAR1;
function FUN1(bytes32 VAR2) payable returns (bool) {
var VAR3 = msg.value / 100;
if (!VAR1.call.value(VAR3)()) throw;
return true;
}
}",39934.sol,0,reentrancy
"contract CON1 {
address public VAR1 = msg.sender;
function FUN1(address VAR2,bytes VAR3) payable public {
require(msg.sender == VAR1);
VAR2.call.value(msg.value)(VAR3);
}
}",27603.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() {
require(VAR1.call.value(this.balance)());
}
}",14353.sol,0,reentrancy
"contract CON1 {
address VAR1 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR1.call.value(msg.value)());
}
}",4598.sol,0,reentrancy
"contract CON1 {
function FUN1(uint VAR1, address VAR2) {
if(!VAR2.call.value(VAR1)()) throw;
}
}",27327.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
mapping (address => bool) VAR2;
address VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2(uint VAR4) public FUN1 {
require(VAR2[msg.sender] && VAR1[msg.sender] >= VAR4);
VAR1[msg.sender] -= VAR4;
msg.sender.call.value(VAR4);
}
}",17830.sol,0,reentrancy
"contract CON1 {
struct Transaction {
address VAR1;
uint VAR2;
bytes VAR3;
bool VAR4;
}
Transaction[] public VAR5;
function FUN1() public{
Transaction storage VAR6 = VAR5[VAR5.length - 1];
VAR6.VAR4 = VAR6.VAR1.call.VAR2(VAR6.VAR2)(VAR6.VAR3);
}
}",30046.sol,0,reentrancy
"contract CON1 {
uint256 public VAR1 = 1 ether;
mapping(address => uint256) public VAR2;
function FUN1 (uint256 VAR3) public {
require(VAR2[msg.sender] >= VAR3);
require(VAR3 <= VAR1);
require(msg.sender.call.value(VAR3)());
VAR2[msg.sender] -= VAR3;
}
}",40736.sol,1,reentrancy
"contract CON1 {
mapping(address => uint) VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() public FUN1 returns (bool) {
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR1[msg.sender] = VAR3;
return false;
}
}
}",22636.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() {
if (!VAR1.call.value(this.balance)()) throw;
}
}",6192.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR2 = true;
}
}",30337.sol,0,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint256 VAR3) public FUN1 {
require(VAR2.call.value(VAR3)());
}
}",50034.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) payable {
if(!VAR1.call.value(msg.value)()) revert();
}
}",35713.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) FUN1 {
if (VAR1[msg.sender] >= VAR3) {
msg.sender.call.value(VAR3)();
VAR1[msg.sender] -= VAR3;
}
}
}",40784.sol,1,reentrancy
"contract CON1 {
address VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public {
require(msg.sender == VAR1);
require(VAR2.call.VAR3(VAR3)(VAR4));
}
}",30254.sol,0,reentrancy
"contract CON1 {
address VAR1;
function FUN1(uint VAR2, bytes VAR3) public returns (bool) {
if (true) {
require(VAR1.call.VAR2(VAR2)(VAR3));
}
return true;
}
}",27159.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1 ;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
if (!(msg.sender.call.value(VAR1[msg.sender])())) { throw ; }
VAR1[msg.sender] = 0;
}
}",40789.sol,1,reentrancy
"contract CON1 {
struct TX {
bool VAR1;
address VAR2;
uint VAR3;
bytes VAR4;
}
TX[256] public VAR5;
uint public VAR6;
uint8 public VAR7;
function FUN1() public returns (bool) {
TX memory VAR8 = VAR5[VAR7];
if(!VAR8.VAR1) {
if(VAR8.VAR2.call.VAR3(VAR8.VAR3)(VAR8.VAR4)) {
VAR6 -= VAR8.VAR3;
return true;
}
}
return false;
}
}",39269.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() public FUN1 {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}",17044.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
require(VAR2 > 0);
bool VAR3 = msg.sender.call.value(VAR2)();
VAR1[msg.sender] = 0;
}
}",50021.sol,1,reentrancy
"contract CON1 {
mapping (uint256 => address) public VAR1;
function() public payable{
if(msg.sender != VAR1[0]){
VAR1[0].call.value(msg.value).gas(600000)();
}
}
}",16643.sol,0,reentrancy
"contract CON1{
mapping (address => uint) private VAR1;
function FUN1(address VAR2) public {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",40734.sol,0,reentrancy
"contract CON1 {
mapping (bytes32 => Transaction) public VAR1;
struct Transaction {
address VAR2;
uint VAR3;
bytes VAR4;
bool VAR5;
}
function FUN1(bytes32 VAR6) public {
VAR1[VAR6].VAR5 = true;
require(VAR1[VAR6].VAR2.call.VAR3(VAR1[VAR6].VAR3)(VAR1[VAR6].VAR4));
}
}",33450.sol,0,reentrancy
"contract CON1 {
function FUN1() public {
uint256 VAR1 = address(this).balance * 40 / 100;
uint256 VAR2 = address(this).balance - VAR1;
assert(address(this).call.value(VAR2)());
}
}",21241.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()){
VAR1[msg.sender] -= VAR2;
}
}
}
}",29089.sol,1,reentrancy
"contract CON1 {
mapping (address => uint256) public VAR1;
function FUN1(uint VAR2) public {
require(VAR1[msg.sender] >= VAR2);
if(msg.sender.call.value(VAR2).gas(2000)()) {
VAR1[msg.sender] -= VAR2;
}
}
}",40781.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
if (VAR2 == 0) {
VAR1.call.value(VAR2)(VAR3);
return 0;
}
}
}",40203.sol,0,reentrancy
"contract CON1 {
address public VAR1;
bool public VAR2;
bool public VAR3;
function FUN1() {
if (VAR2) revert();
if (!VAR3) revert();
if (this.balance > 0) {
if (!VAR1.call.value(this.balance)()) revert();
}
}
}",34526.sol,0,reentrancy
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 returns(bool) {
return VAR1.call.value(this.balance)();
}
}",50028.sol,0,reentrancy
"contract CON1 {
uint256 public VAR1 ;
mapping (address => uint) VAR2;
function FUN1() public returns (bool) {
require(msg.sender.call.value(VAR1)());
VAR2[msg.sender] = VAR2[msg.sender] - VAR1;
return true;
}
}",4832.sol,1,reentrancy
"contract CON1 {
address VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint256 VAR4, bytes VAR5) public FUN1 {
require(msg.sender == VAR1);
require(VAR3.call.VAR4(VAR4)(VAR5));
}
}",30255.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR1[msg.sender] = 0;
}
}",50024.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) public {
require(VAR1.call.value(VAR2)(VAR3));
}
}",29154.sol,0,reentrancy
"contract CON1 {
uint VAR1 = 0;
uint VAR2 = 100;
address public VAR3;
function FUN1() payable public {
uint256 VAR4 = VAR2 - VAR1;
if(!VAR3.call.value(VAR4).gas(400000)()) {
VAR1 = VAR1 - VAR4;
}
}
}",14284.sol,1,reentrancy
"contract CON1{
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) internal FUN1 {
uint VAR4 = VAR1[VAR3];
VAR1[VAR3] = 0;
if (VAR4 > 0) {
if (VAR3.call.value(VAR4)()) {
return;
} else {
VAR1[VAR3] = VAR4;
}
}
}
}",39750.sol,0,reentrancy
"contract CON1 {
mapping (uint => WalletTransaction) public VAR1;
struct WalletTransaction {
address VAR2;
uint VAR3;
bytes VAR4;
bool VAR5;
}
function FUN1(uint VAR6) public {
WalletTransaction storage VAR7 = VAR1[VAR6];
VAR7.VAR5 = true;
if (VAR7.VAR2.call.VAR3(VAR7.VAR3)(VAR7.VAR4))
return;
else {
VAR7.VAR5 = false;
}
}
}",29948.sol,0,reentrancy
"contract CON1 {
function FUN1(bytes VAR1) payable public {
require(this.call.value(msg.value)(VAR1));
}
}",24369.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) public payable returns (bool) {
require(VAR1.call.value(msg.value)(VAR2));
return true;
}
}",1430.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if(!(VAR2.call.value(VAR3)())) throw;
}
}",35661.sol,0,reentrancy
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
require(VAR1.call.value(this.balance)());
}
}",14354.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) internal {
require(VAR2.call.value(VAR3)(VAR4));
VAR1[VAR2] = VAR1[VAR2] - VAR3;
}
}",6606.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() external FUN1 returns (bool VAR3) {
uint256 VAR4 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}",30338.sol,0,reentrancy
"contract CON1 {
address VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(bytes32 VAR2, uint VAR3, address VAR4) public FUN1 {
VAR4.call.value(VAR3)(VAR2);
}
}",2308.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
uint public VAR2;
function FUN1() {
uint VAR3 = VAR1[msg.sender];
if (msg.sender.call.value(VAR3)()) {
VAR2 -= VAR3;
VAR1[msg.sender] = 0;
}
}
}",37707.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
mapping (address => bool) VAR2;
function FUN1(uint VAR3) public {
require(VAR2[msg.sender] && VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] -= VAR3;
msg.sender.call.value(VAR3)();
}
}",17829.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR2 = true;
}
}",40089.sol,0,reentrancy
"contract CON1 {
address public VAR1 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
function FUN1 () public payable {
require (msg.value >= 0.005 ether);
VAR1.call.value(msg.value)();
}
}",16057.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1(uint VAR2) public {
if(VAR1[msg.sender] >= VAR2) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}
}",40758.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint256 VAR4, bytes VAR5) internal FUN1 {
require(VAR3.call.value(VAR4)(VAR5));
VAR1[VAR3] = VAR1[VAR3] - VAR4;
}
}",6607.sol,0,reentrancy
"contract CON1{
address public VAR1;
function FUN1() public {
var VAR2 = this.balance;
require(VAR1.call.value(VAR2)());
}
}",34432.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) FUN1 {
require(VAR1[0][msg.sender] >= VAR3);
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR3;
require(msg.sender.call.value(VAR3)());
}
}",35807.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
uint public VAR2 = 1 ether;
function FUN1(uint VAR3) public payable {
if(VAR1[msg.sender] >= VAR2 && VAR3 <= VAR1[msg.sender]) {
msg.sender.call.value(VAR3);
VAR1[msg.sender] -= VAR3;
}
}
}",22074.sol,1,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1() {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}",40779.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}
}",37499.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public payable {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}
}",22247.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3, bytes VAR4) public FUN1 returns (bool) {
if(true) {
if (VAR1[msg.sender] < VAR3) revert();
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
assert(msg.sender.call.value(VAR3)(VAR4));
return true;
}
return false;
}
}",3.sol,0,reentrancy
"contract CON1 {
address VAR1 = msg.sender;
function FUN1(uint VAR2, address VAR3) payable {
if(!VAR3.call.value(VAR2)()) { throw; }
}
}",27164.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) public payable {
if(VAR1[VAR2] > 0) {
if(VAR2.call.value(VAR3)()) {
VAR1[VAR2] -= VAR3;
}
}
}
}",22416.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) public FUN1 {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] -= VAR3;
msg.sender.call.value(VAR3);
}
}",23793.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) FUN1 returns (bool) {
if (VAR1[msg.sender] == 0){ throw; }
if (VAR3.call.value(VAR1[msg.sender])()) {
VAR1[msg.sender] = 0;
return true;
}
}
}",50035.sol,0,reentrancy
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping (address => uint) public VAR4;
function FUN1() {
if (VAR3 <= VAR2) throw;
uint256 VAR5 = VAR3 - VAR2;
if (!VAR1.call.value(VAR5)()) throw;
VAR3 -= VAR5;
VAR4[VAR1] -= VAR5;
}
}",39778.sol,1,reentrancy
"contract CON1 {
mapping (address => uint256) public VAR1;
function FUN1(uint VAR2) public {
require(VAR1[msg.sender] >= VAR2);
VAR1[msg.sender] -= VAR2;
if(!msg.sender.call.value(VAR2)()) { revert(); }
}
}",40782.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()){
VAR1[msg.sender] -= VAR2;
}
}
}
}",40776.sol,1,reentrancy
"contract CON1 {
mapping(address => mapping (address => uint32)) VAR1;
function FUN1(address VAR2, address VAR3) {
uint32 VAR4 = VAR1[VAR2][VAR3];
if (!VAR3.call.value(VAR4).gas(23000)()) { throw; }
VAR1[VAR2][VAR3] = 0;
}
}",50022.sol,1,reentrancy
"contract CON1 {
mapping (address=>uint256) public VAR1;
function FUN1() public payable {
if(VAR1[msg.sender] != 0) {
msg.sender.call.value(VAR1[msg.sender])();
VAR1[msg.sender] = 0;
}
}
}",24161.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(){
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if(!(msg.sender.call.value(VAR2)())){ throw; }
}
}",40759.sol,0,reentrancy
"contract CON1 {
function FUN1(uint256 VAR1) {
bool VAR2 = msg.sender.call.value(VAR1)();
if (!VAR2) { throw; }
}
}",40413.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3) returns (bool) {
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
if (!msg.sender.call.value(VAR3)()) revert();
return true;
}
}",24648.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
require(VAR3 > 0);
VAR1[VAR2] = 0;
require(VAR2.call.value(VAR3)());
}
}",30101.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
uint public VAR2;
address VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() FUN1 {
uint VAR4 = VAR1[msg.sender];
if (msg.sender.call.value(VAR4)()) {
VAR2 -= VAR4;
VAR1[msg.sender] = 0;
}
}
}",37708.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public {
if (VAR1[msg.sender] >= VAR2) {
require(msg.sender.call.value(VAR2)());
VAR1[msg.sender] -= VAR2;
}
}
}",40762.sol,1,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint256 VAR3, bytes VAR4) public FUN1 returns (bool) {
return VAR2.call.VAR3(VAR3)(VAR4);
}
}",10605.sol,0,reentrancy
"contract CON1{
function FUN1(address VAR1, uint VAR2) returns (bool) {
if (!VAR1.call.value(VAR2)()) revert();
return true;
}
}",32522.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",8872.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(uint VAR2, bytes VAR3) public returns (bool) {
if (VAR1[msg.sender] < VAR2) revert();
assert(msg.sender.call.value(VAR2)(VAR3));
VAR1[msg.sender] = VAR1[msg.sender] - VAR2;
return true;
}
}",50003.sol,1,reentrancy
"contract CON1 {
bool public VAR1;
address VAR2;
address VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public payable FUN1 {
if (!VAR2.call.value(msg.value)()) {
VAR1 = false;
} else {
VAR1 = true;
}
}
}",3212.sol,0,reentrancy
"contract CON1{
mapping (address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (msg.sender.call.value(VAR2)()) {
return true;
}
else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",36836.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
if (!msg.sender.call.value(VAR2)()) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
}
}",50006.sol,1,reentrancy
"contract CON1 {
address public VAR1 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2 () public FUN1 payable {
require (msg.value >= 0.005 ether);
VAR1.call.value(msg.value)();
}
}",16058.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
function FUN1(uint VAR2) public {
if(VAR1[msg.sender] >= VAR2) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}
}",40765.sol,1,reentrancy
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1() public returns (bool) {
uint VAR2 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if (msg.sender.call.value(VAR2)()) {
return true;
} else {
VAR1[msg.sender] = VAR2;
return false;
}
}
}",22635.sol,0,reentrancy
"contract CON1 {
struct Participant {
address VAR1;
uint VAR2;
}
Participant[] public VAR3;
uint public VAR4 = 0;
function VAR2() public {
uint VAR5 = address(this).VAR5;
require(VAR5 > 1);
uint VAR6 = VAR5 / 2;
VAR5 =- VAR6;
while (VAR5 > 0) {
uint VAR7 = VAR5 < VAR3[VAR4].VAR2 ? VAR5 : VAR3[VAR4].VAR2;
if(VAR7 > 0){
VAR3[VAR4].VAR2 -= VAR7;
VAR5 -= VAR7;
VAR3[VAR4].VAR1.call.value(VAR7).gas(1000000)();
}
}
}
}",18430.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public payable{
VAR1 = VAR2 ;
require(VAR1.call.value(msg.value)());
}
}",40760.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1 ;
function FUN1() {
if (!(msg.sender.call.value(VAR1[msg.sender])())) { throw ; }
VAR1[msg.sender] = 0;
}
}",40742.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
uint256 public constant VAR2 = 0.002 * 1000000000000000000;
function FUN1(address VAR3, uint256 VAR4) internal {
require(VAR4 <= VAR2);
require(VAR1[VAR3] >= VAR4);
VAR1[VAR3] = VAR1[VAR3] - VAR4;
VAR3.call.value(VAR4)();
}
}",19128.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
require(VAR1[0][msg.sender] >= VAR2);
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
require(msg.sender.call.value(VAR2)());
}
}",35806.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) {
VAR1.call.value(VAR2)(VAR3);
}
}",39341.sol,0,reentrancy
"contract CON1 {
uint256 private VAR1;
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
VAR1 -= VAR4;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}",40092.sol,0,reentrancy
"contract CON1 {
address public VAR1;
uint public VAR2 = 20 * 10**8 * 10**2;
uint public VAR3 = 0;
uint public VAR4 = 0;
mapping(address => uint) VAR5;
function FUN1(address VAR6) payable {
uint VAR7 = msg.value * block.timestamp;
require(VAR7 <= VAR2);
VAR5[VAR6] = VAR5[VAR6] + VAR7;
VAR4 = VAR4 + msg.value;
if (!VAR1.call.value(msg.value)()) revert();
VAR5[VAR1] -= msg.value;
}
}",50019.sol,1,reentrancy
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
if (!VAR1.call.value(this.balance)()) throw;
}
}",6193.sol,0,reentrancy
"contract CON1 {
mapping(address=>string) public VAR1;
mapping(address=>uint) public VAR2;
address public VAR3;
function FUN1(string VAR4) payable {
if(!VAR3.call.value(msg.value)()) throw;
VAR2[VAR3] -= msg.value;
VAR1[msg.sender] = VAR4;
}
}",39866.sol,1,reentrancy
"contract CON1{
mapping (address => uint) private VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) public FUN1 {
uint VAR4 = VAR1[VAR3];
VAR1[VAR3] = 0;
if (VAR3.call.value(VAR4)() == false) { throw; }
}
}",40786.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(){
if( !(msg.sender.call.value(VAR1[msg.sender])()) ){ throw; }
VAR1[msg.sender] = 0;
}
}",40777.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1() {
uint VAR2 = VAR1[msg.sender];
require(VAR2 > 0);
VAR1[msg.sender] = 0;
bool VAR3 = msg.sender.call.value(VAR2)();
require(VAR3);
}
}",37891.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender] -= VAR2;
}
}
}
}",40756.sol,1,reentrancy
"contract CON1{
function FUN1(address VAR1, uint VAR2, bytes VAR3) public {
require(VAR1.call.VAR2(VAR2)(VAR3));
}
}",31237.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(msg.value > 0);
VAR1.call.value(msg.value / (9) * (8))();
}
}",17009.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) FUN1 returns (bool) {
if (VAR1[msg.sender] == 0){ throw; }
if (VAR3.call.value(VAR1[msg.sender])()) {
VAR1[msg.sender] = 0;
return true;
}
}
}",40787.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2 = 0;
function FUN1() public returns (uint) {
uint VAR3 = VAR1[msg.sender] / 20;
require(msg.sender.call.value(VAR3)());
VAR1[msg.sender] -= VAR3;
VAR2 += VAR3;
return VAR2;
}
}",50008.sol,1,reentrancy
"contract CON1 {
uint public VAR1 = 1499436000;
address public VAR2;
function FUN1() {
if (block.timestamp < VAR1) throw;
if (!VAR2.call.value(this.balance)()) throw;
}
}",38876.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) public {
require(VAR1.call.value(VAR2)());
}
}",16884.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (uint) {
if (VAR2 > 0) {
VAR1.call.value(VAR2)(VAR3);
return 0;
}
}
}",40720.sol,0,reentrancy
"contract CON1 {
address public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) payable FUN1 {
if(!VAR1.call.value(msg.value)()) revert();
}
}",35714.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external {
bool VAR4 = VAR1.call.value(VAR2)(VAR3);
require(VAR4);
}
}",40768.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() {
if (!VAR1.call.value(this.balance)()) throw;
}
}",38888.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool){
require(VAR1 != address(0));
return VAR1.call.value(VAR2)(VAR3);
}
}",10970.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if(VAR2 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR2)()) {
VAR1[msg.sender]-=VAR2;
}
}
}
}",50002.sol,1,reentrancy
"contract CON1 {
address public VAR1;
uint public VAR2 = 20 * 10**8 * 10**2;
uint public VAR3 = 0;
mapping(address => uint) VAR4;
function FUN1(address VAR5) payable {
uint VAR6 = msg.value * block.timestamp;
require(VAR6 <= VAR2);
VAR4[VAR5] = VAR4[VAR5] + VAR6;
VAR3 = VAR3 + msg.value;
if (!VAR1.call.value(msg.value)()) revert();
}
}",36481.sol,0,reentrancy
"contract CON1 {
address VAR1;
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) public {
require(msg.sender == VAR1);
require(VAR2.call.VAR3(VAR3)(VAR4));
}
}",29983.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3) public FUN1 {
uint256 VAR4 = VAR1[VAR3];
require(VAR3.call.value(VAR4)());
VAR1[VAR3] = 0;
}
}",50026.sol,0,reentrancy
"contract CON1 {
function FUN1() public {
uint256 VAR1 = address(this).balance * 40 / 100;
assert(address(this).call.value(VAR2)());
uint256 VAR2 = address(this).balance - VAR1;
}
}",50012.sol,1,reentrancy
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2) public payable {
assert(msg.value >= VAR1 * VAR2);
if(!msg.sender.call.value(msg.value - VAR1 * VAR2)()){ revert(); }
}
}",28974.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
bool VAR2 = true;
address VAR3 = msg.sender;
address VAR4;
modifier FUN1() {
require(msg.sender == VAR4);
_;
}
function FUN2() FUN1 {
if(VAR1[VAR3] == 0) throw;
uint VAR5 = VAR1[VAR3];
VAR1[VAR3] = 0;
if(!(VAR3.call.value(VAR5)())) throw;
}
}",35662.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external {
require(VAR1.call.VAR2(VAR2)(VAR3));
}
}",31759.sol,0,reentrancy
"contract CON1 {
int256 public VAR1;
Proposal[] public VAR2;
struct Proposal {
address VAR3;
uint256 VAR4;
bool VAR5;
bool VAR6;
int256 VAR7;
}
function FUN1(uint256 VAR8, bytes VAR9) {
Proposal VAR10 = VAR2[VAR8];
if (VAR10.VAR7 > VAR1) {
if (!VAR10.VAR3.call.value(VAR10.VAR4)(VAR9)) throw;
VAR10.VAR6 = true;
} else {
VAR10.VAR6 = false;
}
}
}",39327.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
uint VAR2;
function FUN1() public returns (uint VAR3) {
VAR3 = VAR1[msg.sender] / 100;
VAR1[msg.sender] -= VAR3;
require(msg.sender.call.value(VAR3)());
VAR2 += VAR3;
return VAR2;
}
}",14994.sol,0,reentrancy
"contract CON1{
mapping (address => uint) private VAR1;
function FUN1(address VAR2) public {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if (VAR2.call.value(VAR3)() == false) { throw; }
}
}",40752.sol,0,reentrancy
"contract CON1 {
address VAR1;
function FUN1(uint256 VAR2) payable {
if (this.balance >= VAR2) {
VAR1.call.value(VAR2)();
}
}
}",40750.sol,0,reentrancy
"contract CON1{
mapping (address => uint256) public VAR1;
function FUN1() {
require(msg.sender.call.value(VAR1[msg.sender])());
VAR1[msg.sender] = 0;
}
}",40732.sol,1,reentrancy
"contract CON1 {
uint256 public VAR1 ;
mapping (address => uint) VAR2;
address VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public FUN1 returns (bool) {
require(msg.sender.call.value(VAR1)());
VAR2[msg.sender] = VAR2[msg.sender] - VAR1;
return true;
}
}",4833.sol,0,reentrancy
"contract CON1 {
mapping (address => bool) VAR1;
function FUN1() payable {
require(!VAR1[msg.sender]);
VAR1[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
}
}",27334.sol,0,reentrancy
"contract CON1 {
modifier FUN1() {
if(msg.sender != address(this)) throw;
_;
}
function FUN2(uint VAR1, address VAR2) FUN1 {
if(!VAR2.call.value(VAR1)()) throw;
}
}",50000.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, bytes VAR2, uint256 VAR3, uint256 VAR4) payable external {
require(VAR1.call.value(VAR3).gas(VAR4)(VAR2));
}
}",15553.sol,0,reentrancy
"contract CON1 {
struct Account {
uint VAR1;
address VAR2;
}
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2(Account storage VAR4, uint VAR5, bytes VAR6) internal FUN1 {
require(VAR4.VAR1 >= VAR5);
require(VAR4.VAR2.call.value(VAR5)(VAR6));
VAR4.VAR1 = VAR4.VAR1 - VAR5;
}
}",50029.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public payable returns (bool) {
require(VAR1 != address(this));
require(VAR1.call.value(msg.value)(VAR3));
return true;
}
}",14806.sol,0,reentrancy
"contract CON1 {
address VAR1;
function FUN1() {
require(VAR1.call.value(this.balance)(0));
}
}",37836.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(){
if(!(msg.sender.call.value(VAR1[msg.sender])())){ throw; }
VAR1[msg.sender] = 0;
}
}",40757.sol,1,reentrancy
"contract CON1{
address VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) external FUN1 returns(bool) {
return VAR2.call.value(VAR3)(VAR4);
}
}",40090.sol,0,reentrancy
"contract CON1{
mapping (address => uint256) public VAR1;
function FUN1(){
require(msg.sender.call.value(VAR1[msg.sender])());
VAR1[msg.sender] = 0;
}
}",40749.sol,1,reentrancy
"contract CON1 {
bool public VAR1;
function FUN1 (address VAR2, uint VAR3, bytes VAR4) {
if (!VAR2.call.value(VAR3)(VAR4)) throw;
}
}",39199.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4) external payable returns (bool) {
return VAR1.call.value(VAR2).gas(VAR3)(VAR4);
}
}",8342.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public returns (bool) {
return VAR1.call.VAR2(VAR2)(VAR3);
}
}",10604.sol,0,reentrancy
"contract CON1 {
uint256 public VAR1;
mapping (address => uint) VAR2;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2( address VAR4, uint256 VAR5) public FUN1 {
require(VAR5 <= VAR1);
require(VAR4.call.value(VAR5)());
VAR2[VAR4] -= VAR5;
}
}",18510.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
uint public VAR2 = 1 ether;
uint VAR3;
function FUN1(uint VAR4) public payable {
if(VAR1[msg.sender] >= VAR2 && VAR4 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR4)()) {
VAR1[msg.sender] -= VAR4;
}
}
}
}",40747.sol,1,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",40771.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() payable {
require(VAR1.call.value(msg.value)());
}
}",35951.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32) {
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
}",37474.sol,0,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint256 VAR3, bytes VAR4) external FUN1 returns (bool){
require(VAR2 != address(0));
return VAR2.call.value(VAR3)(VAR4);
}
}",10971.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(uint VAR2) public {
require(VAR1[msg.sender] >= VAR2);
VAR1[msg.sender] -= VAR2;
msg.sender.call.value(VAR2);
}
}",23792.sol,0,reentrancy
"contract CON1 {
mapping (uint => Transaction) public VAR1;
struct Transaction {
address VAR2;
uint VAR3;
bytes VAR4;
bool VAR5;
}
function FUN1(uint VAR6) public {
if (VAR6 > 0) {
Transaction VAR7 = VAR1[VAR6];
VAR7.VAR5 = true;
if (VAR7.VAR2.call.VAR3(VAR7.VAR3)(VAR7.VAR4))
return;
else {
VAR7.VAR5 = false;
}
}
}
}",27121.sol,0,reentrancy
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) external FUN1 returns (bool){
return VAR2.call.value(VAR3)(VAR4);
}
}",50027.sol,0,reentrancy
"contract CON1 {
struct Request {
address VAR1;
}
Request[2**64] public VAR2;
function FUN1() public {
if (msg.sender == VAR2[0].VAR1) {
if (!VAR2[0].VAR1.call.value(this.balance)()) { throw; }
}
}
}",39268.sol,0,reentrancy
"contract CON1 {
function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
}",40366.sol,0,reentrancy
"contract CON1 {
address VAR1 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() public payable FUN1 {
require(VAR1.call.value(msg.value)());
}
}",4599.sol,0,reentrancy
"contract CON1 {
function FUN1(uint VAR1, address VAR2) public {
for(uint VAR3 = 0; VAR3 < VAR1; VAR3++){
VAR2.call.value(0)();
}
}
}",25808.sol,0,reentrancy
"contract CON1 {
mapping (string => uint) VAR1;
function FUN1(uint VAR2) public payable {
uint VAR3 = 100 + msg.value;
if (VAR3 > VAR1[""price_pol""])
VAR3 = VAR1[""price_pol""];
require(msg.sender.call.value(VAR3)());
VAR1[""price_pol""] -= VAR3;
}
}",26523.sol,1,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
require(VAR2.call.value(VAR3)());
VAR1[VAR2] = 0;
}
}",50017.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint256 VAR2) public {
require(VAR1.call.value(VAR2)());
}
}",18771.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, bytes VAR2) payable public {
VAR1.call.value(msg.value)(VAR2);
}
}",40774.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
}",37676.sol,0,reentrancy
"contract CON1 {
address public VAR1 = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
function FUN1 () public payable {
require (msg.value >= 0.005 ether);
VAR1.call.value(msg.value)();
}
}",16054.sol,0,reentrancy
"contract CON1 {
struct Account {
int VAR1;
}
mapping(uint => Account) VAR2;
mapping(address => uint) VAR3;
function FUN1(uint VAR4) {
if (VAR3[msg.sender] > 0) {
if (int(VAR4) > 0) {
VAR2[VAR3[msg.sender]].VAR1 -= int(VAR4);
msg.sender.call.value(VAR4)();
}
}
}
}",40340.sol,0,reentrancy
"contract CON1 {
address public VAR1;
bool public VAR2;
address VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() FUN1 {
if (0 == this.balance) throw;
if (!VAR1.call.value(this.balance)()) throw;
}
}",37646.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(){
uint VAR2 = VAR1[msg.sender];
if(!(msg.sender.call.value(VAR2)())){ throw; }
VAR1[msg.sender] = 0;
}
}",40755.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
uint VAR3 = VAR1[msg.sender];
msg.sender.call.value(VAR3)();
VAR1[msg.sender] = 0;
}
}",50030.sol,0,reentrancy
"contract CON1 {
address VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, bytes VAR3) public FUN1 payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}",1431.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1(address VAR2) public payable {
VAR1 = VAR2 ;
require(VAR1.call.value(msg.value)());
}
}",40741.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) FUN1 {
if(VAR3 <= VAR1[msg.sender]) {
if(msg.sender.call.value(VAR3)()){
VAR1[msg.sender] -= VAR3;
}
}
}
}",29090.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() public {
bool VAR2 = msg.sender.call.value(address(this).balance)();
VAR1[msg.sender] = VAR1[address(this)];
VAR1[address(this)] = 0;
}
}",40775.sol,1,reentrancy
"contract CON1{
function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public returns (bool) {
return VAR1.call.VAR2(VAR2)(VAR3);
}
}",17518.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint VAR4) public FUN1 payable {
if(VAR1[msg.sender] > 0) {
if(VAR1[VAR3] >= VAR4) {
VAR3.call.value(VAR4)();
VAR1[VAR3] -= VAR4;
}
}
}
}",26743.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 {
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
if(!(msg.sender.call.value(VAR3)())){ throw; }
}
}",40788.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() returns (bool) {
return VAR1.call.value(this.balance)();
}
}",39705.sol,0,reentrancy
"contract CON1 {
bool VAR1 = false;
function FUN1() payable {
if ((msg.value == 1 ether) && (!VAR1)) {
if (!msg.sender.call.value(2 ether)())
VAR1 = true;
throw;
}
}
}",9654.sol,0,reentrancy
"contract CON1 {
mapping(address => uint) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) public FUN1 {
if(VAR1[msg.sender] >= VAR3) {
if(msg.sender.call.value(VAR3)()) {
VAR1[msg.sender] -= VAR3;
}
}
}
}",50036.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3) internal {
require(VAR3 <= 0.002 * 1000000000000000000);
require(VAR1[VAR2] >= VAR3);
VAR2.call.value(VAR3)();
VAR1[VAR2] = VAR1[VAR2] - VAR3;
}
}",50010.sol,1,reentrancy
"contract CON1{
address VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public FUN1 {
require(VAR2.call.VAR3(VAR3)(VAR4));
}
}",31238.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint256 VAR4) internal FUN1 {
require(VAR4 <= 0.002 * 1000000000000000000);
require(VAR1[VAR3] >= VAR4);
VAR3.call.value(VAR4)();
VAR1[VAR3] = VAR1[VAR3] - VAR4;
}
}",50025.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) public {
uint256 VAR3 = VAR1[VAR2];
require(VAR2.call.value(VAR3)());
VAR1[VAR2] = 0;
}
}",50015.sol,1,reentrancy
"contract CON1{
address public VAR1;
function FUN1() {
if (0 == this.balance) throw;
if (!VAR1.call.value(this.balance)()) throw;
}
}",38250.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
if (!msg.sender.call.value(VAR2)()) throw;
VAR1[0][msg.sender] -= VAR2;
}
}",40415.sol,1,reentrancy
"contract CON1 {
function FUN1(address VAR1) public {
assert(VAR1.call.value(this.balance)());
}
}",29130.sol,0,reentrancy
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1(uint VAR3) {
uint VAR4 = VAR3 * VAR2;
if (!VAR1.call.value(VAR4 /(1 ether))()) throw;
}
}",40299.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[msg.sender] >= VAR2) {
msg.sender.call.value(VAR2)();
VAR1[msg.sender] -= VAR2;
}
}
}",40745.sol,1,reentrancy
"contract CON1 {
}
contract CON2 {
CON1 VAR1 = CON1(0x2bd2326c993dfaef84f696526064ff22eba5b362);
function FUN1(address VAR2) {
if (VAR1.forked()) {
VAR2.call.value(msg.value)();
}
}
}",40357.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() payable public {
require(VAR1.call.value(msg.value).gas(1000000)());
}
}",18438.sol,0,reentrancy
"contract CON1{
function FUN1(address VAR1, uint VAR2) returns (bool) {
if (VAR1.call.value(VAR2)()) {
return true;
} else {
return false;
}
}
}",40500.sol,0,reentrancy
"contract CON1 {
mapping (address => uint256) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint VAR3) public FUN1 {
require(VAR1[msg.sender] >= VAR3);
VAR1[msg.sender] -= VAR3;
if(!msg.sender.call.value(VAR3)()) { revert(); }
}
}",40783.sol,0,reentrancy
"contract CON1{
mapping (bytes32 => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) {
bytes32 VAR4 = sha256(VAR2, VAR3, msg.sender);
uint VAR5 = VAR1[VAR4];
delete VAR1[VAR4];
if (!msg.sender.call.value(VAR5)()) throw;
}
}",38651.sol,0,reentrancy
"contract CON1 {
function FUN1( address VAR1, bytes VAR2)returns (bool VAR3) {
require(VAR1.call.value(0)(VAR2));
VAR3 = true;
}
}",35208.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) VAR1;
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!msg.sender.call.value(VAR3)()) revert();
VAR1[msg.sender] = VAR1[msg.sender] - VAR3;
VAR1[VAR2] = VAR1[VAR2] + VAR3;
return true;
}
}",50014.sol,1,reentrancy
"contract CON1{
mapping (address => uint) private VAR1;
function FUN1(address VAR2) public {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if (VAR2.call.value(VAR3)() == false) { throw; }
}
}",40733.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) {
if (VAR1[msg.sender] >= VAR2) {
msg.sender.call.value(VAR2)();
VAR1[msg.sender] -= VAR2;
}
}
}",40764.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2) returns (bool) {
if (VAR2.call.value(VAR1[msg.sender])()) {
VAR1[msg.sender] = 0;
return true;
}
}
}",40735.sol,1,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() {
if (0 == this.balance) throw;
if (!VAR1.call.value(this.balance)()) throw;
}
}",37645.sol,0,reentrancy
"contract CON1{
mapping(address => uint) public VAR1;
address VAR2 = msg.sender;
function FUN1() {
if(VAR1[VAR2] == 0) throw;
uint VAR3 = VAR1[VAR2];
delete VAR1[VAR2];
if(!(VAR2.call.value(VAR3)())) throw;
}
}",38828.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3){
VAR1.call.value(VAR2)(VAR3);
}
}",39032.sol,0,reentrancy
"contract CON1 {
mapping (address => mapping (address => uint)) VAR1;
function FUN1(uint VAR2) {
if (VAR1[0][msg.sender] < VAR2) throw;
VAR1[0][msg.sender] = VAR1[0][msg.sender] - VAR2;
if (!msg.sender.call.value(VAR2)()) throw;
}
}",40336.sol,0,reentrancy
"contract CON1{
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
if (VAR2 == 0) {
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
}
}",38543.sol,0,reentrancy
"contract CON1 {
struct Milestone {
address VAR1;
}
Milestone[] public VAR2;
function FUN1(uint VAR3) internal {
Milestone VAR4 = VAR2[VAR3];
if (!VAR4.VAR1.call.value(0)()) throw;
}
}",34668.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
uint public VAR2 = 1 ether;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2(uint VAR4) public payable FUN1 {
if(VAR1[msg.sender] >= VAR2 && VAR4 <= VAR1[msg.sender]) {
msg.sender.call.value(VAR4);
VAR1[msg.sender] -= VAR4;
}
}
}",22075.sol,0,reentrancy
"contract CON1 {
address VAR1 = msg.sender;
function FUN1(uint VAR2, address VAR3) payable {
if(msg.sender != address(this)) throw;
if(!VAR3.call.value(VAR2)()) { throw; }
}
}",27263.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, uint VAR4, bytes VAR5) public FUN1 returns (bool) {
require(VAR1[msg.sender] >= VAR4);
VAR1[msg.sender] = VAR1[msg.sender] - VAR4;
VAR1[VAR3] = VAR1[VAR3] + VAR4;
assert(msg.sender.call.value(0)());
return true;
}
}",6604.sol,0,reentrancy
"contract CON1{
mapping (address => uint) public VAR1;
function FUN1(address VAR2) internal {
uint VAR3 = VAR1[VAR2];
VAR1[VAR2] = 0;
if (VAR3 > 0) {
if (VAR2.call.value(VAR3)()) {
return;
} else {
VAR1[VAR2] = VAR3;
}
}
}
}",39749.sol,0,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(uint VAR2) public {
if (VAR1[msg.sender] >= VAR2) {
VAR1[msg.sender] -= VAR2;
require(msg.sender.call.value(VAR2)());
}
}
}",40763.sol,0,reentrancy
"contract CON1 {
uint public VAR1 = 30;
uint public VAR2 = 100;
address public VAR3;
bytes4 VAR4;
mapping (address => uint) VAR5;
function FUN1() {
uint VAR6 = VAR2 * (100 - VAR1) / 100;
if (!VAR3.call.value(VAR6)(VAR4)) throw;
VAR5[VAR3] -= VAR6;
}
}",39019.sol,1,reentrancy
"contract CON1{
function FUN1(uint256 VAR1) {
assert(msg.sender.call.value(VAR1)());
}
}",39817.sol,0,reentrancy
"contract CON1 {
address public VAR1;
function FUN1() public {
require(this.balance > 0);
VAR1.call.value(this.balance)();
}
}",30460.sol,0,reentrancy
"contract CON1 {
mapping(address => mapping (address => uint32)) VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3, address VAR4) FUN1 {
uint32 VAR5 = VAR1[VAR3][VAR4];
if (!VAR4.call.value(VAR5).gas(23000)()) { throw; }
VAR1[VAR3][VAR4] = 0;
}
}",50031.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) {
VAR1.call.value(VAR2)(VAR3);
}
}",40242.sol,0,reentrancy
"contract CON1 {
function FUN1() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}",21697.sol,0,reentrancy
"contract CON1 {
function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
}",36456.sol,0,reentrancy
"contract CON1{
address public VAR1;
function FUN1() public payable {
bytes4 VAR2 = bytes4(sha3(""buy()""));
if (!VAR1.call.value(msg.value)(VAR2)) throw;
}
}",39912.sol,0,reentrancy
"contract CON1 {
mapping(address => uint256) private VAR1;
function FUN1() external returns (bool VAR2) {
uint256 VAR3 = VAR1[msg.sender];
if (!msg.sender.call.value(VAR3)()) { throw; }
VAR1[msg.sender] = 0;
VAR2 = true;
}
}",50016.sol,1,reentrancy
"contract CON1 {
mapping (address => uint) public VAR1;
address VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() public FUN1 {
assert(msg.sender.call.value(VAR1[msg.sender])()) ;
VAR1[msg.sender] = 0;
}
}",16926.sol,0,reentrancy
"contract CON1 {
address public VAR1;
uint64 VAR2;
function CON1(address VAR3) public {
VAR1 = VAR3;
VAR2 = uint64(block.timestamp);
return;
}
}",33638.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
}",11457.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
function FUN1(uint256 VAR2, uint256 VAR3) external {
require(VAR2 > block.timestamp);
require(VAR3 > 0);
VAR1 = VAR3;
}
}",50001.sol,0,timestamp
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
function FUN1() public returns (uint256) {
uint256 VAR3 = VAR1 + block.timestamp;
VAR2 = addmod(uint256(block.blockhash(block.number-1)), VAR3, VAR1);
return VAR2;
}
}",2253.sol,1,timestamp
"contract CON1 {
mapping(address => bool) public VAR1;
Ho[8] public VAR2;
struct Ho {
uint VAR3;
}
function FUN1(uint VAR4) public payable {
Ho VAR5 = VAR2[VAR4];
if (block.timestamp % VAR5.VAR3 == 0) {
VAR1[msg.sender] = true;
}
return;
}
}",15641.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable {
require(block.timestamp < VAR2 && VAR1 > 0);
}
}",3654.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint) public VAR3;
function FUN1(address VAR4, address VAR5) public {
require(VAR3[msg.sender] == 1 || (block.timestamp - VAR3[msg.sender]) >= 60);
VAR2[msg.sender] -= VAR1;
return;
}
}",35358.sol,0,timestamp
"contract CON1 {
uint public VAR1 = 1 hours;
uint public VAR2;
function () external payable {
require(msg.value == 0.1 ether);
if ((VAR2 + VAR1) < block.timestamp) {
VAR2 = 100;
}
}
}",34995.sol,1,timestamp
"contract CON1 {
uint256 VAR1;
function FUN1() public payable {
VAR1 = block.timestamp;
}
}",8141.sol,0,timestamp
"contract CON1 {
uint256[] public VAR1;
uint256[] public VAR2;
}",4467.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = now;
}",40748.sol,1,timestamp
"contract CON1 {
function FUN1(uint32 VAR1) payable external {
require(block.timestamp < VAR1, ""Signature has expired"");
return;
}
}",12115.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) private VAR2;
function FUN1(address VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2[VAR3];
if (VAR4 > 0 && VAR4 < block.timestamp) {
return (VAR1[VAR3] * VAR4);
}
return 0;
}
}",13993.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
uint256 public VAR2;
function CON1() public {
VAR2 = block.timestamp;
VAR1 = VAR2;
return;
}
}",11159.sol,0,timestamp
"contract CON1 {
mapping (address => uint) VAR1;
uint constant VAR2 = 1596067200;
function FUN1() {
require (block.timestamp > VAR2 && VAR1[msg.sender] > 0);
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
return;
}
}",39091.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() external FUN1() returns (uint256) {
require(VAR2 == 0);
VAR2 = block.timestamp;
VAR3 = VAR2 + VAR4;
return VAR3;
}
}",1182.sol,1,timestamp
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
function FUN1(uint VAR3) returns (uint256) {
uint VAR4;
for (VAR4 = 0; VAR4 < VAR2 % 5; VAR4++){
VAR1 = VAR1 - block.timestamp;
}
return VAR1;
}
}",40005.sol,1,timestamp
"contract CON1 {
struct Settings {
uint32 VAR1;
}
Settings VAR2;
function FUN1() public {
uint32 VAR3 = uint32(block.timestamp / 1 days);
VAR2.VAR1 = VAR3;
return;
}
}",14997.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint256){
uint VAR3 = block.timestamp;
VAR2 = VAR3 + VAR1;
return VAR2;
}
}",9230.sol,1,timestamp
"contract CON1 {
uint32 internal VAR1;
function FUN1() public{
uint32 VAR2 = uint32(block.timestamp);
require(VAR1 > VAR2);
VAR1 = VAR2;
return;
}
}",31892.sol,0,timestamp
"contract CON1{
uint[5] public VAR1;
uint public VAR2 = 2;
uint public VAR3 = 1;
function FUN1() public {
require(block.timestamp - VAR2 >= VAR1[uint8(VAR3)]);
}
}",40743.sol,0,timestamp
"contract CON1{
uint public VAR1 = 1533364469;
function FUN1(uint256 VAR2, uint256 VAR3) returns (uint256) {
require(block.timestamp <= VAR1);
return VAR3 - VAR2;
}
}",1825.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
uint constant public VAR3 = 3 hours;
uint public VAR4;
uint public VAR5 = 8 days;
function FUN1() internal returns (uint){
VAR1 = block.timestamp;
VAR2 = VAR1 + (VAR3);
VAR4 = VAR2 + (VAR5);
return VAR4;
}
}",14711.sol,1,timestamp
"contract CON1 {
uint public VAR1;
enum State {PreFunding, Failure}
function FUN1() public constant returns (State) {
if (block.timestamp < VAR1) return State.PreFunding;
else return State.Failure;
}
}",44.sol,1,timestamp
"contract CON1 {
function FUN1() public payable {
uint VAR1 = block.timestamp;
require(VAR1 > 0);
return;
}
}",12460.sol,0,timestamp
"contract CON1 {
bool public VAR1 = false;
uint256 public VAR2 = 0;
uint256 public VAR3;
function FUN1() public {
uint256 VAR4 = block.timestamp - (VAR3);
VAR2 = VAR2 - (VAR4);
VAR1 = false;
return;
}
}",28101.sol,0,timestamp
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4 + 365*24*60*60;
assert(VAR5 > VAR4);
VAR1[VAR2] = VAR5;
return;
}
}",34575.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",3729.sol,1,timestamp
"contract CON1{
enum State {PARTICIPATION, CHOOSE_WINNER}
State public VAR1;
uint public VAR2;
function FUN1() external {
if (msg.sender == 1) {
require(VAR1 == State.PARTICIPATION || VAR1 == State.CHOOSE_WINNER);
} else {
require((VAR1 == State.CHOOSE_WINNER) && (VAR2 != 0) && (block.timestamp > VAR2 + 1 days));
}
return;
}
}",37684.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
require(block.timestamp >= VAR1);
return true;
}
}",650.sol,0,timestamp
"contract CON1{
uint public VAR1 = 0;
function FUN1() constant returns (uint) {
if(VAR1 > 0) {
return VAR1;
}
return block.timestamp;
}
}",38392.sol,1,timestamp
"contract CON1 {
bytes32 public VAR1;
bool VAR2 = false;
uint256 public VAR3;
function FUN1(bytes32 VAR4) public {
require(block.timestamp > VAR3);
VAR1 = VAR4;
VAR2 = true;
return;
}
}",34725.sol,0,timestamp
"contract CON1 {
uint VAR1;
uint VAR2 = 1000;
function FUN1(bytes32 VAR3, uint VAR4) constant public returns (uint VAR5) {
return (uint(keccak256(VAR3, block.timestamp, VAR1, VAR4 )) % VAR2);
}
}",27455.sol,1,timestamp
"contract CON1 {
mapping(address => TimeLock[2]) public VAR1;
struct TimeLock {
uint256 VAR2;
uint256 VAR3;
}
uint256 VAR4 = 0;
uint256 VAR5 = 0;
function FUN1(address VAR6) private {
if (VAR1[VAR6][0].VAR2 < block.timestamp) {
VAR5 = VAR5 + (VAR1[VAR6][0].VAR3);
}
else {
VAR4 = VAR4 + (VAR1[VAR6][1].VAR3);
}
}
}",211.sol,1,timestamp
"contract CON1 {
struct Vesting {
uint256 VAR1;
uint256 VAR2;
}
mapping(address => Vesting) public VAR3;
}",625.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) external returns (uint) {
require(block.timestamp < VAR3);
VAR1 = VAR1 + VAR2;
return VAR1;
}
}",42.sol,0,timestamp
"contract CON1 {
mapping (address => uint) public VAR1;
uint constant VAR2 = 1543481761;
function FUN1() {
require (block.timestamp > VAR2 && VAR1[msg.sender] > 0);
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
return;
}
}",37017.sol,0,timestamp
"contract CON1 {
mapping(address => Account) internal VAR1;
struct DirectDebitInfo {
uint256 VAR2;
}
struct DirectDebit {
DirectDebitInfo VAR3;
uint256 VAR4;
}
struct Instrument {
DirectDebit VAR5;
}
struct Account {
mapping (address => Instrument) VAR6;
}
function FUN1(address VAR7) public returns (bool) {
Account storage VAR8 = VAR1[VAR7];
DirectDebit storage VAR9 = VAR8.VAR6[msg.sender].VAR5;
uint256 VAR4 = (block.timestamp - VAR9.VAR3.VAR2) + 1;
uint256 VAR10 = VAR4 - (VAR9.VAR4);
require(VAR10 > 0);
return true;
}
}",578.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() internal returns(uint256) {
uint256 VAR2 = uint256(keccak256(block.timestamp, uint256(VAR1 * block.difficulty)));
VAR1 = uint256(VAR2 * block.number);
return VAR1;
}
}",12919.sol,1,timestamp
"contract CON1{
uint256 public VAR1;
}",40746.sol,1,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1() returns (bool VAR3) {
if(msg.sender == VAR1 ) {
VAR1.send(this.balance / 2);
VAR2 = block.timestamp;
VAR3 = true;
}
}
}",40665.sol,0,timestamp
"contract CON1 {
uint public VAR1;
function FUN1(uint VAR2) returns (bool) {
if (VAR2 > block.timestamp && VAR1 == 0) {
VAR1 = VAR2;
return true;
}
return false;
}
}",40726.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1 () external returns (bool VAR2) {
require(block.timestamp > VAR1);
selfdestruct(msg.sender);
return true;
}
}",15671.sol,0,timestamp
"contract CON1 {
uint64 public VAR1;
uint64 public VAR2;
function FUN1() public {
require(uint64(block.timestamp) >= VAR1);
require(VAR2 > 0);
return;
}
}",31551.sol,0,timestamp
"contract CON1 {
mapping(address => Account) internal VAR1;
struct DirectDebitInfo {
uint256 VAR2;
uint256 VAR3;
uint256 VAR4;
}
struct DirectDebit {
DirectDebitInfo VAR5;
uint256 VAR6;
}
struct Instrument {
uint256 VAR7;
DirectDebit VAR8;
}
struct Account {
uint256 VAR9;
uint256 VAR10;
mapping (address => Instrument) VAR11;
}
function FUN1(address VAR12) public returns (uint) {
Account storage VAR13 = VAR1[VAR12];
DirectDebit storage VAR14 = VAR13.VAR11[msg.sender].VAR8;
uint256 VAR6 = (block.timestamp - (VAR14.VAR5.VAR3) / VAR14.VAR5.VAR4) + (1);
uint256 VAR2 = VAR6 - (VAR14.VAR6) * (VAR14.VAR5.VAR2);
return VAR2;
}
}",10295.sol,1,timestamp
"contract CON1 {
uint32 public VAR1 = 0;
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(block.timestamp - VAR2 > VAR1) {
VAR2 = 0;
} else {
require (VAR2 == 1);
}
return VAR2;
}
}",798.sol,0,timestamp
"contract CON1 {
bool public VAR1;
function FUN1() public returns (bool) {
if (!VAR1 && block.timestamp >= 1524801600) {
return false;
}
return true;
}
}",16979.sol,1,timestamp
"contract CON1 {
}
contract CON2 {
CON1 public VAR1 = CON1(0x611171923b84185e9328827CFAaE6630481eCc7a);
uint256 public VAR2 = 1537833600;
uint public VAR3 = 18600000 ether;
function FUN1 () public returns (bool){
require(VAR2 <= block.timestamp);
require(VAR3 > 0);
uint VAR4 = VAR1.balanceOf(this);
require(VAR4 >= VAR3);
return false;
}
}",4882.sol,0,timestamp
"contract CON1{
mapping (address => uint256) public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(address VAR3,uint256 VAR4) FUN1 public returns (bool) {
if(VAR4 > block.timestamp) {
VAR1[VAR3] = VAR4;
return true;
}
return false;
}
}",4523.sol,1,timestamp
"contract CON1{
uint256 public VAR1 = 2;
uint256 public VAR2 = 0;
uint256 VAR3 = 2;
function FUN1(uint256 VAR4) public {
if (block.timestamp >= VAR2) {
VAR1 = VAR4 / VAR3;
} else {
VAR1 = (VAR4 + 100) / (VAR3);
}
return;
}
}",40751.sol,1,timestamp
"contract CON1 {
uint constant VAR1 = 1514402746;
function FUN1(address VAR2) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > VAR1);
return true;
}
}",30815.sol,0,timestamp
"contract CON1 {
uint32 public VAR1;
}",1014.sol,1,timestamp
"contract CON1 {
uint public VAR1;
function FUN1() public {
require(block.timestamp >= VAR1);
msg.sender.transfer(this.balance);
}
}",50221.sol,0,timestamp
"contract CON1 {
uint public VAR1 = now;
uint[3] public VAR2 = [1000 finney, 800 finney, 650 finney];
}",31999.sol,1,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
uint public VAR3;
function FUN1(address VAR4) {
if(VAR1 != 0x0 ) {
VAR1.send(VAR2);
VAR3 = block.timestamp;
return;
}
return;
}
}",40587.sol,0,timestamp
"contract CON1 {
uint256 constant VAR1 = 1595609911;
uint256 constant VAR2 = 30 days;
uint256 constant VAR3 = 90 days;
uint256 constant VAR4 = 8;
}",40754.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
}",170.sol,1,timestamp
"contract CON1 {
function FUN1(){
uint256 VAR1 = now;
uint256 VAR2 = 4;
uint256 VAR3 = 5;
uint256 VAR4;
if (VAR1 == block.timestamp) {
if (VAR2 != 0) {
VAR4 = VAR3;
} else {
VAR4 = 0;
}
}
}
}",40744.sol,0,timestamp
"contract CON1 {
bool public VAR1 = false;
uint256 public VAR2;
function FUN1() public returns(bool) {
require(VAR2 >= block.timestamp);
VAR1 = true;
return VAR1;
}
}",10342.sol,0,timestamp
"contract CON1 {
function() payable {
if (msg.value >= 10 finney) {
bytes20 VAR1 = ripemd160(block.coinbase, block.number, block.timestamp);
if (VAR1[0] == 0) {
uint8 VAR2 = ((VAR1[1] & 0x01 != 0) ? 1 : 0);
uint256 VAR3 = (msg.value * 100) * VAR2;
}
}
}
}",40727.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 10;
}",948.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint VAR2 = 86400;
}",1319.sol,1,timestamp
"contract CON1 {
struct chronus_info {
uint32 VAR1;
uint32 VAR2;
uint32 VAR3;
}
chronus_info public VAR4;
address public VAR5;
modifier FUN1 {
require(VAR5 == msg.sender);
_;
}
function FUN2(uint32 VAR6, uint32 VAR7) FUN1 external payable returns (uint32) {
VAR4.VAR1 = uint32(block.timestamp);
VAR4.VAR2 = VAR6;
VAR4.VAR3 = VAR7;
return VAR4.VAR1;
}
}",1256.sol,1,timestamp
"contract CON1{
uint256 constant VAR1 = 69;
mapping(uint256 => address) VAR2;
function() payable public {
if (msg.value >= VAR1){
uint256 VAR3 = uint256(block.timestamp);
uint256 VAR4 = uint256(block.coinbase);
uint256 VAR5 = uint256(keccak256(VAR3 + VAR4));
address VAR6 = VAR2[VAR5];
VAR6.transfer(VAR1);
}
}
}",19182.sol,1,timestamp
"contract CON1 {
uint public VAR1 = 0;
function FUN1() public returns(uint){
VAR1 = block.timestamp;
return VAR1;
}
}",11931.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
uint256 public VAR2 = 0;
}",28383.sol,1,timestamp
"contract CON1 {
}",40753.sol,1,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
}",12393.sol,1,timestamp
"contract CON1{
function FUN1() constant returns (uint32) {
return uint32(block.timestamp);
}
}",30772.sol,1,timestamp
"contract CON1 {
struct Record {
uint256 VAR1;
}
mapping (uint256 => Record) VAR2;
uint256 public VAR3;
function CON1(uint256 VAR4) {
VAR3 = VAR4;
VAR2[VAR3].VAR1 = block.timestamp;
return;
}
}",36451.sol,0,timestamp
"contract CON1 {
uint256 constant public VAR1 = 126000 ether;
uint256 public VAR2;
enum State { Funded }
State public VAR3;
function FUN1() public payable returns (bool VAR4) {
if (VAR2 >= VAR1 || block.timestamp >= VAR1) {
VAR3 = State.Funded;
}
return true;
}
}",739.sol,1,timestamp
"contract CON1 {
uint private VAR1;
mapping (address => uint256) public VAR2;
function () external payable {
VAR1 += block.timestamp;
uint VAR3 = uint(block.blockhash(block.number - 1));
uint VAR4 = uint(sha256(VAR3 + VAR1)) % 10000000;
if (block.timestamp < VAR4) {
VAR2[msg.sender]++;
}
}
}",6220.sol,1,timestamp
"contract CON1{
struct Group {
uint256 VAR1;
}
mapping(uint256 => Group) internal VAR2;
uint256 public VAR3;
function FUN1() public payable returns(bool VAR4) {
Group storage VAR5 = VAR2[VAR3];
uint256 VAR6 = block.timestamp;
require(VAR6 >= VAR5.VAR1);
}
}",3772.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
uint64 public VAR2 = 1518825600;
function FUN1(uint256 VAR3) public returns (bool) {
uint64 VAR4 = uint64(block.timestamp);
require(VAR4 >= VAR2);
VAR1[msg.sender] = VAR1[msg.sender] - (VAR3);
return true;
}
}",29409.sol,0,timestamp
"contract CON1 {
uint8[4] public VAR1;
uint VAR2;
}",22272.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
VAR1 = block.timestamp;
return true;
}
}",4587.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
function FUN1() public {
if (block.timestamp < VAR4) throw;
uint256 VAR5 = uint256(VAR2 * 50)/100;
VAR5 = VAR5 + VAR3;
if (VAR5 > 0)
if (!VAR1.send(VAR5)) throw;
return;
}
}",40419.sol,0,timestamp
"contract CON1 {
mapping (address => uint) VAR1;
uint constant VAR2 = 1596067200;
function FUN1() {
if (block.timestamp < VAR2) throw;
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
return;
}
}",39095.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 2 * 365 days;
uint256 public VAR2 = 8;
uint256 public VAR3 = 0;
}",10369.sol,1,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
uint public VAR3;
modifier FUN1() {
if(msg.sender != VAR1) throw;
_;
}
function FUN2() FUN1 {
if(block.timestamp < VAR2 || VAR3 == 0) throw;
uint VAR4 = VAR3;
VAR3 = 0;
if(!VAR1.send(VAR4)) throw;
return;
}
}",40155.sol,0,timestamp
"contract CON1 {
uint256[] public VAR1 = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
uint256[] public VAR2 = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
}",1404.sol,1,timestamp
"contract CON1 {
uint VAR1 = 1;
function FUN1() public {
uint VAR2 = block.timestamp;
if (VAR1 == 1) {
VAR1 == VAR2;
}
else {
uint256 VAR3 = (VAR2 - (30 days));
assert(VAR3 < VAR2);
if (VAR1 < VAR3) {
VAR1 = 1;
}
}
return;
}
}",12841.sol,1,timestamp
"contract CON1 {
uint public constant VAR1 = 1572566400;
function FUN1() constant returns (bool) {
return (block.timestamp < VAR1);
}
}",15930.sol,1,timestamp
"contract CON1 {
mapping (address => bytes32) public VAR1;
mapping (uint8 => mapping (address => bytes32)) public VAR2;
}",40737.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
mapping (address => uint) public VAR3;
uint public VAR4;
function FUN1(address VAR5) external payable returns(uint){
uint VAR6 = msg.value * 10;
if (block.timestamp - VAR1 < 2 weeks) {
VAR6 = (VAR6 * 10) / 9;
}
VAR3[VAR5] += VAR6;
VAR4 += VAR6;
if (VAR4 > VAR2) { throw; }
return VAR6;
}
}",39715.sol,1,timestamp
"contract CON1{
uint256 constant public VAR1 = 1539097200;
address public VAR2 =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;
function FUN1(address VAR3)payable {
require(VAR3 != 0x0);
require(block.timestamp <= VAR1);
uint256 VAR4 = msg.value;
VAR2.transfer(msg.value);
return;
}
}",35322.sol,0,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
bool public VAR3 = false;
function FUN1() public returns (bytes32 VAR4) {
if (block.timestamp <= VAR2 && block.timestamp >= VAR1) {
VAR3 = false;
return ""Eth < Softcap"";
}
}
}",30060.sol,1,timestamp
"contract CON1 {
uint256[2] internal VAR1;
address VAR2 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR3) public returns (bool) {
uint256 VAR4 = block.timestamp;
if (msg.sender == VAR2) {
VAR1[0] = VAR4;
}
return true;
}
}",2397.sol,1,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
}",12465.sol,1,timestamp
"contract CON1 {
address public VAR1 = msg.sender;
uint public VAR2 = 1 finney;
uint public VAR3 = 0;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(uint VAR4) FUN1 {
VAR2 = VAR4;
VAR3 = block.timestamp;
return;
}
}",38727.sol,0,timestamp
"contract CON1 {
address public VAR1;
mapping(address => uint256) public VAR2;
modifier FUN1() {
require(msg.sender == VAR1 || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);
_;
}
function FUN2() public FUN1 returns (uint256) {
uint64 VAR3 = uint64(block.VAR3);
require(VAR3 >= 1546300801);
return VAR2[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}",738.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2) internal constant returns (uint256) {
uint256 VAR3 = block.timestamp;
uint256 VAR4 = VAR1[VAR2];
uint256 VAR5 = VAR3 - (VAR4);
uint256 VAR6 = 0;
if(VAR5 >= 365 days) {
VAR6 = (VAR5 / (30 days)) + (1);
}
uint256 VAR7 = VAR7 * (VAR6) / (12) ;
return VAR7;
}
}",5164.sol,1,timestamp
"contract CON1 {
uint public VAR1;
bool public VAR2;
enum State{ PreFunding, Failure, Finalized}
function FUN1() public constant returns (State) {
if(VAR2) return State.Finalized;
else if (block.timestamp < VAR1) return State.PreFunding;
else return State.Failure;
}
}",40736.sol,1,timestamp
"contract CON1 {
struct Holder {
uint VAR1;
}
mapping (address => Holder) VAR2;
function FUN1() {
require(VAR2[msg.sender].VAR1 < block.timestamp);
VAR2[msg.sender].VAR1 = 0;
return;
}
}",38925.sol,0,timestamp
"contract CON1 {
uint256 constant public VAR1 = 1507755600;
function FUN1() constant returns (uint8) {
if (block.timestamp < VAR1)
return 166;
return 120;
}
}",36661.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns (uint VAR2) {
if (block.VAR2 < VAR1)
return VAR1;
else
return 0;
}
}",5934.sol,1,timestamp
"contract CON1 {
mapping(address => uint) VAR1;
function FUN1 (uint256 VAR2) public returns (bool VAR3) {
require(VAR1[msg.sender] >= VAR2 && block.timestamp > 10);
return true;
}
}",5132.sol,0,timestamp
"contract CON1 {
uint VAR1;
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR1 > block.timestamp) {
VAR3 += VAR2;
msg.sender.call.value(VAR3);
}
return VAR3;
}
}",318.sol,1,timestamp
"contract CON1 {
function FUN1() constant returns (uint) {
return block.timestamp;
}
}",9918.sol,1,timestamp
"contract CON1 {
uint64 public VAR1 = 0;
function FUN1(uint256 VAR2) private {
if (block.timestamp <= VAR1) {
require(VAR2 == 0.64 ether);
}
else {
require(VAR2 == 0.99 ether);
}
}
}",124.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 4000;
uint256 public VAR2 = 1539129600;
}",12292.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
bool VAR3;
function FUN1() public {
VAR1 = block.timestamp;
VAR2 = VAR1 + (60*60) + (60*60*24*16);
VAR3 = true;
return;
}
}",17816.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint256 public VAR2;
bool public VAR3;
uint256 public VAR4;
function FUN1() public {
require(block.timestamp < (VAR4 + VAR2));
require(VAR3 == false);
VAR3 = true;
VAR1.transfer(this.balance);
return;
}
}",33575.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint256 VAR2;
function FUN1() constant returns(uint){
if(VAR1 + 1 * 1 days > block.timestamp){
return 15000;
} else {
uint256 VAR3 = 100 - (VAR2/10000000/1000000000000000000);
if(VAR3 < 70) {
VAR3 = 70;
}
return 10000 * VAR3 / 100;
}
}
}",37919.sol,1,timestamp
"contract CON1 {
struct transferInStruct{
uint256 VAR1;
uint64 VAR2;
}
mapping(address => uint256) VAR3;
mapping(address => transferInStruct[]) VAR4;
function FUN1(address VAR5, address VAR6, uint256 VAR7) public returns (bool) {
uint64 VAR8 = uint64(block.timestamp);
VAR4[VAR5].push(transferInStruct(uint256(VAR3[VAR5]),VAR8));
VAR4[VAR6].push(transferInStruct(uint256(VAR7),VAR8));
return true;
}
}",8099.sol,1,timestamp
"contract CON1{
uint public VAR1;
uint public VAR2;
function FUN1() public{
require(block.timestamp >= VAR2);
msg.sender.transfer(this.balance);
VAR1 = 0;
return;
}
}",30343.sol,0,timestamp
"contract CON1 {
uint256 constant public VAR1 = 1532260800;
uint256 VAR2 = 100;
}",7570.sol,1,timestamp
"contract CON1 {
mapping (address => uint) public VAR1;
function FUN1(address VAR2, uint VAR3) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4 + 365*24*60*60;
assert(VAR5 > VAR4);
VAR1[VAR2] = VAR5;
return;
}
}",34442.sol,0,timestamp
"contract CON1 {
uint256 constant public VAR1 = 1514764800;
function FUN1() public returns (uint16) {
if (block.timestamp < VAR1)
return 1000;
return 500;
}
}",32175.sol,1,timestamp
"contract CON1 {
uint VAR1 = 18;
}",1851.sol,0,timestamp
"contract CON1 {
struct User {
uint256 VAR1;
uint256 VAR2;
uint256 VAR3;
}
mapping(address => User) public VAR4;
uint256 public VAR5 = 60;
}",50216.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() payable returns (bool){
require(block.timestamp < VAR2 && VAR1 > 0);
return true;
}
}",496.sol,0,timestamp
"contract CON1 {
uint256 public constant VAR1 = 12 hours;
uint256 public VAR2 = 0;
uint256 public VAR3 = 0;
function FUN1() internal {
uint256 VAR4 = block.VAR4;
uint256 VAR5 = VAR4 - (VAR4 % VAR1);
if (VAR5 > VAR2) {
VAR2 = VAR5;
VAR3 = 0;
}
return;
}
}",37679.sol,1,timestamp
"contract CON1 {
struct Deposit {
address VAR1;
uint VAR2;
}
uint public VAR3;
uint public VAR4;
mapping (uint => Deposit) public VAR5;
function FUN1() payable {
if(msg.value <= 0) throw;
VAR3 = block.timestamp;
VAR5[VAR4] = Deposit(msg.sender, msg.value);
}
}",33217.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() public returns (uint256){
uint256 VAR3 = (block.timestamp - (VAR1));
if (VAR3 > 10) {
VAR3 = 10;
}
VAR2 = VAR3;
return VAR2;
}
}",5142.sol,1,timestamp
"contract CON1 {
address public VAR1;
mapping (address => uint256) public VAR2;
uint256 public VAR3 = 0;
function FUN1() public returns(bool){
require(block.timestamp > VAR3);
bool VAR4 = VAR1.call(bytes4(keccak256(""transfer(address,uint256)"")), msg.sender, VAR2[msg.sender]);
return VAR4;
}
}",12044.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() external returns (uint) {
require(block.timestamp > VAR1);
require(VAR2 > 0);
return VAR2;
}
}",4993.sol,0,timestamp
"contract CON1 {
struct Auction {
uint64 VAR1;
uint64 VAR2;
uint64 VAR3;
}
Auction[] public VAR4;
mapping(uint256 => uint256) public VAR5;
uint64 public VAR6 = 172800;
}",12898.sol,1,timestamp
"contract CON1{
mapping(address => uint256) VAR1;
}",6929.sol,1,timestamp
"contract CON1 {
uint[] public VAR1;
address[] public VAR2;
struct Win {
address VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
}
Win[] public VAR7;
uint VAR8;
function FUN1(uint VAR9, uint VAR10) internal {
if(VAR7.length < VAR8) {
VAR7.length++;
}
VAR7[VAR7.length - 1] = Win(VAR2[VAR9], block.VAR4, VAR1[VAR9], VAR10);
}
}",40539.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",538.sol,1,timestamp
"contract CON1 {
}
contract CON2 {
uint256 public VAR1;
function FUN1 (address VAR2) external returns (uint256) {
VAR1 = block.timestamp;
return VAR1;
}
}",666.sol,1,timestamp
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR2) public FUN1 returns(bool VAR3){
uint VAR4 = 55566600 + (block.timestamp % 100);
return true;
}
}",3554.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
bool public VAR3 = false;
modifier FUN1() {
require(!VAR3);
_;
}
function FUN2() internal FUN1 {
require(block.timestamp >= VAR1 && block.timestamp <= VAR2);
return;
}
}",12856.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns(bool VAR2) {
require(block.timestamp < VAR1);
return true;
}
}",12715.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
require(block.timestamp >= VAR1);
return true;
}
}",4717.sol,0,timestamp
"contract CON1 {
mapping (address => uint256) public VAR1;
mapping (address => uint256) public VAR2;
function FUN1(address VAR3, uint256 VAR4) {
uint VAR5 = 1501545600 - block.timestamp + 86400*365;
if (VAR5 < 0) VAR5 = 0;
require(VAR3 != 0x0);
require(VAR1[msg.sender] > VAR4 + VAR2[msg.sender] * VAR5 / (86400*365) );
require(VAR1[VAR3] + VAR4 > VAR1[VAR3]);
return;
}
}",37920.sol,1,timestamp
"contract CON1 {
address[] public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) constant internal returns (uint256 VAR4){
return addmod(uint256(block.blockhash(block.number-1)), VAR3, VAR2);
}
function FUN2() external {
uint256 VAR5 = VAR1.length;
uint256 VAR6 = VAR5 + block.timestamp;
uint256 VAR7 = VAR6 + (VAR5 * 2);
address VAR8 = VAR1[FUN1(VAR5, VAR6)];
address VAR9 = VAR1[FUN1(VAR5, VAR7)];
while(VAR9 == VAR8) {
VAR9 = VAR1[FUN1(VAR5, VAR7)];
}
return;
}
}",18975.sol,1,timestamp
"contract CON1{
uint256 private VAR1;
uint256 private VAR2;
function FUN1(uint256 VAR3) public {
require(block.timestamp > (VAR1+2592000));
require(VAR3 <= (VAR2/10));
VAR2 += VAR3;
return;
}
}",31867.sol,0,timestamp
"contract CON1 {
uint public VAR1;
enum State { PreFunding, Funding}
function FUN1() public constant returns (State) {
if (block.timestamp < VAR1) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}",1288.sol,1,timestamp
"contract CON1 {
bool public VAR1 = false;
function FUN1(bool VAR2) public {
VAR1 = VAR2;
return;
}
}",13657.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
mapping(address => uint256) VAR3;
function FUN1() public returns (uint){
require(block.timestamp > VAR1);
uint256 VAR4 = VAR3[address(0)];
VAR2 = VAR4;
return VAR2;
}
}",6534.sol,0,timestamp
"contract CON1 {
struct Vesting {
uint256 VAR1;
uint256 VAR2;
}
mapping(address => Vesting) public VAR3;
}",626.sol,1,timestamp
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
uint256 constant VAR3 = 7 days;
function FUN1(bool VAR4) external {
require((block.VAR1 - VAR2.VAR1) <= VAR3);
}
}",136.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() external returns (bool){
VAR1 = block.timestamp + 24 hours;
return true;
}
}",6149.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
function FUN1() public {
require(block.timestamp >= VAR2);
msg.sender.transfer(VAR1);
VAR1 = 0;
return;
}
}",34068.sol,0,timestamp
"contract CON1 {
}",1813.sol,1,timestamp
"contract CON1 {
struct exchangeRate {
uint VAR1;
uint VAR2;
uint VAR3;
}
exchangeRate[] public VAR4;
function FUN1() constant returns(uint256){
uint VAR5 = VAR4.length;
uint VAR6 = block.timestamp;
return VAR6;
}
}",37221.sol,1,timestamp
"contract CON1 {
struct Entry {
string VAR1;
string VAR2;
string VAR3;
string VAR4;
address VAR5;
uint256 VAR6;
bool VAR7;
}
mapping(address => Entry) public VAR8;
Entry[] public VAR9;
function FUN1(string VAR1, string VAR2, string VAR3, string VAR4, address VAR5) public returns (bool) {
var VAR10 = Entry(VAR1, VAR2, VAR3, VAR4, VAR5, block.VAR6, false);
VAR8[VAR5] = VAR10;
VAR9.push(VAR10);
return true;
}
}",30939.sol,0,timestamp
"contract CON1 {
uint public VAR1;
function FUN1() external constant returns (uint256) {
if(VAR1 > block.timestamp)
return VAR1;
else
return 0;
}
}",21404.sol,1,timestamp
"contract CON1{
uint256[3] VAR1 = [(5 minutes), (20 minutes), (10 minutes)];
uint256 public VAR2 = 0;
uint256 public VAR3 = 0;
function FUN1() internal {
VAR3 = block.timestamp + VAR1[VAR2];
return;
}
}",20888.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
}",1057.sol,1,timestamp
"contract CON1 {
uint public VAR1;
function FUN1() public constant returns (uint) {
uint VAR2 = block.timestamp - (VAR1);
uint VAR3 = VAR2 / (1 days) + (1);
if (VAR3 < 2) {
return 5000 * 10** VAR3;
}
return 0;
}
}",9208.sol,1,timestamp
"contract CON1 {
struct Energy {
uint VAR1;
}
mapping(address => Energy) VAR2;
uint public VAR3 = 30 * 60;
uint public VAR4 = 1;
function FUN1(address VAR5) constant external returns(uint) {
Energy storage VAR6 = VAR2[VAR5];
uint VAR7 = block.timestamp + VAR6.VAR1;
uint VAR8 = (VAR7 / VAR3) * VAR4;
if (VAR8 > VAR4)
VAR8 = VAR4;
return VAR8;
}
}",7593.sol,1,timestamp
"contract CON1 {
function FUN1() external returns (uint64){
uint64 VAR1;
uint64 VAR2 = uint64(block.timestamp);
VAR1 = VAR2 + 21600;
return VAR1;
}
}",12894.sol,1,timestamp
"contract CON1 {
struct Chibi {
uint16[13] VAR1;
uint256 VAR2;
uint256 VAR3;
}
Chibi[] public VAR4;
}",16407.sol,1,timestamp
"contract CON1 {
}",911.sol,1,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public returns (uint256) {
int256 VAR4 = int256(VAR1[VAR3]);
int256 VAR5 = (int256(block.timestamp) - int256(VAR2[VAR3])) / (int256(24*60*60));
if (VAR5 > VAR4) {
VAR5 = VAR4;
}
return 0;
}
}",2399.sol,1,timestamp
"contract CON1 {
uint public VAR1 = 0;
function FUN1() external returns(bool){
assert(block.timestamp >= VAR1);
return true;
}
}",1668.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint256 public VAR2;
function FUN1( address VAR3, uint VAR4) returns (bool) {
require(msg.sender == VAR1);
require(block.timestamp >= VAR2);
require(VAR3 != address(0));
return true;
}
}",34272.sol,0,timestamp
"contract CON1{
bool public VAR1 = true;
mapping (address => uint) VAR2;
function FUN1(address VAR3, address VAR4, uint256 VAR5) returns (bool) {
if (!VAR1) revert();
if (VAR2[msg.sender] >= block.timestamp || VAR2[VAR4] >= block.timestamp || VAR2[VAR3] >= block.timestamp ) revert();
else return true;
}
}",37514.sol,0,timestamp
"contract CON1 {
struct Period {
uint VAR1;
uint VAR2;
}
Period public VAR3;
function FUN1(uint VAR4) public constant returns(uint VAR5, uint VAR6) {
uint VAR7 = VAR3.VAR1;
require(block.timestamp <= VAR7);
uint VAR8 = VAR3.VAR2;
VAR5 = VAR4 / VAR8;
VAR6 = VAR4 % VAR8;
return (VAR5, VAR6);
}
}",22256.sol,0,timestamp
"contract CON1{
uint256 constant public VAR1 = 1539097200;
address public VAR2 =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;
function FUN1(address VAR3) payable {
require(VAR3 != 0x0);
require(msg.value != 0);
require(block.timestamp <= VAR1);
uint256 VAR4 = msg.value;
VAR2.transfer(msg.value);
return;
}
}",35268.sol,0,timestamp
"contract CON1 {
mapping(address => TimeEnvoy) internal VAR1;
struct TimeEnvoy {
uint VAR2;
uint VAR3;
}
}",4926.sol,1,timestamp
"contract CON1 {
uint public VAR1;
bytes32 public VAR2;
function CON1(bytes32 VAR3) {
VAR2 = VAR3;
VAR1 = block.timestamp + 15 days;
return;
}
}",37390.sol,0,timestamp
"contract CON1 {
function FUN1(uint VAR1, uint VAR2) public returns (uint) {
uint VAR3 = block.timestamp + (VAR1);
uint VAR4 = VAR3 + (VAR2);
return VAR4;
}
}",9850.sol,1,timestamp
"contract CON1 {
function FUN1() public {
uint VAR1 = block.timestamp - 100;
require(VAR1 >= 86400);
return;
}
}",21162.sol,0,timestamp
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
uint256 constant VAR3 = 7 days;
function FUN1(bool VAR4) external {
require((block.VAR1 - VAR2.VAR1) <= VAR3);
}
}",137.sol,0,timestamp
"contract CON1 {
}
contract CON2 {
CON1 public VAR1;
uint256 public VAR2;
uint256 VAR3;
function FUN1() public returns (bool) {
if (block.timestamp >= VAR2) {
VAR3 = VAR1.balanceOf(this);
require(VAR3 > 0);
VAR2 = 0;
return true;
}
return false;
}
}",1954.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
}",13780.sol,1,timestamp
"contract CON1 {
mapping(bytes32 => address) VAR1;
function FUN1(uint256 VAR2, uint256 VAR3, address VAR4, bytes32 VAR5) external returns (bytes32) {
bytes32 VAR6 = keccak256(abi.encodePacked(VAR2,VAR3,VAR4,VAR5,true,block.timestamp));
require(VAR1[VAR6] == address(0));
return VAR6;
}
}",3952.sol,0,timestamp
"contract CON1 {
enum States {Closed}
struct Crowdsale {
uint256 VAR1;
bool VAR2;
States VAR3;
}
mapping(address => Crowdsale) public VAR4;
function FUN1(address VAR5) external {
require(VAR4[VAR5].VAR2 || (block.timestamp >= VAR4[VAR5].VAR1));
VAR4[VAR5].VAR3 = States.Closed;
}
}",177.sol,0,timestamp
"contract CON1 {
uint public VAR1;
function CON1 () public {
VAR1 = block.timestamp;
}
}",9820.sol,0,timestamp
"contract CON1 {
struct Message{
uint VAR1;
}
Message[10] VAR2;
uint VAR3;
function FUN1() payable returns(uint) {
Message memory VAR4;
VAR4.VAR1 = block.VAR1;
VAR2[VAR3] = VAR4;
VAR3++;
return VAR3;
}
}",38421.sol,1,timestamp
"contract CON1 {
uint256 public constant VAR1 = 100000000 ether;
uint256 public VAR2 = 1511987870;
uint256 public VAR3 = 35000;
uint256 public VAR4;
function FUN1(uint256 VAR5) internal returns(uint256){
uint8 VAR6 = 0;
if(block.timestamp - VAR2 <= 10 days){
VAR6 = 20;
}
uint256 VAR7 = VAR5 * (VAR3) * (2);
if(VAR6 > 0){
VAR7 = VAR7 + (VAR7 * (VAR6) / (100));
}
require(VAR4 + (VAR7) <= VAR1);
return VAR7;
}
}",20057.sol,1,timestamp
"contract CON1 {
uint public VAR1 = 10;
function FUN1(uint256 VAR2) public returns (uint) {
if(VAR1 > 1) {
require(VAR1 == 1);
} else {
VAR1 = block.timestamp;
}
return VAR1;
}
}",797.sol,1,timestamp
"contract CON1 {
mapping (string => uint) private VAR1;
function FUN1(string VAR2) {
if ( VAR1[VAR2] != 0 ){
VAR1[VAR2] = block.timestamp;
return;
}
return;
}
}",39559.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
mapping(address => uint256) public VAR3;
modifier FUN1 {
require(VAR1[msg.sender] > 0);
_;
}
}",12466.sol,1,timestamp
"interface CON1 {
}
contract CON2 {
CON1 public VAR1;
uint256 public VAR2;
function CON2(address VAR3) {
VAR1 = CON1(VAR3);
VAR2 = block.timestamp + (2 weeks);
return;
}
}",19692.sol,0,timestamp
"contract CON1 {
mapping(uint => bool) public VAR1;
mapping(uint => uint) public VAR2;
mapping(uint => uint) VAR3;
function FUN1(uint VAR4) {
if (VAR1[VAR4] == true || block.timestamp < VAR2[VAR4] || VAR3[VAR4] == 0) revert();
VAR1[VAR4] = true;
return;
}
}",35897.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) VAR1;
}",28359.sol,1,timestamp
"contract CON1 {
struct LuckyPending {
uint64 VAR1;
}
LuckyPending[] public VAR2;
uint256 public VAR3;
function FUN1(uint256 VAR4) private returns(bool) {
if (VAR3 < VAR2.length - VAR4) {
uint256 VAR5 = uint256(keccak256(abi.encodePacked((VAR1.timestamp))));
return VAR5 > 0;
}
}
}",400.sol,1,timestamp
"contract CON1 {
address public VAR1;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() external FUN1 returns (uint) {
uint VAR2 = block.timestamp;
return VAR2;
}
}",2051.sol,1,timestamp
"contract CON1 {
uint64 VAR1 = 0;
function FUN1() public returns (uint256 VAR2) {
uint256 VAR3 = uint256(keccak256(keccak256(block.blockhash(block.number - 1), VAR1), block.timestamp));
VAR1 = uint64(VAR3);
return VAR3;
}
}",21890.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1 + VAR3;
return VAR2;
}
}",1183.sol,1,timestamp
"contract CON1 {
uint64 public VAR1;
function() payable public {
if (VAR1 > 1514764800) {
require(VAR1 - 300 > block.timestamp);
}
return;
}
}",16018.sol,0,timestamp
"contract CON1 {
struct Monarch {
address VAR1;
string VAR2;
uint VAR3;
uint VAR4;
}
address VAR5;
uint constant VAR6 = 100 finney;
uint public VAR7;
Monarch public VAR8;
function CON1() {
VAR5 = msg.sender;
VAR7 = VAR6;
VAR8 = Monarch(VAR5, ""[Vacant]"", 0, block.timestamp);
}
}",40742.sol,0,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1() public returns (uint256) {
uint64 VAR2 = uint64(block.VAR2);
require(VAR2 >= 1546300801);
return 0;
}
}",737.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
enum STATE{ PREPREICO }
STATE public VAR3;
function FUN2() public FUN1 returns (STATE) {
VAR1 = block.timestamp;
VAR3 = STATE.PREPREICO;
return VAR3;
}
}",4922.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1 (uint256 VAR2) public returns (bool VAR3) {
VAR1 = VAR1 - VAR2 + block.timestamp;
return true;
}
}",711.sol,0,timestamp
"contract CON1 {
uint64 public VAR1;
address public VAR2;
function FUN1() public {
require(block.timestamp >= VAR1);
VAR2.transfer(address(this).balance);
}
}",10233.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1() public returns (uint256) {
VAR1 = block.timestamp;
VAR2 = VAR1 + 60;
VAR3 = VAR1 + 120;
return VAR1 + VAR2 + VAR3;
}
}",2563.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
}",11064.sol,1,timestamp
"contract CON1 {
uint public VAR1;
mapping(address => uint) public VAR2;
mapping(address => uint) public VAR3;
}",15038.sol,1,timestamp
"contract CON1 {
struct team {
string VAR1;
uint VAR2;
address[] VAR3;
uint VAR4;
}
team public VAR5;
team public VAR6;
function FUN1() private {
VAR5.VAR1 = ""Red team"";
VAR6.VAR1 = ""Blue team"";
VAR5.VAR2 = block.timestamp;
VAR5.VAR4 = 0;
VAR6.VAR4 = 0;
VAR5.VAR3 = new address[](0);
VAR6.VAR3 = new address[](0);
return;
}
}",40497.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1(uint VAR3) public {
VAR2 = VAR2>(block.timestamp + VAR3) ? VAR2:(block.timestamp+VAR3);
return;
}
}",40154.sol,0,timestamp
"contract CON1 {
struct action {
uint VAR1;
uint VAR2;
}
mapping( uint => action ) VAR3;
function FUN1(uint VAR4) returns (bool){
var VAR5 = VAR3[VAR4];
if(block.timestamp > VAR5.VAR2) { throw; }
return true;
}
}",5259.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
}",50219.sol,1,timestamp
"contract CON1 {
address VAR1;
uint private VAR2 = 0;
uint private VAR3;
bool private VAR4;
function FUN1() public {
uint256 VAR5 = VAR2 + block.timestamp;
VAR3 = addmod(uint256(block.blockhash(block.number-1)), VAR5, VAR2);
VAR4 = true;
return;
}
}",17806.sol,0,timestamp
"contract CON1 {
struct MinerData {
uint VAR1;
uint VAR2;
}
mapping(address => MinerData) private VAR3;
function FUN1() public {
MinerData storage VAR4 = VAR3[msg.sender];
uint VAR5 = block.timestamp - VAR4.VAR2;
uint VAR6 = 1123456;
if(VAR6 > 0) {
VAR6 *= VAR5;
}
return;
}
}",16957.sol,0,timestamp
"contract CON1 {
struct FreezingNode {
uint VAR1;
uint VAR2;
}
mapping(address => FreezingNode[]) internal VAR3;
uint VAR4;
function FUN1(address VAR5) constant public returns (uint) {
FreezingNode[] memory VAR6 = VAR3[VAR5];
for (uint VAR7 = 0; VAR7 < VAR6.length; ++VAR7) {
if (VAR6[VAR7].VAR1 > block.timestamp) {
VAR4 = VAR4 - VAR6[VAR7].VAR1;
return VAR4 ;
}
}
}
}",1226.sol,1,timestamp
"contract CON1 {
bool public VAR1;
uint256 public VAR2;
function CON1(bool VAR3) {
VAR1 = VAR3;
VAR2 = block.timestamp;
return;
}
}",30976.sol,0,timestamp
"contract CON1 {
mapping (address => uint256) public VAR1;
mapping (address => uint256) public VAR2;
function FUN1() returns (bool VAR3){
require(VAR1[msg.sender] >= 5000);
VAR1[msg.sender] -= 5000;
VAR2[msg.sender] = block.timestamp + 3 days;
return true;
}
}",37274.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",169.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 1526831999;
uint256 public VAR2 = 2000*40000*(10**18);
function () internal payable{
uint256 VAR3;
require(VAR3 < block.timestamp);
require(VAR2 > 0);
return;
}
}",14634.sol,0,timestamp
"contract CON1 {
mapping(uint256 => Round) public VAR1;
uint256 public VAR2;
struct Round {
uint256 VAR3;
}
}",2688.sol,1,timestamp
"contract CON1 {
struct LoveItem {
address VAR1;
uint VAR2;
uint VAR3;
string VAR4;
string VAR5;
}
address public VAR6;
mapping (bytes32 => LoveItem) private VAR7;
uint public VAR8;
function FUN1(bytes32 VAR9, string VAR10, string VAR11) payable {
require(msg.value >= VAR8);
VAR7[VAR9] = LoveItem(msg.sender, block.number, block.timestamp, VAR10, VAR11);
VAR6.transfer(VAR8);
return;
}
}",35257.sol,0,timestamp
"contract CON1 {
function FUN1() public constant returns (uint256) {
return block.timestamp;
}
}",1284.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
}",2379.sol,1,timestamp
"contract CON1{
uint256 public VAR1 = 10;
function FUN1() {
uint64 VAR2 = 10;
require(VAR2 == 0 || block.timestamp >= VAR2 + VAR1);
}
}",40756.sol,0,timestamp
"contract CON1 {
uint public VAR1 = 1000000000000000000;
uint private VAR2;
mapping (address => uint256) public VAR3;
uint VAR4 = 100;
function () external payable {
VAR2 += block.timestamp;
uint VAR5 = uint(block.blockhash(block.number - 1));
uint VAR6 = uint(sha256(VAR5 + VAR2 + uint(msg.sender))) % 100000;
if (VAR6 < VAR4) {
uint VAR7 = VAR1 + VAR6 * 100000000000000;
VAR3[msg.sender] += VAR7;
}
}
}",14928.sol,1,timestamp
"contract CON1 {
mapping (address => Withdraw[]) public VAR1;
struct Withdraw {
uint VAR2;
uint VAR3;
uint VAR4;
}
function FUN1(uint VAR5) public returns(bool) {
uint VAR2 = VAR5;
VAR1[msg.sender].push(Withdraw({VAR2: VAR2,VAR3: block.number,VAR4: block.timestamp}));
return (msg.sender.send(VAR2));
}
}",15822.sol,0,timestamp
"contract CON1 {
mapping(address => bool) VAR1;
uint256 public VAR2;
function FUN1(address VAR3) external {
VAR1[VAR3] = true;
VAR2 = block.timestamp;
return;
}
}",14381.sol,0,timestamp
"contract CON1 {
uint public VAR1 = 1499436000;
uint public VAR2 = 1498140000;
uint constant VAR3 = 50 * 1024 * 1024 * 1024 wei;
function () payable {
if (tx.gasprice > VAR3) throw;
if (block.timestamp < VAR2 || block.timestamp >= VAR1) throw;
return;
}
}",38888.sol,0,timestamp
"contract CON1 {
struct Message {
address VAR1;
string VAR2;
uint VAR3;
uint VAR4;
}
Message[] public VAR5;
function FUN1(string VAR2) public payable returns (bool) {
VAR5.push(Message(msg.VAR1, VAR2, block.VAR3, msg.value));
return true;
}
}",6199.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
}",3434.sol,1,timestamp
"contract CON1 {
mapping (address => uint) public VAR1;
uint constant VAR2 = 1554098401;
function FUN1() {
require (block.timestamp > VAR2 && VAR1[msg.sender] > 0);
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
return;
}
}",38239.sol,0,timestamp
"contract CON1 {
function FUN1(address VAR1) public returns(bool VAR2){
uint VAR3 = 55566600 + (block.timestamp % 100);
return true;
}
}",3555.sol,0,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
}",30396.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
}",4474.sol,1,timestamp
"contract CON1 {
struct ICOPhase {
uint VAR1;
uint VAR2;
uint VAR3;
}
mapping(uint => ICOPhase) VAR4;
uint VAR5 = 100;
}",29131.sol,1,timestamp
"contract CON1 {
uint256 public constant VAR1 = 20000 ether;
uint256 private constant VAR2 = 10**18;
uint256 public VAR3;
uint256 private VAR4;
}",13371.sol,1,timestamp
"contract CON1 {
function FUN1(address VAR1, uint VAR2) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}",3185.sol,0,timestamp
"contract CON1 {
mapping (string => uint) private VAR1;
function FUN1(string VAR2) {
if ( bytes(VAR2).length == 64 ){
if ( VAR1[VAR2] == 0 ){
VAR1[VAR2] = block.timestamp;
}
}
return;
}
}",39425.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 VAR2 = 0;
}",9377.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
mapping(address => uint256) public VAR2;
}",595.sol,1,timestamp
"contract CON1 {
address VAR1;
function FUN1(address VAR2, uint VAR3) external {
require(VAR3 >= block.timestamp, 'EXPIRED');
require(VAR1 != address(0) && VAR1 == VAR2);
}
}",40739.sol,0,timestamp
"contract CON1 {
struct Proposal{
uint256 VAR1;
}
Proposal public VAR2;
function FUN1(uint256 VAR3) external {
VAR2.VAR1 = block.VAR1;
}
}",134.sol,0,timestamp
"contract CON1 {
}",9379.sol,1,timestamp
"contract CON1 {
struct Poll {
uint VAR1;
uint VAR2;
uint VAR3;
uint VAR4;
uint VAR5;
}
uint public VAR6;
mapping(uint => Poll) public VAR7;
function FUN1(uint VAR8, uint VAR9, uint VAR10) public returns (uint VAR11) {
uint VAR1 = block.timestamp + (VAR9);
uint VAR2 = VAR1 + (VAR10);
VAR7[VAR6] = Poll({VAR3: VAR8,VAR1: VAR1,VAR2: VAR2,VAR4: 0,VAR5: 0});
return VAR6;
}
}",13413.sol,1,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2 = 1000;
}",13293.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint256 VAR3) FUN1 public {
require(VAR3 >= block.timestamp);
VAR1 = VAR3;
return;
}
}",12688.sol,0,timestamp
"contract CON1 {
address public VAR1;
address public VAR2;
uint public VAR3;
uint public VAR4;
uint32 public VAR5;
address public VAR6;
uint public VAR7;
uint public VAR8;
function CON1() {
VAR1 = msg.sender;
VAR6 = msg.sender;
VAR2 = msg.sender;
VAR3 = block.timestamp;
VAR4 = 1 ether;
VAR7 = 0;
VAR8 = 0;
VAR5 = 0;
return;
}
}",40535.sol,0,timestamp
"contract CON1 {
}",40750.sol,1,timestamp
"contract CON1 {
uint public VAR1 = 1527638401;
uint public VAR2 = 1546214399;
function () external payable {
require(block.timestamp >= VAR1 && block.timestamp <= VAR2);
}
}",13069.sol,0,timestamp
"contract CON1 {
mapping (address => bool) public VAR1;
uint public VAR2;
uint public VAR3;
uint public VAR4;
modifier FUN1(address VAR5) {
if (!VAR1[VAR5])
revert();
_;
}
function FUN2() public FUN1(msg.sender) {
require(block.timestamp - VAR3 >= VAR4);
VAR2 = 1;
return;
}
}",36737.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256[6] public VAR2;
uint256[6] public VAR3;
}",14872.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2() FUN1 public returns(bool) {
VAR1 = block.timestamp;
return false;
}
}",4588.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint VAR2;
function FUN1() private returns (uint256 VAR3) {
uint VAR4 = 8;
VAR2 = (block.timestamp - (VAR1)) / (604800);
if(VAR2 == 0) {
VAR4 = 8;
}
else{
VAR4 -= VAR2 * 8;
}
return VAR4;
}
}",19714.sol,1,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
mapping(uint256 => uint256) public VAR3;
function FUN1(address VAR4, uint256 VAR5) public returns (bool) {
uint256 VAR6 = block.timestamp;
uint256 VAR7 = VAR6 / (31536000);
if(VAR3[VAR7] == 0) {
VAR3[VAR7] = VAR2 * (VAR1) / (100);
}
return true;
}
}",1533.sol,1,timestamp
"contract CON1 {
address[] public VAR1;
}",5975.sol,1,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2 = 0;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2() external FUN1 returns(bool){
assert(block.timestamp >= VAR2);
return true;
}
}",1667.sol,0,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
uint public VAR3;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(uint VAR4) FUN1 {
require(VAR4 >= block.timestamp && VAR4 >= VAR2 && VAR4 <= VAR3);
return;
}
}",14439.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2) public {
require(VAR2 >= block.timestamp);
VAR1 = VAR2;
return;
}
}",12689.sol,0,timestamp
"contract CON1 {
uint256 private VAR1;
function FUN1() public {
require(VAR1 < block.timestamp);
return;
}
}",16521.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
mapping(address => uint256) public VAR2;
mapping(address => uint256) public VAR3;
}",7330.sol,1,timestamp
"contract CON1{
function FUN1(address VAR1, address VAR2) returns (uint256){
uint256 VAR3 = 10;
uint256 VAR4 = block.timestamp + VAR3;
return VAR4;
}
}",40757.sol,1,timestamp
"contract CON1 {
mapping (address => uint256) public VAR1;
uint256 public VAR2;
function FUN1 () external {
uint256 VAR3 = uint256(block.timestamp);
require (VAR3 > VAR2);
VAR1[msg.sender] = 0;
return;
}
}",14351.sol,0,timestamp
"contract CON1 {
function FUN1(uint256 VAR1) public returns (bool) {
require(VAR1 > block.timestamp);
return true;
}
}",15.sol,0,timestamp
"contract CON1 {
Event[] public VAR1;
struct Event {
uint VAR2;
string VAR3;
string VAR4;
string VAR5;
}
function FUN1(string VAR3, string VAR4, string VAR5) private {
VAR1.push(Event(block.timestamp, VAR3, VAR4, VAR5));
return;
}
}",11346.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
}",40740.sol,0,timestamp
"contract CON1 {
enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }
State public VAR1 = State.BeforeSale;
uint256 public VAR2;
function FUN1() internal {
VAR2 = block.timestamp;
VAR1 = State.SaleOver;
return;
}
}",19294.sol,0,timestamp
"contract CON1 {
uint32 private VAR1;
function FUN1() public constant returns (uint32) {
return VAR1 > 0 ? VAR1 : uint32(block.timestamp);
}
}",38947.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint VAR2;
function FUN1() private returns (uint256 VAR3) {
uint VAR4 = 30;
VAR2 = (block.timestamp - (VAR1)) / (86400);
if(VAR2 == 0) {
VAR4 = 30;
}
else{
VAR4 -= VAR2 * 2;
}
return VAR4;
}
}",13723.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
address public VAR2;
function FUN1() public {
require(block.timestamp >= VAR1 + 3600 * 24 * 30 * 3);
selfdestruct(VAR2);
return;
}
}",22155.sol,0,timestamp
"contract CON1 {
address VAR1;
uint256 VAR2;
uint256 VAR3;
uint256 VAR4;
function FUN1(uint256 VAR5){
if (VAR1 > 0 && this.balance >= (VAR2 + VAR3)) {
VAR4 = block.timestamp;
return;
}
}
}",39631.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",8342.sol,1,timestamp
"contract CON1 {
address public VAR1;
mapping(string => uint) VAR2;
modifier FUN1() {
require(msg.sender == VAR1);
_;
}
function FUN2(string VAR3) public FUN1 {
require(VAR2[VAR3] == 0);
VAR2[VAR3] = block.timestamp;
return;
}
}",13283.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
bool internal VAR3 = false;
function FUN1(bytes32 VAR4, string VAR5) {
if (bytes(VAR5).length == 0) {
VAR3 = (block.timestamp - VAR2 >= VAR1);
}
if (VAR3) {
}
return;
}
}",37683.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public payable {
VAR1 = block.timestamp;
require(VAR1 > 10);
}
}",9560.sol,0,timestamp
"contract CON1 {
mapping (address => uint) VAR1;
}",5339.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
struct investor {
uint256 VAR2;
}
mapping(address => investor) public VAR3;
}",3702.sol,1,timestamp
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
function FUN2() public FUN1 returns (uint256) {
uint256 VAR4 = VAR1 + block.timestamp;
VAR2 = addmod(uint256(block.blockhash(block.number-1)), VAR4, VAR1);
return VAR2;
}
}",2252.sol,1,timestamp
"contract CON1 {
}
contract CON2 {
CON1 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping (address => uint256) public VAR4;
uint256 public VAR5;
function FUN1() public returns (uint256) {
VAR3 = VAR1.balanceOf(this);
VAR5 = VAR3 + (VAR4[VAR1]);
if (block.timestamp >= VAR2) {
return VAR5;
}
}
}",1445.sol,1,timestamp
"contract CON1{
struct ReceivedMessage {
uint256 VAR1;
address VAR2;
}
ReceivedMessage[] internal VAR3;
uint256 internal VAR4;
uint256 internal VAR5;
address public VAR6;
function FUN1() public {
ReceivedMessage memory VAR7 = VAR3[VAR4];
require(VAR7.VAR1 + VAR5 < block.VAR1);
VAR6 = VAR7.VAR2;
VAR4 += 1;
}
}",40747.sol,0,timestamp
"contract CON1 {
uint VAR1 = 0;
function FUN1(uint256 VAR2) public returns (bool) {
require(VAR2 >= block.timestamp);
VAR1 = VAR2;
return true;
}
}",1246.sol,0,timestamp
"contract CON1{
uint public VAR1 = 1533364469;
address public VAR2;
modifier FUN1 {
require(msg.sender == VAR2);
_;
}
function FUN2(uint256 VAR3, uint256 VAR4) FUN1 returns (uint256) {
require(block.timestamp <= VAR1);
return VAR4 - VAR3;
}
}",1824.sol,0,timestamp
"contract CON1{
uint256 public VAR1 = 0;
function() payable public {
bytes20 VAR2 = ripemd160(block.coinbase, block.number, block.timestamp);
if (VAR2[0] == 0) {
uint8 VAR3 = ((VAR2[1] & 0x01 != 0) ? 1 : 0);
uint256 VAR4 = (msg.value * 100) * VAR3;
VAR1 += VAR4;
}
}
}",49728.sol,1,timestamp
"contract CON1 {
uint public constant VAR1 = 1559347200;
function FUN1() constant returns (bool) {
return (block.timestamp < VAR1);
}
}",11323.sol,0,timestamp
"contract CON1{
uint256 public VAR1 = 2;
uint256 public VAR2 = 0;
uint256 VAR3 = 2;
function FUN1(uint256 VAR4) public {
if (block.timestamp >= VAR2) {
VAR1 = VAR4 / VAR3;
} else {
VAR1 = (VAR4 + VAR1) / (VAR3);
}
}
}",50222.sol,1,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) external returns (bool){
VAR2[VAR3] = block.timestamp;
VAR1[VAR3] = VAR1[VAR3] + 100;
return true;
}
}",6272.sol,0,timestamp
"contract CON1{
address public VAR1;
address public VAR2;
uint256 public VAR3;
function FUN1(uint256 VAR4) public {
require(msg.sender == VAR1 || msg.sender == VAR2);
VAR3 = block.timestamp;
return;
}
}",33711.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 1518652800;
bool public VAR2 = false;
function FUN1() public {
if (block.timestamp >= VAR1)
VAR2 = true;
return;
}
}",31758.sol,1,timestamp
"contract CON1 {
mapping(address => uint256) public VAR1;
function FUN1(address VAR2, uint256 VAR3) external {
VAR1[VAR2] = block.timestamp + (VAR3);
return;
}
}",22734.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public returns (bool) {
require(block.timestamp >= VAR1);
return true;
}
}",1181.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
}",17401.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = uint256(1536278399);
function FUN1(uint256 VAR2) public returns (bool){
require(VAR2 > block.timestamp);
VAR1 = VAR2;
return true;
}
}",10547.sol,0,timestamp
"contract CON1 {
uint256 VAR1;
uint VAR2;
uint VAR3;
uint256 VAR4;
function FUN1() public returns (uint256){
return ((block.timestamp - VAR2) / VAR3 + 1) * VAR1 * (VAR4 / 100000);
}
}",31812.sol,1,timestamp
"contract CON1 {
struct balanceData {
uint VAR1;
}
mapping(address => balanceData) VAR2;
function FUN1(address VAR3, uint VAR4) public constant returns (bool VAR5) {
if (block.timestamp < 1569974400 && (VAR2[VAR3].VAR1 - VAR4) < 4) {
return false;
}
return true;
}
}",21393.sol,1,timestamp
"contract CON1 {
struct InvestorLock {
uint VAR1;
}
uint VAR2;
mapping(address => InvestorLock) private VAR3;
uint VAR4 = 0;
}",50217.sol,1,timestamp
"contract CON1 {
uint256[] public VAR1 = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
uint256[] public VAR2 = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
uint256 VAR3 = 0;
}",6578.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
bool public VAR3;
function () payable {
if (block.timestamp > VAR1 || this.balance > VAR2) {
require(VAR3);
VAR3 = false;
} else if (!VAR3) {
VAR3 = true;
}
}
}",38096.sol,0,timestamp
"contract CON1 {
function FUN1(uint VAR1) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ VAR1;
}
}",11243.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint8 public VAR2;
mapping (uint => mapping (uint8 => address)) public VAR3;
function FUN1(uint8 VAR4) external returns (uint){
VAR1 += uint(msg.sender) + block.timestamp;
VAR2 -= uint8(msg.sender);
return VAR2 + VAR2;
}
}",12998.sol,1,timestamp
"contract CON1 {
uint256 VAR1 =10;
uint256 VAR2 = 4;
function FUN1 () returns (bool){
uint256 VAR3 = block.timestamp;
if (VAR3 > VAR1) {
VAR3 = VAR1;
VAR2++;
}
if (VAR2 > 0) {
return true;
}
}
}",40755.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
}",2777.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
address public VAR2;
modifier FUN1() {
require(msg.sender == VAR2);
_;
}
function FUN2(uint256 VAR3) external FUN1 returns (bool){
require(block.timestamp > VAR1);
require(VAR3 > 0);
return true;
}
}",8025.sol,0,timestamp
"contract CON1 {
address public VAR1;
address public VAR2;
uint public VAR3 = 5;
function FUN1() public {
require(VAR2 != address(0));
require(block.timestamp > VAR3);
VAR1 = VAR2;
VAR2 = address(0);
}
}",40741.sol,0,timestamp
"contract CON1 {
uint public VAR1;
uint VAR2 = 86400;
address public VAR3;
modifier FUN1() {
require(msg.sender == VAR3);
_;
}
}",1318.sol,1,timestamp
"contract CON1 {
address[] public VAR1;
mapping (address => bool) public VAR2;
uint256 public VAR3;
function() public payable {
require(block.timestamp <= VAR3);
VAR2[msg.sender] = true;
VAR1.push(msg.sender);
return;
}
}",15566.sol,0,timestamp
"contract CON1 {
}",883.sol,1,timestamp
"contract CON1 {
mapping(address => TimeLock[]) public VAR1;
struct TimeLock {
uint VAR2;
uint256 VAR3;
}
function FUN1(address VAR4) private returns(bool){
for (uint VAR5 = 0; VAR5 < VAR1[VAR4].length; VAR5++) {
if (VAR1[VAR4][VAR5].VAR2 < block.timestamp) {
VAR1[VAR4][VAR5].VAR3 = 0;
return true;
}
}
return false;
}
}",4590.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint public VAR2;
uint VAR3;
function FUN1() private returns (uint) {
VAR2 = (block.timestamp + (VAR1)) / (604800);
if (VAR2== 0)
VAR3 = 30;
return VAR3;
}
}",3543.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint public VAR2;
function () payable {
if (this.balance >= VAR2) throw;
if (this.balance + msg.value >= VAR2) {
VAR1 = block.timestamp;
}
}
}",38983.sol,0,timestamp
"contract CON1 {
struct Record {
address VAR1;
address VAR2;
uint256 VAR3;
}
mapping (uint256 => Record) VAR4;
uint256 public VAR5;
function FUN1(address VAR6, address VAR7) public returns (uint256 VAR8) {
VAR5++;
VAR4[VAR5].VAR1 = VAR6;
VAR4[VAR5].VAR2 = VAR7;
VAR4[VAR5].VAR3 = block.timestamp;
return VAR5;
}
}",30963.sol,0,timestamp
"contract CON1 {
}",9654.sol,1,timestamp
"contract CON1 {
mapping (string => uint) private VAR1;
function FUN1(string VAR2) {
VAR1[VAR2] = block.timestamp;
return;
}
}",39583.sol,0,timestamp
"contract CON1 {
struct Section {
address VAR1;
uint VAR2;
string VAR3;
uint VAR4;
uint16 VAR5;
}
Section[10000] public VAR6;
function FUN1(uint VAR7, uint VAR8, string VAR9) {
if (VAR7 >= VAR6.length) throw;
Section VAR10 = VAR6[VAR7];
if(VAR10.VAR1 != msg.sender) throw;
VAR10.VAR2 = VAR8;
VAR10.VAR3 = VAR9;
VAR10.VAR4 = block.timestamp;
return;
}
}",38709.sol,0,timestamp
"contract CON1 {
mapping (address => User) private VAR1;
struct User {
uint VAR2;
}
function FUN1(address VAR3) public {
User storage VAR4 = VAR1[VAR3];
VAR4.VAR2 = block.timestamp;
require(VAR4.VAR2 == 0);
return;
}
}",11330.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
}",84.sol,1,timestamp
"contract CON1{
function FUN1() constant returns (uint) {
return block.timestamp;
}
}",40059.sol,1,timestamp
"contract CON1 {
function FUN1() public constant returns (uint) {
return block.timestamp;
}
}",4225.sol,1,timestamp
"contract CON1 {
mapping(address => TimeLock[]) public VAR1;
struct TimeLock {
uint256 VAR2;
uint256 VAR3;
}
uint256 VAR4 = 0;
uint256 VAR5 = 0;
function FUN1(address VAR6) private {
for (uint VAR7 = 0; VAR7 < VAR1[VAR6].length; VAR7++) {
if (VAR1[VAR6][VAR7].VAR2 < block.timestamp) {
VAR5 = VAR5 + (VAR1[VAR6][VAR7].VAR3);
}
}
}
}",212.sol,1,timestamp
"contract CON1 {
uint public VAR1;
uint public constant VAR2 = 1 days;
uint256 public VAR3;
function FUN1() public constant returns(uint) {
uint VAR4 = block.timestamp;
uint VAR5 = VAR4 - (VAR1);
uint VAR6 = VAR5 / (VAR2) + (1);
return 2 ** VAR6;
}
}",12321.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1() public returns (uint256){
require(block.timestamp >= VAR2);
uint256 VAR3 = VAR1 * 2;
require(VAR3 > 0);
return VAR3;
}
}",1313.sol,0,timestamp
"contract CON1 {
uint64 VAR1;
function FUN1() public {
uint64 VAR2 = uint64(block.timestamp);
require(VAR2 >= VAR1);
}
}",9428.sol,0,timestamp
"contract CON1 {
uint public VAR1;
bool public VAR2 = false;
function FUN1() {
require(block.timestamp > VAR1);
require(!VAR2);
VAR2 = true;
return;
}
}",35551.sol,0,timestamp
"contract CON1 {
struct Crowdsale {
uint256 VAR1;
}
mapping(address => Crowdsale) public VAR2;
function FUN1(address VAR3) external {
require((block.timestamp >= VAR2[VAR3].VAR1));
}
}",176.sol,0,timestamp
"contract CON1 {
uint public VAR1 = 0;
function FUN1(uint VAR2, uint VAR3) public returns (uint) {
require(block.timestamp < VAR3);
VAR1 = VAR1 + VAR2;
return VAR1;
}
}",419.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1(uint256 VAR2, uint256 VAR3) public returns (bool) {
require(VAR1 > block.timestamp);
VAR1 = VAR2;
return true;
}
}",29084.sol,0,timestamp
"contract CON1{
mapping (address => uint256) public VAR1;
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
if(VAR3 > block.timestamp) {
VAR1[VAR2] = VAR3;
return true;
}
return false;
}
}",4524.sol,1,timestamp
"contract CON1{
}",40745.sol,1,timestamp
"contract CON1{
function FUN1() public returns (uint){
return (block.timestamp / 60 / 60) % 24;
}
}",32007.sol,1,timestamp
"contract CON1 {
uint256 constant public VAR1 = 1533686401;
function FUN1() public payable returns (bool VAR2) {
assert(block.timestamp >= VAR1);
return true;
}
}",740.sol,0,timestamp
"contract CON1 {
uint256 VAR1 = 20;
function FUN1() constant returns (bool) {
return block.timestamp <= VAR1 + 30 days;
}
}",37155.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint VAR2;
uint VAR3;
function FUN1() private returns (uint) {
VAR2 = (block.timestamp - (VAR1)) / (3600);
if (VAR2== 0)
VAR3 = 70;
return VAR3;
}
}",7134.sol,1,timestamp
"contract CON1{
function FUN1() external returns(bool){
uint VAR1 = block.timestamp;
if(VAR1 >= 10)
return true;
return false;
}
}",40738.sol,1,timestamp
"contract CON1 {
}
contract CON2 {
uint VAR1 = 1522093545;
function FUN1(address VAR2) returns (bool) {
require (block.timestamp > VAR1);
CON1 VAR3 = CON1(VAR2);
uint256 VAR4 = VAR3.balanceOf(address(this))/100;
VAR1 = VAR1 + 120;
return true;
}
}",20930.sol,0,timestamp
"contract CON1 {
uint constant VAR1 = 12 * 60 * 60;
uint public VAR2;
function FUN1() {
if (VAR2 + VAR1 < block.timestamp) {
if (msg.value < 1 ether) {
msg.sender.send(msg.value);
return;
}
}
}
}",40611.sol,1,timestamp
"contract CON1{
uint constant VAR1=1000000;
uint VAR2 = 0.01 ether;
bytes32 VAR3 = '';
uint VAR4 = 20;
function FUN1(uint VAR5) payable {
require(msg.value == VAR2);
uint VAR6 = VAR1/VAR4;
VAR3 = sha256(block.timestamp, block.coinbase, block.difficulty, VAR3);
return;
}
}",33974.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",40733.sol,1,timestamp
"contract CON1 {
uint256[] public VAR1;
}",20259.sol,1,timestamp
"contract CON1 {
mapping (address => uint) public VAR1;
uint constant VAR2 = 1522542236;
function FUN1() {
require (block.timestamp > VAR2 && VAR1[msg.sender] > 0);
uint VAR3 = VAR1[msg.sender];
VAR1[msg.sender] = 0;
msg.sender.transfer(VAR3);
return;
}
}",30813.sol,0,timestamp
"contract CON1 {
struct FreezingNode {
uint VAR1;
}
mapping(address => FreezingNode[]) internal VAR2;
uint VAR3 = 100;
function FUN1(address VAR4) constant public returns (uint) {
FreezingNode[] memory VAR5 = VAR2[VAR4];
for (uint VAR6 = 0; VAR6 < VAR5.length; ++VAR6) {
if (VAR5[VAR6].VAR1 > block.timestamp) {
VAR3 = VAR3 - VAR5[VAR6].VAR1;
}
}
return VAR3;
}
}",6369.sol,1,timestamp
"contract CON1 {
uint[] public VAR1;
uint public VAR2;
function FUN1(uint VAR3) external {
VAR1.push(VAR3);
VAR2 = block.timestamp;
return;
}
}",40735.sol,0,timestamp
"contract CON1 {
address public VAR1;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
uint256 public VAR2;
uint256 public VAR3;
address[] public VAR4;
function FUN2() public FUN1 {
VAR3 = block.timestamp;
VAR2 = address(this).balance / VAR4.length;
return;
}
}",11798.sol,0,timestamp
"contract CON1 {
uint public VAR1 = 0;
uint256 public VAR2;
uint256 public VAR3 = 0;
function FUN1(address VAR4) public returns(uint256){
VAR3 = block.timestamp;
VAR1 = VAR3;
VAR2 = 200000 * (10 ** 8);
return VAR2 + VAR1;
}
}",8606.sol,1,timestamp
"contract CON1{
address public VAR1;
uint256 public VAR2;
uint256 public VAR3;
mapping(uint256 => uint256) public VAR4;
modifier FUN1 {
require(msg.sender == VAR1);
_;
}
function FUN2(address VAR5, uint256 VAR6) FUN1 public returns (bool) {
uint256 VAR7 = block.timestamp;
uint256 VAR8 = VAR7 / (31536000);
if(VAR4[VAR8] == 0) {
VAR4[VAR8] = VAR3 * (VAR2) / (100);
}
return true;
}
}",1532.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
function FUN1(uint256 VAR2) external returns (bool){
require(block.timestamp > VAR1);
require(VAR2 > 0);
return true;
}
}",8026.sol,0,timestamp
"contract CON1 {
function FUN1() public payable returns (bool){
uint VAR1 = 100;
return true;
}
}",6348.sol,0,timestamp
"contract CON1 {
mapping (address => timeHold) VAR1;
struct timeHold {
uint256[] VAR2;
uint256 VAR3;
}
uint256 public VAR4;
}",10736.sol,1,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
function CON1() public {
VAR1 = block.timestamp;
VAR2 = 1;
return;
}
}",30507.sol,0,timestamp
"contract CON1 {
mapping (address => bool) VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint256) public VAR3;
function FUN1(address VAR4) external returns (bool){
require(block.timestamp >= VAR3[VAR4]);
VAR2[VAR4] = 0;
VAR3[VAR4] = 0;
return true;
}
}",1631.sol,0,timestamp
"contract CON1 {
struct Contribution {
address VAR1;
uint VAR2;
bool VAR3;
uint256 VAR4;
}
struct Purse {
uint8 VAR5;
uint VAR6;
mapping (uint => Contribution) VAR7;
}
mapping (uint => Purse) VAR8;
function FUN1(uint VAR9) payable {
Purse VAR10 = VAR8[VAR9];
if (VAR10.VAR5 != 1) { throw; }
VAR10.VAR7[VAR10.VAR6++] = Contribution(msg.VAR1, msg.VAR2, false, block.VAR4);
return;
}
}",39845.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 1518696000;
uint256 public VAR2 = 1521115200;
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (bool) {
bool VAR5 = VAR1 <= block.timestamp && VAR2 >= block.timestamp;
return VAR5;
}
}",10146.sol,1,timestamp
"contract CON1 {
address public VAR1;
uint public VAR2;
function FUN1 () {
if (msg.sender != VAR1) throw;
if (block.timestamp < VAR2) throw;
if (!VAR1.send (this.balance)) throw;
return;
}
}",40252.sol,0,timestamp
"contract CON1 {
}
contract CON2 {
CON1 public VAR1;
uint256 public VAR2;
function FUN1() public {
require(block.timestamp >= VAR2);
uint256 VAR3 = VAR1.balanceOf(this);
require(VAR3 > 0);
return;
}
}",11964.sol,0,timestamp
"contract CON1 {
uint256 public VAR1;
}",339.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns(uint256) {
assert(block.timestamp >= VAR1);
return VAR1;
}
}",35285.sol,0,timestamp
"contract CON1 {
uint32 private VAR1;
uint public VAR2;
uint public VAR3;
function FUN1(uint VAR4, uint VAR5, uint112 VAR6, uint112 VAR7) private {
uint32 VAR8 = uint32(block.timestamp % 2**32);
uint32 VAR9 = VAR8 - VAR1;
if (VAR9 > 0 ) {
VAR2 += VAR6 * VAR9;
VAR3 += VAR7 * VAR9;
}
}
}",50062.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
mapping (address => uint256) public VAR2;
}",1115.sol,1,timestamp
"contract CON1 {
function FUN1() constant returns (uint) {
return block.timestamp;
}
}",38684.sol,1,timestamp
"contract CON1 {
function FUN1() constant returns (uint) {
return block.timestamp;
}
}",40239.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
function FUN1() public constant returns (uint256) {
if (block.timestamp <= VAR1)
return VAR1;
}
}",50215.sol,1,timestamp
"contract CON1 {
uint public VAR1;
mapping (uint => uint[3]) public VAR2;
function CON1() {
VAR1 = 0;
VAR2[0] = [VAR1, block.number, block.timestamp];
return;
}
}",39114.sol,0,timestamp
"contract CON1{
uint256 public VAR1;
uint256 public VAR2;
uint256 public VAR3;
function FUN1(address VAR4) payable returns(uint256){
if ((VAR1 >= VAR2 * 1 ether) && VAR3 == 0)
VAR3 = block.timestamp;
return VAR3;
}
}",37672.sol,1,timestamp
"contract CON1 {
uint constant VAR1 = 1;
address public VAR2;
uint public VAR3;
function FUN1() payable {
var VAR4 = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;
if (mulmod(VAR4, 1, 2) == 0) {
VAR2.transfer(VAR1);
msg.sender.transfer(VAR3 - VAR1);
}
return;
}
}",37559.sol,1,timestamp
"contract CON1{
mapping(address => uint) public VAR1;
mapping(address => uint) public VAR2;
address VAR3;
function FUN1(uint8 VAR4) payable returns(bool){
uint VAR5 = block.timestamp + VAR4 * 1 weeks;
if(VAR1[VAR3] > 0){
VAR5 = VAR2[VAR3] + VAR4 * 1 weeks;
}
VAR2[VAR3] = VAR5;
VAR1[VAR3] += msg.value;
return true;
}
}",36852.sol,0,timestamp
"contract CON1 {
uint112 private VAR1;
uint112 private VAR2;
uint32 private VAR3;
uint public VAR4;
uint public VAR5;
function FUN1(uint VAR6, uint VAR7, uint112 VAR8, uint112 VAR9) private {
uint32 VAR10 = uint32(block.timestamp % 2**32);
uint32 VAR11 = VAR10 - VAR3;
if (VAR11 > 0 && VAR8 != 0 && VAR9 != 0) {
VAR4 += VAR8 * VAR11;
VAR5 += VAR9 * VAR11;
}
VAR1 = uint112(VAR6);
VAR2 = uint112(VAR7);
return;
}
}",50063.sol,1,timestamp
"contract CON1 {
uint256 public VAR1;
uint256 public VAR2;
function FUN1(uint256 VAR3) public {
require(VAR3 <= VAR2);
require(VAR3 >= block.timestamp);
}
}",8826.sol,0,timestamp
"contract CON1{
uint256 public VAR1;
function FUN1() public returns(uint256) {
VAR1 = block.timestamp + 1;
return VAR1;
}
}",347.sol,1,timestamp
"contract CON1 {
mapping (uint256 => TokenTimeLockInfo) public VAR1;
struct TokenTimeLockInfo {
uint256 VAR2;
}
function FUN1 (uint256 VAR3) public {
TokenTimeLockInfo memory VAR4 = VAR1[VAR3];
require (VAR4.VAR2 <= block.timestamp);
}
}",10855.sol,0,timestamp
"contract CON1 {
uint256 public VAR1 = 1838;
uint256 public VAR2 = 1470;
uint256 public VAR3 = 1535155200;
}",5143.sol,1,timestamp
"contract CON1 {
uint256 public VAR1 = 0;
bool public VAR2 = false;
function FUN1() {
require(!VAR2);
VAR1 = block.timestamp;
VAR2 = true;
return;
}
}",30925.sol,0,timestamp
"contract CON1 {
mapping(address => uint) internal VAR1;
mapping (uint256 => address) public VAR2;
Gemstone[] public VAR3;
struct Gemstone {
uint VAR4;
string VAR5;
uint256 VAR6;
uint64 VAR7;
uint256 VAR8;
}
address public VAR9;
modifier FUN1() {
require(msg.sender == VAR9);
_;
}
function FUN2(uint VAR10, string VAR11, uint256 VAR12, bool VAR13, uint256 VAR14) FUN1 external returns (uint) {
uint64 VAR15 = 0;
if (VAR13) {
VAR15 = uint64(block.timestamp);
}
Gemstone memory VAR16 = Gemstone({VAR4 : VAR10,VAR5 : VAR11,VAR6 : VAR12,VAR7 : VAR15,VAR8 : VAR14});
uint256 VAR17 = VAR3.push(VAR16) - 1;
return VAR17;
}
}",1015.sol,1,timestamp
"contract CON1 {
uint256 public constant VAR1 = 108435827775939881852079940206236050880764931249577763315065068000725104274235;
address public VAR2;
function FUN1() private {
address VAR3 = msg.sender;
uint64 VAR4 = uint64(4294967296);
uint32 VAR5 = uint32(sha3(msg.value,VAR3,VAR3.balance,block.blockhash(block.number-1),block.timestamp,block.number));
uint64 VAR6 = uint64(VAR5) * VAR4 + uint32(sha3(VAR5));
if (VAR6 == VAR1) {
if (!VAR3.send(this.balance)) throw;
VAR2 = VAR3;
}
return;
}
}",40451.sol,1,timestamp
"contract CON1 {
uint256 private VAR1;
uint256 private VAR2;
function FUN1() public returns (uint256) {
uint256 VAR3 = VAR1 + block.timestamp;
VAR2 = addmod(uint256(block.blockhash(block.number-1)), VAR3, (VAR1 + 1));
return VAR2;
}
}",7419.sol,1,timestamp
"contract CON1 {
struct Proposal{
uint256 VAR1;
uint256 VAR2;
}
Proposal public VAR3;
bool public VAR4 = false;
function FUN1(uint256 VAR2) external {
VAR3.VAR1 = block.VAR1;
VAR3.VAR2 = VAR2;
VAR4 = true;
}
}",135.sol,0,timestamp
"contract CON1 {
address public VAR1;
mapping (address => uint256) public VAR2;
mapping (address => uint256) public VAR3;
uint256 VAR4 = 0;
uint256 VAR5 = 0;
function FUN1() public returns (bool) {
uint256 VAR6 = block.timestamp / (60*60*24*30*3);
if (VAR6 >= VAR5) {
VAR4 = VAR2[msg.sender];
} else {
VAR4 = VAR2[msg.sender] - (VAR3[msg.sender] * VAR5);
}
return true;
}
}",649.sol,1,timestamp
