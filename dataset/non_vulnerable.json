[
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR11 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nfunction CON4 () public {\nVAR14 = msg.sender;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool) {\nrequire (msg.sender == VAR14);\nif (VAR3 > 0) {\nif (VAR3 > safeSub (VAR11, VAR13)) return false;\nVAR9 [msg.sender] = safeAdd (VAR9 [msg.sender], VAR3);\nVAR13 = safeAdd (VAR13, VAR3);\n}\nreturn true;\n}\nfunction FUN5 (uint256 VAR3) public returns (bool) {\nrequire (msg.sender == VAR14);\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR13 = safeSub (VAR13, VAR3);\nreturn true;\n} else return true;\n}\nfunction FUN6 (address VAR12) public {\nrequire (msg.sender == VAR14);\nVAR14 = VAR12;\n}\nuint256 internal VAR13;\naddress public VAR14;\n}",
        "label": false,
        "name": "0x9c43a9d11eb1457e52960bcd226b279f61f337b1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6a7ec9df733435c7e7702ac3ddbb48ecfe299a5d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring private VAR12 = \"IPW Token\";\nstring private VAR13 = \"IPWT\";\nuint8 private VAR14 = 18;\nuint256 public VAR18 = 10000000000 * (10 ** uint256(VAR14));\nconstructor() public CON3(VAR12, VAR13, VAR14) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0xa02d0b6bfce1dbd02b9cbb70e6b480333e8a86ec.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new owner is the zero address\");\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 0;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nstruct LockFund {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\nbool VAR13;\n}\nmapping (address => LockFund) public VAR14;\nconstructor(uint256 VAR15,string memory VAR16,string memory VAR17) public {\nVAR6 = VAR15 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR16; VAR4 = VAR17; }\nfunction FUN5(address VAR18, address VAR19, uint VAR20) internal {\nrequire(VAR19 != address(0x0),\"\u76ee\u7684\u5730\u5740\u4e0d\u80fd\u4e3a\u7a7a\");\nrequire(VAR18 != VAR19,\"\u81ea\u5df1\u4e0d\u80fd\u7ed9\u81ea\u5df1\u8f6c\u8d26\");\nrequire(VAR7[VAR18] - getLockedAmount(VAR18) >= VAR20,\"\u8f6c\u8d26\u7684\u6570\u91cf\u4e0d\u80fd\u8d85\u8fc7\u53ef\u7528\u7684\u6570\u91cf\");\nrequire(VAR7[VAR19] + VAR20 > VAR7[VAR19],\"\u8f6c\u8d26\u7684\u6570\u91cf\u6709\u95ee\u9898\");\nuint VAR21 = VAR7[VAR18] + VAR7[VAR19];\nVAR7[VAR18] -= VAR20;\nVAR7[VAR19] += VAR20;\nassert(VAR7[VAR18] + VAR7[VAR19] == VAR21);\n}\nfunction FUN6(address VAR19, uint256 VAR20) public returns (bool VAR22) {\nFUN5(msg.sender, VAR19, VAR20);\nreturn true;\n}\nfunction FUN7(address VAR18, address VAR19, uint256 VAR20) public returns (bool VAR22) {\nrequire(VAR20 <= VAR8[VAR18][msg.sender]); VAR8[VAR18][msg.sender] -= VAR20;\nFUN5(VAR18, VAR19, VAR20);\nreturn true;\n}\nfunction FUN8(address VAR23, uint256 VAR20) public\nreturns (bool VAR22) {\nVAR8[msg.sender][VAR23] = VAR20;\nreturn true;\n}\nfunction FUN9(address VAR23, uint256 VAR20, bytes memory VAR24)\npublic\nreturns (bool VAR22) {\nCON2 VAR25 = CON2(VAR23);\nif (FUN8(VAR23, VAR20)) {\nVAR25.receiveApproval(msg.sender, VAR20, address(this), VAR24);\nreturn true;\n}\n}\nfunction FUN10(uint256 VAR20) public returns (bool VAR22) {\nrequire(VAR7[msg.sender] >= VAR20); VAR7[msg.sender] -= VAR20; VAR6 -= VAR20;\nreturn true;\n}\nfunction FUN11(address VAR18, uint256 VAR20) public returns (bool VAR22) {\nrequire(VAR7[VAR18] >= VAR20); require(VAR20 <= VAR8[VAR18][msg.sender]); VAR7[VAR18] -= VAR20; VAR8[VAR18][msg.sender] -= VAR20; VAR6 -= VAR20;\nreturn true;\n}\nfunction FUN12(address VAR26, uint256 VAR27, uint256 VAR28, uint256 VAR29, uint256 VAR30,bool VAR31) FUN1 public {\nFUN5(msg.sender, VAR26, VAR27);\nLockFund storage VAR32 = VAR14[VAR26];\nVAR32.VAR9 = VAR27;\nVAR32.VAR10 = VAR28;\nVAR32.VAR11 = VAR29;\nVAR32.VAR12 = VAR30;\nVAR32.VAR13 = VAR31;\n}\nfunction FUN13(address VAR26) FUN1 public{\nLockFund storage VAR32 = VAR14[VAR26];\nrequire(VAR32.VAR13 == true,\"\u8be5\u5730\u5740\u4e0d\u652f\u6301\u64a4\u9500\u64cd\u4f5c\");\nuint256 VAR33 = getLockedAmount(VAR26);\nrequire(VAR7[owner()] + VAR33 > VAR7[owner()],\"\u8f6c\u8d26\u7684\u6570\u91cf\u6709\u95ee\u9898\");\nuint VAR21 = VAR7[owner()] + VAR7[VAR26];\nVAR7[VAR26] -= VAR33;\nVAR7[owner()] += VAR33;\nVAR32.VAR9 = 0;\nassert(VAR7[owner()] + VAR7[VAR26] == VAR21);\n}\n}",
        "label": false,
        "name": "0xe463d1ee18bcbce681215d15738018eadaa82260.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\naddress private VAR11;\nuint256 VAR12;\nbool VAR13 = false;\nfunction CON4 (uint256 VAR14) public {\nVAR11 = msg.sender;\nVAR12 = VAR14;\nVAR9 [msg.sender] = VAR14;\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN1 (VAR2, VAR3);\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN2 (VAR6, VAR2, VAR3);\n}\nfunction FUN3 (address VAR8, uint256 VAR15, uint256 VAR16)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR15)\nreturn FUN3 (VAR8, VAR16);\nelse return false;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool VAR4) {\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR12 = safeSub (VAR12, VAR3);\nreturn true;\n} else return true;\n}\nfunction FUN5 (address VAR17) public {\nrequire (msg.sender == VAR11);\nVAR11 = VAR17;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR11);\nif (!VAR13) {\nVAR13 = true;\nFreeze ();\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR11);\nif (VAR13) {\nVAR13 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0xaaaebe6fe48e54f431b0c390cfaf0b017d09d42d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = 1000000000000 ; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0xe72ACCEb20075C3B463a9C0Fb1158ffA42A19091));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xebe7d83b89670baa27e343c1f40b7bfcdfe28966.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nuint public constant VAR1 = 16000000;\nstring public constant VAR2 = \"GIX\";\nstring public constant VAR3 = \"Blockchain Gigs\";\nuint8 public constant VAR4 = 18;\nuint256 public constant VAR5 = VAR1 * 10 ** uint256(VAR4);\nuint256 public constant VAR6 = 500;\naddress public VAR7;\nmapping (address => uint256) VAR8;\nmapping (address => mapping (address => uint256)) VAR9;\nfunction () public payable {\nFUN2();\n}\nfunction CON1() {\nVAR8[msg.sender] = VAR5;\nVAR7 = msg.sender;\n}\nfunction FUN2() payable {\nrequire(msg.value > 0);\nuint256 VAR10 = msg.value.mul(VAR6);\nVAR8[msg.sender] = VAR8[msg.sender].add(VAR10);\nVAR7.FUN4(msg.value);\n}\nfunction FUN3(address VAR11) constant returns (uint256 VAR12){\nreturn VAR8[VAR11];\n}\nfunction FUN4(address VAR13, uint256 VAR14) returns (bool VAR15) {\nrequire(VAR13 != 0x0);\nrequire(VAR8[msg.sender] >= VAR14 && VAR14 > 0);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN5(address VAR16, address VAR13, uint256 VAR14) returns (bool VAR15){\nrequire(VAR13 != 0x0);\nrequire(VAR9 [VAR16][msg.sender] >= 0 && VAR8[VAR16] >= VAR14 && VAR14 > 0);\nVAR8[VAR16] = VAR8[VAR16].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nVAR9[VAR16][msg.sender] = VAR9[VAR16][msg.sender].sub(VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) returns (bool VAR15){\nVAR9[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR11, address VAR17) constant returns (uint256 VAR18){\nreturn VAR9[VAR11][VAR17];\n}\n}",
        "label": false,
        "name": "0x06ea7f6e403b68b228423cec502deb793c1c6c18.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON3 {\nCON2 public VAR3 = CON2(0x611171923b84185e9328827CFAaE6630481eCc7a);\nuint256 public VAR4 = 1537833600; uint256 public VAR5 = 1552348800;\naddress public VAR6 = 0xC5fed49Be1F6c3949831a06472aC5AB271AF89BD; uint public VAR7 = 18600000 ether;\naddress public VAR8 = 0x5B5521E9D795CA083eF928A58393B8f7FF95e098; uint public VAR9 = 3720000 ether;\naddress public VAR10 = 0x556dB38b73B97954960cA72580EbdAc89327808E; uint public VAR11 = 4650000 ether;\nfunction FUN3 () public FUN1 {\nrequire(VAR4 <= block.timestamp);\nrequire(VAR7 > 0);\nuint VAR12 = VAR3.balanceOf(this);\nrequire(VAR12 >= VAR7);\nif (VAR3.transfer(VAR6, VAR7)) {\nVAR7 = 0;\n}\n}\nfunction FUN4 () public FUN1 {\nrequire(VAR5 <= block.timestamp);\nrequire(VAR9 > 0);\nrequire(VAR11 > 0);\nuint VAR12 = VAR3.balanceOf(this);\nrequire(VAR12 >= VAR9 + VAR11);\nif (VAR3.transfer(VAR8, VAR9)) {\nVAR9 = 0;\n}\nif (VAR3.transfer(VAR10, VAR11)) {\nVAR11 = 0;\n}\n}\n}",
        "label": false,
        "name": "0x489cbb70668f5c6e0160ef57fb10c97ddff3548e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 8;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = 25000000000000000; VAR1 = VAR8;\"X-Ries\"; VAR2 = VAR9;\"XRX\"; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x5f12f33d0a36fd369e4fffae3d82eff9160013ce.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\naddress public VAR2;\nfunction CON1() {\nVAR2 = msg.sender;\nVAR1[msg.sender] = 1000;\n}\nfunction FUN1(address VAR3, uint256 VAR4) {\nif (VAR1[msg.sender]<VAR4) throw;\nif (VAR1[VAR3]+VAR4<VAR1[VAR3]) throw;\nif (VAR4<0) throw;\nVAR1[msg.sender] -= VAR4;\nVAR1[VAR3] += VAR4;\n}\n}",
        "label": false,
        "name": "0xdea48d521832780f5e437f7f744c94d2cda85af9.sol"
    },
    {
        "source": "contract CON1 {\nmapping (bytes32 => bool) public VAR1;\nfunction FUN1(bytes32 VAR2, address VAR3) internal {\nbytes32 VAR4 = keccak256(abi.encode(VAR2, VAR3));\nrequire(!VAR1[VAR4], \"Signature not unique\");\nVAR1[VAR4] = true;\n}\nbytes32 constant VAR5 = keccak256(\"EIP712Domain(string VAR17,string VAR18,uint256 VAR19,address VAR20)\");\nbytes32 constant VAR6 = keccak256(\"AttestationRequest(bytes32 VAR21,bytes32 VAR22)\");\nbytes32 constant VAR7 = keccak256(\"AddAddress(address VAR23,bytes32 VAR22)\");\nbytes32 constant VAR8 = keccak256(\"RemoveAddress(address VAR24,bytes32 VAR22)\");\nbytes32 constant VAR9 = keccak256(\"PayTokens(address VAR25,address VAR26,uint256 VAR27,bytes32 VAR22)\");\nbytes32 constant VAR10 = keccak256(\"ReleaseTokensFor(address VAR25,uint256 VAR27,bytes32 VAR22)\");\nbytes32 constant VAR11 = keccak256(\"AttestFor(address VAR28,address VAR29,uint256 VAR30,bytes32 VAR21,bytes32 VAR31)\");\nbytes32 constant VAR12 = keccak256(\"ContestFor(address VAR29,uint256 VAR30,bytes32 VAR31)\");\nbytes32 constant VAR13 = keccak256(\"RevokeAttestationFor(bytes32 VAR32,bytes32 VAR22)\");\nbytes32 constant VAR14 = keccak256(\"VoteFor(uint16 VAR33,address VAR34,bytes32 VAR22,address VAR35)\");\nbytes32 constant VAR15 = keccak256(\"LockupTokensFor(address VAR25,uint256 VAR27,bytes32 VAR22)\");\nbytes32 VAR16;\nconstructor (string VAR17, string VAR18, uint256 VAR19) public {\nVAR16 = hash(EIP712Domain({VAR17: VAR17,VAR18: VAR18,VAR19: VAR19,VAR20: this}));\n}\nstruct EIP712Domain {\nstring VAR17;\nstring VAR18;\nuint256 VAR19;\naddress VAR20;\n}\nstruct AttestationRequest {\nbytes32 VAR21;\nbytes32 VAR22;\n}\nstruct AddAddress {\naddress VAR23;\nbytes32 VAR22;\n}\nstruct RemoveAddress {\naddress VAR24;\nbytes32 VAR22;\n}\nstruct PayTokens {\naddress VAR25;\naddress VAR26;\nuint256 VAR27;\nbytes32 VAR22;\n}\nstruct AttestFor {\naddress VAR28;\naddress VAR29;\nuint256 VAR30;\nbytes32 VAR21;\nbytes32 VAR31;\n}\nstruct ContestFor {\naddress VAR29;\nuint256 VAR30;\nbytes32 VAR31;\n}\nstruct RevokeAttestationFor {\nbytes32 VAR32;\nbytes32 VAR22;\n}\nstruct VoteFor {\nuint16 VAR33;\naddress VAR34;\nbytes32 VAR22;\naddress VAR35;\n}\nstruct LockupTokensFor {\naddress VAR25;\nuint256 VAR27;\nbytes32 VAR22;\n}\nstruct ReleaseTokensFor {\naddress VAR25;\nuint256 VAR27;\nbytes32 VAR22;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON1 {\nusing SafeERC20 for CON3;\nusing SafeMath for uint256;\naddress public VAR36;\nmapping(address => uint256) public VAR37;\nCON3 public VAR38;\nconstructor(CON3 VAR39,address VAR40) public CON1(\"Bloom Token Escrow Marketplace\", \"2\", 1) {\nVAR38 = VAR39;\nVAR36 = VAR40;\n}\nmodifier FUN2() {\nrequire(msg.VAR25 == VAR36);\n_;\n}\nfunction FUN3(address VAR3,uint256 VAR41,bytes32 VAR42,bytes VAR43) external {\nFUN4(VAR3,VAR41,VAR42,VAR43);\nFUN6(VAR3, VAR41);\n}\nfunction FUN4(address VAR3,uint256 VAR41,bytes32 VAR42,bytes VAR43) private {\nbytes32 VAR2 = generateLockupTokensDelegationSchemaHash(VAR3, VAR41, VAR42);\nrequire(VAR3 == recoverSigner(VAR2, VAR43), 'Invalid LockupTokens Signature');\nFUN1(VAR2, VAR3);\n}\nfunction FUN5(uint256 VAR41) external {\nFUN6(msg.VAR25, VAR41);\n}\nfunction FUN6(address VAR3,uint256 VAR41) private {\nVAR38.safeTransferFrom(VAR3, this, VAR41);\nFUN14(VAR3, VAR41);\n}\nfunction FUN7(address VAR3,uint256 VAR41,bytes32 VAR42,bytes VAR43) external {\nFUN8(VAR3,VAR41,VAR42,VAR43);\nFUN10(VAR3, VAR41);\n}\nfunction FUN8(address VAR3,uint256 VAR41,bytes32 VAR42,bytes VAR43) private {\nbytes32 VAR2 = generateReleaseTokensDelegationSchemaHash(VAR3, VAR41, VAR42);\nrequire(VAR3 == recoverSigner(VAR2, VAR43), 'Invalid ReleaseTokens Signature');\nFUN1(VAR2, VAR3);\n}\nfunction FUN9(uint256 VAR41) external {\nFUN10(msg.VAR25, VAR41);\n}\nfunction FUN10(address VAR44,uint256 VAR41) private {\nFUN15(VAR44, VAR41);\nVAR38.safeTransfer(VAR44, VAR41);\n}\nfunction FUN11(address VAR44, address VAR45, uint256 VAR41) private {\nFUN15(VAR44, VAR41);\nVAR38.safeTransfer(VAR45, VAR41);\n}\nfunction FUN12(address VAR44,address VAR45,uint256 VAR41,bytes32 VAR42,bytes VAR46) external FUN2 {\nFUN13(VAR44,VAR45,VAR41,VAR42,VAR46);\nFUN11(VAR44, VAR45, VAR41);\n}\nfunction FUN13(address VAR44,address VAR45,uint256 VAR41,bytes32 VAR42,bytes VAR46) private {\nbytes32 VAR2 = generatePayTokensSchemaHash(VAR44, VAR45, VAR41, VAR42);\nrequire(VAR44 == recoverSigner(VAR2, VAR46), 'Invalid Payment Signature');\nFUN1(VAR2, VAR44);\n}\nfunction FUN14(address VAR47, uint256 VAR41) private {\nVAR37[VAR47] = VAR37[VAR47].add(VAR41);\n}\nfunction FUN15(address VAR47, uint256 VAR41) private {\nrequire(VAR37[VAR47] >= VAR41);\nVAR37[VAR47] = VAR37[VAR47].sub(VAR41);\n}\n}\ncontract CON5 {\naddress public VAR48;\nbool public VAR49;\nconstructor(address VAR50) public {\nVAR48 = VAR50;\nVAR49 = true;\n}\nmodifier FUN16() {\nrequire(msg.VAR25 == VAR48, 'Method can only be called by VAR48');\nrequire(VAR49, 'Method can only be called during initialization');\n_;\n}\nfunction FUN17() public FUN16 {\nVAR49 = false;\n}\n}\ncontract CON6 is CON5, CON1{\nCON4 public VAR51;\nconstructor(address VAR50,CON4 VAR52) CON5(VAR50) CON1(\"Bloom Attestation Logic\", \"2\", 1) public {\nVAR51 = VAR52;\n}\nfunction FUN18(address VAR53,address VAR54,uint256 VAR55,bytes VAR56,bytes32 VAR57,bytes32 VAR58,bytes VAR59 ) external {\nFUN20(VAR53,msg.VAR25,VAR54,VAR55,VAR56,VAR57,VAR58,VAR59);\n}\nfunction FUN19(address VAR53,address VAR60,address VAR54,uint256 VAR55,bytes VAR56,bytes32 VAR57,bytes32 VAR58,bytes VAR59, bytes VAR43) external {\nFUN25(VAR53, VAR60, VAR54, VAR55, VAR57, VAR58, VAR43);\nFUN20(VAR53,VAR60,VAR54,VAR55,VAR56,VAR57,VAR58,VAR59);\n}\nfunction FUN20(address VAR53,address VAR60,address VAR54,uint256 VAR55,bytes VAR56,bytes32 VAR57,bytes32 VAR58,bytes VAR59) private {\nFUN24(VAR53,VAR57,VAR58,VAR59);\nif (VAR55 > 0) {\nVAR51.FUN12(VAR54, VAR60, VAR55, VAR58, VAR56);\n}\n}\nfunction FUN21(address VAR54,uint256 VAR55,bytes32 VAR58,bytes VAR56) external {\nFUN23(msg.VAR25,VAR54,VAR55,VAR58,VAR56);\n}\nfunction FUN22(address VAR60,address VAR54,uint256 VAR55,bytes32 VAR58,bytes VAR56,bytes VAR43) external {\nFUN26(VAR60,VAR54,VAR55,VAR58,VAR43);\nFUN23(VAR60,VAR54,VAR55,VAR58,VAR56);\n}\nfunction FUN23(address VAR60,address VAR54,uint256 VAR55,bytes32 VAR58,bytes VAR56) private {\nif (VAR55 > 0) {\nVAR51.FUN12(VAR54, VAR60, VAR55, VAR58, VAR56);\n}\n}\nfunction FUN24(address VAR53,bytes32 VAR57,bytes32 VAR58,bytes VAR59) private {\nbytes32 VAR2 = generateRequestAttestationSchemaHash(VAR57, VAR58);\nrequire(VAR53 == recoverSigner(VAR2, VAR59));\nFUN1(VAR2, VAR53);\n}\nfunction FUN25(address VAR53,address VAR60,address VAR54,uint256 VAR55,bytes32 VAR57,bytes32 VAR58,bytes VAR43) private {\nbytes32 VAR61 = generateAttestForDelegationSchemaHash(VAR53, VAR54, VAR55, VAR57, VAR58);\nrequire(VAR60 == recoverSigner(VAR61, VAR43), 'Invalid AttestFor Signature');\nFUN1(VAR61, VAR60);\n}\nfunction FUN26(address VAR60,address VAR54,uint256 VAR55,bytes32 VAR58,bytes VAR43) private {\nbytes32 VAR61 = generateContestForDelegationSchemaHash(VAR54, VAR55, VAR58);\nrequire(VAR60 == recoverSigner(VAR61, VAR43), 'Invalid ContestFor Signature');\nFUN1(VAR61, VAR60);\n}\nfunction FUN27(address VAR54,address VAR60,address VAR53,bytes32 VAR57) public FUN16 {\n}\nfunction FUN28(bytes32 VAR62) external {\nFUN31(VAR62, msg.VAR25);\n}\nfunction FUN29(address VAR3,bytes32 VAR62,bytes32 VAR42,bytes VAR43) external {\nFUN30(VAR3, VAR62, VAR42, VAR43);\nFUN31(VAR62, VAR3);\n}\nfunction FUN30(address VAR3,bytes32 VAR62,bytes32 VAR42,bytes VAR43) private {\nbytes32 VAR61 = generateRevokeAttestationForDelegationSchemaHash(VAR62, VAR42);\nrequire(VAR3 == recoverSigner(VAR61, VAR43), 'Invalid RevokeFor Signature');\nFUN1(VAR61, VAR3);\n}\nfunction FUN31(bytes32 VAR62,address VAR3) private {\n}\nfunction FUN32(CON4 VAR63) external FUN16 {\naddress VAR64 = VAR51;\nVAR51 = VAR63;\n}\n}",
        "label": false,
        "name": "0xceec7aaa57e3a77c73a9954b9b7d5b32ab688318.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nstruct Knight\n{\naddress VAR1;\nuint256 VAR2;\n}\nmapping(string => Knight) VAR3;\nCON1 constant VAR4 = CON1(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B);\nmapping(bool => uint256) private VAR5;\nmapping(bool => mapping(address => uint256)) private VAR6;\nbool constant VAR7 = false;\nbool constant VAR8 = true;\nconstructor() public {\nVAR3[\"Safir\"].VAR2 = 27;\nVAR3[\"Safir\"].VAR1 = 0x61F646be9E40F3C83Ae6C74e8b33f2708396D08C;\nVAR3[\"Lucan\"].VAR2 = 27;\nVAR3[\"Lucan\"].VAR1 = 0x445D779acfE04C717cc6B0071D3713D7E405Dc99;\nVAR3[\"Lancelot\"].VAR2 = 27;\nVAR3[\"Lancelot\"].VAR1 = 0x5873d3875274753f6680a2256aCb02F2e42Be1A6;\nVAR3[\"Hoel\"].VAR2 = 11;\nVAR3[\"Hoel\"].VAR1 = 0x85a4F876A007649048a7D44470ec1d328895B8bb;\nVAR3[\"YwainTheBastard\"].VAR2 = 8;\nVAR3[\"YwainTheBastard\"].VAR1 = 0x2AB8D865Db8b9455F4a77C70B9D8d953E314De28;\n}\nfunction () external payable {\n}\nfunction FUN2() external {\nFUN4(VAR7);\nFUN4(VAR8);\nuint256 VAR9 = VAR6[VAR8][msg.sender];\nuint256 VAR10 = VAR6[VAR7][msg.sender];\nif(VAR9 > 0) {\nVAR6[VAR8][msg.sender] = 0;\nVAR4.transfer.gas(40000)(msg.sender,VAR9);\n}\nif(VAR10 > 0) {\nVAR6[VAR7][msg.sender] = 0;\nmsg.sender.transfer(VAR10);\n}\n}\nfunction FUN3(bool VAR11) internal {\nuint256 VAR12 = VAR11 ? VAR4.balanceOf.gas(40000)(address(this)) : address(this).VAR12;\nif(VAR12 > 0) {\nVAR5[VAR11] = VAR12\n.sub(VAR6[VAR11][VAR3[\"Safir\"].VAR1])\n.sub(VAR6[VAR11][VAR3[\"Lucan\"].VAR1])\n.sub(VAR6[VAR11][VAR3[\"Lancelot\"].VAR1])\n.sub(VAR6[VAR11][VAR3[\"YwainTheBastard\"].VAR1])\n.sub(VAR6[VAR11][VAR3[\"Hoel\"].VAR1]);\n} else {\nVAR5[VAR11] = 0;\n}\n}\nfunction FUN4(bool VAR11) private {\nFUN3(VAR11);\nif(VAR5[VAR11] > 0) {\nuint256 VAR13 = VAR5[VAR11].div(100);\nuint256 VAR14 = VAR3[\"Safir\"].VAR2.mul(VAR13);\nuint256 VAR15 = VAR3[\"Lucan\"].VAR2.mul(VAR13);\nuint256 VAR16 = VAR3[\"Lancelot\"].VAR2.mul(VAR13);\nuint256 VAR17 = VAR3[\"YwainTheBastard\"].VAR2.mul(VAR13);\nVAR6[VAR11][VAR3[\"Safir\"].VAR1] = VAR6[VAR11][VAR3[\"Safir\"].VAR1].add(VAR14);\nVAR6[VAR11][VAR3[\"Lucan\"].VAR1] = VAR6[VAR11][VAR3[\"Lucan\"].VAR1].add(VAR15);\nVAR6[VAR11][VAR3[\"Lancelot\"].VAR1] = VAR6[VAR11][VAR3[\"Lancelot\"].VAR1].add(VAR16);\nVAR6[VAR11][VAR3[\"YwainTheBastard\"].VAR1] = VAR6[VAR11][VAR3[\"YwainTheBastard\"].VAR1].add(VAR17);\nVAR6[VAR11][VAR3[\"Hoel\"].VAR1] = VAR6[VAR11][VAR3[\"Hoel\"].VAR1]\n.add(VAR5[VAR11] - VAR14 - VAR15 - VAR16 - VAR17);\nVAR5[VAR11] = 0;\n}\n}\n}",
        "label": false,
        "name": "0xacbc1971af62f42ee1ed89bc79308828e6b044f1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\naddress private VAR11;\nconstructor() internal {\nVAR11 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR11 = address(0);\n}\nfunction FUN12(address VAR12) public FUN10 {\nFUN13(VAR12);\n}\nfunction FUN13(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nstring public constant VAR13 = \"ARTIDToken\";\nstring public constant VAR14 = \"ARTID\";\nuint8 public constant VAR15 = 18;\nconstructor() public {\nFUN14();\n}\nfunction FUN14() private{\nFUN7(address(0x7003d8df7b38f4c758975fd4800574fecc0da7cd), 12e6 * 1e18);\nFUN7(address(0xdfdaa3b74fcc65b9e90d5922a74f8140a2b67d0f), 12e6 * 1e18);\nFUN7(address(0x0141f8d84f25739e426fd19783a1ec3a1f5a35e0), 12e6 * 1e18);\nFUN7(address(0x8863f676474c65e9b85dc2b7fee16188503ae790), 12e6 * 1e18);\nFUN7(address(0xabf2e86c69648e9ed6cd284f4f82df3f9df7a3dd), 12e6 * 1e18);\nFUN7(address(0x66348c99019d6c21fe7c4f954fd5a5cb0b41aa2c), 12e6 * 1e18);\nFUN7(address(0x3257b7ebb5e52c67cdd0c1112b28db362b7463cd), 12e6 * 1e18);\nFUN7(address(0x0c26122396a4bd59d855f19b69dadba3b19ba4d7), 12e6 * 1e18);\nFUN7(address(0x5b38e7b2c9ac03fa53e96220dcd299e3b47e1624), 12e6 * 1e18);\nFUN7(address(0x5593105770cd53802c067734d7e321e22e08c9a4), 3949480 * 1e18);\nFUN7(address(0xa8cdeef81970f44444eeb2c87c7eb2eb9a097a34), 3022807 * 1e18);\nFUN7(address(0x0b9e4d7d67552a3a044cbdc024188eaa057b72bc), 2400100 * 1e18);\nFUN7(address(0x7631029bd3f117b1a746506a04af966a5ede1b46), 2400000 * 1e18);\nFUN7(address(0x1ba5d47dcb2dc5d0afa86be3b7f5e2c421525b75), 109391 * 1e18);\nFUN7(address(0xb847988c1ea802842ff89466c8a35d5d052840bb), 100000 * 1e18);\nFUN7(address(0xcd807ad1b19f9a5a9fc1af1b1da448696d041504), 8363 * 1e18);\nFUN7(address(0x3ed4ac1eced4bd01c51a2317609120a16b85e19e), 8248 * 1e18);\nFUN7(address(0xfc886ff0fb687826e5a2572f366e38a6e81ea249), 364 * 1e18);\nFUN7(address(0xc6a1c5c60ecf4d6bf8b340f207505272fa281ede), 201 * 1e18);\nFUN7(address(0xa8cb97cbd42acca81eb3680d9b94ace459b502a2), 182 * 1e18);\nFUN7(address(0xf22e45982ed32849ee8fe2a342534f2a53b93695), 120 * 1e18);\nFUN7(address(0xe9d520f036d16a48636bf16371dcce0819cf6229), 100 * 1e18);\nFUN7(address(0x84d6339aa4900310aa9780ec66db57c88d2cd734), 100 * 1e18);\nFUN7(address(0x2c049093f263669a432dac59dac31d3c2b9c1996), 100 * 1e18);\nFUN7(address(0x23345fd753519795b9d7238690ababbb0469eb3e), 100 * 1e18);\nFUN7(address(0x421926ee0cb7941058387fc1a85532e7a94aa3c1), 100 * 1e18);\nFUN7(address(0x82389b139658378cdec2c1ed600aa4717ca59fad), 100 * 1e18);\nFUN7(address(0x93bb098498d538749a1d00f564555430a06bffbe), 44 * 1e18);\nFUN7(address(0xe619413a56bfcafbb84916f86d646248cc1abe76), 30 * 1e18);\nFUN7(address(0xce2dae844a2f473cb10e72ea5b5cd82ce1c86c76), 30 * 1e18);\nFUN7(address(0xbd189a18b2cc01bcf00574ee4f7ddad1e15183ee), 20 * 1e18);\nFUN7(address(0x0c4206f1e138cc8f584b89b6f62a4330120237ee), 20 * 1e18);\n}\n}",
        "label": false,
        "name": "0x0ecf0851b2cb945ddbee413c0e23f0c01cd4df7d.sol"
    },
    {
        "source": "contract CON1\n{\naddress public VAR1;\naddress public VAR2;\naddress public VAR3;\nmodifier FUN1{\nrequire(msg.sender == VAR1); _; }\nmodifier FUN2{\nrequire(msg.sender == VAR2); _; }\nmodifier FUN3{\nrequire(msg.sender == VAR3); _; }\nconstructor() public {\nVAR1 = msg.sender; }\nfunction FUN4(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR1;\nVAR1 = VAR4;\n}\nfunction FUN5(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR2;\nVAR2 = VAR4;\n}\nfunction FUN6(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR3;\nVAR3 = VAR4;\n}\n}\ncontract CON2\n{\n}\ncontract CON3 is CON2, CON1\n{\nusing SafeMath for uint;\nstring public VAR6;\nstring public VAR7;\nuint public VAR8;\nuint constant private VAR9 = 10**18;\nuint constant public VAR10 = 2500000 * VAR9;\nuint constant public VAR11 = 2500000 * VAR9;\nuint public VAR12;\nuint public VAR13;\nuint public VAR14;\nmapping (address => uint) public VAR15;\nmapping (address => mapping ( address => uint )) public VAR16;\nbool public VAR17 = true;\nbool public VAR18 = true;\nuint public VAR19 = 0;\nconstructor() public\n{\nVAR6 = \"SBtesting\";\nVAR8 = 18;\nVAR7 = \"SBtest\";\nVAR12 = 0;\nVAR13 = 0;\nrequire(VAR10 == VAR11);\n}\nfunction FUN7(address VAR4, uint VAR20) public returns (bool) {\nrequire(isTransferable() == true);\nrequire(VAR15[msg.sender] >= VAR20);\nVAR15[msg.sender] = VAR15[msg.sender].sub(VAR20);\nVAR15[VAR4] = VAR15[VAR4].add(VAR20);\nreturn true;}\nfunction FUN8(address VAR21, uint VAR20) public returns (bool){\nrequire(isTransferable() == true);\nrequire(VAR15[msg.sender] >= VAR20);\nVAR16[msg.sender][VAR21] = VAR20;\nreturn true; }\nfunction FUN9(address VAR22, address VAR4, uint VAR20) public returns (bool) {\nrequire(isTransferable() == true);\nrequire(VAR15[VAR22] >= VAR20);\nrequire(VAR16[VAR22][msg.sender] >= VAR20);\nVAR16[VAR22][msg.sender] = VAR16[VAR22][msg.sender].sub(VAR20);\nVAR15[VAR22] = VAR15[VAR22].sub(VAR20);\nVAR15[VAR4] = VAR15[VAR4].add(VAR20);\nreturn true;}\nfunction FUN10(address VAR4, uint VAR20) FUN2 public\n{\nuint VAR23 = VAR20 * VAR9;\nrequire(VAR11 >= VAR13.add(VAR23));\nVAR15[VAR4] = VAR15[VAR4].add(VAR23);\nVAR12 = VAR12.add(VAR23);\nVAR13 = VAR13.add(VAR23);\n}\nfunction FUN11() FUN3 public\n{\nrequire(VAR17 == true);\nrequire(VAR18 == false);\nVAR17 = false;\n}\nfunction FUN12() FUN3 public\n{\nrequire(VAR17 == false);\nVAR17 = true;\n}\nfunction () payable external\n{\nrevert();\n}\nfunction FUN14() FUN3 public\n{\nrequire(VAR18 == true);\nVAR18 = false;\nuint VAR24 = now;\nVAR19 = VAR24;\n}\nfunction FUN15(address VAR25, uint VAR26, uint VAR20) FUN3 public\n{\nif(VAR25 == address(0x0))\n{\nuint VAR27 = VAR20.mul(10 ** VAR26);\nmsg.sender.FUN7(VAR27);\n}\nelse\n{\nuint VAR23 = VAR20.mul(10 ** VAR26);\nCON2(VAR25).FUN7(msg.sender, VAR23);\n}\n}\nfunction FUN16(uint VAR20) FUN3 public\n{\nuint VAR23 = VAR20 * VAR9;\nrequire(VAR15[msg.sender] >= VAR23);\nVAR15[msg.sender] = VAR15[msg.sender].sub(VAR23);\nVAR14 = VAR14.add(VAR23);\nVAR12 = VAR12.sub(VAR23);\n}\nfunction FUN17() FUN1 public\n{\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0x2c8826775fb4d5c883fba7c2ffa0ef0854dd9529.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nOwnershipTransferred(VAR1, VAR2);\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\nPause();\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\nUnpause();\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nstring public constant VAR4 = \"Crypterra Token\";\nstring public constant VAR5 = \"CPTX\";\nuint8 public constant VAR6 = 18;\nuint256 public constant VAR7 = 600000000 * (10 ** uint256(VAR6));\nmapping(address => uint256) VAR8;\nmapping (address => mapping (address => uint256)) internal VAR9;\nuint256 VAR10;\nfunction CON4() public {\nVAR10 = VAR7;\nVAR8[msg.sender] = VAR7;\n}\nmodifier FUN7 {\nassert(0x0 != msg.sender);\n_;\n}\nfunction FUN8(address VAR11, uint256 VAR12) FUN3 FUN7 public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR8[msg.sender] >= VAR12);\nrequire(VAR8[VAR11] + VAR12 >= VAR8[VAR11]);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR12);\nVAR8[VAR11] = VAR8[VAR11].add(VAR12);\nreturn true;\n}\nfunction FUN9(address VAR13, address VAR11, uint256 VAR12) FUN3 FUN7 public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR8[VAR13] >= VAR12);\nrequire(VAR9[VAR13][msg.sender] >= VAR12);\nrequire(VAR8[VAR11] + VAR12 >= VAR8[VAR11]);\nVAR8[VAR13] = VAR8[VAR13].sub(VAR12);\nVAR8[VAR11] = VAR8[VAR11].add(VAR12);\nVAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR12);\nreturn true;\n}\nfunction FUN10(address VAR14, uint256 VAR12) FUN3 public returns (bool) {\nVAR9[msg.sender][VAR14] = VAR12;\nreturn true;\n}\nfunction FUN11(uint256 VAR12) public {\nrequire(VAR12 > 0);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR12);\nVAR10 = VAR10.sub(VAR12);\nBurn(msg.sender, VAR12);\n}\n}",
        "label": false,
        "name": "0x57929e21bb0de26166d3f3cfa09be0b2bb9f0a9c.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\naddress private VAR2;\nconstructor() public {\nFUN3(msg.sender);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2, \"msg.sender should be onlyPendingOwner\");\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR1, \"msg.sender should be owner\");\n_;\n}\nfunction FUN3(address VAR3) internal {\nVAR1 = VAR3;\n}\nfunction FUN4(address VAR3) public FUN2 {\nVAR2 = VAR3;\n}\nfunction FUN5() public FUN1 {\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON2 is CON1 {\naddress private VAR4;\nmodifier FUN6() {\nrequire(msg.sender == VAR4, \"msg.sender should be operator\");\n_;\n}\nfunction FUN7(address VAR5) public FUN2 {\nrequire(VAR5 != address(0), \"Cannot change the newOperator to the zero address\");\nVAR4 = VAR5;\n}\n}\ncontract CON3 is CON2 {\nmapping (address => uint256) public VAR6;\nfunction FUN8(address VAR7, uint256 VAR8) public FUN6 {\nVAR6[VAR7] = VAR8;\n}\n}",
        "label": false,
        "name": "0x468b8809ec8e0ab8cd56050f820b028417218ef3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR11);\nFUN6(VAR13, VAR10, VAR11);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].add(VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].sub(VAR15);\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR16, uint256 VAR11) internal {\nVAR8[VAR16][msg.sender] = VAR8[VAR16][msg.sender].sub(VAR11);\nFUN8(VAR16, VAR11);\n}\n}\ncontract CON4 is CON3 {\nfunction FUN10(uint256 VAR11) public {\nFUN8(msg.sender, VAR11);\n}\nfunction FUN11(address VAR13, uint256 VAR11) public {\nFUN9(VAR13, VAR11);\n}\n}\ncontract CON5 {\naddress private VAR17;\nconstructor () internal {\nVAR17 = msg.sender;\n}\nmodifier FUN12() {\nrequire(isOwner());\n_;\n}\nfunction FUN13() public FUN12 {\nVAR17 = address(0);\n}\nfunction FUN14(address VAR18) public FUN12 {\nFUN15(VAR18);\n}\nfunction FUN15(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON6 {\nusing Roles for Roles.Role;\nRoles.Role private VAR19;\nconstructor () internal {\nFUN19(msg.sender);\n}\nmodifier FUN16() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN17(address VAR16) public FUN16 {\nFUN19(VAR16);\n}\nfunction FUN18() public {\nFUN20(msg.sender);\n}\nfunction FUN19(address VAR16) internal {\nVAR19.add(VAR16);\n}\nfunction FUN20(address VAR16) internal {\nVAR19.remove(VAR16);\n}\n}\ncontract CON7 is CON6 {\nbool private VAR20;\nconstructor () internal {\nVAR20 = false;\n}\nmodifier FUN21() {\nrequire(!VAR20);\n_;\n}\nmodifier FUN22() {\nrequire(VAR20);\n_;\n}\nfunction FUN23() public FUN16 FUN21 {\nVAR20 = true;\n}\nfunction FUN24() public FUN16 FUN22 {\nVAR20 = false;\n}\n}\ncontract CON8 {\nusing Roles for Roles.Role;\nRoles.Role private VAR21;\nconstructor () internal {\nFUN28(msg.sender);\n}\nmodifier FUN25() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN26(address VAR16) public FUN25 {\nFUN28(VAR16);\n}\nfunction FUN27() public {\nFUN29(msg.sender);\n}\nfunction FUN28(address VAR16) internal {\nVAR21.add(VAR16);\n}\nfunction FUN29(address VAR16) internal {\nVAR21.remove(VAR16);\n}\n}\ncontract CON9 {\nusing Roles for Roles.Role;\nRoles.Role private VAR22;\nconstructor () internal {\nFUN33(msg.sender);\n}\nmodifier FUN30() {\nrequire(isWhitelistAdmin(msg.sender));\n_;\n}\nfunction FUN31(address VAR16) public FUN30 {\nFUN33(VAR16);\n}\nfunction FUN32() public {\nFUN34(msg.sender);\n}\nfunction FUN33(address VAR16) internal {\nVAR22.add(VAR16);\n}\nfunction FUN34(address VAR16) internal {\nVAR22.remove(VAR16);\n}\n}\ncontract CON10 is CON9 {\nusing Roles for Roles.Role;\nRoles.Role private VAR23;\nmodifier FUN35() {\nrequire(isWhitelisted(msg.sender));\n_;\n}\nfunction FUN36(address VAR16) public FUN30 {\nFUN39(VAR16);\n}\nfunction FUN37(address VAR16) public FUN30 {\nFUN40(VAR16);\n}\nfunction FUN38() public {\nFUN40(msg.sender);\n}\nfunction FUN39(address VAR16) internal {\nVAR23.add(VAR16);\n}\nfunction FUN40(address VAR16) internal {\nVAR23.remove(VAR16);\n}\n}\ncontract CON11 is CON5, CON10 {\nconstructor ()\nCON10() public {\n}\nfunction FUN41(address VAR24) public FUN30 {\nif (!isWhitelisted(VAR24)) {\nFUN36(VAR24);\n}\n}\nfunction FUN42(address VAR16) public FUN12 {\nrequire(VAR16 != msg.sender, \"Use renounceWhitelistAdmin\");\nFUN34(VAR16);\n}\n}\ncontract CON12 is CON2, CON4, CON5, CON7, CON8 {\nmapping(address => uint256) public VAR25;\naddress[] public VAR26;\nmapping (address => uint256) public VAR27;\naddress payable[] public VAR28;\nuint256 public VAR29 = 50 finney;\nuint256 public VAR30 = 50; uint256 public VAR31 = 50; uint256 public VAR32 = 1 ether;\nuint256 public VAR33 = 50;\nuint256 public VAR34 = 50;\nPrice public VAR35;\naddress public VAR36;\nstruct Price {\nuint256 VAR37;\nuint256 VAR38;\n}\nconstructor (uint256 VAR39, address VAR40)\nCON2(\"CRYPTO10 Hedged\", \"C10\", 18)\nCON4()\nCON7() public {\nVAR35 = Price(VAR39, 1000);\nrequire(VAR39 > 0, \"Invalid VAR35 numerator\");\nrequire(VAR40 != address(0), \"Invalid whitelist address\");\nVAR36 = VAR40;\n}\nfunction () external payable {\nFUN61(msg.sender);\n}\nfunction FUN44() external payable {\nFUN61(msg.sender);\n}\nfunction FUN45(uint256 VAR41) external FUN12 {\nrequire(VAR41 > 0, \"Must be greater than 0\");\nVAR33 = VAR41;\n}\nfunction FUN46(uint256 VAR42) external FUN12 {\nrequire(VAR42 > 0, \"Must be greater than 0\");\nVAR34 = VAR42;\n}\nfunction FUN47(uint256 VAR43) external FUN12 {\nrequire(VAR43 < 10000, \"Must be less than 100 percent\");\nVAR30 = VAR43;\n}\nfunction FUN48(uint256 VAR43) external FUN12 {\nrequire(VAR43 < 10000, \"Must be less than 100 percent\");\nVAR31 = VAR43;\n}\nfunction FUN49(uint256 VAR44) external FUN12 {\nrequire(VAR44 > 0, \"Minimum must be greater than 0\");\nVAR29 = VAR44;\n}\nfunction FUN50(uint256 VAR45) external FUN12 {\nrequire(VAR45 > 0, \"Minimum must be greater than 0\");\nVAR32 = VAR45;\n}\nfunction FUN51(uint256 VAR46) external FUN25 {\nrequire(VAR46 > 0, \"Must be positive value\");\nVAR35.VAR37 = VAR46;\nFUN62();\nFUN64();\n}\nfunction FUN52(uint256 VAR47) external FUN25 {\nrequire(VAR47 > 0, \"Must be positive value\");\nVAR35.VAR38 = VAR47;\n}\nfunction FUN53(uint256 VAR48) external FUN21\nFUN35 {\naddress payable VAR24 = msg.sender;\nrequire(balanceOf(VAR24) >= VAR48,\"Cannot withdraw more than VAR51 held\");\nrequire(VAR48 >= VAR32, \"Too few tokens\");\nFUN10(VAR48);\nuint256 VAR49 = VAR27[VAR24];\nif (VAR49 == 0) {\nVAR28.push(VAR24);\n}\nVAR27[VAR24] = VAR49.add(VAR48);\n}\nfunction FUN54(CON3 VAR50) external FUN12 {\nrequire(address(VAR50) != address(0), \"Invalid address\");\nuint256 VAR51 = VAR50.balanceOf(address(this));\nVAR50.FUN1(owner(), VAR50.balanceOf(address(this)));\n}\nfunction FUN55(address VAR16, uint256 VAR11) external FUN12 {\nFUN8(VAR16, VAR11);\n}\nfunction FUN56() external payable {\nrequire(msg.VAR11 > 0, \"Must be positive value\");\n}\nfunction FUN57(uint256 VAR52) external FUN12 {\nrequire(VAR52 <= address(this).VAR51, \"Insufficient balance\");\nmsg.sender.FUN1(VAR52);\n}\nfunction FUN58(address VAR16) external FUN12 {\nrequire(VAR16 != msg.sender, \"Use renounceMinter\");\nFUN29(VAR16);\n}\nfunction FUN59(address VAR16) external FUN12 {\nrequire(VAR16 != msg.sender, \"Use renouncePauser\");\nFUN20(VAR16);\n}\nfunction FUN60(address VAR10, uint256 VAR11) public FUN25 FUN21 returns (bool) {\nFUN7(VAR10, VAR11);\nreturn true;\n}\nfunction FUN61(address VAR24) internal FUN21 FUN35 {\nassert(VAR24 != address(0));\nrequire(msg.VAR11 >= VAR29, \"Minimum wei not met\");\nuint256 VAR49 = VAR25[VAR24];\nif (VAR49 == 0) {\nVAR26.push(VAR24);\n}\nVAR25[VAR24] = VAR49.add(msg.VAR11);\n}\nfunction FUN62() internal {\nuint256 VAR53 = min(VAR26.length, VAR33);\nuint256 VAR54 = VAR26.length;\nuint256 VAR55 = VAR26.length.sub(VAR53);\nfor (uint256 VAR56 = VAR54; VAR56 > VAR55; VAR56--) {\nFUN63(VAR56 - 1);\n}\n}\nfunction FUN63(uint256 VAR57) internal {\naddress VAR24 = VAR26[VAR57];\nuint256 VAR58 = VAR25[VAR24];\nuint256 VAR59 = VAR58.mul(VAR30) / 10000;\nuint256 VAR51 = VAR58.sub(VAR59);\nuint256 VAR60 = VAR51.mul(VAR35.VAR37) / VAR35.VAR38;\nVAR25[VAR24] = 0;\nVAR26.pop();\nif (VAR59 > 0) {\naddress(uint160(owner())).FUN1(VAR59);\n}\nFUN60(VAR24, VAR60);\n}\nfunction FUN64() internal {\nuint256 VAR61 = min(VAR28.length, VAR34);\nuint256 VAR54 = VAR28.length;\nuint256 VAR55 = VAR28.length.sub(VAR61);\nfor (uint256 VAR56 = VAR54; VAR56 > VAR55; VAR56--) {\nFUN65(VAR56 - 1);\n}\n}\nfunction FUN65(uint256 VAR57) internal {\naddress payable VAR24 = VAR28[VAR57];\nuint256 VAR62 = VAR27[VAR24];\nuint256 VAR63 = VAR62.mul(VAR35.VAR38) / VAR35.VAR37;\nVAR27[VAR24] = 0;\nVAR28.pop();\nif (address(this).VAR51 < VAR63) {\nFUN60(VAR24, VAR62);\nreturn;\n}\nuint256 VAR59 = VAR63.mul(VAR31) / 10000;\nuint256 VAR51 = VAR63.sub(VAR59);\nif (VAR24.send(VAR51)) {\nif (VAR59 > 0) {\naddress(uint160(owner())).FUN1(VAR59);\n}\n} else {\nFUN60(VAR24, VAR62);\n}\n}\nmodifier FUN35() {\nrequire(CON11(VAR36).isWhitelisted(msg.sender), \"Must be whitelisted\");\n_;\n}\n}",
        "label": false,
        "name": "0x000c100050e98c91f9114fa5dd75ce6869bf4f53.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint256 public VAR1;\nmapping (address => uint256) public VAR2;\nmapping (address => mapping (address => uint256)) public VAR3;\nconstructor () public { }\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR4] = VAR5;\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nreturn FUN3(msg.sender, VAR6, VAR5);\n}\nfunction FUN3(address VAR7, address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR2[VAR7] >= VAR5, \"Insufficient user balance\");\nif (VAR7 != msg.sender && allowance(VAR7, msg.sender) != uint256(-1)) {\nrequire(allowance(VAR7, msg.sender) >= VAR5, \"Insufficient user allowance\");\nVAR3[VAR7][msg.sender] = VAR3[VAR7][msg.sender].sub(VAR5);\n}\nVAR2[VAR7] = VAR2[VAR7].sub(VAR5);\nVAR2[VAR6] = VAR2[VAR6].add(VAR5);\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nstring constant public VAR8 = \"Veil Ether\"; string constant public VAR9 = \"Veil ETH\"; uint256 constant public VAR10 = 18;\nconstructor () public { }\nfunction() public payable {\nFUN7();\n}\nfunction FUN5(address VAR4, uint256 VAR11) public payable returns (bool) {\nFUN7();\nFUN1(VAR4, VAR11);\nreturn true;\n}\nfunction FUN6(uint256 VAR5, address VAR12) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR5, \"Insufficient user balance\");\nrequire(VAR12 != address(0), \"Invalid target address\");\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR1 = VAR1.sub(VAR5);\nVAR12.FUN2(VAR5);\nreturn true;\n}\nfunction FUN7() public payable returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].add(msg.value);\nVAR1 = VAR1.add(msg.value);\nreturn true;\n}\nfunction FUN8(uint256 VAR5) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR5, \"Insufficient user balance\");\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR1 = VAR1.sub(VAR5);\nmsg.sender.FUN2(VAR5);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x53b04999c1ff2d77fcdde98935bb936a67209e4c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\naddress public VAR11;\naddress public VAR12;\nuint256 public VAR13 = now;\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN8(address VAR14) external FUN6 {\nFUN10(VAR14);\n}\nfunction FUN9(address VAR15) external FUN7 {\nFUN11(VAR15);\n}\nfunction FUN10(address VAR14) internal {\nrequire(VAR14 != address(0));\nVAR1[VAR11] = VAR1[VAR11].sub(VAR1[VAR11]);\nVAR1[VAR14] = VAR1[VAR14].add(VAR1[VAR11]);\nVAR11 = VAR14;\n}\nfunction FUN11(address VAR15) internal {\nrequire(VAR15 != address(0));\nVAR12 = VAR15;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR16 = false;\nbool public VAR17 = true;\nmodifier FUN12() {\nrequire(!VAR16 || msg.sender == VAR11);\n_;\n}\nmodifier FUN13() {\nrequire(VAR16);\n_;\n}\nfunction FUN14() FUN6 FUN12 public {\nrequire(VAR17 == true);\nVAR16 = true;\n}\nfunction FUN15() FUN6 FUN13 public {\nrequire(VAR16 == true);\nVAR16 = false;\n}\nfunction FUN16() FUN6 public{\nVAR16 = false;\nVAR17 = false;\n}\n}\ncontract CON7 is CON6 {\nusing SafeMath for uint;\nuint256 VAR18;\nuint256 VAR19;\nuint256 VAR20;\nbool VAR21;\nbool VAR22 ;\nbool VAR23;\nbool VAR24;\nbool VAR25;\nbool VAR26;\nuint256 public VAR27;\nuint256 public VAR28 ;\nuint256 public VAR29 ;\nuint256 public VAR30 ;\nstring public constant VAR31 = \"SAM Token\";\nstring public constant VAR32 = \"SAM\";\nuint public constant VAR33 = 0;\nconstructor(address VAR34,address VAR35,uint256 VAR36,address VAR37,address VAR38) public {\nVAR11 = VAR34;\nVAR12 = VAR35;\nVAR36 = VAR36;\nVAR2 = VAR2.add(VAR36);\nVAR28 = 450000000;\nVAR29 = 200000000;\nVAR27 = 100000000;\nVAR30 = 50000000;\nVAR18 = VAR18.add(VAR27);\nVAR19 = VAR19.add(VAR30);\nVAR20 = VAR20.add(VAR29);\nVAR1[VAR12] = VAR1[VAR12].add(VAR28);\nVAR1[VAR37] = VAR1[VAR37].add(150000000);\nVAR1[VAR38] = VAR1[VAR38].add(50000000);\n}\nmodifier FUN17(uint VAR39) {\nassert(msg.data.length >= VAR39 * 32 + 4);\n_;\n}\nfunction FUN1(address VAR40, uint VAR41) public FUN12 FUN17(2) returns (bool VAR42) {\nrequire(VAR40 != address(0));\nrequire(VAR41 > 0);\nrequire(VAR41 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR41);\nVAR1[VAR40] = VAR1[VAR40].add(VAR41);\nreturn true;\n}\nfunction FUN3(address VAR43, uint VAR41) public FUN12 FUN17(2) returns (bool VAR42) {\nrequire(VAR43 != address(0));\nVAR5[msg.sender][VAR43] = VAR41;\nreturn true;\n}\nfunction FUN2(address VAR44, address VAR40, uint VAR41) public FUN12 FUN17(3) returns (bool VAR42) {\nrequire(VAR41 > 0);\nrequire(VAR44 != address(0));\nrequire(VAR40 != address(0));\nrequire(VAR5[VAR44][msg.sender] > 0);\nrequire(VAR1[VAR44]>0);\nVAR1[VAR44] = VAR1[VAR44].sub(VAR41);\nVAR5[VAR44][msg.sender] = VAR5[VAR44][msg.sender].sub(VAR41);\nVAR1[VAR40] = VAR1[VAR40].add(VAR41);\nreturn true;\n}\nfunction FUN18(uint VAR4) public returns (bool VAR42) {\nrequire(VAR1[msg.sender] >= VAR4);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\nreturn true;\n}\nfunction FUN19(address VAR44, uint VAR4) public returns (bool VAR42) {\nrequire(VAR1[VAR44] >= VAR4);\nrequire(VAR4 <= VAR5[VAR44][msg.sender]);\nVAR1[VAR44] = VAR1[VAR44].sub(VAR4);\nVAR5[VAR44][msg.sender] = VAR5[VAR44][msg.sender].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN21(address VAR45, uint VAR41) public FUN6 returns (bool VAR42) {\nrequire(VAR45 != address(0));\nrequire(isContract(VAR45));\nreturn CON2(VAR45).FUN1(VAR11, VAR41);\n}\nfunction FUN22(address VAR46) external FUN6 returns(bool) {\nrequire(VAR46 != address(0), \"Address is not valid\");\nrequire(!VAR21, \"owner release has already done\");\nif (now > VAR13.add(365 days) && VAR22 == false ) {\nVAR1[VAR46] = VAR1[VAR46].add(VAR18);\nVAR22 = true;\nVAR21 = true;\nVAR18 = 0;\nreturn true;\n}\n}\nfunction FUN23(address VAR47) external FUN6 returns(bool) {\nrequire(VAR47 != address(0), \"Address is not valid\");\nrequire(!VAR24, \"Team release has already done\");\nif (now > VAR13.add(365 days) && VAR23 == false) {\nVAR1[VAR47] = VAR1[VAR47].add(VAR20);\nVAR23 = true;\nVAR24 = true;\nVAR20 = 0;\nreturn true;\n}\n}\nfunction FUN24(address VAR38) external FUN6 returns(bool) {\nrequire(VAR38 != address(0), \"Address is not valid\");\nrequire(!VAR26, \"Bounty release already done\");\nif (now > VAR13.add(180 days) && VAR25 == false) {\nVAR1[VAR38] = VAR1[VAR38].add(VAR19);\nVAR25 = true;\nVAR26 = true;\nVAR19 = 0;\nreturn true;\n}\n}\n}",
        "label": false,
        "name": "0xe05dccf448f2f0dc0257fe5f507d22f9f0d5bbf1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN4(uint256 VAR6) public {\nrequire(VAR6 <= VAR3[msg.sender]);\naddress VAR7 = msg.sender;\nVAR3[VAR7] = VAR3[VAR7].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON5 is CON2 {\n}\ncontract CON6 is CON5, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR9]);\nrequire(VAR6 <= VAR8[VAR9][msg.sender]);\nVAR3[VAR9] = VAR3[VAR9].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR6) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON1 {\naddress public VAR14;\nbool VAR15;\nbool public VAR16 = false;\nfunction FUN9(address VAR17) external {\nrequire(VAR17 != address(0));\nrequire(VAR15 == false);\nVAR14 = VAR17;\nVAR15 = true;\n}\nmodifier FUN10() {\nif(msg.sender != VAR14) {\nrequire(!VAR16);\n}\n_;\n}\nmodifier FUN11() {\nrequire(VAR16);\n_;\n}\nfunction FUN12() FUN1 FUN10 public {\nVAR16 = true;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR16 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\nfunction FUN6(address VAR10, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN6(VAR10, VAR6);\n}\nfunction FUN7(address VAR10, uint VAR11) public FUN10 returns (bool VAR18) {\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN8(address VAR10, uint VAR12) public FUN10 returns (bool VAR18) {\nreturn super.FUN8(VAR10, VAR12);\n}\n}\ncontract CON9 is CON6, CON1 {\nmapping (address => bool) public VAR19;\nfunction FUN14(address VAR20) public FUN1 {\nVAR19[VAR20] = true;\n}\nfunction FUN15(address VAR20) public FUN1 {\nVAR19[VAR20] = false;\n}\nmodifier FUN16(address VAR21) {\nrequire(!VAR19[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN16(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN16(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON10 is CON6, CON1 {\nmapping (address => uint) public VAR22;\nfunction FUN17(address VAR20, uint VAR23) public FUN1 {\nuint VAR24;\nVAR24 = now + (VAR23 * 1 days);\nVAR22[VAR20] = VAR24;\n}\nfunction FUN18(address VAR20) public FUN1 {\nVAR22[VAR20] = now;\n}\nmodifier FUN19(address VAR21) {\nrequire(now >= VAR22[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN19(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN19(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON11 is CON10, CON9, CON8, CON4 {\nstring public constant VAR25 = \"GoldToken\";\nstring public constant VAR26 = \"GTK\";\nuint public constant VAR27 = 18;\nuint public constant VAR28 = 500000000 * (10 ** VAR27);\nconstructor() public {\nVAR4 = VAR28;\nVAR3[msg.sender] = VAR4;\n}\n}",
        "label": false,
        "name": "0x0785d6edc7c7a19cbcc5fb56a406b1351fc907dc.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ncontract CON3 {\nmodifier FUN1(bool VAR1) {\nrequire(VAR1);\n_;\n}\nmodifier FUN2(bool VAR1) {\n_;\nassert(VAR1);\n}\nmodifier FUN3(bool VAR1) {\nrequire(VAR1);\n_;\nassert(VAR1);\n}\n}\ncontract CON4 is CON3 {\naddress public VAR2;\nfunction CON4() { VAR2 = msg.sender; }\nfunction FUN4(address VAR3) FUN1(FUN5()) { VAR2 = VAR3; }\nfunction FUN5() internal returns (bool) { return msg.sender == VAR2; }\n}\ncontract CON5 is CON2, CON3, CON4 {\nmapping (address => bool) VAR4;\nfunction FUN6(address VAR5)\nFUN1(FUN5())\n{\nVAR4[VAR5] = true;\n}\nfunction FUN7(address VAR5)\nFUN1(FUN5())\n{\nVAR4[VAR5] = false;\n}\n}",
        "label": false,
        "name": "0xd42316be0e813104096ab537fee2fe0f5076bb2f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 {\naddress private VAR18;\nconstructor () internal {\nVAR18 = msg.sender;\n}\nmodifier FUN11() {\nrequire(isOwner());\n_;\n}\nfunction FUN12() public FUN11 {\nVAR18 = address(0);\n}\nfunction FUN13(address VAR19) public FUN11 {\nFUN14(VAR19);\n}\nfunction FUN14(address VAR19) internal {\nrequire(VAR19 != address(0));\nVAR18 = VAR19;\n}\n}\ninterface CON5 {\n}\ncontract CON6 is CON2, CON3, CON4 {\nconstructor(string memory VAR15,string memory VAR16,uint8 VAR17,uint256 VAR20) CON3(VAR15, VAR16, VAR17) CON4() public {\nCON2.FUN7(msg.sender, VAR20);\n}\nfunction FUN15(address VAR21, address VAR4, uint256 VAR22) external FUN11 {\nrequire(VAR4 != address(0x0));\nrequire(CON5(VAR21).FUN1(VAR4, VAR22));\n}\n}",
        "label": false,
        "name": "0xce5114d7fa8361f0c088ee26fa3a5446c4a1f50b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\naddress public constant VAR7 = address(0x0);\nmodifier FUN4(uint256 VAR8) {\nrequire(VAR4[msg.sender] >= VAR8);\n_;\n}\nfunction FUN5(uint256 VAR8)\npublic\nFUN4(VAR8)\n{\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\n}\n}\ncontract CON5 is CON3, CON1 {\nstring public VAR9;\nstring public VAR10;\nbool public VAR11;\nuint256 public VAR12 = 18;\nfunction CON5(string VAR13,string VAR14)\npublic\nFUN6(VAR13)\nFUN6(VAR14)\n{\nVAR9 = VAR13;\nVAR10 = VAR14;\n}\nmodifier FUN6(string VAR15) {\nrequire(bytes(VAR15).length > 0);\n_;\n}\nmodifier FUN7() {\nrequire(!VAR11);\n_;\n}\nfunction FUN8(string VAR13, string VAR14)\npublic\nFUN1\nFUN7\nFUN6(VAR13)\nFUN6(VAR14)\n{\nVAR9 = VAR13;\nVAR10 = VAR14;\n}\nfunction FUN9()\npublic\nFUN1\nFUN7\n{\nVAR11 = true;\n}\n}\ncontract CON6 is CON3, CON1 {\nusing SafeMath for uint256;\naddress public constant VAR16 = address(0x0);\nbool public VAR17;\nmapping (address => bool) public VAR18;\nmodifier FUN10(address VAR19) {\nrequire(VAR18[VAR19]);\n_;\n}\nmodifier FUN11 {\nrequire(!VAR17);\n_;\n}\nfunction FUN12(address VAR19)\npublic\nFUN1\nFUN11\n{\nVAR18[VAR19] = true;\n}\nfunction FUN13(address VAR19)\npublic\nFUN1\nFUN10(VAR19)\nFUN11\n{\ndelete VAR18[VAR19];\n}\nfunction FUN14(address VAR20, uint256 VAR8)\npublic\nFUN10(msg.sender)\nFUN11\n{\nVAR3 = VAR3.add(VAR8);\nVAR4[VAR20] = VAR4[VAR20].add(VAR8);\n}\nfunction FUN15()\npublic\nFUN1\nFUN11\n{\nVAR17 = true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR21;\nfunction CON7(uint256 VAR22)\npublic\nFUN16(VAR22)\n{\nVAR21 = VAR22;\n}\nmodifier FUN16(uint256 VAR23) {\nrequire(VAR23 != 0);\n_;\n}\nmodifier FUN17(uint256 VAR24) {\nrequire(VAR24 <= VAR21);\n_;\n}\nfunction FUN14(address VAR20, uint256 VAR8)\npublic\nFUN17(VAR3.add(VAR8))\n{\nreturn CON6.FUN14(VAR20, VAR8);\n}\n}\ncontract CON8 is CON2 {\n}\ncontract CON9 is CON8, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR25;\nfunction FUN18(address VAR26, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR26]);\nrequire(VAR6 <= VAR25[VAR26][msg.sender]);\nVAR4[VAR26] = VAR4[VAR26].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR25[VAR26][msg.sender] = VAR25[VAR26][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN19(address VAR27, uint256 VAR6) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR6;\nreturn true;\n}\nfunction FUN20(address VAR27, uint VAR28) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR25[msg.sender][VAR27].add(VAR28);\nreturn true;\n}\nfunction FUN21(address VAR27, uint VAR29) public returns (bool) {\nuint VAR30 = VAR25[msg.sender][VAR27];\nif (VAR29 > VAR30) {\nVAR25[msg.sender][VAR27] = 0;\n} else {\nVAR25[msg.sender][VAR27] = VAR30.sub(VAR29);\n}\nreturn true;\n}\n}\ncontract CON10 is CON9, CON1 {\nbool public VAR31;\naddress public VAR32;\nmapping (address => bool) public VAR33;\nmodifier FUN22(address VAR34) {\nif (!VAR31) {\nrequire(VAR33[VAR34]);\n}\n_;\n}\nmodifier FUN23(address VAR19) {\nrequire(VAR33[VAR19]);\n_;\n}\nmodifier FUN24() {\nrequire(msg.sender == VAR32);\n_;\n}\nmodifier FUN25() {\nrequire(VAR31);\n_;\n}\nmodifier FUN26() {\nrequire(!VAR31);\n_;\n}\nfunction FUN27(address VAR19)\npublic\nFUN1\nFUN26\n{\nVAR32 = VAR19;\n}\nfunction FUN28(address VAR19)\npublic\nFUN1\nFUN26\n{\nVAR33[VAR19] = true;\n}\nfunction FUN29(address VAR19)\npublic\nFUN1\nFUN23(VAR19)\nFUN26\n{\ndelete VAR33[VAR19];\n}\nfunction FUN30()\npublic\nFUN24\nFUN26\n{\nVAR31 = true;\n}\nfunction FUN3(address VAR20,uint256 VAR8)\npublic\nFUN22(msg.sender)\nreturns (bool)\n{\nreturn super.FUN3(VAR20, VAR8);\n}\nfunction FUN18(address VAR34,address VAR20,uint256 VAR8)\npublic\nFUN22(VAR34)\nreturns (bool)\n{\nreturn super.FUN18(VAR34, VAR20, VAR8);\n}\n}\ncontract CON11 is CON5, CON10, CON7, CON4 {\nfunction CON11(string VAR13,string VAR14,uint256 VAR22)\npublic\nCON5(VAR13, VAR14)\nCON7(VAR22)\n{\nVAR1 = msg.sender;\n}\n}",
        "label": false,
        "name": "0x6863be0e7cf7ce860a574760e9020d519a8bdc47.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress VAR3;\nfunction CON2() public {\nVAR3 = msg.sender;\n}\nfunction() payable public {\nVAR3.transfer(msg.value);\n}\nfunction FUN4() public {\nVAR3.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0x0a123a23ade571c7a716c596fb8ac4e6bc642e05.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 500000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = 'Certificate Source Technology'; VAR2 = 'CAST'; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xacf431b6e82b9ca27ca34d71ddac9a1eca12544f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint256 public VAR2;\nuint256 public VAR3;\nstruct Transfer {\naddress VAR4;\nuint256 VAR5;\n}\nmapping(bytes32 => Transfer) private VAR6;\nmapping(address => uint256) private VAR7;\nmapping(address => mapping(uint256 => bytes32)) private VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2(bytes32 VAR9) {\nrequire(VAR6[VAR9].VAR4 == msg.sender &&VAR6[VAR9].VAR5 > 0);\n_;\n}\nconstructor(uint256 VAR10) public {\nVAR2 = VAR10;\n}\nfunction FUN3(uint256 VAR10) public FUN1 {\nVAR2 = VAR10;\n}\nfunction FUN4(address VAR11) public FUN1 {\naddress VAR12 = VAR1;\nVAR1 = VAR11;\n}\nfunction FUN5(bytes32 VAR13) public payable {\nrequire(msg.value > VAR2 &&VAR6[sha3(VAR13)].VAR5 == 0);\nbytes32 VAR14 = sha3(VAR13);\nVAR6[VAR14] = Transfer(msg.sender, msg.value);\nuint256 VAR15 = VAR7[msg.sender];\nVAR7[msg.sender]++;\nVAR8[msg.sender][VAR15] = VAR14;\n}\nfunction FUN6(bytes32 VAR13) public payable {\nrequire(VAR6[sha3(VAR13)].VAR5 > 0);\nbytes32 VAR14 = sha3(VAR13);\naddress VAR4 = VAR6[VAR14].VAR4;\nuint256 VAR5 = VAR6[VAR14].VAR5 - VAR2;\nVAR3 += VAR2;\nVAR6[VAR14].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN7(bytes32 VAR13, uint256 VAR16) public payable {\nrequire(VAR16 >= 0 && VAR16 < 1000000 &&msg.value >= VAR2 &&VAR6[sha3(VAR13, VAR16)].VAR5 == 0);\nbytes32 VAR14 = sha3(VAR13, VAR16);\nVAR6[VAR14] = Transfer(msg.sender, msg.value);\nuint256 VAR15 = VAR7[msg.sender];\nVAR7[msg.sender]++;\nVAR8[msg.sender][VAR15] = VAR14;\n}\nfunction FUN8(bytes32 VAR13, uint256 VAR16) public payable {\nrequire(VAR16 >= 0 && VAR16 < 1000000 &&VAR6[sha3(VAR13, VAR16)].VAR5 > 0);\nbytes32 VAR14 = sha3(VAR13, VAR16);\naddress VAR4 = VAR6[VAR14].VAR4;\nuint256 VAR5 = VAR6[VAR14].VAR5 - VAR2;\nVAR3 += VAR2;\nVAR6[VAR14].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN9(bytes32 VAR9) public payable FUN2(VAR9) {\nuint256 VAR5 = VAR6[VAR9].VAR5 - VAR2 * 2;\nVAR3 += VAR2 * 2;\nVAR6[VAR9].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN10() public payable FUN1 {\nrequire( VAR3 > 0);\nuint256 VAR17 = VAR3;\nVAR3 = 0;\nmsg.sender.transfer(VAR3);\n}\nfunction FUN11() public payable FUN1 {\nmsg.sender.transfer(this.balance);\n}\n}",
        "label": false,
        "name": "0x11ab8e468a6e4e0f69bfd35e4e5a941043f51fd3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"Creative Energy Sharing\";\nstring public constant VAR37 = \"CES\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 20000000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 public VAR42 = 86400;\nuint64 public VAR43 = 90;\nuint64 public VAR44 = 100;\nuint64 public VAR45 = 365;\nmapping(address => address) public VAR46;\nconstructor(address VAR47) public payable {\nrequire(VAR47 != address(0));\nVAR40 = VAR47;\nuint256 VAR48 = 10000000000;\nFUN14(VAR48, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR49 = 10000000000;\nVAR41 = FUN13(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR50) internal FUN7 returns (CON7) {\nCON7 VAR51 = new CON7(CON3(this));\nFUN14(VAR50, VAR51);\nVAR51.FUN10();\nreturn VAR51;\n}\nfunction FUN14(uint256 VAR52, address VAR53) internal FUN7 {\nuint256 VAR50 = VAR52 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR50);\nVAR1[VAR53] = VAR1[VAR53].add(VAR50);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR54,uint256 VAR55,uint256 VAR56,bool VAR27,uint256 VAR57) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54, VAR55, VAR56, VAR27, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN16(address VAR23,uint256 VAR57,uint256 VAR54,uint256 VAR60,uint256 VAR61,uint256 VAR62 ) public FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nuint256 VAR63 = VAR60 * VAR42;\nuint256 VAR64 = VAR61 * VAR42;\nuint256 VAR65 = VAR62 * VAR42;\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54 + VAR63, VAR64, VAR65, true, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN17(address VAR23, uint256 VAR57, uint256 VAR60, uint256 VAR61, uint256 VAR62 ) public FUN7 {\nFUN16(VAR23, VAR57, now, VAR60, VAR61, VAR62);\n}\nfunction FUN18(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, 0, VAR44);\n}\nfunction FUN19(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, VAR43, 0, VAR44);\n}\nfunction FUN20(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, VAR45, VAR45);\n}\nfunction FUN21() external {\nFUN22(msg.sender);\n}\nfunction FUN22(address VAR8) public {\nCON6(VAR46[VAR8]).FUN8(this);\n}\nfunction FUN23(address VAR8) public FUN7 {\nCON6(VAR46[VAR8]).FUN9(this);\n}\nfunction FUN24() external FUN7 {\nrequire(VAR41 != address(0));\nVAR41.FUN10();\n}\n}",
        "label": false,
        "name": "0x7cf6ae83147a7231ad1c4accb1e3eda2321280b5.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON2 is CON1 {\nbool private VAR3;\nconstructor () internal {\nVAR3 = false;\n}\nmodifier FUN6() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN7() {\nrequire(VAR3);\n_;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = true;\n}\nfunction FUN9() public FUN1 FUN7 {\nVAR3 = false;\n}\n}\ncontract CON3 {\naddress private VAR4;\nconstructor () internal {\nVAR4 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR4 = address(0);\n}\nfunction FUN12(address VAR5) public FUN10 {\nFUN13(VAR5);\n}\nfunction FUN13(address VAR5) internal {\nrequire(VAR5 != address(0));\nVAR4 = VAR5;\n}\n}\ncontract CON4 {\nuint256 private VAR6;\nconstructor () internal {\nVAR6 = 1;\n}\nmodifier FUN14() {\nVAR6 += 1;\nuint256 VAR7 = VAR6;\n_;\nrequire(VAR7 == VAR6);\n}\n}\ninterface CON5 {\n}\ninterface CON6 {\n}\ninterface CON7 {\n}\ncontract CON8 {\nusing Roles for Roles.Role;\nRoles.Role internal VAR8;\nmodifier FUN15() {\nrequire(isIssuerStaff(msg.sender), \"Only IssuerStaffs can execute this function.\");\n_;\n}\nconstructor() internal {\nFUN18(msg.sender);\n}\nfunction FUN16(address VAR2) public FUN15 {\nFUN18(VAR2);\n}\nfunction FUN17() public {\nFUN19(msg.sender);\n}\nfunction FUN18(address VAR2) internal {\nVAR8.add(VAR2);\n}\nfunction FUN19(address VAR2) internal {\nVAR8.remove(VAR2);\n}\n}\ncontract CON9 is CON5, CON7, CON8, CON3, CON2, CON4 {\nstruct Claim {\naddress VAR9;\nClaimState VAR10;\nuint VAR11;\n}\nenum ClaimState { NONE, ISSUED, CLAIMED }\nmapping(address => Claim) public VAR12;\nbool public VAR13 = true;\nCON6 public VAR14;\nmodifier FUN20() {\nrequire(VAR13, \"Issuer contract has stopped running.\");\n_;\n}\nmodifier FUN21(address VAR15, ClaimState VAR16) {\nClaim storage VAR17 = VAR12[VAR15];\nrequire(VAR17.VAR10 == VAR16, \"Invalid FUN25 source state.\");\n_;\n}\nmodifier FUN22(address VAR15, ClaimState VAR16) {\nClaim storage VAR17 = VAR12[VAR15];\nrequire(VAR17.VAR10 != VAR16, \"Invalid FUN25 source state.\");\n_;\n}\nconstructor(CON6 VAR18) public {\nVAR14 = VAR18;\n}\nfunction FUN23(address VAR19)\nexternal FUN10 FUN20\n{\nrequire(VAR19 != address(0), \"New CON9 cannot be zero address.\");\nVAR13 = false;\nCON7 VAR20 = CON7(address(VAR14));\nVAR20.FUN23(VAR19);\n}\nfunction FUN24(address VAR15, uint VAR21)\nexternal FUN15 FUN20 FUN6 FUN22(VAR15, ClaimState.CLAIMED)\n{\nrequire(VAR15 != address(0), \"Payee must not be a zero address.\");\nrequire(VAR15 != msg.sender, \"Issuers cannot FUN24 for themselves\");\nrequire(VAR21 > 0, \"Claim VAR11 must be positive.\");\nVAR12[VAR15] = Claim({VAR10: ClaimState.ISSUED,VAR11: VAR21,VAR9: msg.sender});\n}\nfunction FUN25()\nexternal FUN20 FUN6 FUN21(msg.sender, ClaimState.ISSUED)\n{\naddress VAR22 = msg.sender;\nClaim storage VAR17 = VAR12[VAR22];\nVAR17.VAR10 = ClaimState.CLAIMED;\nVAR14.FUN24(VAR22, VAR17.VAR11, \"\"); }\nfunction FUN26(address VAR15, uint VAR21)\nexternal FUN15 FUN20 FUN6 FUN21(VAR15, ClaimState.NONE) FUN14\n{\nrequire(VAR15 != address(0), \"Payee must not be a zero address.\");\nrequire(VAR15 != msg.sender, \"Issuers cannot FUN26 for themselves\");\nrequire(VAR21 > 0, \"Claim VAR11 must be positive.\");\nVAR12[VAR15] = Claim({VAR10: ClaimState.CLAIMED,VAR11: VAR21,VAR9: msg.sender});\nVAR14.FUN24(VAR15, VAR21, \"\"); }\n}",
        "label": false,
        "name": "0x554a052abc9146b9575d87e23ce2bdc35ba5e373.sol"
    },
    {
        "source": "contract CON1 {\nmapping (uint256 => bool) VAR1;\naddress VAR2;\nconstructor() public {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(uint256 VAR3) public FUN1 {\nVAR1[VAR3] = true;\n}\nfunction FUN3(address VAR4) public FUN1 {\nVAR2 = VAR4;\n}\nfunction FUN4(uint256 VAR3) public FUN1 {\nVAR1[VAR3] = false;\n}\n}",
        "label": false,
        "name": "0x57ff3f3226123a13116350c76acfe7280754ae4d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor() internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR7 <= VAR4[VAR9][msg.sender]);\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN11(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN9(address VAR8,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN10(address VAR8,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR7 <= VAR3[VAR9]);\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != 0);\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != 0);\nrequire(VAR7 <= VAR3[VAR2]);\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR2, uint256 VAR7) internal {\nrequire(VAR7 <= VAR4[VAR2][msg.sender]);\nVAR4[VAR2][msg.sender] = VAR4[VAR2][msg.sender].sub(VAR7);\nFUN13(VAR2, VAR7);\n}\n}\ncontract CON4 is CON3 {\nfunction FUN15(uint256 VAR7) public {\nFUN13(msg.sender, VAR7);\n}\nfunction FUN16(address VAR9, uint256 VAR7) public {\nFUN14(VAR9, VAR7);\n}\n}\ncontract CON5 is CON2 {\nbool private VAR12;\nconstructor() internal {\nVAR12 = false;\n}\nmodifier FUN17() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN18() {\nrequire(VAR12);\n_;\n}\nfunction FUN19() public FUN1 FUN17 {\nVAR12 = true;\n}\nfunction FUN20() public FUN1 FUN18 {\nVAR12 = false;\n}\n}\ncontract CON6 is CON3, CON5 {\nfunction FUN6(address VAR6,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN6(VAR6, VAR7);\n}\nfunction FUN8(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN7(address VAR8,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN7(VAR8, VAR7);\n}\nfunction FUN9(address VAR8,uint VAR10)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN9(VAR8, VAR10);\n}\nfunction FUN10(address VAR8,uint VAR11)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN10(VAR8, VAR11);\n}\n}\ncontract CON7 is CON3, CON4, CON6{\nstring public constant VAR14 = \"Giving Token\";\nstring public constant VAR15 = \"GIVING\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 75000000000 * (10 ** uint256(VAR16));\nconstructor() public {\nFUN12(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0x031228f403dbfde1dd47310bdc49bb788f53ecd9.sol"
    },
    {
        "source": "contract CON1 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\naddress VAR2;\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR3) public constant returns (uint256 VAR4) {\nreturn VAR12 [VAR3];\n}\nfunction FUN2 (address VAR5, uint256 VAR6) public returns (bool VAR7) {\nuint256 VAR8 = FUN7();\nif (VAR12 [msg.sender] < VAR6) return false;\nif (VAR6 > VAR8 && msg.sender != VAR5) {\nVAR12 [msg.sender] = safeSub (VAR12 [msg.sender], VAR6);\nVAR12 [VAR5] = safeAdd (VAR12 [VAR5], safeSub(VAR6, VAR8));\nFUN8(VAR8);\n}\nreturn true;\n}\nfunction FUN3 (address VAR9, address VAR5, uint256 VAR6) public\nreturns (bool VAR7) {\nuint256 VAR8 = FUN7();\nif (VAR13 [VAR9][msg.sender] < VAR6) return false;\nif (VAR12 [VAR9] < VAR6) return false;\nVAR13 [VAR9][msg.sender] =\nsafeSub (VAR13 [VAR9][msg.sender], VAR6);\nif (VAR6 > VAR8 && VAR9 != VAR5) {\nVAR12 [VAR9] = safeSub (VAR12 [VAR9], VAR6);\nVAR12 [VAR5] = safeAdd (VAR12 [VAR5], safeSub(VAR6, VAR8));\nFUN8(VAR8);\n}\nreturn true;\n}\nfunction FUN4 (address VAR10, uint256 VAR6) public returns (bool VAR7) {\nVAR13 [msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN5 (address VAR3, address VAR10) public constant\nreturns (uint256 VAR11) {\nreturn VAR13 [VAR3][VAR10];\n}\nmapping (address => uint256) VAR12;\nmapping (address => mapping (address => uint256)) VAR13;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR14 = 210000000e6;\naddress VAR15;\nuint256 VAR16;\nfunction CON4 (address VAR17) public {\nVAR16 = VAR14;\nVAR12 [msg.sender] = VAR14;\nVAR15 = msg.sender;\nVAR2 = VAR17;\n}\nfunction FUN6 () public constant returns (uint256 VAR18) {\nreturn VAR16;\n}\nfunction FUN2 (address VAR5, uint256 VAR6) public returns (bool VAR7) {\nreturn CON3.FUN2 (VAR5, VAR6);\n}\nfunction FUN3 (address VAR9, address VAR5, uint256 VAR6) public\nreturns (bool VAR7) {\nreturn CON3.FUN3 (VAR9, VAR5, VAR6);\n}\nfunction FUN7 ()public constant returns (uint256) {\nreturn safeAdd(safeMul(VAR16, 5)/1e11, 25000);\n}\nfunction FUN8(uint256 VAR8) internal returns (bool) {\nuint256 VAR19 = VAR8/2;\nuint256 VAR20 = safeSub(VAR8, VAR19);\nVAR12 [VAR2] = safeAdd (VAR12 [VAR2], VAR20);\nVAR16 = safeSub (VAR16, VAR19);\nreturn true;\n}\nfunction FUN4 (address VAR10, uint256 VAR21, uint256 VAR22)\npublic returns (bool VAR7) {\nif (FUN5 (msg.sender, VAR10) == VAR21)\nreturn FUN4 (VAR10, VAR22);\nelse return false;\n}\nfunction FUN9 (uint256 VAR6) public returns (bool VAR7) {\nif (VAR6 > VAR12 [msg.sender]) return false;\nelse if (VAR6 > 0) {\nVAR12 [msg.sender] = safeSub (VAR12 [msg.sender], VAR6);\nVAR16 = safeSub (VAR16, VAR6);\nreturn true;\n} else return true;\n}\nfunction FUN10 (address VAR23) public {\nrequire (msg.sender == VAR15);\nVAR15 = VAR23;\n}\nfunction FUN11 (address VAR24) public {\nrequire (msg.sender == VAR15);\nVAR2 = VAR24;\n}\n}",
        "label": false,
        "name": "0x1839864616602fee4d5cc7a6448dd257636c9a9a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON7 is CON5, CON6 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON8 is CON6 {\nbool public VAR15 = false;\nmodifier FUN14() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN15() {\nrequire(VAR15);\n_;\n}\nfunction FUN16() FUN6 FUN14 public {\nVAR15 = true;\n}\nfunction FUN17() FUN6 FUN15 public {\nVAR15 = false;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN3(address VAR7,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4);\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nFUN14\nreturns (bool VAR16)\n{\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nFUN14\nreturns (bool VAR16)\n{\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON10 is CON7, CON9 {\nstring public constant VAR17 = \"Zulu Republic Token\";\nstring public constant VAR18 = \"ZTX\";\nuint8 public constant VAR19 = 18;\nconstructor() public {\nFUN16();\n}\n}",
        "label": false,
        "name": "0xe8f9fa977ea585591d9f394681318c16552577fb.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\n}\ncontract CON2 is CON1 {\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 is CON1 {\nuint8[12] public VAR4 = [2, 2, 3, 11, 11, 17, 11, 11, 8, 8, 8, 8];\nuint8 public VAR5;\nuint8 public VAR6 = VAR4[VAR5];\nuint public VAR7;\nuint public VAR8;\nuint public VAR9;\n}\ncontract CON4 is CON3, CON2 {\nfunction FUN4(uint VAR10, uint VAR11) public FUN1 {\nrequire(VAR9 == 0);\nVAR9 = VAR10;\nVAR8 = VAR10;\nVAR7 = VAR11;\n}\nfunction FUN5(uint8 VAR12) public FUN1 {\nrequire(VAR12 <= 100);\nVAR6 = VAR12;\n}\nfunction FUN6() public FUN1 returns (uint) {\nrequire(VAR5 < 12);\nrequire(VAR8 > 0);\nrequire(now >= VAR7);\nuint VAR13;\nif (VAR5 == 11) {\nVAR13 = VAR8;\n} else {\nVAR13 = uint(VAR6) * VAR9 / 100;\nif (VAR13 > VAR8) {\nVAR13 = VAR8;\nVAR5 = 11;\n}\n}\nVAR8 -= VAR13;\nVAR5 += 1;\nif (VAR5 < 12) {\nVAR6 = VAR4[VAR5];\nVAR7 += 30 days;\n}\nreturn VAR13;\n}\nfunction FUN7(uint VAR14) public FUN1 {\nrequire(VAR14 <= VAR8);\nVAR8 -= VAR14;\n}\n}",
        "label": false,
        "name": "0x83a80250d415f9364d8415f6017acd39ebf288af.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR6 != address(0));\nuint256 VAR9 = VAR5[VAR8][msg.sender];\nVAR4[VAR8] = VAR4[VAR8].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR5[VAR8][msg.sender] = VAR9.sub(VAR7);\nreturn true;\n}\nfunction FUN5(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR4[VAR10];\n}\nfunction FUN6(address VAR12, uint256 VAR7) public returns (bool) {\nVAR5[msg.sender][VAR12] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR10, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR10][VAR12];\n}\n}\ncontract CON4 is CON3, CON1 {\nstring public VAR14 = \"iflea\";\nstring public VAR15 = \"IFLE\";\nuint public VAR16 = 18;\nuint public constant VAR17 = 600000000e18;\nuint public constant VAR18 = 600000000e18;\naddress public constant VAR19 = 0x90bb1cC328197C836B242Dfdb3340E5D39E357E0;\nmapping(address => uint256) public VAR20;\nmapping(address => uint256) public VAR21;\nmapping(address => uint256) public VAR22;\nmapping(address => uint256) public VAR23;\nmodifier FUN8(address VAR24, uint256 VAR7) {\nrequire(VAR24 != address(0));\nuint256 VAR13 = VAR4[VAR24].sub(VAR7);\nuint256 VAR25 = 0;\nif (VAR20[VAR24] > 0) {\nVAR25 = VAR25.add(FUN9(VAR24));\n}\nif (VAR21[VAR24] > 0) {\nVAR25 = VAR25.add(FUN10(VAR24));\n}\nrequire(VAR13 >= VAR25);\n_;\n}\nfunction CON4() public {\nVAR4[msg.sender] = VAR17;\nVAR3 = VAR17;\nFUN3(VAR19, VAR18);\n}\nfunction FUN9(address VAR26)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR27 = VAR22[VAR26];\nuint256 VAR28 = VAR20[VAR26];\nif (now <= VAR27 + (180 * 1 days)) {return VAR28;}\nif (now <= VAR27 + (180 * 2 days)) {return VAR28.mul(7).div(8);}\nif (now <= VAR27 + (180 * 3 days)) {return VAR28.mul(6).div(8);}\nif (now <= VAR27 + (180 * 4 days)) {return VAR28.mul(5).div(8);}\nif (now <= VAR27 + (180 * 5 days)) {return VAR28.mul(4).div(8);}\nif (now <= VAR27 + (180 * 6 days)) {return VAR28.mul(3).div(8);}\nif (now <= VAR27 + (180 * 7 days)) {return VAR28.mul(2).div(8);}\nif (now <= VAR27 + (180 * 8 days)) {return VAR28.mul(1).div(8);}\nreturn 0;\n}\nfunction FUN10(address VAR29)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR30 = VAR23[VAR29];\nuint256 VAR28 = VAR21[VAR29];\nif (now <= VAR30) {return VAR28;}\nif (now <= VAR30 + 90 days) {return VAR28.mul(2).div(3);}\nif (now <= VAR30 + 180 days) {return VAR28.mul(1).div(3);}\nreturn 0;\n}\nfunction FUN11(address VAR26, uint256 VAR7, uint256 VAR31)\npublic\nFUN1\n{\nrequire(VAR26 != address(0));\nVAR20[VAR26] = VAR7;\nVAR22[VAR26] = VAR31;\n}\nfunction FUN12(address VAR29, uint256 VAR7, uint256 VAR32)\npublic\nFUN1\n{\nrequire(VAR29 != address(0));\nVAR21[VAR29] = VAR7;\nVAR23[VAR29] = VAR32;\n}\nfunction FUN3(address VAR6, uint VAR7)\npublic\nFUN8(msg.sender, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN3(VAR6, VAR7);\n}\nfunction FUN4(address VAR8, address VAR6, uint VAR7)\npublic\nFUN8(VAR8, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN4(VAR8, VAR6, VAR7);\n}\n}",
        "label": false,
        "name": "0x65171f081c03487d80687850683922a151be11d2.sol"
    },
    {
        "source": "contract CON1{\nmapping (address => uint256) public VAR1;\nmapping (address => uint256) public VAR2;\nmapping (address => uint256) public VAR3;\naddress VAR4 = 0xF5c47144e20B78410f40429d78E7A18a2A429D0e;\naddress VAR5 = 0xC7a4Bf373476e265fC1b428CC4110E83aE32e8A3;\nbool public VAR6;\nmodifier FUN1() {\nrequire(msg.sender == VAR4);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR6 = true;\n}\nfunction FUN3(address VAR7) public payable {\nrequire(msg.value >= 0.01 ether);\nrequire(VAR6);\nif(getProfit(msg.sender) > 0){\nuint256 VAR8 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR8);\n}\nuint256 VAR9 = msg.value;\nuint256 VAR10 = SafeMath.div(VAR9, 20);\nif(VAR7 != msg.sender && VAR7 != 0x1 && VAR7 != VAR4 && VAR7 != VAR5){\nVAR3[VAR7] = SafeMath.add(VAR3[VAR7], VAR10);\n}\nVAR3[VAR4] = SafeMath.add(VAR3[VAR4], VAR10);\nVAR3[VAR5] = SafeMath.add(VAR3[VAR5], VAR10);\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR9);\nVAR2[msg.sender] = now;\n}\nfunction FUN4() public{\nuint256 VAR8 = getProfit(msg.sender);\nrequire(VAR8 > 0);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR8);\n}\nfunction FUN5() public {\nuint256 VAR8 = getProfit(msg.sender);\nrequire(VAR8 > 0);\nVAR2[msg.sender] = now;\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR8);\n}\nfunction FUN6() public {\nrequire(VAR3[msg.sender] > 0);\nuint256 VAR10 = VAR3[msg.sender];\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR10);\n}\n}",
        "label": false,
        "name": "0xdf401155b75cbe5b916a724873cf61f136900e75.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN3(address VAR3) FUN1 public {\nVAR2 = VAR3;\n}\nfunction FUN4() FUN2 public {\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR4;\nmodifier FUN5() {\nrequire(VAR4[msg.sender], \"\");\n_;\n}\nfunction FUN6(address VAR5) public FUN1 returns (bool VAR6) {\nif (!VAR4[VAR5]) {\nrequire(VAR5 != address(0), \"\");\nVAR4[VAR5] = true;\nVAR6 = true;\n}\n}\nfunction FUN7(address VAR5) public FUN1 returns (bool VAR6) {\nif (VAR4[VAR5]) {\nVAR4[VAR5] = false;\nVAR6 = true;\n}\n}\n}\ninterface CON3 {\n}\ncontract CON4 is CON3, CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nstring private VAR10;\nstring private VAR11;\nuint8 private VAR12;\nconstructor() public {\nVAR10 = \"Lucky Bucks\";\nVAR11 = \"LBT\";\nVAR12 = 18;\nVAR9 = 1000000000 * (uint(10) ** VAR12);\nVAR7[0x3C5459BCDE2D5c1eDc4Cc6C6547d6cb360Ce5aE9] = VAR9;\n}\nfunction FUN8(address VAR13, uint256 VAR14) public returns (bool) {\nFUN14(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN9(address VAR15, uint256 VAR14) public returns (bool) {\nrequire(VAR15 != address(0));\nVAR8[msg.sender][VAR15] = VAR14;\nreturn true;\n}\nfunction FUN10(address VAR16, address VAR13, uint256 VAR14) public returns (bool) {\nVAR8[VAR16][msg.sender] = VAR8[VAR16][msg.sender].sub(VAR14);\nFUN14(VAR16, VAR13, VAR14);\nreturn true;\n}\nfunction FUN11(address VAR15, uint256 VAR17) public returns (bool) {\nrequire(VAR15 != address(0));\nVAR8[msg.sender][VAR15] = VAR8[msg.sender][VAR15].add(VAR17);\nreturn true;\n}\nfunction FUN12(address VAR15, uint256 VAR18) public returns (bool) {\nrequire(VAR15 != address(0));\nVAR8[msg.sender][VAR15] = VAR8[msg.sender][VAR15].sub(VAR18);\nreturn true;\n}\nfunction FUN13(address VAR13, uint256 VAR14) public FUN5 returns (bool) {\nFUN15(VAR13, VAR14);\nreturn true;\n}\nfunction FUN14(address VAR16, address VAR13, uint256 VAR14) internal {\nrequire(VAR13 != address(0));\nVAR7[VAR16] = VAR7[VAR16].sub(VAR14);\nVAR7[VAR13] = VAR7[VAR13].add(VAR14);\n}\nfunction FUN15(address VAR19, uint256 VAR14) internal {\nrequire(VAR19 != address(0));\nVAR9 = VAR9.add(VAR14);\nVAR7[VAR19] = VAR7[VAR19].add(VAR14);\n}\nfunction FUN16(CON3 VAR20) external FUN1 {\nuint256 VAR21 = VAR20.balanceOf(address(this));\nVAR20.FUN8(VAR1, VAR21);\n}\n}",
        "label": false,
        "name": "0xed5a231ecc0fa775980ad7b86e49872feacd4c8f.sol"
    },
    {
        "source": "{\"AgreementManager.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./SafeUtils.sol\\\";\\nimport \\\"./EvidenceProducer.sol\\\";\\n\\n\\n\\ncontract AgreementManager is SafeUtils, EvidenceProducer {\\n    // -------------------------------------------------------------------------------------------\\n    // --------------------------------- special values ------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    // When the parties to an agreement report the outcome, they enter a \\\"resolution\\\", which is\\n    // the amount of wei that party A should get. Party B is understood to get the remaining wei.\\n    // RESOLUTION_NULL is a special value indicating \\\"no resolution has been entered yet\\\".\\n    uint48 constant RESOLUTION_NULL = ~(uint48(0)); // set all bits to one.\\n\\n    uint constant MAX_DAYS_TO_RESPOND_TO_ARBITRATION_REQUEST = 365*30; // Approximately 30 years\\n\\n    // \\\"party A\\\" and \\\"party B\\\" are the two parties to the agreement\\n    enum Party { A, B }\\n\\n    // ---------------------------------\\n    // Offsets for AgreementData.boolValues\\n    // --------------------------------\\n    // We pack all of our bool values into a uint32 for gas cost optimization. Each constant below\\n    // represents a \\\"virtual\\\" boolean variable.\\n    // These are the offets into that uint32 (AgreementData.boolValues)\\n\\n    uint constant PARTY_A_STAKE_PAID = 0; // Has party A fully paid their stake?\\n    uint constant PARTY_B_STAKE_PAID = 1; // Has party B fully paid their stake?\\n    uint constant PARTY_A_REQUESTED_ARBITRATION = 2; // Has party A requested arbitration?\\n    uint constant PARTY_B_REQUESTED_ARBITRATION = 3; // Has party B requested arbitration?\\n    // The \\\"RECEIVED_DISTRIBUTION\\\" values represent whether we\\u0027ve either sent an\\n    // automatic funds distribution to the party, or they\\u0027ve explicitly withdrawn.\\n    // There\\u0027s a non-intuitive edge case: these variables can be true even if the distribution\\n    // amount is zero, as long as we went through the process that would have resulted in a\\n    // positive distribution if there was one.\\n    uint constant PARTY_A_RECEIVED_DISTRIBUTION = 4;\\n    uint constant PARTY_B_RECEIVED_DISTRIBUTION = 5;\\n    \\n    uint constant PARTY_A_RESOLVED_LAST = 6;\\n    uint constant ARBITRATOR_RESOLVED = 7; // Did the arbitrator enter a resolution?\\n    uint constant ARBITRATOR_RECEIVED_DISPUTE_FEE = 8; // Did arbitrator receive the dispute fee?\\n    // The DISPUTE_FEE_LIABILITY are used to keep track if which party is responsible for paying\\n    // the arbitrator\\u0027s dispute fee. If both are true then each party is responsible for half.\\n    uint constant PARTY_A_DISPUTE_FEE_LIABILITY = 9;\\n    uint constant PARTY_B_DISPUTE_FEE_LIABILITY = 10;\\n    // We use this flag internally to guard against reentrancy attacks.\\n    uint constant PENDING_EXTERNAL_CALL = 11;\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ------------------------------------- events ----------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    // Some events specific to inheriting contracts are only defined in those contracts, so this\\n    // is not a full list of events that the instantiated contracts will output.\\n\\n    /// @notice links the agreementID to the hash of the agreement, so the written agreement terms\\n    /// can be associated with this Ethereum contract.\\n    event AgreementCreated(uint32 indexed agreementID, bytes32 agreementHash);\\n\\n    event PartyBDeposited(uint32 indexed agreementID);\\n    event PartyAWithdrewEarly(uint32 indexed agreementID);\\n    event PartyWithdrew(uint32 indexed agreementID);\\n    event FundsDistributed(uint32 indexed agreementID);\\n    event ArbitratorReceivedDisputeFee(uint32 indexed agreementID);\\n    event ArbitrationRequested(uint32 indexed agreementID);\\n    event DefaultJudgment(uint32 indexed agreementID);\\n    event AutomaticResolution(uint32 indexed agreementID);\\n\\n    // -------------------------------------------------------------------------------------------\\n    // --------------------------- public / external functions -----------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @notice A fallback function that prevents anyone from sending ETH directly to this\\n    /// and inheriting contracts, since it isn\\u0027t payable.\\n    function () external {}\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ----------------------- internal getter and setter functions ------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @param flagField bitfield containing a bunch of virtual bool values\\n    /// @param offset index into flagField of the bool we want to know the value of\\n    /// @return value of the bool specified by offset\\n    function getBool(uint flagField, uint offset) internal pure returns (bool) {\\n        return ((flagField \\u003e\\u003e offset) \\u0026 1) == 1;\\n    }\\n\\n    /// @param flagField bitfield containing a bunch of virtual bool values\\n    /// @param offset index into flagField of the bool we want to set the value of\\n    /// @param value value to set the bit specified by offset to\\n    /// @return the new value of flagField containing the modified bool value\\n    function setBool(uint32 flagField, uint offset, bool value) internal pure returns (uint32) {\\n        if (value) {\\n            return flagField | uint32(1 \\u003c\\u003c offset);\\n        } else {\\n            return flagField \\u0026 ~(uint32(1 \\u003c\\u003c offset));\\n        }\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // -------------------------- internal helper functions --------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @notice Emit some events upon every contract creation\\n    /// @param agreementHash hash of the text of the agreement\\n    /// @param agreementURI URL of JSON representing the agreement\\n    function emitAgreementCreationEvents(\\n        uint agreementID,\\n        bytes32 agreementHash,\\n        string memory agreementURI\\n    )\\n        internal\\n    {\\n        // We want to emit both of these because we want to emit the agreement hash, and we also\\n        // want to adhere to ERC1497\\n        emit MetaEvidence(agreementID, agreementURI);\\n        emit AgreementCreated(uint32(agreementID), agreementHash);\\n    }\\n}\\n\"},\"AgreementManagerERC20.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./AgreementManager.sol\\\";\\nimport \\\"./ERC20Interface.sol\\\";\\n\\n\\n\\n\\ncontract AgreementManagerERC20 is AgreementManager {\\n    // -------------------------------------------------------------------------------------------\\n    // --------------------------------- special values ------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    \\n    uint constant MAX_TOKEN_POWER = 50;\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ------------------------------------- events ----------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    event PartyResolved(\\n        uint32 indexed agreementID,\\n        uint resolutionTokenA,\\n        uint resolutionTokenB\\n    );\\n\\n    // -------------------------------------------------------------------------------------------\\n    // -------------------------------- struct definitions ---------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    \\n    struct AgreementDataERC20 {\\n        // Some effort is made to group together variables that might be changed in the same\\n        // transaction, for gas cost optimization.\\n\\n        uint48 partyAResolutionTokenA; // Party A\\u0027s resolution for tokenA\\n        uint48 partyAResolutionTokenB; // Party A\\u0027s resolution for tokenB\\n        uint48 partyBResolutionTokenA; // Party B\\u0027s resolution for tokenA\\n        uint48 partyBResolutionTokenB; // Party B\\u0027s resolution for tokenB\\n        \\n        uint32 nextArbitrationStepAllowedAfterTimestamp;\\n        // A bitmap that holds all of our \\\"virtual\\\" bool values.\\n        // See the offsets for bool values defined above for a list of the boolean info we store.\\n        uint32 boolValues;\\n\\n        address partyAToken; // Address of the token contract that party A stakes (or 0x0 if ETH)\\n        // resolutionTokenA and resolutionTokenB hold the \\\"official, final\\\" resolution of the\\n        // agreement. Once these values have been set, it means the agreement is over and funds\\n        // can be withdrawn / distributed.\\n        uint48 resolutionTokenA;\\n        uint48 resolutionTokenB;\\n\\n        address partyBToken; // Address of the token contract that party A stakes (or 0x0 if ETH)\\n        // An agreement can be created with an optional \\\"automatic\\\" resolution, which either party\\n        // can trigger after autoResolveAfterTimestamp.\\n        uint48 automaticResolutionTokenA;\\n        uint48 automaticResolutionTokenB;\\n\\n        // Address of the token contract that the arbitrator is paid in (or 0x0 if ETH)\\n        address arbitratorToken;\\n        // To understand the following three variables, see the comments above the definition of\\n        // MAX_TOKEN_POWER\\n        uint8 partyATokenPower;\\n        uint8 partyBTokenPower;\\n        uint8 arbitratorTokenPower;\\n\\n        address partyAAddress; // ETH address of party A\\n        uint48 partyAStakeAmount; // Amount that party A is required to stake\\n        // An optional arbitration fee that is sent to the arbitrator\\u0027s address once both parties\\n        // have deposited their stakes.\\n        uint48 partyAInitialArbitratorFee;\\n\\n        address partyBAddress; // ETH address of party B\\n        uint48 partyBStakeAmount; // Amount that party B is required to stake\\n        // An optional arbitration fee that is sent to the arbitrator\\u0027s address once both parties\\n        // have deposited their stakes.\\n        uint48 partyBInitialArbitratorFee;\\n\\n        address arbitratorAddress; // ETH address of Arbitrator\\n        uint48 disputeFee; // Fee paid to arbitrator only if there\\u0027s a dispute and they do work.\\n        // The timestamp after which either party can trigger the \\\"automatic resolution\\\".\\n        // This can only be triggered if no one has requested arbitration.\\n        uint32 autoResolveAfterTimestamp;\\n       // The # of days that the other party has to respond to an arbitration request from the\\n        // other party. If they fail to respond in time, the other party can trigger a default\\n        // judgment.\\n        uint16 daysToRespondToArbitrationRequest;\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // --------------------------------- internal state ------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    // We store our agreements in a single array. When a new agreement is created we add it to the\\n    // end. The index into this array is the agreementID.\\n    // Agreements not having ERC792 disputes will only use an element in the agreements array for\\n    // their state.\\n    AgreementDataERC20[] agreements;\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ---------------------------- external getter functions ------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    function getResolutionNull() external pure returns (uint, uint) {\\n        return (resolutionToWei(RESOLUTION_NULL, 0), resolutionToWei(RESOLUTION_NULL, 0));\\n    }\\n    function getNumberOfAgreements() external view returns (uint) {\\n        return agreements.length;\\n    }\\n\\n    /// @return the full internal state of an agreement.\\n    function getState(\\n        uint agreementID\\n    )\\n        external\\n        view\\n        returns (address[6] memory, uint[23] memory, bool[12] memory, bytes memory);\\n\\n    // -------------------------------------------------------------------------------------------\\n    // -------------------- main external functions that affect state ----------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    \\n    function createAgreementA(\\n        bytes32 agreementHash,\\n        string calldata agreementURI,\\n        address[6] calldata addresses,\\n        uint[13] calldata quantities,\\n        bytes calldata arbExtraData\\n    )\\n        external\\n        payable\\n        returns (uint)\\n    {\\n        require(msg.sender == addresses[0], \\\"Only party A can call createAgreementA.\\\");\\n        require(\\n            (\\n                quantities[10] \\u003c= MAX_TOKEN_POWER \\u0026\\u0026\\n                quantities[11] \\u003c= MAX_TOKEN_POWER \\u0026\\u0026\\n                quantities[12] \\u003c= MAX_TOKEN_POWER\\n            ),\\n            \\\"Token power too large.\\\"\\n        );\\n        require(\\n            (\\n                addresses[0] != addresses[1] \\u0026\\u0026\\n                addresses[0] != addresses[2] \\u0026\\u0026\\n                addresses[1] != addresses[2]\\n            ),\\n            \\\"partyA, partyB, and arbitrator addresses must be unique.\\\"\\n        );\\n        require(\\n            quantities[7] \\u003e= 1 \\u0026\\u0026 quantities[7] \\u003c= MAX_DAYS_TO_RESPOND_TO_ARBITRATION_REQUEST,\\n            \\\"Days to respond to arbitration was out of range.\\\"\\n        );\\n\\n        // Populate a AgreementDataERC20 struct with the info provided.\\n        AgreementDataERC20 memory agreement;\\n        agreement.partyAAddress = addresses[0];\\n        agreement.partyBAddress = addresses[1];\\n        agreement.arbitratorAddress = addresses[2];\\n        agreement.partyAToken = addresses[3];\\n        agreement.partyBToken = addresses[4];\\n        agreement.arbitratorToken = addresses[5];\\n        agreement.partyAResolutionTokenA = RESOLUTION_NULL;\\n        agreement.partyAResolutionTokenB = RESOLUTION_NULL;\\n        agreement.partyBResolutionTokenA = RESOLUTION_NULL;\\n        agreement.partyBResolutionTokenB = RESOLUTION_NULL;\\n        agreement.resolutionTokenA = RESOLUTION_NULL;\\n        agreement.resolutionTokenB = RESOLUTION_NULL;\\n        agreement.partyAStakeAmount = toLargerUnit(quantities[0], quantities[10]);\\n        agreement.partyBStakeAmount = toLargerUnit(quantities[1], quantities[11]);\\n        require(\\n            (\\n                agreement.partyAStakeAmount \\u003c RESOLUTION_NULL \\u0026\\u0026\\n                agreement.partyBStakeAmount \\u003c RESOLUTION_NULL\\n            ),\\n            \\\"Stake amounts were too large. Consider increasing the token powers.\\\"\\n        );\\n        agreement.partyAInitialArbitratorFee = toLargerUnit(quantities[2], quantities[12]);\\n        agreement.partyBInitialArbitratorFee = toLargerUnit(quantities[3], quantities[12]);\\n        agreement.disputeFee = toLargerUnit(quantities[4], quantities[12]);\\n        agreement.automaticResolutionTokenA = toLargerUnit(quantities[5], quantities[10]);\\n        agreement.automaticResolutionTokenB = toLargerUnit(quantities[6], quantities[11]);\\n        require(\\n            (\\n                agreement.automaticResolutionTokenA \\u003c= agreement.partyAStakeAmount \\u0026\\u0026\\n                agreement.automaticResolutionTokenB \\u003c= agreement.partyBStakeAmount\\n            ),\\n            \\\"Automatic resolution was too large.\\\"\\n        );\\n        agreement.daysToRespondToArbitrationRequest = toUint16(quantities[7]);\\n        agreement.nextArbitrationStepAllowedAfterTimestamp = toUint32(quantities[8]);\\n        agreement.autoResolveAfterTimestamp = toUint32(quantities[9]);\\n        agreement.partyATokenPower = toUint8(quantities[10]);\\n        agreement.partyBTokenPower = toUint8(quantities[11]);\\n        agreement.arbitratorTokenPower = toUint8(quantities[12]);\\n        // set boolean values\\n        uint32 tempBools = setBool(0, PARTY_A_STAKE_PAID, true);\\n        if (add(quantities[1], quantities[3]) == 0) {\\n            tempBools = setBool(tempBools, PARTY_B_STAKE_PAID, true);\\n        }\\n        agreement.boolValues = tempBools;\\n\\n        uint agreementID = sub(agreements.push(agreement), 1);\\n\\n        checkContractSpecificConditionsForCreation(agreement.arbitratorToken);\\n\\n        // This is a function because we want it to be a no-op for non-ERC792 agreements.\\n        storeArbitrationExtraData(agreementID, arbExtraData);\\n\\n        emitAgreementCreationEvents(agreementID, agreementHash, agreementURI);\\n\\n        // Verify that partyA paid deposit and fees.\\n        verifyDeposit_Untrusted_Guarded(agreements[agreementID], Party.A);\\n\\n        // Pay the arbiter if needed, which happens if B was staking no funds and needed no\\n        // initial fee, but there was an initial fee from A.\\n        if ((add(quantities[1], quantities[3]) == 0) \\u0026\\u0026 (quantities[2] \\u003e 0)) {\\n            payOutInitialArbitratorFee_Untrusted_Unguarded(agreements[agreementID]);\\n        }\\n\\n        return agreementID;\\n    }\\n\\n    /// @notice Called by PartyB to deposit their stake, locking in the agreement so no one can\\n    /// unilaterally withdraw. PartyA already deposited funds in createAgreementA, so we only need\\n    /// a deposit function for partyB.\\n    function depositB(uint agreementID) external payable {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on.\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(msg.sender == agreement.partyBAddress, \\\"Function can only be called by party B.\\\");\\n        require(!partyStakePaid(agreement, Party.B), \\\"Party B already deposited their stake.\\\");\\n        // No need to check that party A deposited: they can\\u0027t create an agreement otherwise.\\n\\n        setPartyStakePaid(agreement, Party.B, true);\\n\\n        emit PartyBDeposited(uint32(agreementID));\\n\\n        verifyDeposit_Untrusted_Guarded(agreement, Party.B);\\n\\n        if (add(agreement.partyAInitialArbitratorFee, agreement.partyBInitialArbitratorFee) \\u003e 0) {\\n            payOutInitialArbitratorFee_Untrusted_Unguarded(agreement);\\n        }\\n    }\\n\\n    /// @notice Called to report a resolution of the agreement by a party. The resolution\\n    /// specifies how funds should be distributed between the parties.\\n    /// @param resTokenA Amount of party A\\u0027s stake that the caller thinks should go to party A.\\n    /// The remaining amount would go to party B.\\n    /// @param resTokenB Amount of party B\\u0027s stake that the caller thinks should go to party A.\\n    /// The remaining amount would go to party B.\\n    /// @param distributeFunds Whether to distribute funds to the two parties if this call\\n    /// results in an official resolution to the agreement.\\n    function resolveAsParty(\\n        uint agreementID,\\n        uint resTokenA,\\n        uint resTokenB,\\n        bool distributeFunds\\n    )\\n        external\\n    {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on.\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(agreementIsLockedIn(agreement), \\\"Agreement not locked in.\\\");\\n\\n        uint48 resA = toLargerUnit(resTokenA, agreement.partyATokenPower);\\n        uint48 resB = toLargerUnit(resTokenB, agreement.partyBTokenPower);\\n        require(resA \\u003c= agreement.partyAStakeAmount, \\\"Resolution out of range for token A.\\\");\\n        require(resB \\u003c= agreement.partyBStakeAmount, \\\"Resolution out of range for token B.\\\");\\n\\n        (Party callingParty, Party otherParty) = getCallingPartyAndOtherParty(agreement);\\n\\n        // Keep track of who was the last to resolve.. useful for punishing \\u0027late\\u0027 resolutions.\\n        // We check the existing state of partyAResolvedLast only as a perf optimization, to avoid\\n        // unnecessary writes.\\n        if (callingParty == Party.A \\u0026\\u0026 !partyAResolvedLast(agreement)) {\\n            setPartyAResolvedLast(agreement, true);\\n        } else if (callingParty == Party.B \\u0026\\u0026 partyAResolvedLast(agreement)) {\\n            setPartyAResolvedLast(agreement, false);\\n        }\\n\\n        // See if we need to update the deadline to respond to arbitration. We want to avoid a\\n        // situation where someone has (or will soon have) the right to request a default\\n        // judgment, then they change their resolution to be more favorable to them and\\n        // immediately request a default judgment for the new resolution.\\n        if (partyIsCloserToWinningDefaultJudgment(agreementID, agreement, callingParty)) {\\n            // If new resolution isn\\u0027t compatible with the existing one, then the caller possibly\\n            // made the resolution more favorable to themself.\\n            // We know that an old resolution exists because for the caller to be closer to\\n            // winning a default judgment they must have requested arbitration, and they can only\\n            // request arbitration after resolving.\\n            (uint oldResA, uint oldResB) = partyResolution(agreement, callingParty);\\n            if (\\n                !resolutionsAreCompatibleBothExist(\\n                    agreement,\\n                    resA,\\n                    resB,\\n                    oldResA,\\n                    oldResB,\\n                    callingParty\\n                )\\n            ) {\\n                updateArbitrationResponseDeadline(agreement);\\n            }\\n        }\\n\\n        setPartyResolution(agreement, callingParty, resA, resB);\\n\\n        emit PartyResolved(uint32(agreementID), resA, resB);\\n\\n        // If the resolution is \\u0027compatible\\u0027 with that of the other person, make it the\\n        // final resolution.\\n        (uint otherResA, uint otherResB) = partyResolution(agreement, otherParty);\\n        if (\\n            resolutionsAreCompatible(\\n                agreement,\\n                resA,\\n                resB,\\n                otherResA,\\n                otherResB,\\n                callingParty\\n            )\\n        ) {\\n            finalizeResolution_Untrusted_Unguarded(\\n                agreementID,\\n                agreement,\\n                resA,\\n                resB,\\n                distributeFunds,\\n                false\\n            );\\n        }\\n    }\\n\\n    /// @notice If A calls createAgreementA but B is delaying in calling depositB, A can get their\\n    /// funds back by calling earlyWithdrawA. This closes the agreement to further deposits. A or\\n    /// B wouldhave to call createAgreementA again if they still wanted to do an agreement.\\n    function earlyWithdrawA(uint agreementID) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(msg.sender == agreement.partyAAddress, \\\"earlyWithdrawA not called by party A.\\\");\\n        require(\\n            partyStakePaid(agreement, Party.A) \\u0026\\u0026 !partyStakePaid(agreement, Party.B),\\n            \\\"Early withdraw not allowed.\\\"\\n        );\\n        require(!partyReceivedDistribution(agreement, Party.A), \\\"partyA already received funds.\\\");\\n\\n        setPartyReceivedDistribution(agreement, Party.A, true);\\n\\n        emit PartyAWithdrewEarly(uint32(agreementID));\\n\\n        executeDistribution_Untrusted_Unguarded(\\n            agreement.partyAAddress,\\n            agreement.partyAToken,\\n            toWei(agreement.partyAStakeAmount, agreement.partyATokenPower),\\n            agreement.arbitratorToken,\\n            toWei(agreement.partyAInitialArbitratorFee, agreement.arbitratorTokenPower)\\n        );\\n    }\\n\\n    /// @notice This can only be called after a resolution is established.\\n    /// Each party calls this to withdraw the funds they\\u0027re entitled to, based on the resolution.\\n    /// Normally funds are distributed automatically when the agreement gets resolved. However\\n    /// it is possible for a malicious user to prevent their counterparty from getting an\\n    /// automatic distribution, by using an address for the agreement that can\\u0027t receive payments.\\n    /// If this happens, the agreement should be resolved by setting the distributeFunds parameter\\n    /// to false in whichever function is called to resolve the disagreement. Then the parties can\\n    /// independently extract their funds via this function.\\n    function withdraw(uint agreementID) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on\\\");\\n        require(agreement.resolutionTokenA != RESOLUTION_NULL, \\\"Agreement not resolved.\\\");\\n\\n        emit PartyWithdrew(uint32(agreementID));\\n\\n        distributeFundsToPartyHelper_Untrusted_Unguarded(\\n            agreementID,\\n            agreement,\\n            getCallingParty(agreement)\\n        );\\n    }\\n\\n    /// @notice Request that the arbitrator get involved to settle the disagreement.\\n    /// Each party needs to pay the full arbitration fee when calling this. However they will be\\n    /// refunded the full fee if the arbitrator agrees with them.\\n    function requestArbitration(uint agreementID) external payable;\\n\\n    /// @notice If the other person hasn\\u0027t paid their arbitration fee in time, this function\\n    /// allows the caller to cause the agreement to be resolved in their favor without the\\n    /// arbitrator getting involved.\\n    /// @param distributeFunds Whether to distribute funds to both parties.\\n    function requestDefaultJudgment(uint agreementID, bool distributeFunds) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on.\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(agreementIsLockedIn(agreement), \\\"Agreement not locked in.\\\");\\n\\n        (Party callingParty, Party otherParty) = getCallingPartyAndOtherParty(agreement);\\n\\n        require(\\n            !partyResolutionIsNull(agreement, callingParty),\\n            \\\"requestDefaultJudgment called before party resolved.\\\"\\n        );\\n        require(\\n            block.timestamp \\u003e agreement.nextArbitrationStepAllowedAfterTimestamp,\\n            \\\"requestDefaultJudgment not allowed yet.\\\"\\n        );\\n\\n        emit DefaultJudgment(uint32(agreementID));\\n\\n        require(\\n            partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\\n                agreementID,\\n                agreement,\\n                callingParty\\n            ),\\n            \\\"Party didn\\u0027t fully pay the dispute fee.\\\"\\n        );\\n        require(\\n            !partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\\n                agreementID,\\n                agreement,\\n                otherParty\\n            ),\\n            \\\"Other party fully paid the dispute fee.\\\"\\n        );\\n\\n        (uint48 partyResA, uint48 partyResB) = partyResolution(\\n            agreement,\\n            callingParty\\n        );\\n\\n        finalizeResolution_Untrusted_Unguarded(\\n            agreementID,\\n            agreement,\\n            partyResA,\\n            partyResB,\\n            distributeFunds,\\n            false\\n        );\\n    }\\n\\n    /// @notice If enough time has elapsed, either party can trigger auto-resolution (if enabled)\\n    /// by calling this function, provided that neither party has requested arbitration yet.\\n    /// @param distributeFunds Whether to distribute funds to both parties\\n    function requestAutomaticResolution(uint agreementID, bool distributeFunds) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on.\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(agreementIsLockedIn(agreement), \\\"Agreement not locked in.\\\");\\n        require(\\n            (\\n                !partyRequestedArbitration(agreement, Party.A) \\u0026\\u0026\\n                !partyRequestedArbitration(agreement, Party.B)\\n            ),\\n            \\\"Arbitration stops auto-resolution\\\"\\n        );\\n        require(\\n            msg.sender == agreement.partyAAddress || msg.sender == agreement.partyBAddress,\\n            \\\"Unauthorized sender.\\\"\\n        );\\n        require(\\n            agreement.autoResolveAfterTimestamp \\u003e 0,\\n            \\\"Agreement does not support automatic resolutions.\\\"\\n        );\\n        require(\\n            block.timestamp \\u003e agreement.autoResolveAfterTimestamp,\\n            \\\"AutoResolution not allowed yet.\\\"\\n        );\\n\\n        emit AutomaticResolution(uint32(agreementID));\\n\\n        finalizeResolution_Untrusted_Unguarded(\\n            agreementID,\\n            agreement,\\n            agreement.automaticResolutionTokenA,\\n            agreement.automaticResolutionTokenB,\\n            distributeFunds,\\n            false\\n        );\\n    }\\n\\n    /// @notice Either party can record evidence on the blockchain in case off-chain communication\\n    /// breaks down. Uses ERC1497. Allows submitting evidence even after an agreement is closed in\\n    /// case someone wants to clear their name.\\n    /// @param evidence can be any string containing evidence. Usually will be a URI to a document\\n    /// or video containing evidence.\\n    function submitEvidence(uint agreementID, string calldata evidence) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(\\n            (\\n                msg.sender == agreement.partyAAddress ||\\n                msg.sender == agreement.partyBAddress ||\\n                msg.sender == agreement.arbitratorAddress\\n            ),\\n            \\\"Unauthorized sender.\\\"\\n        );\\n\\n        emit Evidence(Arbitrator(agreement.arbitratorAddress), agreementID, msg.sender, evidence);\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ----------------------- internal getter and setter functions ------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    // Functions that simulate direct access to AgreementDataERC20 state variables.\\n    // These are used either for bools (where we need to use a bitmask), or for\\n    // functions when we need to vary between party A/B depending on the argument.\\n    // The later is necessary because the solidity compiler can\\u0027t pack structs well when their\\n    // elements are arrays. So we can\\u0027t just index into an array.\\n\\n    // ------------- Some getter functions ---------------\\n\\n    function partyResolution(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint48, uint48)\\n    {\\n        if (party == Party.A)\\n            return (agreement.partyAResolutionTokenA, agreement.partyAResolutionTokenB);\\n        else\\n            return (agreement.partyBResolutionTokenA, agreement.partyBResolutionTokenB);\\n    }\\n\\n    function partyResolutionIsNull(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n         // We can test only token A, because if token A will be null IFF token B is null\\n        if (party == Party.A) return agreement.partyAResolutionTokenA == RESOLUTION_NULL;\\n        else return agreement.partyBResolutionTokenA == RESOLUTION_NULL;\\n    }\\n\\n    function partyAddress(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (address)\\n    {\\n        if (party == Party.A) return agreement.partyAAddress;\\n        else return agreement.partyBAddress;\\n    }\\n\\n    function partyStakePaid(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_STAKE_PAID);\\n        else return getBool(agreement.boolValues, PARTY_B_STAKE_PAID);\\n    }\\n\\n    function partyStakeAmount(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint48)\\n    {\\n        if (party == Party.A) return agreement.partyAStakeAmount;\\n        else return agreement.partyBStakeAmount;\\n    }\\n\\n    function partyInitialArbitratorFee(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint48)\\n    {\\n        if (party == Party.A) return agreement.partyAInitialArbitratorFee;\\n        else return agreement.partyBInitialArbitratorFee;\\n    }\\n\\n    function partyRequestedArbitration(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_REQUESTED_ARBITRATION);\\n        else return getBool(agreement.boolValues, PARTY_B_REQUESTED_ARBITRATION);\\n    }\\n\\n    function partyReceivedDistribution(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_RECEIVED_DISTRIBUTION);\\n        else return getBool(agreement.boolValues, PARTY_B_RECEIVED_DISTRIBUTION);\\n    }\\n\\n    function partyToken(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (address)\\n    {\\n        if (party == Party.A) return agreement.partyAToken;\\n        else return agreement.partyBToken;\\n    }\\n\\n    function partyTokenPower(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint8)\\n    {\\n        if (party == Party.A) return agreement.partyATokenPower;\\n        else return agreement.partyBTokenPower;\\n    }\\n\\n    function partyAResolvedLast(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return getBool(agreement.boolValues, PARTY_A_RESOLVED_LAST);\\n    }\\n\\n    function arbitratorResolved(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return getBool(agreement.boolValues, ARBITRATOR_RESOLVED);\\n    }\\n\\n    function arbitratorReceivedDisputeFee(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return getBool(agreement.boolValues, ARBITRATOR_RECEIVED_DISPUTE_FEE);\\n    }\\n\\n    function partyDisputeFeeLiability(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_DISPUTE_FEE_LIABILITY);\\n        else return getBool(agreement.boolValues, PARTY_B_DISPUTE_FEE_LIABILITY);\\n    }\\n\\n    function pendingExternalCall(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return getBool(agreement.boolValues, PENDING_EXTERNAL_CALL);\\n    }\\n\\n    // ------------- Some setter functions ---------------\\n\\n    function setPartyResolution(\\n        AgreementDataERC20 storage agreement,\\n        Party party,\\n        uint48 valueTokenA,\\n        uint48 valueTokenB\\n    )\\n        internal\\n    {\\n        if (party == Party.A) {\\n            agreement.partyAResolutionTokenA = valueTokenA;\\n            agreement.partyAResolutionTokenB = valueTokenB;\\n        } else {\\n            agreement.partyBResolutionTokenA = valueTokenA;\\n            agreement.partyBResolutionTokenB = valueTokenB;\\n        }\\n    }\\n\\n    function setPartyStakePaid(\\n        AgreementDataERC20 storage agreement,\\n        Party party,\\n        bool value\\n    )\\n        internal\\n    {\\n        if (party == Party.A)\\n            agreement.boolValues = setBool(agreement.boolValues, PARTY_A_STAKE_PAID, value);\\n        else\\n            agreement.boolValues = setBool(agreement.boolValues, PARTY_B_STAKE_PAID, value);\\n    }\\n\\n    function setPartyRequestedArbitration(\\n        AgreementDataERC20 storage agreement,\\n        Party party,\\n        bool value\\n    )\\n        internal\\n    {\\n        if (party == Party.A) {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_A_REQUESTED_ARBITRATION,\\n                value\\n            );\\n        } else {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_B_REQUESTED_ARBITRATION,\\n                value\\n            );\\n        }\\n    }\\n\\n    function setPartyReceivedDistribution(\\n        AgreementDataERC20 storage agreement,\\n        Party party,\\n        bool value\\n    )\\n        internal\\n    {\\n        if (party == Party.A) {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_A_RECEIVED_DISTRIBUTION,\\n                value\\n            );\\n        } else {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_B_RECEIVED_DISTRIBUTION,\\n                value\\n            );\\n        }\\n    }\\n\\n    function setPartyAResolvedLast(AgreementDataERC20 storage agreement, bool value) internal {\\n        agreement.boolValues = setBool(agreement.boolValues, PARTY_A_RESOLVED_LAST, value);\\n    }\\n\\n    function setArbitratorResolved(AgreementDataERC20 storage agreement, bool value) internal {\\n        agreement.boolValues = setBool(agreement.boolValues, ARBITRATOR_RESOLVED, value);\\n    }\\n\\n    function setArbitratorReceivedDisputeFee(\\n        AgreementDataERC20 storage agreement,\\n        bool value\\n    )\\n        internal\\n    {\\n        agreement.boolValues = setBool(\\n            agreement.boolValues,\\n            ARBITRATOR_RECEIVED_DISPUTE_FEE,\\n            value\\n        );\\n    }\\n\\n    function setPartyDisputeFeeLiability(\\n        AgreementDataERC20 storage agreement,\\n        Party party,\\n        bool value\\n    )\\n        internal\\n    {\\n        if (party == Party.A) {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_A_DISPUTE_FEE_LIABILITY,\\n                value\\n            );\\n        } else {\\n            agreement.boolValues = setBool(\\n                agreement.boolValues,\\n                PARTY_B_DISPUTE_FEE_LIABILITY,\\n                value\\n            );\\n        }\\n    }\\n\\n    function setPendingExternalCall(AgreementDataERC20 storage agreement, bool value) internal {\\n        agreement.boolValues = setBool(agreement.boolValues, PENDING_EXTERNAL_CALL, value);\\n    }\\n\\n    /// @notice set the value of PENDING_EXTERNAL_CALL and return the previous value.\\n    function getThenSetPendingExternalCall(\\n        AgreementDataERC20 storage agreement,\\n        bool value\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        uint32 previousBools = agreement.boolValues;\\n        agreement.boolValues = setBool(previousBools, PENDING_EXTERNAL_CALL, value);\\n        return getBool(previousBools, PENDING_EXTERNAL_CALL);\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // -------------------------- internal helper functions --------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @notice We store ETH/token amounts in uint48s demoninated in larger units of that token.\\n    /// Specifically, our internal representation is in units of 10^tokenPower wei.\\n    /// toWei converts from our internal representation to the wei amount.\\n    /// @dev This can\\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\\n    /// @param value internal value that we want to convert to wei\\n    /// @param tokenPower The exponent to use to convert our internal representation to wei.\\n    /// @return the wei value\\n    function toWei(uint value, uint tokenPower) internal pure returns (uint) {\\n        return mul(value, (10 ** tokenPower));\\n    }\\n\\n    /// @notice Like toWei but resolutionToWei is for \\\"resolution\\\" values which might have a\\n    /// special value of RESOLUTION_NULL, which we need to handle separately.\\n    /// @dev This can\\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\\n    /// @param value internal value that we want to convert to wei\\n    /// @param tokenPower The exponent to use to convert our internal representation to wei.\\n    /// @return the wei value\\n    function resolutionToWei(uint value, uint tokenPower) internal pure returns (uint) {\\n        if (value == RESOLUTION_NULL) {\\n            return uint(~0); // set all bits of a uint to 1\\n        }\\n        return mul(value, (10 ** tokenPower));\\n    }\\n\\n    /// @notice Convert a value expressed in wei to our internal representation (which is\\n    /// in units of 10^tokenPower wei)\\n    /// @dev This can\\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\\n    /// @param weiValue wei value that we want to convert from\\n    /// @param tokenPower The exponent to use to convert wei to our internal representation\\n    /// @return the amount of our internal units of the given value\\n    function toLargerUnit(uint weiValue, uint tokenPower) internal pure returns (uint48) {\\n        return toUint48(weiValue / (10 ** tokenPower));\\n    }\\n\\n    /// @notice Requires that the caller be party A or party B.\\n    /// @return whichever party the caller is.\\n    function getCallingParty(AgreementDataERC20 storage agreement) internal view returns (Party) {\\n        if (msg.sender == agreement.partyAAddress) {\\n            return Party.A;\\n        } else if (msg.sender == agreement.partyBAddress) {\\n            return Party.B;\\n        } else {\\n            require(false, \\\"getCallingParty must be called by a party to the agreement.\\\");\\n        }\\n    }\\n\\n    /// @param party a party for whom we want to get the other party.\\n    /// @return the other party who was not given in the parameter.\\n    function getOtherParty(Party party) internal pure returns (Party) {\\n        if (party == Party.A) {\\n            return Party.B;\\n        }\\n        return Party.A;\\n    }\\n\\n    /// @notice Fails if called by anyone other than a party.\\n    /// @return the calling party first and the \\\"other party\\\" second.\\n    function getCallingPartyAndOtherParty(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (Party, Party)\\n    {\\n        if (msg.sender == agreement.partyAAddress) {\\n            return (Party.A, Party.B);\\n        } else if (msg.sender == agreement.partyBAddress) {\\n            return (Party.B, Party.A);\\n        } else {\\n            require(\\n                false,\\n                \\\"getCallingPartyAndOtherParty must be called by a party to the agreement.\\\"\\n            );\\n        }\\n    }\\n\\n    /// @notice This is a version of resolutionsAreCompatible where we know that both resolutions\\n    /// are not RESOLUTION_NULL. It\\u0027s more gas efficient so we should use it when possible.\\n    /// See comments for resolutionsAreCompatible to understand the purpose and arguments.\\n    function resolutionsAreCompatibleBothExist(\\n        AgreementDataERC20 storage agreement,\\n        uint resolutionTokenA,\\n        uint resolutionTokenB,\\n        uint otherResolutionTokenA,\\n        uint otherResolutionTokenB,\\n        Party resolutionParty\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // If the tokens are different, ensure that both token resolutions are compatible.\\n        if (agreement.partyAToken != agreement.partyBToken) {\\n            if (resolutionParty == Party.A) {\\n                return resolutionTokenA \\u003c= otherResolutionTokenA \\u0026\\u0026\\n                    resolutionTokenB \\u003c= otherResolutionTokenB;\\n            } else {\\n                return otherResolutionTokenA \\u003c= resolutionTokenA \\u0026\\u0026\\n                    otherResolutionTokenB \\u003c= resolutionTokenB;\\n            }\\n        }\\n\\n        // Now we know tokens are the same. We need to convert to wei because the same resolution\\n        // can be represented in many different ways.\\n        uint resSum = add(\\n            resolutionToWei(resolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(resolutionTokenB, agreement.partyBTokenPower)\\n        );\\n        uint otherSum = add(\\n            resolutionToWei(otherResolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(otherResolutionTokenB, agreement.partyBTokenPower)\\n        );\\n        if (resolutionParty == Party.A) {\\n            return resSum \\u003c= otherSum;\\n        } else {\\n            return otherSum \\u003c= resSum;\\n        }\\n    }\\n\\n    /// @notice Compatible means that the participants don\\u0027t disagree in a selfish direction.\\n    /// Alternatively, it means that we know some resolution will satisfy both parties.\\n    /// If one person resolves to give the other person the maximum possible amount, this is\\n    /// always compatible with the other person\\u0027s resolution, even if that resolution is\\n    /// RESOLUTION_NULL. Otherwise, one person having a resolution of RESOLUTION_NULL\\n    /// implies the resolutions are not compatible.\\n    /// @param resolutionTokenA The component of a resolution provided by either party A\\n    /// or party B representing party A\\u0027s staked token. Can\\u0027t be RESOLUTION_NULL.\\n    /// @param resolutionTokenB The component of a resolution provided by either party A\\n    /// or party B representing party B\\u0027s staked token. Can\\u0027t be RESOLUTION_NULL.\\n    /// @param otherResolutionTokenA The component of a resolution provided either by the\\n    /// other party or by the arbitrator representing party A\\u0027s staked token. It may be\\n    /// RESOLUTION_NULL.\\n    /// @param otherResolutionTokenB The component of a resolution provided either by the\\n    /// other party or by the arbitrator representing party A\\u0027s staked token. It may be\\n    /// RESOLUTION_NULL.\\n    /// @param resolutionParty The party corresponding to the resolution provided by the\\n    /// \\u0027resolutionTokenA\\u0027 and \\u0027resolutionTokenB\\u0027 parameters.\\n    /// @return whether the resolutions are compatible.\\n    function resolutionsAreCompatible(\\n        AgreementDataERC20 storage agreement,\\n        uint resolutionTokenA,\\n        uint resolutionTokenB,\\n        uint otherResolutionTokenA,\\n        uint otherResolutionTokenB,\\n        Party resolutionParty\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // If we\\u0027re not dealing with the NULL case, we can use resolutionsAreCompatibleBothExist\\n        if (otherResolutionTokenA != RESOLUTION_NULL) {\\n            return resolutionsAreCompatibleBothExist(\\n                agreement,\\n                resolutionTokenA,\\n                resolutionTokenB,\\n                otherResolutionTokenA,\\n                otherResolutionTokenB,\\n                resolutionParty\\n            );\\n        }\\n\\n        // Now we know otherResolution is null.\\n        // See if resolutionParty wants to give all funds to the other party.\\n        if (resolutionParty == Party.A) {\\n            // only 0 from Party A is compatible with RESOLUTION_NULL\\n            return resolutionTokenA == 0 \\u0026\\u0026 resolutionTokenB == 0;\\n        } else {\\n            // only the max possible amount from Party B is compatible with RESOLUTION_NULL\\n            return resolutionTokenA == agreement.partyAStakeAmount \\u0026\\u0026\\n                resolutionTokenB == agreement.partyBStakeAmount;\\n        }\\n    }\\n\\n    /// @return Whether the party provided is closer to winning a default judgment than the other\\n    /// party.\\n    function partyIsCloserToWinningDefaultJudgment(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        returns (bool);\\n\\n    \\n    function getPartyArbitrationRefundInWei(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint);\\n\\n    /// @notice This lets us write one version of createAgreementA for both ERC792 and simple\\n    /// arbitration.\\n    /// @param arbExtraData some data that the creator of the agreement optionally passes in\\n    /// when creating an ERC792 agreement.\\n    function storeArbitrationExtraData(uint agreementID, bytes memory arbExtraData) internal;\\n\\n    /// @notice Some inheriting contracts have restrictions on how the arbitrator can be paid.\\n    /// This enforces those restrictions.\\n    function checkContractSpecificConditionsForCreation(address arbitratorToken) internal;\\n\\n    /// @dev \\u0027_Sometimes_Untrusted_Guarded\\u0027 means that in some inheriting contracts it\\u0027s\\n    /// _Untrusted_Guarded, in some it isn\\u0027t. Look at the implementation in the specific\\n    /// contract you\\u0027re interested in to know.\\n    function partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        returns (bool);\\n\\n    /// @notice \\u0027Open\\u0027 means people should be allowed to take steps toward a future resolution.\\n    /// An agreement isn\\u0027t open after it has ended (a final resolution exists), or if someone\\n    /// withdrew their funds before the second party could deposit theirs.\\n    /// @dev partyB can\\u0027t do an early withdrawal, so we only need to check if partyA withdrew.\\n    function agreementIsOpen(AgreementDataERC20 storage agreement) internal view returns (bool) {\\n        // If the tokenA resolution is null then the tokenB one is too, so just check A\\n        return agreement.resolutionTokenA == RESOLUTION_NULL \\u0026\\u0026\\n            !partyReceivedDistribution(agreement, Party.A);\\n    }\\n\\n    /// @notice \\u0027Locked in\\u0027 means both parties have deposited their stake. It conveys that the\\n    /// agreement is fully accepted and no one can get money out without someone else\\u0027s approval.\\n    function agreementIsLockedIn(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return partyStakePaid(agreement, Party.A) \\u0026\\u0026 partyStakePaid(agreement, Party.B);\\n    }\\n\\n    /// @notice Set or extend the deadline for both parties to pay the arbitration fee.\\n    function updateArbitrationResponseDeadline(AgreementDataERC20 storage agreement) internal {\\n        agreement.nextArbitrationStepAllowedAfterTimestamp =\\n            toUint32(\\n                add(\\n                    block.timestamp,\\n                    mul(agreement.daysToRespondToArbitrationRequest, (1 days))\\n                )\\n            );\\n    }\\n\\n    /// @notice When both parties have deposited their stakes, the arbitrator is paid any\\n    /// \\u0027initial\\u0027 arbitration fee that was required. We assume we\\u0027ve already checked that the\\n    /// arbitrator is owed a nonzero amount.\\n    function payOutInitialArbitratorFee_Untrusted_Unguarded(\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n    {\\n        uint totalInitialFeesWei = toWei(\\n            add(agreement.partyAInitialArbitratorFee, agreement.partyBInitialArbitratorFee),\\n            agreement.arbitratorTokenPower\\n        );\\n\\n        sendFunds_Untrusted_Unguarded(\\n            agreement.arbitratorAddress,\\n            agreement.arbitratorToken,\\n            totalInitialFeesWei\\n        );\\n    }\\n\\n    /// @notice Transfers funds from this contract to a given address\\n    /// @param to The address to send the funds.\\n    /// @param token The address of the token being sent.\\n    /// @param amount The amount of wei of the token to send.\\n    function sendFunds_Untrusted_Unguarded(\\n        address to,\\n        address token,\\n        uint amount\\n    )\\n        internal\\n    {\\n        if (amount == 0) {\\n            return;\\n        }\\n        if (token == address(0)) {\\n            // Need to cast to uint160 to make it payable.\\n            address(uint160(to)).transfer(amount);\\n        } else {\\n            require(ERC20Interface(token).transfer(to, amount), \\\"ERC20 transfer failed.\\\");\\n        }\\n    }\\n\\n    /// @notice Pull ERC20 tokens into this contract from the caller\\n    /// @param token The address of the token being pulled.\\n    /// @param amount The amount of wei of the token to pulled.\\n    function receiveFunds_Untrusted_Unguarded(\\n        address token,\\n        uint amount\\n    )\\n        internal\\n    {\\n        if (token == address(0)) {\\n            require(msg.value == amount, \\\"ETH value received was not what was expected.\\\");\\n        } else if (amount \\u003e 0) {\\n            require(\\n                ERC20Interface(token).transferFrom(msg.sender, address(this), amount),\\n                \\\"ERC20 transfer failed.\\\"\\n            );\\n        }\\n    }\\n\\n    /// @notice The depositor needs to send their stake amount (in the token they\\u0027re staking), and\\n    /// also potentially an initial arbitration fee, in arbitratorToken. This function verifies\\n    /// that the current transaction has caused those funds to be moved to our contract.\\n    function verifyDeposit_Untrusted_Guarded(\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n    {\\n        address partyTokenAddress = partyToken(agreement, party);\\n\\n        // Make sure people don\\u0027t accidentally send ETH when the only required tokens are ERC20\\n        if (partyTokenAddress != address(0) \\u0026\\u0026 agreement.arbitratorToken != address(0)) {\\n            require(msg.value == 0, \\\"ETH was sent, but none was needed.\\\");\\n        }\\n\\n        // Wrap these receives in a reentrancy guard. (Technically this shouldn\\u0027t be necessary,\\n        // but that\\u0027s not obvious enough to make it worth risking a bug.)\\n        bool previousValue = getThenSetPendingExternalCall(agreement, true);\\n        if (partyTokenAddress == agreement.arbitratorToken) {\\n            // Both tokens we\\u0027re receiving are of the same type, so we can do one combined receive\\n            receiveFunds_Untrusted_Unguarded(\\n                partyTokenAddress,\\n                add(\\n                    toWei(partyStakeAmount(agreement, party), partyTokenPower(agreement, party)),\\n                    toWei(\\n                        partyInitialArbitratorFee(agreement, party),\\n                        agreement.arbitratorTokenPower\\n                    )\\n                )\\n            );\\n        } else {\\n            // Tokens are of different types, so do one receive for each.\\n            receiveFunds_Untrusted_Unguarded(\\n                partyTokenAddress,\\n                toWei(partyStakeAmount(agreement, party), partyTokenPower(agreement, party))\\n            );\\n            receiveFunds_Untrusted_Unguarded(\\n                agreement.arbitratorToken,\\n                toWei(\\n                    partyInitialArbitratorFee(agreement, party),\\n                    agreement.arbitratorTokenPower\\n                )\\n            );\\n        }\\n        setPendingExternalCall(agreement, previousValue);\\n    }\\n\\n    /// @notice Distribute funds from this contract to the given address, using up to two\\n    /// different tokens.\\n    /// @param to The address to distribute to.\\n    /// @param token1 The first token address\\n    /// @param amount1 The amount of token1 to distribute in wei\\n    /// @param token2 The second token address\\n    /// @param amount2 The amount of token2 to distribute in wei\\n    function executeDistribution_Untrusted_Unguarded(\\n        address to,\\n        address token1,\\n        uint amount1,\\n        address token2,\\n        uint amount2\\n    )\\n        internal\\n    {\\n        // All of the calls below are Reentrancy Safe, as they don\\u0027t depend on any internal state\\n        // nor do they modify any state. You can quickly see this by noting that this function\\n        // doesn\\u0027t have access to any references to an agreement, so it can\\u0027t affect state.\\n        if (token1 == token2) {\\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount2));\\n        } else {\\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\\n        }\\n    }\\n\\n    /// @notice Distribute funds from this contract to the given address, using up to three\\n    /// different tokens.\\n    /// @param to The address to distribute to.\\n    /// @param token1 The first token address\\n    /// @param amount1 The amount of token1 to distribute in wei\\n    /// @param token2 The second token address\\n    /// @param amount2 The amount of token2 to distribute in wei\\n    /// @param token3 The third token address\\n    /// @param amount3 The amount of token3 to distribute in wei\\n    function executeDistribution_Untrusted_Unguarded(\\n        address to,\\n        address token1,\\n        uint amount1,\\n        address token2,\\n        uint amount2,\\n        address token3,\\n        uint amount3\\n    )\\n        internal\\n    {\\n        // All of the calls below are Reentrancy Safe, as they don\\u0027t depend on any internal state\\n        // nor do they modify any state. You can quickly see this by noting that this function\\n        // doesn\\u0027t have access to any references to an agreement, so it can\\u0027t affect state.\\n\\n        // Check for all combinations of which tokens are the same, to minimize the amount of\\n        // transfers.\\n        if (token1 == token2 \\u0026\\u0026 token1 == token3) {\\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, add(amount2, amount3)));\\n        } else if (token1 == token2) {\\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount2));\\n            sendFunds_Untrusted_Unguarded(to, token3, amount3);\\n        } else if (token1 == token3) {\\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount3));\\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\\n        } else if (token2 == token3) {\\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\\n            sendFunds_Untrusted_Unguarded(to, token2, add(amount2, amount3));\\n        } else {\\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\\n            sendFunds_Untrusted_Unguarded(to, token3, amount3);\\n        }\\n    }\\n\\n    /// @notice A helper function that sets the final resolution for the agreement, and\\n    /// also distributes funds to the participants based on distributeFundsToParties and\\n    /// distributeFundsToArbitrator.\\n    function finalizeResolution_Untrusted_Unguarded(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement,\\n        uint48 resA,\\n        uint48 resB,\\n        bool distributeFundsToParties,\\n        bool distributeFundsToArbitrator\\n    )\\n        internal\\n    {\\n        agreement.resolutionTokenA = resA;\\n        agreement.resolutionTokenB = resB;\\n        calculateDisputeFeeLiability(agreementID, agreement);\\n        if (distributeFundsToParties) {\\n            emit FundsDistributed(uint32(agreementID));\\n            // These calls are not \\\"Reentrancy Safe\\\" (see AgreementManager.sol comments).\\n            // Using reentrancy guard.\\n            bool previousValue = getThenSetPendingExternalCall(agreement, true);\\n            distributeFundsToPartyHelper_Untrusted_Unguarded(agreementID, agreement, Party.A);\\n            distributeFundsToPartyHelper_Untrusted_Unguarded(agreementID, agreement, Party.B);\\n            setPendingExternalCall(agreement, previousValue);\\n        }\\n        if (distributeFundsToArbitrator) {\\n            distributeFundsToArbitratorHelper_Untrusted_Unguarded(agreementID, agreement);\\n        }\\n    }\\n\\n    /// @notice This can only be called after a resolution is established.\\n    /// A helper function to distribute funds owed to a party based on the resolution and any\\n    /// arbitration fee refund they\\u0027re owed.\\n    /// Assumes that a resolution exists.\\n    function distributeFundsToPartyHelper_Untrusted_Unguarded(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n    {\\n        require(!partyReceivedDistribution(agreement, party), \\\"party already received funds.\\\");\\n        setPartyReceivedDistribution(agreement, party, true);\\n\\n        uint distributionAmountA = 0;\\n        uint distributionAmountB = 0;\\n        if (party == Party.A) {\\n            distributionAmountA = agreement.resolutionTokenA;\\n            distributionAmountB = agreement.resolutionTokenB;\\n        } else {\\n            distributionAmountA = sub(agreement.partyAStakeAmount, agreement.resolutionTokenA);\\n            distributionAmountB = sub(agreement.partyBStakeAmount, agreement.resolutionTokenB);\\n        }\\n\\n        uint arbRefundWei = getPartyArbitrationRefundInWei(agreementID, agreement, party);\\n\\n        executeDistribution_Untrusted_Unguarded(\\n            partyAddress(agreement, party),\\n            agreement.partyAToken, toWei(distributionAmountA, agreement.partyATokenPower),\\n            agreement.partyBToken, toWei(distributionAmountB, agreement.partyBTokenPower),\\n            agreement.arbitratorToken, arbRefundWei);\\n    }\\n\\n    /// @notice A helper function to distribute funds owed to the arbitrator. These funds can be\\n    /// distributed either when the arbitrator calls withdrawDisputeFee or resolveAsArbitrator.\\n    function distributeFundsToArbitratorHelper_Untrusted_Unguarded(\\n        uint agreementID,\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n    {\\n        require(!arbitratorReceivedDisputeFee(agreement), \\\"Already received dispute fee.\\\");\\n        setArbitratorReceivedDisputeFee(agreement, true);\\n\\n        emit ArbitratorReceivedDisputeFee(uint32(agreementID));\\n\\n        sendFunds_Untrusted_Unguarded(\\n            agreement.arbitratorAddress,\\n            agreement.arbitratorToken,\\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower)\\n        );\\n    }\\n\\n    /// @notice Calculate and store in state variables who is responsible for paying any\\n    /// arbitration fee (if it was paid).\\n    /// @dev\\n    /// We set PARTY_A_DISPUTE_FEE_LIABILITY if partyA needs to pay some portion of the fee.\\n    /// We set PARTY_B_DISPUTE_FEE_LIABILITY if partyB needs to pay some portion of the fee.\\n    /// If both of the above values are true, then partyA and partyB are each liable for half of\\n    /// the arbitration fee.\\n    function calculateDisputeFeeLiability(\\n        uint argreementID,\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n    {\\n        // If arbitrator hasn\\u0027t or won\\u0027t get the dispute fee, there\\u0027s no liability.\\n        if (!arbitratorGetsDisputeFee(argreementID, agreement)) {\\n            return;\\n        }\\n\\n        // If A and B have compatible resolutions, then the arbitrator never issued a\\n        // ruling. Whichever of partyA and partyB resolved latest should have to pay the full\\n        // fee (because if they had resolved earlier, the arbitrator would never have had to be\\n        // called). See comments for PARTY_A_RESOLVED_LAST.\\n        if (\\n            resolutionsAreCompatibleBothExist(\\n                agreement,\\n                agreement.partyAResolutionTokenA,\\n                agreement.partyAResolutionTokenB,\\n                agreement.partyBResolutionTokenA,\\n                agreement.partyBResolutionTokenB,\\n                Party.A\\n            )\\n        ) {\\n            if (partyAResolvedLast(agreement)) {\\n                setPartyDisputeFeeLiability(agreement, Party.A, true);\\n            } else {\\n                setPartyDisputeFeeLiability(agreement, Party.B, true);\\n            }\\n            return;\\n        }\\n\\n        // Now we know the parties rulings are not compatible with each other. If the ruling\\n        // from the arbitrator is compatible with either party, that party pays no fee and the\\n        // other party pays the full fee. Otherwise the parties are both liable for half the fee.\\n        if (\\n            resolutionsAreCompatibleBothExist(\\n                agreement,\\n                agreement.partyAResolutionTokenA,\\n                agreement.partyAResolutionTokenB,\\n                agreement.resolutionTokenA,\\n                agreement.resolutionTokenB,\\n                Party.A\\n            )\\n        ) {\\n            setPartyDisputeFeeLiability(agreement, Party.B, true);\\n        } else if (\\n            resolutionsAreCompatibleBothExist(\\n                agreement,\\n                agreement.partyBResolutionTokenA,\\n                agreement.partyBResolutionTokenB,\\n                agreement.resolutionTokenA,\\n                agreement.resolutionTokenB,\\n                Party.B\\n            )\\n        ) {\\n            setPartyDisputeFeeLiability(agreement, Party.A, true);\\n        } else {\\n            setPartyDisputeFeeLiability(agreement, Party.A, true);\\n            setPartyDisputeFeeLiability(agreement, Party.B, true);\\n        }\\n    }\\n\\n    /// @return whether the arbitrator has either already gotten or is entitled to withdraw\\n    /// the dispute fee\\n    function arbitratorGetsDisputeFee(\\n        uint argreementID,\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        returns (bool);\\n}\\n\"},\"AgreementManagerERC20_Simple.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./AgreementManagerERC20.sol\\\";\\nimport \\\"./SimpleArbitrationInterface.sol\\\";\\n\\n\\n\\ncontract AgreementManagerERC20_Simple is AgreementManagerERC20, SimpleArbitrationInterface {\\n    // -------------------------------------------------------------------------------------------\\n    // ------------------------------------- events ----------------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    event ArbitratorResolved(\\n        uint32 indexed agreementID,\\n        uint resolutionTokenA,\\n        uint resolutionTokenB\\n    );\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ---------------------------- external getter functions ------------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    // Return a bunch of arrays representing the entire state of the agreement.\\n    function getState(\\n        uint agreementID\\n    )\\n        external\\n        view\\n        returns (address[6] memory, uint[23] memory, bool[12] memory, bytes memory)\\n    {\\n        if (agreementID \\u003e= agreements.length) {\\n            address[6] memory zeroAddrs;\\n            uint[23] memory zeroUints;\\n            bool[12] memory zeroBools;\\n            bytes memory zeroBytes;\\n            return (zeroAddrs, zeroUints, zeroBools, zeroBytes);\\n        }\\n\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        address[6] memory addrs = [\\n            agreement.partyAAddress,\\n            agreement.partyBAddress,\\n            agreement.arbitratorAddress,\\n            agreement.partyAToken,\\n            agreement.partyBToken,\\n            agreement.arbitratorToken\\n        ];\\n        uint[23] memory uints = [\\n            resolutionToWei(agreement.partyAResolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(agreement.partyAResolutionTokenB, agreement.partyBTokenPower),\\n            resolutionToWei(agreement.partyBResolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(agreement.partyBResolutionTokenB, agreement.partyBTokenPower),\\n            resolutionToWei(agreement.resolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(agreement.resolutionTokenB, agreement.partyBTokenPower),\\n            resolutionToWei(agreement.automaticResolutionTokenA, agreement.partyATokenPower),\\n            resolutionToWei(agreement.automaticResolutionTokenB, agreement.partyBTokenPower),\\n            toWei(agreement.partyAStakeAmount, agreement.partyATokenPower),\\n            toWei(agreement.partyBStakeAmount, agreement.partyBTokenPower),\\n            toWei(agreement.partyAInitialArbitratorFee, agreement.arbitratorTokenPower),\\n            toWei(agreement.partyBInitialArbitratorFee, agreement.arbitratorTokenPower),\\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower),\\n            agreement.nextArbitrationStepAllowedAfterTimestamp,\\n            agreement.autoResolveAfterTimestamp,\\n            agreement.daysToRespondToArbitrationRequest,\\n            agreement.partyATokenPower,\\n            agreement.partyBTokenPower,\\n            agreement.arbitratorTokenPower,\\n            // Return a bunch of zeroes where the ERC792 arbitration data is so we can have the\\n            // same API for both\\n            0,\\n            0,\\n            0,\\n            0\\n        ];\\n        bool[12] memory boolVals = [\\n            partyStakePaid(agreement, Party.A),\\n            partyStakePaid(agreement, Party.B),\\n            partyRequestedArbitration(agreement, Party.A),\\n            partyRequestedArbitration(agreement, Party.B),\\n            partyReceivedDistribution(agreement, Party.A),\\n            partyReceivedDistribution(agreement, Party.B),\\n            partyAResolvedLast(agreement),\\n            arbitratorResolved(agreement),\\n            arbitratorReceivedDisputeFee(agreement),\\n            partyDisputeFeeLiability(agreement, Party.A),\\n            partyDisputeFeeLiability(agreement, Party.B),\\n            // Return a false value where the ERC792 arbitration data is so we can have the\\n            // same API for both\\n            false\\n        ];\\n        // Return empty bytes value to keep the same API as for the ERC792 version\\n        bytes memory bytesVal;\\n\\n        return (addrs, uints, boolVals, bytesVal);\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // -------------------- main external/public functions that affect state ---------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @notice Called by arbitrator to report their resolution.\\n    /// Can only be called after arbitrator is asked to arbitrate by both parties.\\n    /// We separate the staked funds of party A and party B because they might use different\\n    /// tokens.\\n    /// @param resTokenA The amount of party A\\u0027s staked funds that the caller thinks should go to\\n    ///  party A. The remaining amount of wei staked for this agreement would go to party B.\\n    /// @param resTokenB The amount of party B\\u0027s staked funds that the caller thinks should go to\\n    ///  party A. The remaining amount of wei staked for this agreement would go to party B.\\n    /// @param distributeFunds Whether to distribute funds to both parties and the arbitrator (if\\n    /// the arbitrator hasn\\u0027t already called withdrawDisputeFee).\\n    function resolveAsArbitrator(\\n        uint agreementID,\\n        uint resTokenA,\\n        uint resTokenB,\\n        bool distributeFunds\\n    )\\n        external\\n    {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(agreementIsLockedIn(agreement), \\\"Agreement not locked in.\\\");\\n\\n        uint48 resA = toLargerUnit(resTokenA, agreement.partyATokenPower);\\n        uint48 resB = toLargerUnit(resTokenB, agreement.partyBTokenPower);\\n\\n        require(\\n            msg.sender == agreement.arbitratorAddress,\\n            \\\"resolveAsArbitrator can only be called by arbitrator.\\\"\\n        );\\n        require(resA \\u003c= agreement.partyAStakeAmount, \\\"Resolution out of range for token A.\\\");\\n        require(resB \\u003c= agreement.partyBStakeAmount, \\\"Resolution out of range for token B.\\\");\\n        require(\\n            (\\n                partyRequestedArbitration(agreement, Party.A) \\u0026\\u0026\\n                partyRequestedArbitration(agreement, Party.B)\\n            ),\\n            \\\"Arbitration not requested by both parties.\\\"\\n        );\\n\\n        setArbitratorResolved(agreement, true);\\n\\n        emit ArbitratorResolved(uint32(agreementID), resA, resB);\\n\\n        bool distributeToArbitrator = !arbitratorReceivedDisputeFee(agreement) \\u0026\\u0026 distributeFunds;\\n\\n        finalizeResolution_Untrusted_Unguarded(\\n            agreementID,\\n            agreement,\\n            resA,\\n            resB,\\n            distributeFunds,\\n            distributeToArbitrator\\n        );\\n    }\\n\\n    /// @notice Request that the arbitrator get involved to settle the disagreement.\\n    /// Each party needs to pay the full arbitration fee when calling this. However they will be\\n    /// refunded the full fee if the arbitrator agrees with them.\\n    /// If one party calls this and the other refuses to, the party who called this function can\\n    /// eventually call requestDefaultJudgment.\\n    function requestArbitration(uint agreementID) external payable {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on\\\");\\n        require(agreementIsOpen(agreement), \\\"Agreement not open.\\\");\\n        require(agreementIsLockedIn(agreement), \\\"Agreement not locked in.\\\");\\n        require(agreement.arbitratorAddress != address(0), \\\"Arbitration is disallowed.\\\");\\n        // Make sure people don\\u0027t accidentally send ETH when the only required tokens are ERC20\\n        if (agreement.arbitratorToken != address(0)) {\\n            require(msg.value == 0, \\\"ETH was sent, but none was needed.\\\");\\n        }\\n\\n        Party callingParty = getCallingParty(agreement);\\n        require(\\n            !partyResolutionIsNull(agreement, callingParty),\\n            \\\"Need to enter a resolution before requesting arbitration.\\\"\\n        );\\n        require(\\n            !partyRequestedArbitration(agreement, callingParty),\\n            \\\"This party already requested arbitration.\\\"\\n        );\\n\\n        bool firstArbitrationRequest =\\n            !partyRequestedArbitration(agreement, Party.A) \\u0026\\u0026\\n            !partyRequestedArbitration(agreement, Party.B);\\n\\n        require(\\n            (\\n                !firstArbitrationRequest ||\\n                block.timestamp \\u003e agreement.nextArbitrationStepAllowedAfterTimestamp\\n            ),\\n            \\\"Arbitration not allowed yet.\\\"\\n        );\\n\\n        setPartyRequestedArbitration(agreement, callingParty, true);\\n\\n        emit ArbitrationRequested(uint32(agreementID));\\n\\n        if (firstArbitrationRequest) {\\n            updateArbitrationResponseDeadline(agreement);\\n        } else {\\n            // Both parties have requested arbitration. Emit this event to conform to ERC1497.\\n            emit Dispute(\\n                Arbitrator(agreement.arbitratorAddress),\\n                agreementID,\\n                agreementID,\\n                agreementID\\n            );\\n        }\\n\\n        receiveFunds_Untrusted_Unguarded(\\n            agreement.arbitratorToken,\\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower)\\n        );\\n    }\\n\\n    /// @notice Allow the arbitrator to indicate they\\u0027re working on the dispute by withdrawing the\\n    /// funds. We can\\u0027t prevent dishonest arbitrator from taking funds without doing work, because\\n    /// they can always call \\u0027resolveAsArbitrator\\u0027 quickly. So we prevent the arbitrator from\\n    /// actually being paid until they either call this function or \\u0027resolveAsArbitrator\\u0027 to avoid\\n    /// the case where we send funds to a nonresponsive arbitrator.\\n    function withdrawDisputeFee(uint agreementID) external {\\n        AgreementDataERC20 storage agreement = agreements[agreementID];\\n\\n        require(!pendingExternalCall(agreement), \\\"Reentrancy protection is on\\\");\\n        require(\\n            (\\n                partyRequestedArbitration(agreement, Party.A) \\u0026\\u0026\\n                partyRequestedArbitration(agreement, Party.B)\\n            ),\\n            \\\"Arbitration not requested\\\"\\n        );\\n        require(\\n            msg.sender == agreement.arbitratorAddress,\\n            \\\"withdrawDisputeFee can only be called by Arbitrator.\\\"\\n        );\\n        require(\\n            !resolutionsAreCompatibleBothExist(\\n                agreement,\\n                agreement.partyAResolutionTokenA,\\n                agreement.partyAResolutionTokenB,\\n                agreement.partyBResolutionTokenA,\\n                agreement.partyBResolutionTokenB,\\n                Party.A\\n            ),\\n            \\\"partyA and partyB already resolved their dispute.\\\"\\n        );\\n\\n        distributeFundsToArbitratorHelper_Untrusted_Unguarded(agreementID, agreement);\\n    }\\n\\n    // -------------------------------------------------------------------------------------------\\n    // ----------------------------- internal helper functions -----------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @dev This functions is a no-op in this version of the contract. It exists because we use\\n    /// inheritance.\\n    function checkContractSpecificConditionsForCreation(address arbitratorToken) internal { }\\n\\n    /// @dev This function is NOT untrusted in this contract.\\n    /// @return whether the given party has paid the arbitration fee in full.\\n    function partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\\n        uint, \\n        AgreementDataERC20 storage agreement,\\n        Party party) internal returns (bool) {\\n\\n        // Since the arbitration fee can\\u0027t change mid-agreement in simple arbitration,\\n        // having requested arbitration means the dispute fee is paid.\\n        return partyRequestedArbitration(agreement, party);\\n    }\\n\\n    /// @return Whether the party provided is closer to winning a default judgment than the other\\n    /// party. For simple arbitration this means just that they\\u0027d paid the arbitration fee\\n    /// and the other party hasn\\u0027t.\\n    function partyIsCloserToWinningDefaultJudgment(\\n        uint ,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        return partyRequestedArbitration(agreement, party) \\u0026\\u0026\\n            !partyRequestedArbitration(agreement, getOtherParty(party));\\n    }\\n\\n    /// @notice See comments in AgreementManagerETH to understand the goal of this\\n    /// important function.\\n    /// @dev We don\\u0027t use the first argument (agreementID) in this version, but it\\u0027s there because\\n    /// we use inheritance.\\n    function getPartyArbitrationRefundInWei(\\n        uint ,\\n        AgreementDataERC20 storage agreement,\\n        Party party\\n    )\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        if (!partyRequestedArbitration(agreement, party)) {\\n            // party didn\\u0027t pay an arbitration fee, so gets no refund.\\n            return 0;\\n        }\\n\\n        // Now we know party paid an arbitration fee, so figure out how much of it they get back.\\n\\n        if (partyDisputeFeeLiability(agreement, party)) {\\n            // party has liability for the dispute fee. The only question is whether they\\n            // pay the full amount or half.\\n            Party otherParty = getOtherParty(party);\\n            if (partyDisputeFeeLiability(agreement, otherParty)) {\\n                // party pays half the fee\\n                return toWei(agreement.disputeFee/2, agreement.arbitratorTokenPower);\\n            }\\n            return 0; // party pays the full fee\\n        }\\n        // No liability -- full refund\\n        return toWei(agreement.disputeFee, agreement.arbitratorTokenPower);\\n    }\\n\\n    /// @return whether the arbitrator has either already received or is entitled to withdraw\\n    /// the dispute fee\\n    function arbitratorGetsDisputeFee(\\n        uint ,\\n        AgreementDataERC20 storage agreement\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        return arbitratorResolved(agreement) || arbitratorReceivedDisputeFee(agreement);\\n    }\\n}\\n\"},\"Arbitrable.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./Arbitrator.sol\\\";\\n\\ncontract Arbitrable {\\n\\n    function rule(uint _dispute, uint _ruling) public;\\n\\n    event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\\n}\"},\"Arbitrator.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./Arbitrable.sol\\\";\\n\\n\\ncontract Arbitrator {\\n\\n    enum DisputeStatus { Waiting, Appealable, Solved }\\n\\n    \\n    event DisputeCreation(uint indexed _disputeID, Arbitrable indexed _arbitrable);\\n\\n    \\n    event AppealPossible(uint indexed _disputeID, Arbitrable indexed _arbitrable);\\n\\n    \\n    event AppealDecision(uint indexed _disputeID, Arbitrable indexed _arbitrable);\\n\\n    \\n    function createDispute(uint _choices, bytes memory _extraData) public payable returns(uint disputeID);\\n\\n    \\n    function arbitrationCost(bytes memory _extraData) public view returns(uint fee);\\n\\n    \\n    function appeal(uint _disputeID, bytes memory _extraData) public payable;\\n\\n    \\n    function appealCost(uint _disputeID, bytes memory _extraData) public view returns(uint fee);\\n\\n    \\n    function appealPeriod(uint _disputeID) public view returns(uint start, uint end);\\n\\n    \\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status);\\n\\n    \\n    function currentRuling(uint _disputeID) public view returns(uint ruling);\\n}\"},\"ERC20Interface.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\ncontract ERC20Interface {\\n    function totalSupply() public view returns (uint);\\n    function balanceOf(address tokenOwner) public view returns (uint balance);\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n    function transfer(address to, uint tokens) public returns (bool success);\\n    function approve(address spender, uint tokens) public returns (bool success);\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\"},\"EvidenceProducer.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\nimport \\\"./Arbitrator.sol\\\";\\n\\n// See ERC 1497\\ncontract EvidenceProducer {\\n    event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\\n    event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\\n    event Evidence(Arbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence);\\n}\"},\"SafeUtils.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\ncontract SafeUtils {\\n    function toUint48(uint val) internal pure returns (uint48) {\\n        uint48 ret = uint48(val);\\n        require(ret == val, \\\"toUint48 lost some value.\\\");\\n        return ret;\\n    }\\n    function toUint32(uint val) internal pure returns (uint32) {\\n        uint32 ret = uint32(val);\\n        require(ret == val, \\\"toUint32 lost some value.\\\");\\n        return ret;\\n    }\\n    function toUint16(uint val) internal pure returns (uint16) {\\n        uint16 ret = uint16(val);\\n        require(ret == val, \\\"toUint16 lost some value.\\\");\\n        return ret;\\n    }\\n    function toUint8(uint val) internal pure returns (uint8) {\\n        uint8 ret = uint8(val);\\n        require(ret == val, \\\"toUint8 lost some value.\\\");\\n        return ret;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"Bad safe math multiplication.\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"Attempt to divide by zero in safe math.\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"Bad subtraction in safe math.\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"Bad addition in safe math.\\\");\\n\\n        return c;\\n    }\\n}\"},\"SimpleArbitrationInterface.sol\":{\"content\":\"pragma solidity 0.5.3;\\n\\n\\n\\ncontract SimpleArbitrationInterface {\\n    // -------------------------------------------------------------------------------------------\\n    // ----------------------------- internal helper functions -----------------------------------\\n    // -------------------------------------------------------------------------------------------\\n\\n    /// @dev This is a no-op when using simple arbitration.\\n    /// Extra arbitration data is only needed for ERC792 arbitration.\\n    function storeArbitrationExtraData(uint, bytes memory) internal { }\\n}\\n\"}}",
        "label": false,
        "name": "0xba5a6e8bbcda99932e86a0aa3f87ebdbe4b20c28.sol"
    },
    {
        "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract Owned{\r\n\r\n        address Owner;\r\n\r\n        modifier OnlyOwner{\r\n        if(msg.sender != Owner){\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n        function Owned(){\r\n        Owner = msg.sender;\r\n    }\r\n\r\n}\r\n\r\ncontract EtherTransfer is Owned{\r\n\r\n                uint constant Fee = 1;\r\n    uint constant Decs = 1000;\r\n\r\n    bool public IsEthereum = false; \r\n\r\n        event ETHTransfer(address indexed From,address indexed To, uint Value);\r\n    event ETCReturn(address indexed Return, uint Value);\r\n\r\n    event ETCTransfer(address indexed From,address indexed To, uint Value);\r\n    event ETHReturn(address indexed Return, uint Value);\r\n    \r\n        AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n        function EtherTransfer(){\r\n        IsEthereum = IsHeOnTheFork.forked();\r\n    }\r\n\r\n        function SendETH(address ETHAddress) returns(bool){\r\n        uint Value = msg.value - (msg.value*Fee/Decs);\r\n                if(IsEthereum && ETHAddress.send(Value)){\r\n            ETHTransfer(msg.sender, ETHAddress, Value);\r\n            return true;\r\n        }else if(!IsEthereum && msg.sender.send(msg.value)){\r\n            ETCReturn(msg.sender, msg.value);\r\n            return true;\r\n        }\r\n                throw;\r\n    }\r\n\r\n        function SendETC(address ETCAddress) returns(bool){\r\n        uint Value = msg.value - (msg.value*Fee/Decs);\r\n                if(!IsEthereum && ETCAddress.send(Value)){\r\n            ETCTransfer(msg.sender, ETCAddress, Value);\r\n            return true;\r\n        } else if(IsEthereum && msg.sender.send(msg.value)){\r\n            ETHReturn(msg.sender, msg.value);\r\n            return true;\r\n        }\r\n                throw;\r\n    }\r\n\r\n        function (){\r\n        throw;\r\n    }\r\n\r\n        function WithDraw() OnlyOwner returns(bool){\r\n        if(this.balance > 0 && Owner.send(this.balance)){\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n}",
        "label": false,
        "name": "0xc4216d17a72bd49e404fe396bb93c9cd8cf3e881.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN2(uint256 VAR4) public {\nFUN3(msg.sender, VAR4);\n}\nfunction FUN3(address VAR5, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR5]);\nVAR1[VAR5] = VAR1[VAR5].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON5 is CON2, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR6;\nfunction FUN4(address VAR7,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR7]);\nrequire(VAR4 <= VAR6[VAR7][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN5(address VAR8, uint256 VAR4) public returns (bool) {\nVAR6[msg.sender][VAR8] = VAR4;\nreturn true;\n}\nfunction FUN6(address VAR8,uint256 VAR9)\npublic\nreturns (bool)\n{\nVAR6[msg.sender][VAR8] = (VAR6[msg.sender][VAR8].add(VAR9));\nreturn true;\n}\nfunction FUN7(address VAR8,uint256 VAR10)\npublic\nreturns (bool)\n{\nuint256 VAR11 = VAR6[msg.sender][VAR8];\nif (VAR10 >= VAR11) {\nVAR6[msg.sender][VAR8] = 0;\n} else {\nVAR6[msg.sender][VAR8] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nfunction FUN8(address VAR7, uint256 VAR4) public {\nrequire(VAR4 <= VAR6[VAR7][msg.sender]);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR4);\nFUN3(VAR7, VAR4);\n}\n}\ncontract CON7 {\naddress public VAR12;\nconstructor() public {\nVAR12 = msg.sender;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN10() public FUN9 {\nVAR12 = address(0);\n}\nfunction FUN11(address VAR13) public FUN9 {\nFUN12(VAR13);\n}\nfunction FUN12(address VAR13) internal {\nrequire(VAR13 != address(0));\nVAR12 = VAR13;\n}\n}\ncontract CON8 is CON7 {\nbool public VAR14 = false;\nmodifier FUN13() {\nrequire(!VAR14);\n_;\n}\nmodifier FUN14() {\nrequire(VAR14);\n_;\n}\nfunction FUN15() FUN9 FUN13 public {\nVAR14 = true;\n}\nfunction FUN16() FUN9 FUN14 public {\nVAR14 = false;\n}\n}\ncontract CON9 is CON6, CON8 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN13\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN4(address VAR7,address VAR3,uint256 VAR4)\npublic\nFUN13\nreturns (bool)\n{\nreturn super.FUN4(VAR7, VAR3, VAR4);\n}\nfunction FUN5(address VAR8,uint256 VAR4)\npublic\nFUN13\nreturns (bool)\n{\nreturn super.FUN5(VAR8, VAR4);\n}\nfunction FUN6(address VAR8,uint VAR9)\npublic\nFUN13\nreturns (bool VAR15)\n{\nreturn super.FUN6(VAR8, VAR9);\n}\nfunction FUN7(address VAR8,uint VAR10)\npublic\nFUN13\nreturns (bool VAR15)\n{\nreturn super.FUN7(VAR8, VAR10);\n}\n}\ncontract CON10 is CON9 {\nstring public constant VAR16 = \"Streamity\";\nstring public constant VAR17 = \"STM\";\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 180000000 * (10 ** uint256(VAR18));\naddress public VAR20 = 0x464398aC8B96DdAd7e22AC37147822E1c69293Cb;\naddress public VAR21 = 0x84726199Ac1579684d58F4A47C4c85f2C45B5a11;\naddress public VAR22 = 0xa2C2f149e4b3EC671a61EAc9F12eAF2489e0Fb10;\naddress public VAR23 = 0xbBB9E0605f0BC7Af1B7238bAC2807a3A8DCb54b5;\naddress public VAR24 = 0xd69824B62D26E7f2316812b8c59F36328196Ca13;\nconstructor () public {\nVAR2 = VAR19;\nVAR1[VAR20] = 129780000 ether;\nVAR1[address(this)] = 50220000 ether;\n}\nuint VAR25 = 4650000 ether;\nuint VAR26 = 3720000 ether;\nfunction FUN17 () public FUN9 {\nrequire(now >= 1537833600);\nif (FUN1(VAR22, VAR26)) {\nVAR26 = 0;\n}\nif (FUN1(VAR23, VAR25)) {\nVAR25 = 0;\n}\n}\nuint VAR27 = 23250000 ether;\nuint VAR28 = 18600000 ether;\nfunction FUN18 () public FUN9 {\nrequire(now >= 1552348800);\nif (FUN1(VAR21, VAR28)) {\nVAR28 = 0;\n}\nif (FUN1(VAR24, VAR27)) {\nVAR27 = 0;\n}\n}\nfunction FUN19(address VAR3, uint VAR4) public FUN9 {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR20]);\nVAR1[VAR20] = VAR1[VAR20].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\n}\n}",
        "label": false,
        "name": "0x2e8c6bbe8e3aa834ef5a851b2cdfc52403d61b87.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 internal VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\n}\ncontract CON3 {\naddress public VAR10;\nconstructor() public {\nVAR10 = msg.sender;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR10);\n_;\n}\n}\ncontract CON4 is CON3 {\naddress public VAR11;\nmodifier FUN8() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN9(address VAR12) FUN7 public {\nVAR11 = VAR12;\n}\nfunction FUN10() FUN8 public {\nVAR10 = VAR11;\nVAR11 = address(0);\n}\n}\ncontract CON5 is CON2, CON4 {\nusing SafeMath for uint256;\nuint64 public constant VAR13 = 1542326400;\nstring public VAR14;\nstring public VAR15;\nuint8 public VAR16;\naddress public VAR17;\naddress public VAR18;\naddress public VAR19;\naddress public VAR20;\naddress public VAR21;\naddress public VAR22;\naddress public VAR23;\nmapping(address => uint64) public VAR24;\nconstructor (address VAR25,address VAR26,address VAR27,address VAR28,address VAR29,address VAR30,address VAR31,uint256 VAR32)\npublic\n{\nrequire(VAR25 != address(0));\nrequire(VAR26 != address(0));\nrequire(VAR27 != address(0));\nrequire(VAR28 != address(0));\nrequire(VAR29 != address(0));\nrequire(VAR30 != address(0));\nrequire(VAR31 != address(0));\nrequire(VAR32 > 0);\nVAR14 = \"Arround\";\nVAR15 = \"ARR\";\nVAR16 = 18;\nVAR17 = VAR25;\nVAR18 = VAR26;\nVAR19 = VAR27;\nVAR20 = VAR28;\nVAR21 = VAR29;\nVAR22 = VAR30;\nVAR23 = VAR31;\nVAR3 = VAR32 * (10 ** uint256(VAR16));\nVAR1[VAR25] = 1104000000 * (10 ** uint256(VAR16)); VAR1[VAR26] = 1251000000 * (10 ** uint256(VAR16)); VAR1[VAR27] = 150000000 * (10 ** uint256(VAR16)); VAR1[VAR28] = 105000000 * (10 ** uint256(VAR16)); VAR1[VAR29] = 45000000 * (10 ** uint256(VAR16)); VAR1[VAR30] = 300000000 * (10 ** uint256(VAR16)); VAR1[VAR31] = 45000000 * (10 ** uint256(VAR16)); require( VAR3 == 3000000000 * (10 ** uint256(VAR16)), \"Total Supply exceeded!!!\");\nVAR24[VAR30] = VAR13 + 31536000; VAR24[VAR28] = VAR13 + 31536000; VAR24[VAR29] = VAR13 + 63158400;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR17 ||msg.sender == VAR18 ||msg.sender == VAR19 ||msg.sender == VAR23);\n_;\n}\nfunction() external { }\nfunction FUN1(address VAR33, uint256 VAR34) public returns (bool) {\nrequire(VAR24[msg.sender] < now);\nreturn super.FUN1(VAR33, VAR34);\n}\nfunction FUN3(address VAR35, address VAR33, uint256 VAR34) public returns (bool) {\nrequire(VAR24[VAR35] < now);\nreturn super.FUN3(VAR35, VAR33, VAR34);\n}\nfunction FUN2(address VAR36, uint256 VAR34) public returns (bool) {\nrequire(VAR24[msg.sender] < now);\nreturn super.FUN2(VAR36, VAR34);\n}\nfunction FUN4(address VAR36, uint VAR37) public returns (bool VAR38) {\nrequire(VAR24[msg.sender] < now);\nreturn super.FUN4(VAR36, VAR37);\n}\nfunction FUN5(address VAR36, uint VAR39) public returns (bool VAR38) {\nrequire(VAR24[msg.sender] < now);\nreturn super.FUN5(VAR36, VAR39);\n}\nfunction FUN13(address[] calldata VAR40, uint256[] calldata VAR34 )\nexternal\nFUN11\nreturns (uint256 VAR41)\n{\nrequire(VAR40.length <= 255); require(VAR34.length == VAR40.length);\nuint8 VAR42 = uint8(VAR40.length);\nuint256 VAR43 = 0;\nfor (uint VAR44=0; VAR44<VAR42; VAR44++){\nVAR43 = VAR43.add(VAR34[VAR44]);\nrequire(VAR40[VAR44] != address(0));\nVAR1[VAR40[VAR44]] = VAR1[VAR40[VAR44]].add(VAR34[VAR44]);\n}\nrequire(VAR43 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR43);\nreturn VAR43;\n}\nfunction FUN14(CON2 VAR45) external FUN7 {\nrequire(address(VAR45) != address(0));\nuint256 VAR46 = VAR45.balanceOf(address(this));\nVAR45.FUN1(VAR10, VAR46);\n}\n}\n////**************************************************************",
        "label": false,
        "name": "0xcb089b8ae76b5df461d40e957603f7a59aea9e0d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() public payable { }\nfunction FUN7() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN8(address VAR4) FUN1 public {\nselfdestruct(VAR4);\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON3 {\nstruct Monster {\nuint64 VAR5;\nuint8 VAR6;\nuint16 VAR7;\nuint16 VAR8;\n}\nCON4 public VAR9 = CON4(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\nuint8 public constant VAR10 = 4;\nuint8 public constant VAR11 = 8;\nuint8 public constant VAR12 = 12;\nuint public constant VAR13 = 3;\nuint16 public VAR14 = 10;\nuint public VAR15 = 4;\nuint64 public VAR16 = 8 minutes;\nuint public VAR17 = 0.04 ether;\nuint public VAR18 = 0.1 ether;\nuint public VAR19;\nuint VAR20;\nmapping(uint => Monster) public VAR21;\nmapping(uint => uint) public VAR22;\nmapping(uint => uint) public VAR23;\nfunction FUN9() public payable {}\nfunction FUN10(uint VAR24) FUN3 FUN15 external payable {\nuint VAR25;\naddress VAR1;\n(,,, VAR25, VAR1,,) = VAR9.getHeroDetails(VAR24);\nrequire(msg.sender == VAR1);\nuint VAR26 = (VAR25 / (32 ** 12)) % 32 + 1;\nuint VAR27 = (VAR25 / (32 ** 8)) % 32 + 1;\nMonster memory VAR28 = VAR21[VAR24];\nuint VAR29 = VAR28.VAR6;\nuint VAR30 = VAR22[VAR24];\nbool VAR31;\nif (VAR29 == 0) {\nrequire(msg.value >= VAR17);\nVAR19 += VAR17;\nVAR21[VAR24] = Monster(uint64(now), 1, VAR14, VAR14);\nVAR28 = VAR21[VAR24];\nVAR22[VAR24] = VAR26;\nVAR30 = VAR26;\nif (msg.value > VAR17) {\nmsg.sender.transfer(msg.value - VAR17);\n}\n} else {\nrequire(VAR30 > 0);\nVAR31 = now > VAR28.VAR5 + VAR16 * 2 ||\n(VAR28.VAR8 == VAR28.VAR7 && now > VAR28.VAR5 + VAR16);\nif (VAR31) {\nuint VAR32 = VAR17 - VAR23[VAR24];\nVAR18 += VAR32;\nVAR19 -= VAR32;\nassert(VAR32 <= VAR17);\n}\nmsg.sender.transfer(msg.value);\n}\nif (!VAR31) {\nFUN13(VAR24, VAR25, VAR27, VAR30);\n}\n}\nfunction FUN11(address VAR33) FUN1 external {\nVAR9 = CON4(VAR33);\n}\nfunction FUN12(uint VAR34) FUN1 external {\nVAR17 = VAR34;\n}\nfunction FUN13(uint VAR24, uint VAR35, uint VAR36, uint VAR37) internal {\nMonster storage VAR28 = VAR21[VAR24];\nuint8 VAR29 = VAR28.VAR6;\nuint VAR38;\n(VAR38,,,,) = VAR9.getHeroPower(VAR35, VAR13);\nuint VAR39;\nif (now > VAR28.VAR5 + VAR16) {\nVAR39 = VAR29 + VAR15;\n} else {\nif (VAR29 >= 2) {\nVAR39 = FUN14(VAR29 / 2);\n}\n}\nif (VAR39 >= VAR37) {\nVAR22[VAR24] = 0;\nuint VAR32 = VAR17 - VAR23[VAR24];\nVAR18 += VAR32;\nVAR19 -= VAR32;\nassert(VAR32 <= VAR17);\n} else {\nVAR22[VAR24] -= VAR39;\nVAR29++;\nVAR21[VAR24] = Monster(uint64(VAR28.VAR5 + VAR16),VAR29, VAR29 * VAR14, VAR29 * VAR14);\nVAR28 = VAR21[VAR24];\n}\nuint VAR40 = (VAR36 + VAR38 / (10 * (1 + FUN14(5)))) / tx.gasprice / 1e9;\nbool VAR41 = VAR40 >= VAR28.VAR8;\nuint VAR42;\nif (VAR41) {\nuint8 VAR43 = VAR29 + 1;\nVAR21[VAR24] = Monster(uint64(now), VAR43, VAR43 * VAR14, VAR43 * VAR14);\nVAR28 = VAR21[VAR24];\nif (VAR29 == VAR10) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR11) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR12) {\nVAR42 = VAR18 / 2;\nVAR18 -= VAR42;\n}\nmsg.sender.transfer(VAR42);\n} else {\nVAR28.VAR8 -= uint8(VAR40);\n}\n}\nfunction FUN14(uint VAR44) private returns (uint) {\nVAR20 = uint(keccak256(VAR20,block.blockhash(block.number - 1),block.coinbase,block.difficulty));\nreturn VAR20 % VAR44;\n}\nmodifier FUN15() {\naddress VAR45 = msg.sender;\nuint VAR46;\nassembly { VAR46 := extcodesize(VAR45) }\nrequire(VAR46 == 0);\n_;\n}\n}",
        "label": false,
        "name": "0xeb84356cd552869cf60b7e5e164f681bfee92cde.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON4, CON1 {\nfunction FUN8(uint256 VAR6) public {\nFUN9(msg.sender, VAR6);\n}\nfunction FUN9(address VAR13, uint256 VAR6) internal{\nrequire(VAR6 <= VAR4[VAR13]);\nVAR4[VAR13] = VAR4[VAR13].sub(VAR6);\nVAR3 = VAR3.sub(VAR6);\n}\n}\ncontract CON7 is CON5, CON1 {\nmodifier FUN10() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN11(address VAR5, uint256 VAR14)\nFUN10\npublic\nreturns (bool)\n{\nVAR3 = VAR3.add(VAR14);\nVAR4[VAR5] = VAR4[VAR5].add(VAR14);\nreturn true;\n}\n}\ncontract CON8 is CON1 {\nbool public VAR15 = false;\nmodifier FUN12() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN13() {\nrequire(VAR15);\n_;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR15 = true;\n}\nfunction FUN15() FUN1 FUN13 public {\nVAR15 = false;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN12 returns (bool VAR16) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN12 returns (bool VAR16) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON10 is CON9, CON7, CON6 {\nstring public constant VAR17 = \"VARO\";\nstring public constant VAR18 = \"VARO\";\nuint8 public constant VAR19 = 2;\n}",
        "label": false,
        "name": "0xa64e816f4eb895533f93e0aecb79468ab57d00ff.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing TokenLib for TokenLib.Token;\nmapping (address => bool) public VAR1;\nuint constant VAR2 = 1474502400;\nfunction FUN1() constant returns (uint) {\nreturn VAR2;\n}\nfunction CON2() {\nVAR1[msg.sender] = true;\n}\nuint VAR3;\nmapping (bytes32 => TokenLib.Token) VAR4;\nmapping (address => bytes32) public VAR5;\nmapping (address => mapping (address => bytes32)) VAR6;\nfunction FUN2(address VAR7, string VAR8) returns (bool VAR9) {\nif (now >= VAR2) throw;\nif (!VAR1[msg.sender]) return false;\nif (VAR5[VAR7] != 0x0) return false;\nbytes32 VAR10 = TokenLib.generateId(VAR8);\nvar VAR11 = VAR4[VAR10];\nif (VAR10 == VAR11.VAR10()) return false;\nVAR11.VAR25 = VAR7;\nVAR11.VAR24 = VAR8;\nVAR5[VAR7] = VAR10;\nVAR3 += 1;\nreturn true;\n}\nfunction FUN3(bytes32 VAR12) returns (bool VAR9) {\nif (now >= VAR2) throw;\nif (!VAR1[msg.sender]) return false;\nvar VAR13 = VAR4[VAR12];\nVAR5[VAR13.VAR25] = 0x0;\nVAR13.VAR24 = '';\nVAR13.VAR25 = 0x0;\nVAR3 -= 1;\nreturn true;\n}\nfunction FUN4(address VAR14) returns (bool) {\nif (now >= VAR2) throw;\nif (!VAR1[msg.sender]) return false;\nVAR1[VAR14] = true;\nreturn true;\n}\nfunction FUN5(address VAR14) returns (bool) {\nif (!VAR1[msg.sender]) return false;\nVAR1[VAR14] = false;\nreturn true;\n}\nfunction FUN6(address VAR7, uint256 VAR15) returns (bool VAR9) {\nreturn FUN6(VAR7, bytes32(VAR15));\n}\nfunction FUN6(address VAR7, bytes32 VAR15) returns (bool VAR9) {\nif (VAR15 == 0x0) return false;\nif (VAR4[VAR15].VAR10() != VAR15) return false;\nif (VAR5[VAR7] != 0x0) return false;\nvar VAR16 = VAR4[VAR15];\nif (VAR16.VAR25 != msg.sender) return false;\nVAR16.VAR25 = VAR7;\nVAR5[msg.sender] = 0x0;\nVAR5[VAR7] = VAR15;\nTokenLib.logTransfer(msg.sender, VAR7, VAR15);\nreturn true;\n}\nfunction FUN7(address VAR17, address VAR7, uint256 VAR15) returns (bool VAR9) {\nreturn FUN7(VAR17, VAR7, bytes32(VAR15));\n}\nfunction FUN7(address VAR17, address VAR7, bytes32 VAR15) returns (bool VAR9) {\nif (VAR15 == 0x0) return false;\nif (VAR4[VAR15].VAR10() != VAR15) return false;\nif (VAR5[VAR7] != 0x0) return false;\nvar VAR16 = VAR4[VAR15];\nif (VAR16.VAR25 != VAR17) return false;\nif (VAR5[VAR17] != VAR15) return false;\nif (VAR6[VAR17][msg.sender] != VAR15) return false;\nVAR16.VAR25 = VAR7;\nVAR5[VAR17] = 0x0;\nVAR5[VAR7] = VAR15;\nVAR6[VAR17][msg.sender] = 0x0;\nTokenLib.logTransfer(VAR17, VAR7, VAR15);\nreturn true;\n}\nfunction FUN8(address VAR18, uint256 VAR15) returns (bool VAR9) {\nreturn FUN8(VAR18, bytes32(VAR15));\n}\nfunction FUN8(address VAR18, bytes32 VAR15) returns (bool VAR9) {\nif (VAR15 == 0x0) return false;\nif (VAR4[VAR15].VAR10() != VAR15) return false;\nvar VAR19 = VAR4[VAR15];\nif (VAR19.VAR25 != msg.sender) return false;\nif (VAR5[msg.sender] != VAR15) return false;\nVAR6[msg.sender][VAR18] = VAR15;\nTokenLib.logApproval(msg.sender, VAR18, VAR15);\nreturn true;\n}\nfunction FUN9() returns (uint VAR20) {\nreturn VAR3;\n}\nfunction FUN10(address VAR21) constant returns (uint256 VAR22) {\nreturn uint(VAR5[VAR21]);\n}\nfunction FUN11(address VAR21, address VAR18) constant returns (uint256 VAR23) {\nreturn uint(VAR6[VAR21][VAR18]);\n}\nfunction FUN12(address VAR21) constant returns (bool) {\nreturn (VAR5[VAR21] != 0x0 && VAR4[VAR5[VAR21]].VAR25 == VAR21);\n}\nfunction FUN13(bytes32 VAR12) constant returns (string VAR24) {\nreturn VAR4[VAR12].VAR24;\n}\nfunction FUN14(bytes32 VAR12) constant returns (address VAR25) {\nreturn VAR4[VAR12].VAR25;\n}\n}",
        "label": false,
        "name": "0x0a43edfe106d295e7c1e591a4b04b5598af9474c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nstruct Disclosure {\nbytes32 VAR2;\nbytes32 VAR3;\nbytes32 VAR4;\nbytes16 VAR5;\nbytes1 VAR6;\nbytes16 VAR7;\nbytes32 VAR8;\nbytes32 VAR9;\nuint VAR10; }\nDisclosure[] public VAR11;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() { if (msg.sender != VAR1) revert(); _ ;}\nfunction FUN2() public constant returns(uint VAR12) {\nif (VAR11.length > 0) {\nreturn VAR11.length - 1; } else {\nreturn 0; }\n}\nfunction FUN3(bytes32 VAR2,bytes32 VAR3,bytes32 VAR4,bytes16 VAR5,bytes1 VAR6,bytes16 VAR7,bytes32 VAR8,bytes32 VAR9) public FUN1() returns(uint VAR13) {\nif (VAR11.length == 0) {\nDisclosure memory VAR14;\nVAR11.push(VAR14);\n}\nDisclosure memory VAR15;\nVAR15.VAR2 = VAR2;\nVAR15.VAR3 = VAR3;\nVAR15.VAR4 = VAR4;\nVAR15.VAR5 = VAR5;\nVAR15.VAR6 = VAR6;\nVAR15.VAR7 = VAR7;\nVAR15.VAR8 = VAR8;\nVAR15.VAR9 = VAR9;\nVAR15.VAR10 = 0;\nuint VAR16 = VAR11.push(VAR15); VAR16 = VAR16 - 1;\nreturn VAR16; }\nfunction FUN4(uint VAR13,bytes32 VAR2,bytes32 VAR3,bytes32 VAR4,bytes16 VAR5,bytes1 VAR6,bytes16 VAR7,bytes32 VAR8,bytes32 VAR9) public FUN1() returns(uint VAR17) {\nif (VAR13 >= VAR11.length) { revert(); }\nif (VAR13 < 1) { revert(); }\nif (VAR11[VAR13].VAR10 > 0) { revert(); }\nDisclosure memory VAR15;\nVAR15.VAR2 = VAR2;\nVAR15.VAR3 = VAR3;\nVAR15.VAR4 = VAR4;\nVAR15.VAR5 = VAR5;\nVAR15.VAR6 = VAR6;\nVAR15.VAR7 = VAR7;\nVAR15.VAR8 = VAR8;\nVAR15.VAR9 = VAR9;\nVAR15.VAR10 = 0;\nuint VAR16 = VAR11.push(VAR15); VAR16 = VAR16 - 1;\nVAR11[VAR13].VAR10 = VAR16;\nreturn VAR16; }\nfunction FUN5(uint VAR13) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32, uint) {\nif (VAR13 >= VAR11.length) { revert(); }\nif (VAR13 < 1) { revert(); }\nDisclosure memory VAR18 = VAR11[VAR13];\nreturn (VAR18.VAR2, VAR18.VAR3, VAR18.VAR4, VAR18.VAR5, VAR18.VAR6, VAR18.VAR7, VAR18.VAR8, VAR18.VAR9, VAR18.VAR10);\n}\nfunction FUN6(uint VAR13) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32) {\nif (VAR13 >= VAR11.length) { revert(); }\nif (VAR13 < 1) { revert(); }\nif (VAR11[VAR13].VAR10 > 0) return FUN6(VAR11[VAR13].VAR10);\nDisclosure memory VAR18 = VAR11[VAR13];\nreturn (VAR18.VAR2, VAR18.VAR3, VAR18.VAR4, VAR18.VAR5, VAR18.VAR6, VAR18.VAR7, VAR18.VAR8, VAR18.VAR9);\n}\n}",
        "label": false,
        "name": "0xff77e51f2c6473f72392865e0a0000de19af774a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() public FUN6 FUN10 returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR15;\nconstructor(uint256 VAR16) public {\nrequire(VAR16 > 0);\nVAR15 = VAR16;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\npublic\nreturns (bool)\n{\nrequire(VAR2.add(VAR14) <= VAR15);\nreturn super.FUN12(VAR3, VAR14);\n}\n}\ncontract CON8 is CON5 {\nbool public VAR17 = false;\nmodifier FUN14() {\nrequire(!VAR17);\n_;\n}\nmodifier FUN15() {\nrequire(VAR17);\n_;\n}\nfunction FUN16() public FUN6 FUN14 {\nVAR17 = true;\n}\nfunction FUN17() public FUN6 FUN15 {\nVAR17 = false;\n}\n}\ncontract CON9 is CON4, CON8 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN3(address VAR7,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4);\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nFUN14\nreturns (bool VAR18)\n{\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nFUN14\nreturns (bool VAR18)\n{\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON10 is CON7, CON9 {\nstring public constant VAR19 = \"Enecuum\"; string public constant VAR20 = \"ENQ\"; uint8 public constant VAR21 = 10;\nuint256 public VAR15 = 687566880 * (10 ** uint256(VAR21));\nuint256 public constant VAR22 = 99901437 * (10 ** uint256(VAR21));\nconstructor(address VAR23)\npublic\nCON7(VAR15)\n{ require(VAR23 != address(0));\nVAR2 = VAR22;\nVAR1[VAR23] = VAR22;\n}\n}",
        "label": false,
        "name": "0x16ea01acb4b0bca2000ee5473348b6937ee6f72f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint private VAR18 = 10000000000e8;\nconstructor () public\nCON3(\"LNKO Token\", \"LNKO\", 8)\n{\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x11afe7fa792589dd1236257f99ba09f510460ad9.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor() public {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4,uint256 VAR5)\npublic\nFUN10\nreturns (bool)\n{\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nfunction FUN16(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN17(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON6 is CON5, CON4 {\nstring public constant VAR12 = \"ALLMEDICOIN\";\nstring public constant VAR13 = \"AMDC\";\nuint8 public constant VAR14 = 18;\nuint256 public constant VAR15 = 99000000000 * (10 ** uint256(VAR14));\nconstructor(address VAR16) public {\nFUN7(VAR16, VAR15);\n}\n}",
        "label": false,
        "name": "0xfb61d5a3ac90ee74ce345173394b9ad88347c7f3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nmapping (address => uint256) VAR3;\nmapping (address => mapping (address => uint256)) VAR4;\nmapping (address => bool) public VAR5;\nmapping (address => bool) public VAR6;\nstring public VAR7 = \"Taylor\";\nstring public VAR8 = \"TAY\";\nuint8 public VAR9 = 18;\nuint256 constant internal VAR10 = 10**18;\nuint256 public VAR11 = 10**7 * VAR10;\nbool public VAR12 = false;\nmodifier FUN3(){\nif(!VAR5[msg.sender]){\nrequire(VAR12);\n}\n_;\n}\nfunction CON2()\nCON1()\npublic\n{\nVAR3[VAR1] = VAR3[VAR1].add(VAR11);\nVAR5[msg.sender] = true;\nVAR6[msg.sender] = true;\n}\nfunction FUN4()\npublic\nFUN1\n{\nVAR12 = true;\n}\nfunction FUN5(address VAR13)\npublic\nFUN1\n{\nVAR5[VAR13] = true;\n}\nfunction FUN6(address VAR14)\npublic\nFUN1\n{\nVAR5[VAR14] = true;\nFUN8(VAR14, VAR3[VAR1]);\n}\nfunction FUN7(address VAR13)\npublic\nFUN1\n{\nVAR6[VAR13] = true;\n}\nfunction FUN8(address VAR15, uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17)\n{\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR16);\nVAR3[VAR15] = VAR3[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN9\n(address VAR18,address VAR15,uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17) {\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR3[VAR18]);\nrequire(VAR16 <= VAR4[VAR18][msg.sender]);\nVAR3[VAR18] = VAR3[VAR18].sub(VAR16);\nVAR3[VAR15] = VAR3[VAR15].add(VAR16);\nVAR4[VAR18][msg.sender] = VAR4[VAR18][msg.sender].sub(VAR16);\nreturn true;\n}\nfunction FUN10(address VAR19, uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17)\n{\nVAR4[msg.sender][VAR19] = VAR16;\nreturn true;\n}\nfunction FUN11(address VAR19, uint VAR20)\npublic\nreturns (bool)\n{\nVAR4[msg.sender][VAR19] = VAR4[msg.sender][VAR19].add(VAR20);\nreturn true;\n}\nfunction FUN12(address VAR19, uint VAR21)\npublic\nreturns (bool)\n{\nuint VAR22 = VAR4[msg.sender][VAR19];\nif (VAR21 > VAR22) {\nVAR4[msg.sender][VAR19] = 0;\n} else {\nVAR4[msg.sender][VAR19] = VAR22.sub(VAR21);\n}\nreturn true;\n}\nfunction FUN13(uint256 VAR23)\npublic\nreturns (bool VAR17)\n{\nrequire(VAR6[msg.sender]);\nrequire(VAR23 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR23);\nVAR11 = VAR11.sub(VAR23);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc4d557d795ce16c49624e48045b380f169e4113f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR12, address VAR13, uint VAR14) public {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN5(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN8(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN7(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN9(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN10(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN4(address VAR12, address VAR13, uint VAR14) FUN1 public {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN11(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN12(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN13(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN14() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN15(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN5(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x660097ac421d0d9efcb26705f7431c886575a337.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmodifier FUN1() {\nrequire(FUN2(msg.VAR17));\n_;\n}\nfunction CON1() { VAR1 = msg.VAR17; }\nfunction FUN2(address VAR2) public returns(bool) { return VAR2 == VAR1; }\nfunction FUN3(address VAR3) public FUN1 {\nif (VAR3 != address(this)) {\nVAR1 = VAR3;\n}\n}\n}\ncontract CON2 is CON1 {\nfunction () payable { }\nfunction FUN5(address VAR4, uint VAR5, bytes VAR6) public FUN1 {\nrequire(VAR4.call.VAR5(VAR5)(VAR6));\n}\n}\ncontract CON3 {\nuint VAR7;\nuint VAR8;\nuint VAR9;\naddress VAR10;\nmapping(address => mapping(address => uint)) VAR11;\nmapping(address => address) VAR12;\nmapping(address => mapping(address => uint)) VAR13;\nmapping(address => uint) public VAR14;\nmapping(address => address) public VAR15;\nmodifier FUN6() {\nrequire(msg.VAR17 == VAR10 || FUN22(msg.VAR17));\n_;\n}\nmodifier FUN1(address VAR16, address VAR17) {\nrequire(FUN2(VAR16, VAR17));\n_;\n}\nmodifier FUN7(address VAR16, address VAR17) {\nrequire(FUN23(VAR16, VAR17));\n_;\n}\nmodifier FUN8(address VAR16, address VAR17) {\nrequire(VAR12[VAR16] == VAR17);\n_;\n}\nmodifier FUN9(CON2 VAR16, address VAR17) {\nrequire(VAR13[VAR16][VAR17] < (now - VAR9));\nVAR13[VAR16][VAR17] = now;\n_;\n}\nmodifier FUN10(address VAR2) { require(VAR2 != address(0));\n_;\n}\nfunction CON3(uint VAR18, uint VAR19, uint VAR20, address VAR21) {\nrequire(VAR19 >= VAR18);\nVAR7 = VAR19;\nVAR8 = VAR18;\nVAR9 = VAR20;\nVAR10 = VAR21;\n}\nfunction FUN11(address VAR1, address VAR22) public FUN10(VAR22) {\nCON2 VAR16 = new CON2();\nVAR11[VAR16][VAR1] = now - VAR7; VAR12[VAR16] = VAR22;\n}\nfunction FUN12(address VAR1, address VAR22, address VAR4, bytes VAR6) public FUN10(VAR22) {\nCON2 VAR16 = new CON2();\nVAR11[VAR16][VAR1] = now - VAR7; VAR12[VAR16] = VAR22;\nVAR16.FUN5(VAR4, 0, VAR6);\n}\nfunction FUN13(address VAR1, address VAR22) public FUN10(VAR22) {\nrequire(VAR12[msg.VAR17] == 0); VAR11[msg.VAR17][VAR1] = now - VAR7; VAR12[msg.VAR17] = VAR22;\n}\nfunction FUN14(address VAR17, CON2 VAR16, address VAR4, uint VAR5, bytes VAR6) public\nFUN6\nFUN1(VAR16, VAR17)\n{\nVAR16.FUN5(VAR4, VAR5, VAR6);\n}\nfunction FUN15(address VAR17, CON2 VAR16, address VAR3) public\nFUN6\nFUN7(VAR16, VAR17)\nFUN9(VAR16, VAR17)\n{\nrequire(!FUN2(VAR16, VAR3));\nVAR11[VAR16][VAR3] = now - VAR8;\n}\nfunction FUN16(address VAR17, CON2 VAR16, address VAR3) public\nFUN6\nFUN8(VAR16, VAR17)\nFUN9(VAR16, VAR17)\n{\nrequire(!FUN2(VAR16, VAR3));\nVAR11[VAR16][VAR3] = now;\n}\nfunction FUN17(address VAR17, CON2 VAR16, address VAR1) public\nFUN6\nFUN7(VAR16, VAR17)\nFUN9(VAR16, VAR17)\n{\nrequire(VAR17 != VAR1);\ndelete VAR11[VAR16][VAR1];\n}\nfunction FUN18(address VAR17, CON2 VAR16, address VAR22) public\nFUN6\nFUN7(VAR16, VAR17)\nFUN9(VAR16, VAR17)\nFUN10(VAR22)\n{\nVAR12[VAR16] = VAR22;\n}\nfunction FUN19(address VAR17, CON2 VAR16, address VAR23) public\nFUN6\nFUN7(VAR16, VAR17)\n{\nVAR14[VAR16] = now;\nVAR15[VAR16] = VAR23;\n}\nfunction FUN20(address VAR17, CON2 VAR16) public\nFUN6\nFUN1(VAR16, VAR17)\n{\naddress VAR24 = VAR15[VAR16];\ndelete VAR14[VAR16];\ndelete VAR15[VAR16];\n}\nfunction FUN21(address VAR17, CON2 VAR16) FUN6 FUN7(VAR16, VAR17) {\nrequire(VAR14[VAR16] != 0 && VAR14[VAR16] + VAR7 < now);\naddress VAR23 = VAR15[VAR16];\ndelete VAR14[VAR16];\ndelete VAR15[VAR16];\nVAR16.FUN3(VAR23);\ndelete VAR12[VAR16];\ndelete VAR11[VAR16][VAR17];\n}\nfunction FUN22(address VAR25) internal constant returns (bool VAR26) {\nif (msg.VAR6.length < 36) return false;\nassembly {\nlet mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nVAR26 := eq(VAR25, and(mask, calldataload(4)))\n}\n}\nfunction FUN2(address VAR16, address VAR1) public constant returns (bool) {\nreturn (VAR11[VAR16][VAR1] > 0 && (VAR11[VAR16][VAR1] + VAR8) <= now);\n}\nfunction FUN23(address VAR16, address VAR1) public constant returns (bool) {\nreturn (VAR11[VAR16][VAR1] > 0 && (VAR11[VAR16][VAR1] + VAR7) <= now);\n}\nfunction FUN24(address VAR16, address VAR22) public constant returns (bool) {\nreturn VAR12[VAR16] == VAR22;\n}\n}",
        "label": false,
        "name": "0x27500ae27b6b6ad7de7d64b1def90f3e6e7ced47.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 {\nusing SafeMath for uint256;\nCON1 public VAR2;\nuint64 public VAR3 = 1538352000;\nuint64 public VAR4 = 1554076800;\nmapping(address => uint256) public VAR5;\nmapping(address => uint256) public VAR6;\naddress VAR7 = 0x0134111c40D59E8476FfabB7D0B2ED6F86513E6e; address VAR8 = 0x7B8E11cFE4E7aFec83276002dD246a71a4bD51EC; address VAR9 = 0xFDA80FA2b42063F5c2Aa14C5da18cBBDfC2f72F8;\naddress VAR10 = 0x5edc1959772b3C63310f475E04a72CdA1733D6A4; address VAR11 = 0x45F8da4a6f465345DdaF003094C2B9D11254B15D; address VAR12 =0x5f77b7F905913431957E800BfbDF5a9DB1B911C7; address VAR13 =0x0Ecff5AA3F6bEcA65e0c39660b8A410c62d18F05; address VAR14 =0xb19f59271B64A2f8240b62Dbd6EEDFF38f6778DD; address VAR15 =0x8a51B8Bc84272E375D2d46A8b29B1E245F2a9248; address VAR16 =0x3B820FDabc92d338E3625BbA2F81366df1C417d6; address VAR17 =0xb3B142e2Edccfb844c83CCcc872cFd8A13505240;\naddress VAR18 = 0xC4Eb8BfFBAA3BC5dF11bdFD2e3800ed88EE0e5c7; address VAR19 = 0xCd25FF018807bd8082E27AD7E12A28964c17159D; address VAR20 =0x05D6b898701961452298D09B87f072239D836Cf4; address VAR21 =0x6BC2ee50CD8491745fD45Fb3a8E400BEdb2e02df; address VAR22 =0x8bfDedbB38ee8e6354BeffdAC26F0c64bBAB4F1d; address VAR23 =0x4BCce99dD86DC640DCd76510aC7E68be67b44dD9; address VAR24 =0x28C6d5D60A57046778be226c1Fea9def8B7bC067; address VAR25 =0x00D56900f9D2d559A89fAEfe2CfbB464B1368dEe; address VAR26 =0x241B9F4eeC66bE554378b1C9fF93FD4aaC0bD31c; address VAR27 =0x536917d509117ccC26171E21CC51335d0b8022CE; address VAR28 =0xf818199304A658B770eEcb85F2ad891D1B582beB; address VAR29 =0x88Aec59d98b2dBEde71F96a5C8044D5b619955C0; address VAR30 =0x35b3bDb3aC3c1c834fb5e9798a6cB9Db97caF370; address VAR31 =0x9CA083D10fC4944F22654829Ac2E9702Ecce204F; address VAR32 =0xBfD84a9641849B07271919AD2ad5F2453F4BF06c; address VAR33 =0x7Ff40441F748229A004bc15e70Fccf3c82A51874; address VAR34 =0xE7B45875d2380113eC3F76E7B7a44549C368E523; address VAR35 =0xB46C56C97664152F77B26c5D0b8B5f1CB642A84E; address VAR36 =0x897a133c4f01aEf11c58fd9Ec0c7932552a39C9f; address VAR37 =0xd9537D3cf1a2624FA309c0AA65ac9eaAE350ef1D; address VAR38 =0x4E4c22151f47D2C236Ac9Ec5D4fC2B46c58b34dE;\nfunction CON2(address VAR39) public {\nVAR2 = CON1(VAR39);\nVAR5[VAR7] = 6840000 * 1 ether; VAR5[VAR8] = 6840000 * 1 ether; VAR5[VAR9] = 320000 * 1 ether;\nVAR5[VAR10] = 900000 * 1 ether; VAR5[VAR11] = 540000 * 1 ether; VAR5[VAR12] = 900000 * 1 ether; VAR5[VAR13] = 180000 * 1 ether; VAR5[VAR14] =900000 * 1 ether; VAR5[VAR15] =180000 * 1 ether; VAR5[VAR16] =180000 * 1 ether; VAR5[VAR17] =180000 * 1 ether;\nVAR5[VAR18] = 250000 * 1 ether; VAR5[VAR19] = 100000 * 1 ether; VAR5[VAR20] = 75000 * 1 ether; VAR5[VAR21] = 75000 * 1 ether; VAR5[VAR22] = 75000 * 1 ether; VAR5[VAR23] = 75000 * 1 ether; VAR5[VAR24] = 75000 * 1 ether; VAR5[VAR25] = 75000 * 1 ether; VAR5[VAR26] = 100000 * 1 ether; VAR5[VAR27] = 100000 * 1 ether; VAR5[VAR28] = 100000 * 1 ether; VAR5[VAR29] = 100000 * 1 ether; VAR5[VAR30] = 100000 * 1 ether; VAR5[VAR31] = 100000 * 1 ether; VAR5[VAR32] = 100000 * 1 ether; VAR5[VAR33] = 50000 * 1 ether; VAR5[VAR34] = 50000 * 1 ether; VAR5[VAR35] = 50000 * 1 ether; VAR5[VAR36] = 50000 * 1 ether; VAR5[VAR37] = 50000 * 1 ether; VAR5[VAR38] = 50000 * 1 ether;\nVAR6[VAR7] = VAR5[VAR7];\nVAR6[VAR8] = VAR5[VAR8];\nVAR6[VAR9] = VAR5[VAR9];\nVAR6[VAR10] = VAR5[VAR10];\nVAR6[VAR11] = VAR5[VAR11];\nVAR6[VAR12] = VAR5[VAR12];\nVAR6[VAR13] = VAR5[VAR13];\nVAR6[VAR14] = VAR5[VAR14];\nVAR6[VAR15] = VAR5[VAR15];\nVAR6[VAR16] = VAR5[VAR16];\nVAR6[VAR17] = VAR5[VAR17];\nVAR6[VAR18] = VAR5[VAR18];\nVAR6[VAR19] = VAR5[VAR19];\nVAR6[VAR20] = VAR5[VAR20];\nVAR6[VAR21] = VAR5[VAR21];\nVAR6[VAR22] = VAR5[VAR22];\nVAR6[VAR23] = VAR5[VAR23];\nVAR6[VAR24] = VAR5[VAR24];\nVAR6[VAR25] = VAR5[VAR25];\nVAR6[VAR26] = VAR5[VAR26];\nVAR6[VAR27] = VAR5[VAR27];\nVAR6[VAR28] = VAR5[VAR28];\nVAR6[VAR29] = VAR5[VAR29];\nVAR6[VAR30] = VAR5[VAR30];\nVAR6[VAR31] = VAR5[VAR31];\nVAR6[VAR32] = VAR5[VAR32];\nVAR6[VAR33] = VAR5[VAR33];\nVAR6[VAR34] = VAR5[VAR34];\nVAR6[VAR35] = VAR5[VAR35];\nVAR6[VAR36] = VAR5[VAR36];\nVAR6[VAR37] = VAR5[VAR37];\nVAR6[VAR38] = VAR5[VAR38];\n}\nfunction FUN1() public {\nrequire(VAR3 <= uint64(now));\nVAR2.transfer(msg.sender, VAR5[msg.sender]);\n}\nfunction FUN2() public {\nrequire(VAR4 <= uint64(now));\nVAR2.transfer(msg.sender, VAR6[msg.sender]);\n}\n}",
        "label": false,
        "name": "0xce5e040786513702fa21a36f465d3be77c48930d.sol"
    },
    {
        "source": "{\"AIV.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\n\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\ninterface IProxy {\\n  function isDeployer(address _address) external view returns(bool);\\n}\\n\\ninterface IEntryPoint {\\n  function getProxyAddress() external view returns(address);\\n}\\n\\n\\n\\n\\n\\n\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n  \\n  constructor() internal {\\n    _owner = msg.sender;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  \\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  \\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  \\n  function isOwner() public view returns (bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  \\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  \\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  \\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\\ncontract ERC20 is IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  \\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  \\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  \\n  function allowance(address owner, address spender) public view returns (uint256) {\\n    return _allowed[owner][spender];\\n  }\\n\\n  \\n  function transfer(address to, uint256 value) public returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  \\n  function approve(address spender, uint256 value) public returns (bool) {\\n    _approve(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  \\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n    _transfer(from, to, value);\\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n    return true;\\n  }\\n\\n  \\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  \\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n    return true;\\n  }\\n\\n  \\n  function _transfer(address from, address to, uint256 value) internal {\\n    require(to != address(0));\\n    require(value \\u003c= _balances[from]);\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  \\n  function _mint(address account, uint256 value) internal {\\n    require(account != address(0));\\n\\n    _totalSupply = _totalSupply.add(value);\\n    _balances[account] = _balances[account].add(value);\\n    emit Transfer(address(0), account, value);\\n  }\\n\\n\\n  \\n  function _approve(address owner, address spender, uint256 value) internal {\\n    require(spender != address(0));\\n    require(owner != address(0));\\n    _allowed[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n}\\n\\ncontract MinterRole is Ownable {\\n  using Roles for Roles.Role;\\n\\n  event MinterAdded(address indexed account);\\n  event MinterRemoved(address indexed account);\\n\\n  Roles.Role private _minters;\\n\\n  constructor () internal {\\n    _addMinter(msg.sender);\\n  }\\n\\n  modifier onlyMinter() {\\n    require(isMinter(msg.sender));\\n    _;\\n  }\\n\\n  function isMinter(address account) public view returns (bool) {\\n    return _minters.has(account);\\n  }\\n\\n  function addMinter(address account) public onlyOwner {\\n    _addMinter(account);\\n  }\\n\\n  function removeMinter(address account) public onlyOwner {\\n    _removeMinter(account);\\n  }\\n\\n  function _addMinter(address account) internal {\\n    _minters.add(account);\\n    emit MinterAdded(account);\\n  }\\n\\n  function _removeMinter(address account) internal {\\n    _minters.remove(account);\\n    emit MinterRemoved(account);\\n  }\\n}\\n\\ncontract PauserRole is Ownable {\\n  using Roles for Roles.Role;\\n\\n  event PauserAdded(address indexed account);\\n  event PauserRemoved(address indexed account);\\n\\n  Roles.Role private _pausers;\\n\\n  constructor () internal {\\n    _addPauser(msg.sender);\\n  }\\n\\n  modifier onlyPauser() {\\n    require(isPauser(msg.sender));\\n    _;\\n  }\\n\\n  function isPauser(address account) public view returns (bool) {\\n    return _pausers.has(account);\\n  }\\n\\n  function addPauser(address account) public onlyOwner {\\n    _addPauser(account);\\n  }\\n\\n  function removePauser(address account) public onlyOwner {\\n    _removePauser(account);\\n  }\\n\\n  function _addPauser(address account) internal {\\n    _pausers.add(account);\\n    emit PauserAdded(account);\\n  }\\n\\n  function _removePauser(address account) internal {\\n    _pausers.remove(account);\\n    emit PauserRemoved(account);\\n  }\\n}\\n\\n\\ncontract Pausable is PauserRole {\\n  event Paused(address account);\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  constructor () internal {\\n    _paused = false;\\n  }\\n\\n  \\n  function paused() public view returns (bool) {\\n    return _paused;\\n  }\\n\\n  \\n  modifier whenNotPaused() {\\n    require(!_paused);\\n    _;\\n  }\\n\\n  \\n  modifier whenPaused() {\\n    require(_paused);\\n    _;\\n  }\\n\\n  \\n  function pause() public onlyPauser whenNotPaused {\\n    _paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  \\n  function unpause() public onlyPauser whenPaused {\\n    _paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n}\\n\\n\\ncontract ERC20Pausable is ERC20, Pausable {\\n  function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\\n    return super.transfer(to, value);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\\n    return super.transferFrom(from, to, value);\\n  }\\n\\n  function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\\n    return super.approve(spender, value);\\n  }\\n\\n  function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\\n    return super.increaseAllowance(spender, addedValue);\\n  }\\n\\n  function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\\n    return super.decreaseAllowance(spender, subtractedValue);\\n  }\\n}\\n\\n\\ncontract ERC20Mintable is ERC20, MinterRole {\\n  \\n  function mint(address to, uint256 value) public onlyMinter returns (bool) {\\n    _mint(to, value);\\n    return true;\\n  }\\n}\\n\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor (string memory name, string memory symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  \\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  \\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  \\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n}\\n\\n\\ncontract ERC20Capped is ERC20Mintable {\\n  uint256 private _cap;\\n\\n  constructor (uint256 cap) public {\\n    require(cap \\u003e 0);\\n    _cap = cap;\\n  }\\n\\n  \\n  function cap() public view returns (uint256) {\\n    return _cap;\\n  }\\n\\n  function _mint(address account, uint256 value) internal {\\n    require(totalSupply().add(value) \\u003c= _cap);\\n    super._mint(account, value);\\n  }\\n}\\n\\n\\n\\ncontract AIV is ERC20Detailed, ERC20Capped, ERC20Pausable  {\\n\\n  mapping(address =\\u003e bool) private whiteList;\\n  IEntryPoint private EntryPoint;\\n  IProxy private Proxy;\\n\\n  constructor(string memory name, string memory symbol, uint8 decimals, uint256 cap)\\n  ERC20Detailed(name, symbol, decimals) ERC20Capped(cap) public {}\\n\\n  modifier canModifyWhiteList() {\\n    address proxyAddress = EntryPoint.getProxyAddress();\\n    Proxy = IProxy(proxyAddress);\\n    require(isOwner() || Proxy.isDeployer(msg.sender));\\n    _;\\n  }\\n\\n  modifier onlyFromWhiteList() {\\n    require(whiteList[msg.sender] == true);\\n    _;\\n  }\\n\\n  function setEntryPointAddress(address _EntryPointAddress) public onlyOwner {\\n    EntryPoint = IEntryPoint(_EntryPointAddress);\\n  }\\n\\n  function addToWhiteList(address _address) public canModifyWhiteList {\\n    whiteList[_address] = true;\\n  }\\n\\n  function removeFromWhiteList(address _address) public canModifyWhiteList {\\n    whiteList[_address] = false;\\n  }\\n\\n  \\n  function approveFromProtocol(address sender, address spender, uint tokens) public onlyFromWhiteList returns (bool success) {\\n    require(balanceOf(sender) \\u003e= tokens);\\n    _approve(sender, spender, _allowed[sender][spender].add(tokens));\\n    return true;\\n  }\\n\\n\\n  function getTotalAmount(uint256[] memory values) internal pure returns(uint256) {\\n    uint256 total;\\n    for (uint8 i = 0; i \\u003c values.length; i++) {\\n      total += values[i];\\n    }\\n    return total;\\n  }\\n\\n  \\n  function transferBatch(address[] memory addresses, uint256[] memory values) public {\\n    require((addresses.length != 0 \\u0026\\u0026 values.length != 0));\\n    require(addresses.length == values.length);\\n    /// @notice Check if the tokens are enough\\n    require(getTotalAmount(values) \\u003c= balanceOf(msg.sender));\\n    for (uint8 j = 0; j \\u003c values.length; j++) {\\n      transfer(addresses[j], values[j]);\\n    }\\n  }\\n    \\n  function mintBatch(address[] memory addresses, uint256[] memory values) public onlyMinter {\\n    require((addresses.length != 0 \\u0026\\u0026 values.length != 0));\\n    require(addresses.length == values.length);\\n    /// @notice Check if the tokens are enough\\n    uint256 value = getTotalAmount(values);\\n    require(totalSupply().add(value) \\u003c= cap());\\n    for (uint8 j = 0; j \\u003c values.length; j++) {\\n      mint(addresses[j], values[j]);\\n    }\\n  }\\n}\"},\"Migrations.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"}}",
        "label": false,
        "name": "0xc35aaea6dd561a9976e1745a22f8cc5a762354bb.sol"
    },
    {
        "source": "contract CON1\n{\naddress public VAR1;\naddress public VAR2;\nmodifier FUN1\n{\nrequire(msg.sender == VAR1 || msg.sender == VAR2);\n_;\n}\nconstructor() public\n{\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR3) FUN1 public\n{\nrequire(VAR3 != VAR1);\nrequire(VAR3 != VAR2);\nrequire(VAR3 != address(0x0));\nVAR1 = VAR3;\n}\nfunction FUN3(address VAR3) FUN1 public\n{\nrequire(VAR3 != VAR1);\nrequire(VAR3 != VAR2);\nrequire(VAR3 != address(0x0));\nVAR2 = VAR3;\n}\n}\ncontract CON2\n{\n}\ncontract CON3 is CON2, CON1\n{\nusing SafeMath for uint;\naddress private VAR4;\nstring public VAR5;\nuint public VAR6;\nstring public VAR7;\nuint constant private VAR8 = 1000000000000000000;\nuint private constant VAR9 = 2592000;\nuint constant public VAR10 = 56200000000 * VAR8;\nuint constant public VAR11 = 19670000000 * VAR8;\nuint constant public VAR12 = 8430000000 * VAR8;\nuint constant public VAR13 = 8430000000 * VAR8;\nuint constant public VAR14 = 8430000000 * VAR8;\nuint constant public VAR15 = 5620000000 * VAR8;\nuint constant public VAR16 = 2810000000 * VAR8;\nuint constant public VAR17 = 2810000000 * VAR8;\nuint public VAR18;\nuint public VAR19;\nuint public VAR20;\nuint public VAR21;\nuint public VAR22;\nuint public VAR23;\nuint public VAR24;\nuint public VAR25;\nuint public VAR26;\nuint public VAR27;\nuint public VAR28;\nuint public VAR29;\nmapping (address => uint) public VAR30;\nmapping (address => mapping ( address => uint )) public VAR31;\nmapping (address => uint) public VAR32;\nuint public VAR33 = 1514818800;\nmapping (address => uint) public VAR34;\nuint public VAR35 = 1514818800;\nmapping (address => uint) public VAR36;\nuint public VAR37 = 1514818800;\nmapping (address => uint) public VAR38;\nuint public VAR39 = 1514818800;\nmapping (address => uint) public VAR40;\nuint public VAR41 = 1514818800;\nbool public VAR42 = true;\nbool public VAR43 = true;\nconstructor() public\n{\nVAR5 = \"VANTA Token\";\nVAR6 = 18;\nVAR7 = \"VNT\";\nVAR4 = msg.sender;\nVAR18 = 0;\nVAR19 = 0;\nVAR23 = 0;\nVAR24 = 0;\nVAR25 = 0;\nVAR26 = 0;\nVAR27 = 0;\nVAR28 = 0;\nrequire(VAR10 == VAR11 + VAR12 + VAR13 + VAR14 + VAR15 + VAR16 + VAR17);\n}\nfunction FUN4(address VAR3, uint VAR44) public returns (bool)\n{\nrequire(isTransferable() == true);\nrequire(VAR30[msg.sender] >= VAR44);\nVAR30[msg.sender] = VAR30[msg.sender].sub(VAR44);\nVAR30[VAR3] = VAR30[VAR3].add(VAR44);\nreturn true;\n}\nfunction FUN5(address VAR45, uint VAR44) public returns (bool)\n{\nrequire(isTransferable() == true);\nrequire(VAR30[msg.sender] >= VAR44);\nVAR31[msg.sender][VAR45] = VAR44;\nreturn true;\n}\nfunction FUN6(address VAR46, address VAR3, uint VAR44) public returns (bool)\n{\nrequire(isTransferable() == true);\nrequire(VAR30[VAR46] >= VAR44);\nrequire(VAR31[VAR46][msg.sender] >= VAR44);\nVAR31[VAR46][msg.sender] = VAR31[VAR46][msg.sender].sub(VAR44);\nVAR30[VAR46] = VAR30[VAR46].sub(VAR44);\nVAR30[VAR3] = VAR30[VAR3].add(VAR44);\nreturn true;\n}\nfunction FUN7(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR11 >= VAR19.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add( VAR47.mul(385)/1000 );\nVAR32[VAR3] = VAR32[VAR3].add( VAR47.mul(385)/1000 );\nVAR34[VAR3] = VAR34[VAR3].add( VAR47.mul(115)/1000 );\nVAR36[VAR3] = VAR36[VAR3].add( VAR47.mul(115)/1000 );\nVAR18 = VAR18.add(VAR47);\nVAR19 = VAR19.add(VAR47);\nVAR20 = VAR20.add(VAR47);\n}\nfunction FUN8(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR11 >= VAR19.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add( VAR47.mul(435)/1000 );\nVAR38[VAR3] = VAR38[VAR3].add( VAR47.mul(435)/1000 );\nVAR40[VAR3] = VAR40[VAR3].add( VAR47.mul(130)/1000 );\nVAR18 = VAR18.add(VAR47);\nVAR19 = VAR19.add(VAR47);\nVAR21 = VAR21.add(VAR47);\n}\nfunction FUN9(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR11 >= VAR19.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR19 = VAR19.add(VAR47);\nVAR22 = VAR22.add(VAR47);\n}\nfunction FUN10(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR12 >= VAR23.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR23 = VAR23.add(VAR47);\n}\nfunction FUN11(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR13 >= VAR24.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR24 = VAR24.add(VAR47);\n}\nfunction FUN12(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR14 >= VAR25.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR25 = VAR25.add(VAR47);\n}\nfunction FUN13(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR16 >= VAR27.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR27 = VAR27.add(VAR47);\n}\nfunction FUN14(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR15 >= VAR26.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR26 = VAR26.add(VAR47);\n}\nfunction FUN15(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR17 >= VAR28.add(VAR47));\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\nVAR28 = VAR28.add(VAR47);\n}\nfunction FUN16() FUN1 public\n{\nrequire(VAR42 == true);\nVAR42 = false;\n}\nfunction FUN17() FUN1 public\n{\nrequire(VAR42 == false);\nVAR42 = true;\n}\nfunction FUN18(address VAR3) FUN1 public\n{\nrequire(VAR42 == false);\nrequire(VAR43 == false);\nuint VAR48 = now;\nuint VAR49 = 0;\nif( (VAR48 >= VAR33) && (VAR32[VAR3] > 0) )\n{\nVAR30[VAR3] = VAR30[VAR3].add(VAR32[VAR3]);\nVAR49 = VAR49.add(VAR32[VAR3]);\nVAR32[VAR3] = 0;\n}\nif( (VAR48 >= VAR35) && (VAR34[VAR3] > 0) )\n{\nVAR30[VAR3] = VAR30[VAR3].add(VAR34[VAR3]);\nVAR49 = VAR49.add(VAR34[VAR3]);\nVAR34[VAR3] = 0;\n}\nif( (VAR48 >= VAR37) && (VAR36[VAR3] > 0) )\n{\nVAR30[VAR3] = VAR30[VAR3].add(VAR36[VAR3]);\nVAR49 = VAR49.add(VAR36[VAR3]);\nVAR36[VAR3] = 0;\n}\n}\nfunction FUN19(address VAR3) FUN1 public\n{\nrequire(VAR42 == false);\nrequire(VAR43 == false);\nuint VAR48 = now;\nuint VAR49 = 0;\nif( (VAR48 >= VAR39) && (VAR38[VAR3] > 0) )\n{\nVAR30[VAR3] = VAR30[VAR3].add(VAR38[VAR3]);\nVAR49 = VAR49.add(VAR38[VAR3]);\nVAR38[VAR3] = 0;\n}\nif( (VAR48 >= VAR41) && (VAR40[VAR3] > 0) )\n{\nVAR30[VAR3] = VAR30[VAR3].add(VAR40[VAR3]);\nVAR49 = VAR49.add(VAR40[VAR3]);\nVAR40[VAR3] = 0;\n}\n}\nfunction () payable external\n{\nrevert();\n}\nfunction FUN21() FUN1 public\n{\nrequire(VAR43 == true);\nVAR43 = false;\n}\nfunction FUN22(address VAR3, uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nVAR30[VAR3] = VAR30[VAR3].add(VAR47);\nVAR18 = VAR18.add(VAR47);\n}\nfunction FUN23(uint VAR50) FUN1 public\n{\nrequire(VAR42 == true);\nrequire(VAR43 == true);\nVAR33 = VAR50;\nVAR35 = VAR50.add(VAR9);\nVAR37 = VAR35.add(VAR9);\n}\nfunction FUN24(uint VAR50) FUN1 public\n{\nrequire(VAR42 == true);\nrequire(VAR43 == true);\nVAR39 = VAR50;\nVAR41 = VAR50.add(VAR9);\n}\nfunction FUN25(uint VAR44) FUN1 public\n{\nuint VAR47 = VAR44 * VAR8;\nrequire(VAR30[msg.sender] >= VAR47);\nVAR30[msg.sender] = VAR30[msg.sender].sub(VAR47);\nVAR29 = VAR29.add(VAR47);\nVAR18 = VAR18.sub(VAR47);\n}\nfunction FUN26() public\n{\nrequire(msg.sender == VAR4);\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0x2a77bf0239c625a0319e21607d6e9093a38b6eed.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR3;\nuint256 internal VAR4;\nfunction FUN5(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR6 <= VAR3[msg.sender]);\nrequire(VAR5 != address(0));\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN6(address VAR8,address VAR5,uint256 VAR6)\npublic\nreturns (bool)\n{\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nrequire(VAR5 != address(0));\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN7(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nVAR7[msg.sender][VAR9] = (VAR7[msg.sender][VAR9].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR9,uint256 VAR11)\npublic\nreturns (bool)\n{\nuint256 VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 >= VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON3 {\nfunction FUN10(uint256 VAR6) public {\nFUN11(msg.sender, VAR6);\n}\nfunction FUN11(address VAR13, uint256 VAR6) internal {\nrequire(VAR6 <= VAR3[VAR13]);\nVAR3[VAR13] = VAR3[VAR13].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON7 is CON6, CON5 {\nfunction FUN12(address VAR8, uint256 VAR6) public {\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nFUN11(VAR8, VAR6);\n}\n}\ncontract CON8 is CON7, CON1 {\nstring public constant VAR14 = \"Amplify\";\nstring public constant VAR15 = \"AMPX\";\nuint8 public constant VAR16 = 18;\nbool public VAR17 = true;\nuint256 public constant VAR18 = 1200000000000000000000000000;\nconstructor() public {\nVAR4 = VAR18;\nVAR3[msg.sender] = VAR18;\n}\nmodifier FUN13 {\nrequire(msg.sender == VAR1 || !VAR17,\"Transfers are not VAR7 until after the crowdsale.\");\n_;\n}\nfunction FUN14() public FUN1 {\nVAR17 = false;\n}\nfunction FUN5(address VAR5, uint256 VAR6) public FUN13 returns (bool) {\nreturn CON3.FUN5(VAR5, VAR6);\n}\nfunction FUN7(address VAR9, uint256 VAR6) public returns (bool) {\nrequire(VAR6 == 0 || VAR7[msg.sender][VAR9] == 0, \"Use FUN8 or FUN9 to prevent double-spend.\");\nreturn CON5.FUN7(VAR9, VAR6);\n}\nfunction FUN6(address VAR8, address VAR5, uint256 VAR6) public FUN13 returns (bool) {\nreturn CON5.FUN6(VAR8, VAR5, VAR6);\n}\n}",
        "label": false,
        "name": "0x735af341f2d9ce3663616cd84ff522dbf62fbc1f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"CALI\";\nVAR5 = \"CaliDog Coin\";\nVAR6 = 18;\nVAR7 = 1000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xa83d6dde2ea968693619b2c2939d5ea207a5c295.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR2 = msg.sender;\nmapping(address=>bool) public VAR3;\nmodifier FUN2() {\nrequire(msg.sender == VAR2 || msg.sender == VAR1);\n_;\n}\nfunction FUN3(address VAR4) public FUN1 {\nVAR2 = VAR4;\n}\nfunction FUN4(address VAR5) public FUN2 {\nrequire(VAR5 != address(0x0));\nrequire(!isWhitelisted(VAR5));\nVAR3[VAR5] = true;\n}\nfunction FUN5(address VAR5) public FUN1 {\nVAR3[VAR5] = false;\n}\n}",
        "label": false,
        "name": "0x4a6ead96974679957a17d2f9c7835a3da7ddf91d.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nassert((VAR3 >= VAR1) && (VAR3 >= VAR2));\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nassert(VAR1 >= VAR2);\nuint256 VAR3 = VAR1 - VAR2;\nreturn VAR3;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 * VAR2;\nassert((VAR1 == 0)||(VAR3/VAR1 == VAR2));\nreturn VAR3;\n}\n}\ncontract CON2 {\nuint256 public VAR4;\n}\ncontract CON3 is CON2 {\nfunction FUN4(address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[msg.sender] -= VAR6;\nVAR13[VAR5] += VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR8, address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[VAR8] >= VAR6 && VAR14[VAR8][msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[VAR5] += VAR6;\nVAR13[VAR8] -= VAR6;\nVAR14[VAR8][msg.sender] -= VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR9) constant returns (uint256 VAR10) {\nreturn VAR13[VAR9];\n}\nfunction FUN7(address VAR11, uint256 VAR6) returns (bool VAR7) {\nVAR14[msg.sender][VAR11] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR11) constant returns (uint256 VAR12) {\nreturn VAR14[VAR9][VAR11];\n}\nmapping (address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) VAR14;\n}\ncontract CON4 is CON3, CON1 {\nstring public constant VAR15 = \"Faceblock\";\nstring public constant VAR16 = \"FBL\";\nuint256 public constant VAR17 = 2;\nstring public VAR18 = \"1.0\";\naddress VAR19; address VAR20;\naddress VAR21; address VAR22; uint256 public constant VAR23 = 5 * (10**6) * 10**VAR17; uint256 public constant VAR24 = 5 * (10**6) * 10**VAR17; uint256 public constant VAR25 = 10 * (10**6) * 10**VAR17;\nfunction CON4()\n{\nVAR20 = '0x3A1F12A15f3159903f2EEbe1a2949A780911f695';\nVAR21 = '0x2E109b1c58625F0770d885ADA419Df16621350bB';\nVAR22 = '0xAeD77852D6810E5c36ED85Ad1beC9c2368F5400F';\nVAR4 = FUN3(VAR23,1);\nVAR4 = FUN1(VAR4,VAR24);\nVAR13[VAR21] = VAR23; VAR13[VAR22] = VAR23; FUN5(0x0, 0x3A1F12A15f3159903f2EEbe1a2949A780911f695, 50 * (10**6) * 10**VAR17);\nFUN5(0x0, 0xAeD77852D6810E5c36ED85Ad1beC9c2368F5400F, 50 * (10**6) * 10**VAR17);\n}\n}",
        "label": false,
        "name": "0xc0c2ee1ce1fed8f6e2764363a36db3dd4cf10022.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR2;\nfunction CON3() public {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON4 {\nusing SafeERC20 for CON1;\nCON1 public VAR4;\naddress public VAR5;\nuint256 public VAR6;\nfunction CON4(CON1 VAR7, address VAR8, uint256 VAR9) public {\nrequire(VAR9 > now);\nVAR4 = VAR7;\nVAR5 = VAR8;\nVAR6 = VAR9;\n}\nfunction FUN3() public {\nrequire(now >= VAR6);\nuint256 VAR10 = VAR4.balanceOf(this);\nrequire(VAR10 > 0);\nVAR4.safeTransfer(VAR5, VAR10);\n}\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR5;\nuint256 public VAR11;\nuint256 public VAR12;\nuint256 public VAR13;\nbool public VAR14;\nmapping (address => uint256) public VAR15;\nmapping (address => bool) public VAR16;\nfunction CON5(address VAR8, uint256 VAR17, uint256 VAR18, uint256 VAR19, bool VAR20) public {\nrequire(VAR8 != address(0));\nrequire(VAR18 <= VAR19);\nVAR5 = VAR8;\nVAR14 = VAR20;\nVAR13 = VAR19;\nVAR11 = VAR17.add(VAR18);\nVAR12 = VAR17;\n}\nfunction FUN3(CON1 VAR4) public {\nuint256 VAR21 = releasableAmount(VAR4);\nrequire(VAR21 > 0);\nVAR15[VAR4] = VAR15[VAR4].add(VAR21);\nVAR4.safeTransfer(VAR5, VAR21);\n}\nfunction FUN4(CON1 VAR4) public FUN1 {\nrequire(VAR14);\nrequire(!VAR16[VAR4]);\nuint256 VAR22 = VAR4.balanceOf(this);\nuint256 VAR21 = releasableAmount(VAR4);\nuint256 VAR23 = VAR22.sub(VAR21);\nVAR16[VAR4] = true;\nVAR4.safeTransfer(VAR2, VAR23);\n}\n}\ncontract CON6 is CON2, CON3 {\n}\ncontract CON7 is CON3 {\nusing SafeMath for uint256;\nCON6 public VAR4;\naddress public VAR24;\naddress public VAR25;\naddress public VAR26;\nuint256 public VAR27;\nuint256 public VAR28;\nuint256 public VAR29;\nuint256 public VAR30;\nuint256 public VAR31;\nuint256 public VAR32;\nuint256 public VAR33;\nuint256 public VAR34;\nuint256 public VAR35;\nuint256 public VAR36;\nmapping (address => address) public VAR37;\nmapping (address => address) public VAR38;\nenum Stages {\nGenesisAllocation,\nGenesisStart,\nGenesisEnd\n}\nStages public VAR39;\nmodifier FUN5(Stages VAR40) {\nrequire(VAR39 == VAR40);\n_;\n}\nfunction CON7(address VAR7,address VAR41,address VAR42,address VAR43,uint256 VAR44)\npublic\n{\nVAR4 = CON6(VAR7);\nVAR24 = VAR41;\nVAR25 = VAR42;\nVAR26 = VAR43;\nVAR36 = VAR44;\nVAR39 = Stages.GenesisAllocation;\n}\nfunction FUN6(uint256 VAR45,uint256 VAR46,uint256 VAR47,uint256 VAR48,uint256 VAR49,uint256 VAR50)\nexternal\nFUN1\nFUN5(Stages.GenesisAllocation)\n{\nrequire(VAR46.add(VAR47).add(VAR48).add(VAR49).add(VAR50) == VAR45);\nVAR27 = VAR45;\nVAR28 = VAR46;\nVAR29 = VAR47;\nVAR30 = VAR48;\nVAR31 = VAR49;\nVAR32 = VAR50;\n}\nfunction VAR12() external FUN1 FUN5(Stages.GenesisAllocation) {\nVAR4.mint(this, VAR27);\nVAR39 = Stages.GenesisStart;\n}\nfunction FUN7(address VAR51,uint256 VAR52,uint256 VAR53,uint256 VAR54)\nexternal\nFUN1\nFUN5(Stages.GenesisStart)\n{\nuint256 VAR55 = VAR33.add(VAR52);\nrequire(VAR55 <= VAR30);\nVAR33 = VAR55;\nFUN9(VAR51, VAR52, VAR53, VAR54);\n}\nfunction FUN8(address VAR51,uint256 VAR52,uint256 VAR53,uint256 VAR54)\nexternal\nFUN1\nFUN5(Stages.GenesisStart)\n{\nuint256 VAR55 = VAR34.add(VAR52);\nrequire(VAR55 <= VAR31);\nVAR34 = VAR55;\nFUN9(VAR51, VAR52, VAR53, VAR54);\n}\nfunction FUN9(address VAR51,uint256 VAR52,uint256 VAR53,uint256 VAR54)\ninternal\n{\nrequire(VAR37[VAR51] == address(0));\nCON5 VAR56 = new CON5(VAR51, VAR36, VAR53, VAR54, true);\nVAR37[VAR51] = VAR56;\nVAR56.FUN2(VAR25);\nVAR4.transfer(VAR56, VAR52);\n}\nfunction FUN10(address VAR51,uint256 VAR52)\nexternal\nFUN1\nFUN5(Stages.GenesisStart)\n{\nuint256 VAR55 = VAR35.add(VAR52);\nrequire(VAR55 <= VAR32);\nVAR35 = VAR55;\nrequire(VAR38[VAR51] == address(0));\nCON4 VAR56 = new CON4(VAR4, VAR51, VAR36);\nVAR38[VAR51] = VAR56;\nVAR4.transfer(VAR56, VAR52);\n}\nfunction FUN11() external FUN1 FUN5(Stages.GenesisStart) {\nVAR4.transfer(VAR24, VAR28);\nVAR4.transfer(VAR25, VAR29);\nVAR4.FUN2(VAR26);\nVAR39 = Stages.GenesisEnd;\n}\n}",
        "label": false,
        "name": "0xd78b6bd09cd28a83cfb21afa0da95c685a6bb0b1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nstring public VAR4 = \"CP\";\nstring public VAR5 = \"Cryptoprofile\";\nuint8 public VAR6 = 18;\nuint256 VAR7 = 753471015000000000000000000;\nmapping(address => uint256) VAR8;\nmapping(address => mapping(address => uint256)) internal VAR9;\nconstructor() public {\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR8[msg.sender]);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR14) public returns (bool VAR12){\nVAR9[msg.sender][VAR13] = (VAR9[msg.sender][VAR13].add(VAR14));\nreturn true;\n}\nfunction FUN7(address VAR13, uint256 VAR15) public returns (bool VAR12)\n{\nuint256 VAR16 = VAR9[msg.sender][VAR13];\nif (VAR15 > VAR16) {\nVAR9[msg.sender][VAR13] = 0;\n} else {\nVAR9[msg.sender][VAR13] = VAR16.sub(VAR15);\n}\nreturn true;\n}\nfunction FUN8(address VAR17, address VAR10, uint256 VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR8[VAR17]);\nrequire(VAR11 <= VAR9[VAR17][msg.sender]);\nVAR8[VAR17] = VAR8[VAR17].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nVAR9[VAR17][msg.sender] = VAR9[VAR17][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR13, uint256 VAR11, bytes memory VAR18) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR18);\nreturn true;\n}\nfunction() external payable {\nrevert();\n}\nfunction FUN11(address VAR19, uint256 VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR19).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x06a6fc23e6ec8a2b2aeeefd70d772dc3d6b45010.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nstring public VAR6; uint8 public VAR7; string public VAR8;\nfunction CON4(uint256 VAR9,string VAR10,uint8 VAR11,string VAR12) public {\nVAR1[msg.sender] = VAR9; VAR2 = VAR9; VAR6 = VAR10; VAR7 = VAR11; VAR8 = VAR12; }\nfunction FUN2(address VAR13, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR13]);\nrequire(VAR4 <= VAR5[VAR13][msg.sender]);\nVAR1[VAR13] = VAR1[VAR13].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR13][msg.sender] = VAR5[VAR13][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR14, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR14] = VAR4;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc7fd2c8f96c38aec1faab031f9d81f0b9d8a360a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd2299b3098cf5e13144caebfdad61ebe505233dc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 private VAR1;\nmapping(bytes32 => uint256) private VAR2;\nmapping(bytes32 => uint256[]) private VAR3;\nmapping(bytes32 => string) private VAR4;\nmapping(bytes32 => address) private VAR5;\nmapping(bytes32 => bytes) private VAR6;\nmapping(bytes32 => bool) private VAR7;\nmapping(bytes32 => int256) private VAR8;\naddress private VAR9;\naddress private VAR10;\nmapping(address => uint256) private VAR11;\nconstructor() public {\nVAR9 = msg.sender;\nVAR1 = CON1(0xf1fd447DAc5AbEAba356cD0010Bac95daA37C265);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR9);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR10);\n_;\n}\nfunction FUN3() public FUN1 {\nFUN7(1, 'Titanium Ranger Hull', 200, 2, 0.2 ether);\nFUN7(2, 'Platinum Ranger Hull', 400, 4, 0.5 ether);\nFUN7(3, 'Adamantium Ranger Hull', 600, 7, 1 ether);\n}\nfunction FUN4(address VAR12, uint256 VAR13) public FUN2 {\nVAR11[VAR12] += VAR13;\n}\nfunction FUN5(address VAR14) public FUN2 returns(uint256) {\nuint256 VAR15 = VAR11[VAR14];\nVAR11[VAR14] = 0;\nreturn VAR15;\n}\nfunction FUN6(uint256 VAR16, address VAR17, string VAR18, string VAR19, string VAR20) public FUN2 returns(uint256) {\nVAR2[_b2(VAR18, VAR17)]++;\nVAR3[_b2(VAR19, VAR17)].push(VAR16);\nuint256 VAR21 = VAR1.addItem(VAR18);\nVAR3[_b2(VAR20, VAR17)].push(VAR21);\nVAR5[_b3(VAR18, VAR21)] = VAR17;\nreturn VAR16;\n}\nfunction FUN7(uint256 VAR22, string VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26) public FUN1 {\nVAR1.FUN7(VAR22);\nVAR4[_b1(\"ships\", VAR22, \"name\")] = VAR23;\nVAR2[_b1(\"ships\", VAR22, \"hp\")] = VAR24;\nVAR2[_b1(\"ships\", VAR22, \"block\")] = VAR25;\nVAR2[_b1(\"ships\", VAR22, \"price\")] = VAR26;\n}\nfunction FUN8(string VAR27, uint256 VAR16, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) private {\nVAR4[_b1(VAR27, VAR16, \"name\")] = VAR23;\nVAR2[_b1(VAR27, VAR16, \"value\")] = VAR28;\nVAR2[_b1(VAR27, VAR16, \"price\")] = VAR26;\nVAR2[_b1(VAR27, VAR16, \"durability\")] = VAR29;\n}\nfunction FUN9(uint256 VAR30, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN9(VAR30);\nFUN8(\"radars\", VAR30, VAR23, VAR28, VAR26, VAR29);\n}\nfunction FUN10(uint256 VAR31, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN10(VAR31);\nFUN8(\"scanners\", VAR31, VAR23, VAR28, VAR26, VAR29);\n}\nfunction FUN11(uint256 VAR32, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN11(VAR32);\nFUN8(\"droids\", VAR32, VAR23, VAR28, VAR26, VAR29);\n}\nfunction FUN12(uint256 VAR33, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN12(VAR33);\nFUN8(\"fuels\", VAR33, VAR23, VAR28, VAR26, VAR29);\n}\nfunction FUN13(uint256 VAR34, string VAR23, uint256 VAR28, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN13(VAR34);\nFUN8(\"generators\", VAR34, VAR23, VAR28, VAR26, VAR29);\n}\nfunction FUN14(uint256 VAR35, string VAR23, uint256 VAR36, uint256 VAR37, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN14(VAR35);\nVAR4[_b1(\"engines\", VAR35, \"name\")] = VAR23;\nVAR2[_b1(\"engines\", VAR35, \"speed\")] = VAR36;\nVAR2[_b1(\"engines\", VAR35, \"giper\")] = VAR37;\nVAR2[_b1(\"engines\", VAR35, \"price\")] = VAR26;\nVAR2[_b1(\"engines\", VAR35, \"durability\")] = VAR29;\n}\nfunction FUN15(uint256 VAR38, string VAR23, uint256 VAR39, uint256 VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, uint256 VAR26, uint256 VAR29) public FUN1 {\nVAR1.FUN15(VAR38);\nVAR4[_b1(\"guns\", VAR38, \"name\")] = VAR23;\nVAR2[_b1(\"guns\", VAR38, \"min\")] = VAR39;\nVAR2[_b1(\"guns\", VAR38, \"max\")] = VAR40;\nVAR2[_b1(\"guns\", VAR38, \"radius\")] = VAR41;\nVAR2[_b1(\"guns\", VAR38, \"recharge\")] = VAR42;\nVAR2[_b1(\"guns\", VAR38, \"ability\")] = VAR43;\nVAR2[_b1(\"guns\", VAR38, \"price\")] = VAR26;\nVAR2[_b1(\"guns\", VAR38, \"durability\")] = VAR29;\n}\nfunction FUN16(uint256 VAR44, string VAR23, uint256 VAR27, uint256 VAR45, uint256 VAR46, uint256 VAR47, uint256 VAR26) public FUN1 {\nVAR1.FUN16(VAR44);\nVAR4[_b1(\"microModules\", VAR44, \"name\")] = VAR23;\nVAR2[_b1(\"microModules\", VAR44, \"itemType\")] = VAR27;\nVAR2[_b1(\"microModules\", VAR44, \"bonusType\")] = VAR45;\nVAR2[_b1(\"microModules\", VAR44, \"bonus\")] = VAR46;\nVAR2[_b1(\"microModules\", VAR44, \"level\")] = VAR47;\nVAR2[_b1(\"microModules\", VAR44, \"price\")] = VAR26;\n}\nfunction FUN17(uint256 VAR48, string VAR23, uint256 VAR27, uint256 VAR45, uint256 VAR46) public FUN1 {\nVAR1.FUN17(VAR48);\nVAR4[_b1(\"artefacts\", VAR48, \"name\")] = VAR23;\nVAR2[_b1(\"artefacts\", VAR48, \"itemType\")] = VAR27;\nVAR2[_b1(\"artefacts\", VAR48, \"bonusType\")] = VAR45;\nVAR2[_b1(\"artefacts\", VAR48, \"bonus\")] = VAR46;\n}\nfunction FUN18(string VAR27, uint256 VAR49, uint256 VAR50) public FUN2 {\nVAR2[_b1(VAR27, VAR49, \"price\")] = VAR50;\n}\nfunction FUN19(address VAR51) public FUN1 {\nFUN20(VAR51);\n}\nfunction FUN20(address VAR51) private {\nrequire(VAR51 != address(0));\nVAR9 = VAR51;\n}\nfunction FUN21(address VAR52) public FUN1 {\nFUN22(VAR52);\n}\nfunction FUN22(address VAR52) private {\nrequire(VAR52 != address(0));\nVAR10 = VAR52;\n}\n}",
        "label": false,
        "name": "0x1c3042baa90d995ea85c19d8a494218fe5c48e72.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"847df4b1ba31f28b9399b52d784e4a8e\";\nstring public constant VAR2 = \"cd195ff7ac4743a1c878f0100e138e36471bb79c0254d58806b8244080979116\";\nmapping (address => bool) private VAR3;\naddress private VAR4 = 0x8D5bd2aBa04A07Bfa0cc976C73eD45B23cC6D6a2;\naddress private VAR5 = 0x688d12D97D0E480559B6bEB6EE9907B625c14Adb;\naddress private VAR6 = 0x34972356Af9B8912c1DC2737fd43352A8146D23D;\naddress private VAR7 = 0x259BBd479Bd174129a3ccb007f608D52cd2630e9;\nfunction() {\nFUN2();\n}\nfunction FUN2() {\nFUN3(msg.sender);\n}\nfunction FUN3(address VAR8) {\nif (FUN4(VAR8)) return;\nVAR3[VAR8] = true;\n}\nfunction FUN4(address VAR8) constant returns (bool) {\nreturn VAR3[VAR8] == true;\n}\nfunction FUN5() constant returns (bool) {\nreturn FUN4(VAR4);\n}\nfunction FUN6() constant returns (bool) {\nreturn FUN4(VAR5);\n}\nfunction FUN7() constant returns (bool) {\nreturn FUN4(VAR6);\n}\nfunction FUN8() constant returns (bool) {\nreturn FUN4(VAR7);\n}\nfunction FUN9() constant returns (bool) {\nreturn (FUN5() &&FUN6() &&FUN7() &&FUN8());\n}\n}",
        "label": false,
        "name": "0x4ada9ae7e255449f333c59740cc44f8e9ca7ff1f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\naddress VAR1;\naddress VAR2;\naddress[] public VAR3;\nmapping (address => bool) public VAR4;\nuint256 public VAR5 = 0;\nuint256 public VAR6;\nuint256 public VAR7;\nbool public VAR8;\nbool public VAR9;\nmodifier FUN1() {\nrequire(!VAR8);\n_;\n}\nmodifier FUN2() {\nrequire(!VAR9);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4[msg.sender] == false);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN5(address VAR10) public FUN3 {\nrequire (VAR10 != address(0));\nVAR2 = VAR10;\nVAR6 = CON1(VAR2).balanceOf(address(this));\n}\nfunction FUN6(address VAR11) FUN3 public {\nif (VAR11 != address(0)) {\nVAR1 = VAR11;\n}\n}\nfunction FUN7() FUN3 public returns (bool) {\nVAR8 = false;\nreturn true;\n}\nfunction FUN8() FUN3 public returns (bool) {\nVAR9 = false;\nreturn true;\n}\nfunction FUN9() FUN3 FUN1 public returns (bool) {\nVAR8 = true;\nreturn true;\n}\nfunction FUN10() FUN3 FUN2 public returns (bool) {\nVAR9 = true;\nreturn true;\n}\nfunction FUN11(address VAR12, uint256 VAR13) private returns (bool) {\nVAR6 = VAR6.sub(VAR13);\nCON1(VAR2).transfer(VAR12,VAR13);\nreturn true;\nif (VAR6 == 0) {\nVAR8 = true;\nVAR9 = true;\n}\n}\nfunction FUN12(uint256 VAR14) public FUN3 {\nVAR7 = VAR14.mul(1e4);\n}\nfunction () external payable{\nif(msg.VAR18 == 0){FUN14();}else{FUN16();}\n}\nfunction FUN14() FUN1 FUN4 internal {\nrequire (VAR7 != 0);\nif (VAR7 > VAR6) {\nVAR7 = VAR6;\n}\nrequire(VAR7 <= VAR6);\naddress VAR15 = msg.sender;\nuint256 VAR16 = VAR7;\nFUN11(VAR15, VAR16);\nif (VAR16 > 0) {\nVAR4[VAR15] = true;\n}\n}\nfunction FUN15(uint VAR17) FUN3 public {\nVAR5 = VAR17;\n}\nfunction FUN16() FUN2 public payable {\nrequire(msg.VAR18 >= 0.001 ether);\nrequire(VAR5 > 0);\nuint256 VAR18 = msg.VAR18.mul(VAR5);\nrequire(VAR6 >= VAR18);\naddress VAR15 = msg.sender;\nuint256 VAR16 = VAR18;\nFUN11(VAR15, VAR16);\nif(msg.VAR18 >= 0.1 ether){\nVAR3.push(msg.sender);\n}\n}\nfunction FUN17() public FUN3 {\nCON1(VAR2).transfer(VAR1,CON1(VAR2).balanceOf(address(this)));\n}\nfunction FUN18() public FUN3 {\nmsg.sender.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0xed9624d6012087adb3a168a396aa73ce5d1b34c5.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1 = \"BasePow Token\";\nstring public VAR2 = \"BSP\";\nuint8 public VAR3 = 18;\nuint256 public VAR4 = 20*10**(18+8);\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR5[msg.sender] = VAR4; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xcc012c36d4d7f86ae9018bddfd0c1e94cdf6731f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1{\nstring public constant VAR1 = \"PolyAlpha\";\nstring public constant VAR2 = \"PAPP\";\nuint8 public constant VAR3 = 18;\nuint256 public VAR4 = 10**9;\nuint256 public VAR5;\naddress public VAR6 = 0xcb194c3127A9728907EeF53c7078A7052f6F23CA;\nmapping (address => uint256) public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nmodifier FUN1() {\nrequire(msg.sender == VAR6);\n_;\n}\nstruct founderLock {\nuint256 VAR10;\nuint256 VAR11;\nuint VAR12;\nuint VAR13;\nuint256 VAR14;\n}\nmapping (address => founderLock) public VAR15;\naddress VAR16 = 0xDD35f75513E6265b57EcE5CC587A09768969525d;\naddress VAR17 = 0x51909b2623d90fF2B04aC503F40C51F12Fc7aB49;\naddress VAR18 = 0x1893A8f045e2eC40498f254D6978A349c53dF2D3;\naddress VAR19 = 0x7BEE83C5103B1734e315Cc0C247E7D98492c193f;\naddress VAR20 = 0xEB759Dd32Fc9454BF5d0C3AFD9C739840987A84f;\nconstructor() public {\nFUN8(VAR16, VAR4/10, 4, 180 days);\nFUN8(VAR17, VAR4/10, 4, 180 days);\nFUN8(VAR18, VAR4/20, 4, 180 days);\nFUN8(VAR19, VAR4/20, 4, 180 days);\nVAR7[VAR20] = VAR4*6/10;\nVAR5 = VAR4/10;\n}\nfunction FUN2(address VAR21, uint256 VAR22) public{\nif (VAR21 == address(0x0)) revert(); if (VAR22 <= 0) revert();\nif (VAR7[msg.sender] < VAR22) revert(); if (VAR7[VAR21] + VAR22 < VAR7[VAR21]) revert(); VAR7[msg.sender] = CON1.safeSub(VAR7[msg.sender], VAR22); VAR7[VAR21] = CON1.safeAdd(VAR7[VAR21], VAR22); }\nfunction FUN3(address VAR23, uint256 VAR22) public\nreturns (bool VAR24) {\nif (VAR22 <= 0) revert();\nVAR9[msg.sender][VAR23] = VAR22;\nreturn true;\n}\nfunction FUN4(address VAR25, address VAR21, uint256 VAR22)public returns (bool VAR24) {\nif (VAR21 == address(0x0)) revert(); if (VAR22 <= 0) revert();\nif (VAR7[VAR25] < VAR22) revert(); if (VAR7[VAR21] + VAR22 < VAR7[VAR21]) revert(); if (VAR22 > VAR9[VAR25][msg.sender]) revert(); VAR7[VAR25] = CON1.safeSub(VAR7[VAR25], VAR22); VAR7[VAR21] = CON1.safeAdd(VAR7[VAR21], VAR22); VAR9[VAR25][msg.sender] = CON1.safeSub(VAR9[VAR25][msg.sender], VAR22);\nreturn true;\n}\nfunction FUN5(uint256 VAR22)public returns (bool VAR24) {\nif (VAR7[msg.sender] < VAR22) revert(); if (VAR22 <= 0) revert();\nVAR7[msg.sender] = CON1.safeSub(VAR7[msg.sender], VAR22); VAR4 = CON1.safeSub(VAR4,VAR22);\nreturn true;\n}\nfunction FUN6(uint256 VAR22)public returns (bool VAR24) {\nif (VAR7[msg.sender] < VAR22) revert(); if (VAR22 <= 0) revert();\nVAR7[msg.sender] = CON1.safeSub(VAR7[msg.sender], VAR22); VAR8[msg.sender] = CON1.safeAdd(VAR8[msg.sender], VAR22);\nreturn true;\n}\nfunction FUN7(uint256 VAR22)public returns (bool VAR24) {\nif (VAR8[msg.sender] < VAR22) revert(); if (VAR22 <= 0) revert();\nVAR8[msg.sender] = CON1.safeSub(VAR8[msg.sender], VAR22); VAR7[msg.sender] = CON1.safeAdd(VAR7[msg.sender], VAR22);\nreturn true;\n}\nfunction FUN8(address VAR26, uint256 VAR22, uint VAR27, uint256 VAR28) internal{\nVAR15[VAR26].VAR10 = VAR22;\nVAR15[VAR26].VAR11 = now;\nVAR15[VAR26].VAR12 = VAR27;\nVAR15[VAR26].VAR13 = VAR27;\nVAR15[VAR26].VAR14 = VAR28;\n}\nfunction FUN9(address VAR26, uint256 VAR22, uint VAR27, uint256 VAR28) public FUN1{\nrequire(VAR22 <= VAR5);\nFUN8( VAR26, VAR22, VAR27, VAR28);\nVAR5 = CON1.safeSub(VAR5, VAR22);\n}\nfunction FUN10 () public{\nrequire(now >= VAR15[msg.sender].VAR11 + (VAR15[msg.sender].VAR13 - VAR15[msg.sender].VAR12 + 1) * VAR15[msg.sender].VAR14);\nrequire(VAR15[msg.sender].VAR12 > 0);\nuint256 VAR29 = CON1.safeDiv(VAR15[msg.sender].VAR10,VAR15[msg.sender].VAR12);\nVAR7[msg.sender] = CON1.safeAdd(VAR7[msg.sender],VAR29);\nVAR15[msg.sender].VAR10 = CON1.safeSub(VAR15[msg.sender].VAR10,VAR29);\nVAR15[msg.sender].VAR12 --;\n}\n}",
        "label": false,
        "name": "0xf297d09924f8fd807bdb0d9fb47b52f6826c70b1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() { VAR1 = msg.sender; }\nmodifier FUN1{ if (msg.sender != VAR1) revert(); _; }\n}\ncontract CON2 is CON1 {\naddress public VAR1 = msg.sender;\nfunction FUN2() payable {\nrequire(msg.value > 0.5 ether);\nVAR1 = msg.sender;\n}\nfunction() public payable {\nFUN4();\n}\nfunction FUN4() public payable {\nrequire(msg.value > 0);\n}\nfunction FUN5(uint VAR2) public FUN1 {\nrequire(VAR2 <= this.balance);\nmsg.sender.transfer(VAR2);\n}\n}",
        "label": false,
        "name": "0x81edefc64aabdce71f68347774bd4673d1d31419.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bytes32 VAR1, bool VAR2) {\nif (msg.value > 0) throw;\n}\nfunction () { throw; }\n}",
        "label": false,
        "name": "0x1e9d5e4ed8ef31cfece10b4c92c9057f991f36bc.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public constant VAR18 = 1000000 * (10 ** 18);\nconstructor () public CON2(\"EXHANGE\", \"EXHANGE\", 18) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x05f20fe8a29414708210ed9be4c6dac95310a324.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor () internal {\nVAR1 = 0x202Abc6cF98863ee0126C182CA325a33A867ACbA;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nuint8 private VAR6;\nstring private VAR7;\nstring private VAR8;\nconstructor() public {\nVAR5 = 900000000e18;\nVAR6 = 18;\nVAR7 = \"RoboCalls\";\nVAR8 = \"RC20\";\nVAR3[VAR1] = VAR5;\n}\nfunction FUN3(address VAR9, uint256 VAR10) public returns (bool) {\nFUN8(msg.sender, VAR9, VAR10);\nreturn true;\n}\nfunction FUN4(address VAR11, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR4[msg.sender][VAR11] = VAR10;\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR9, uint256 VAR10) public returns (bool) {\nVAR4[VAR12][msg.sender] = VAR4[VAR12][msg.sender].sub(VAR10);\nFUN8(VAR12, VAR9, VAR10);\nreturn true;\n}\nfunction FUN6(address VAR11, uint256 VAR13) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR4[msg.sender][VAR11] = VAR4[msg.sender][VAR11].add(VAR13);\nreturn true;\n}\nfunction FUN7(address VAR11, uint256 VAR14) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR4[msg.sender][VAR11] = VAR4[msg.sender][VAR11].sub(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR12, address VAR9, uint256 VAR10) internal {\nrequire(VAR9 != address(0));\nVAR3[VAR12] = VAR3[VAR12].sub(VAR10);\nVAR3[VAR9] = VAR3[VAR9].add(VAR10);\n}\nfunction FUN9(uint256 VAR10) public FUN1 {\nVAR5 = VAR5.sub(VAR10);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR10);\n}\n}",
        "label": false,
        "name": "0x61b2d3ea9f1c6b387c985c73d40e8fbfb284e5c7.sol"
    },
    {
        "source": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"/home/cashlink/stokera-token/contracts/Policy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\n\\nimport './SignatureManager.sol';\\n\\n    },\r\n    \"/home/cashlink/stokera-token/contracts/SignatureManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\n\\ncontract SignatureManager {\\n        },\r\n    \"/home/cashlink/stokera-token/contracts/TokenPlatform.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\n\\nimport './Policy.sol';\\nimport './Upgradeable.sol';\\n\\ninterface ITokenPlatform {\\n    function isITokenPlatform() external pure returns (bool);\\n}\\n\\ncontract TokenPlatform is SingleAuthorityPolicy, ITokenPlatform {\\n    constructor(address _authority) public {\\n        initSingleAuthorityPolicy(_authority);\\n    }\\n\\n    function isITokenPlatform() external pure returns (bool) {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/cashlink/stokera-token/contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\n\\nimport './Utils.sol';\\n\\ninterface IUpgradeProxy {\\n    event OwnershipTransferred(address indexed from, address indexed to);\\n    event ProxyPaused();\\n    event ProxyUnpaused();\\n    event ProxyStartUpgrade(address indexed oldAddress, address indexed newAddress,\\n                            uint256 fromVersion, uint256 toVersion);\\n    event ProxyFinishUpgrade(address indexed oldAddress, address indexed newAddress,\\n                             uint256 fromVersion, uint256 toVersion);\\n    event ProxyCallMigration(address indexed oldAddress, address indexed newAddress,\\n                             uint256 fromVersion, uint256 toVersion);\\n    event ProxyForceVersionBump(address indexed oldAddress, address indexed newAddress,\\n                                uint256 fromVersion, uint256 toVersion);\\n    event ProxyCancelUpgrade(address indexed oldAddress, address indexed newAddress,\\n                             uint256 fromVersion, uint256 toVersion);\\n\\n    function proxyTransferOwnership(address _newOwner) external;\\n    function proxyAcceptOwnership() external;\\n    function proxyPause() external;\\n    function proxyUnpause() external;\\n    function proxyStartUpgrade(address newLogicContract, uint256 newVersion) external;\\n    function proxyFinishUpgrade() external;\\n    function proxyCallMigration(bytes calldata data) external;\\n\\n        },\r\n    \"/home/cashlink/stokera-token/contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\n\\n\\n\"\r\n    }\r\n  }\r\n}}",
        "label": false,
        "name": "0xf4f16983bfbceef567270c235e0cb964e4d42d77.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => mapping (address => uint256)) internal VAR2;\nmapping(address => uint256) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR3[msg.sender] >= VAR5 && VAR3[VAR4].add(VAR5) >= VAR3[VAR4]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[VAR6][msg.sender]);\nVAR3[VAR6] = VAR3[VAR6].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nVAR2[VAR6][msg.sender] = VAR2[VAR6][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR5) public returns (bool) {\nVAR2[msg.sender][VAR7] = VAR5;\nreturn true;\n}\nfunction FUN4(address VAR7, uint256 VAR8) public returns (bool VAR9) {\nVAR2[msg.sender][VAR7] = VAR2[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint256 VAR10) public returns (bool VAR9) {\nuint256 VAR11 = VAR2[msg.sender][VAR7];\nif (VAR10 > VAR11) {\nVAR2[msg.sender][VAR7] = 0;\n} else {\nVAR2[msg.sender][VAR7] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR12 = \"Yoganster \";\nstring public constant VAR13 = \"YOGI\";\nuint256 public constant VAR14 = 18;\nuint256 public constant VAR15 = 1000000000 * (10**VAR14);\naddress public VAR16;\nconstructor() public {\nVAR1 = VAR15;\nVAR16 = msg.sender;\nVAR3[VAR16] = VAR1;\n}\n}",
        "label": false,
        "name": "0x273abaa7397a055e0c3cd00737c795be8f817c40.sol"
    },
    {
        "source": "contract CON1{\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire (msg.sender == VAR1);\n_;\n}\nfunction () payable public {\n}\nfunction FUN3(uint VAR2) FUN1 returns(bool) {\nrequire(VAR2 <= this.balance);\nVAR1.transfer(VAR2);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xfc14bd77c17e37642b01663e41de134b2e4fb825.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nuint256 VAR7 = VAR3[VAR6][msg.sender];\nrequire (VAR5 <= VAR7);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nVAR3[VAR6][msg.sender] = VAR7.sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR5) public returns (bool) {\nrequire((VAR5 == 0) || (VAR3[msg.sender][VAR8] == 0));\nVAR3[msg.sender][VAR8] = VAR5;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nbytes16 public constant VAR9 = \"GUBI\";\nbytes16 public constant VAR10 = \"GUBI\";\nuint8 public constant VAR11 = 18;\nconstructor() public {\nVAR1 = 10000000000000000000000000000;\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x12b2b2331a72d375c453c160b2c8a7010eea510a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) internal VAR5;\nuint256 VAR6;\nfunction FUN9(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR8 <= VAR4[msg.sender]);\nrequire(VAR7 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR8) public returns (bool) {\nVAR5[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN11(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR4[VAR10]);\nrequire(VAR8 <= VAR5[VAR10][msg.sender]);\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\nVAR5[VAR10][msg.sender] = VAR5[VAR10][msg.sender].sub(VAR8);\nreturn true;\n}\nfunction FUN12(address VAR9,uint256 VAR11)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR9] = (VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR9,uint256 VAR12)\npublic\nreturns (bool)\n{\nuint256 VAR13 = VAR5[msg.sender][VAR9];\nif (VAR12 >= VAR13) {\nVAR5[msg.sender][VAR9] = 0;\n} else {\nVAR5[msg.sender][VAR9] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4, CON2 {\nfunction FUN9(address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10,address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN10(address VAR9,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN10(VAR9, VAR8);\n}\nfunction FUN12(address VAR9,uint VAR11)\npublic\nFUN5\nreturns (bool VAR14)\n{\nreturn super.FUN12(VAR9, VAR11);\n}\nfunction FUN13(address VAR9,uint VAR12)\npublic\nFUN5\nreturns (bool VAR14)\n{\nreturn super.FUN13(VAR9, VAR12);\n}\n}\ncontract CON6 is CON5 {\nmapping (address => mapping (address => uint256)) internal VAR15;\nfunction FUN14(address VAR9, uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nVAR15[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN15(uint256 VAR8)\npublic\nFUN5\n{\nFUN17(msg.sender, VAR8);\n}\nfunction FUN16(address VAR10,uint256 VAR8)\npublic\nFUN5\n{\nrequire(VAR8 <= VAR15[VAR10][msg.sender]);\nVAR15[VAR10][msg.sender] = VAR15[VAR10][msg.sender].sub(VAR8);\nFUN17(VAR10, VAR8);\n}\nfunction FUN17(address VAR16,uint256 VAR8)\ninternal\nFUN5\n{\nrequire(VAR8 <= VAR4[VAR16]);\nVAR4[VAR16] = VAR4[VAR16].sub(VAR8);\nVAR6 = VAR6.sub(VAR8);\n}\nfunction FUN18(address VAR9,uint256 VAR11)\npublic\nFUN5\nreturns (bool)\n{\nVAR15[msg.sender][VAR9] = (VAR15[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN19(address VAR9,uint256 VAR12)\npublic\nFUN5\nreturns (bool)\n{\nuint256 VAR13 = VAR15[msg.sender][VAR9];\nif (VAR12 >= VAR13) {\nVAR15[msg.sender][VAR9] = 0;\n} else {\nVAR15[msg.sender][VAR9] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nmapping (address => bool) public VAR17;\nfunction FUN20(address VAR18,bool VAR19)\npublic\nFUN1\n{\nVAR17[VAR18] = VAR19;\n}\nfunction FUN9(address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nrequire(!VAR17[msg.sender], \"Sender account freezed\");\nrequire(!VAR17[VAR7], \"Receiver account freezed\");\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10,address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nrequire(!VAR17[msg.sender], \"Spender account freezed\");\nrequire(!VAR17[VAR10], \"Sender account freezed\");\nrequire(!VAR17[VAR7], \"Receiver account freezed\");\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN15(uint256 VAR8)\npublic\nFUN5\n{\nrequire(!VAR17[msg.sender], \"Sender account freezed\");\nreturn super.FUN15(VAR8);\n}\nfunction FUN16(address VAR10,uint256 VAR8)\npublic\nFUN5\n{\nrequire(!VAR17[msg.sender], \"Spender account freezed\");\nrequire(!VAR17[VAR10], \"Sender account freezed\");\nreturn super.FUN16(VAR10, VAR8);\n}\n}\ncontract CON8 is CON7 {\nstring public constant VAR20 = \"VODA TOKEN\";\nstring public constant VAR21 = \"WDT\";\nuint8 public constant VAR22 = 18;\nuint256 public constant VAR23 = 81000000 * (10 ** uint256(VAR22));\nconstructor() public {\nVAR6 = VAR23;\nVAR4[msg.sender] = VAR23;\n}\n}",
        "label": false,
        "name": "0xd110bb8a24b100c37af7310416e685af807c1f10.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(VAR7, VAR4, VAR5);\nFUN6(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN5(address VAR8, uint256 VAR5) internal {\nrequire(VAR8 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR8] = VAR1[VAR8].add(VAR5);\n}\nfunction FUN6(address VAR9, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR9 != address(0));\nVAR2[VAR9][VAR6] = VAR5;\n}\n}\ncontract CON3 is CON1 {\nstring private VAR10;\nstring private VAR11;\nuint8 private VAR12;\nconstructor (string memory VAR13, string memory VAR14, uint8 VAR15) public {\nVAR10 = VAR13;\nVAR11 = VAR14;\nVAR12 = VAR15;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 380000000 * (10 ** uint256(VAR16));\nconstructor () public CON3(\"Chairman\", \"CEOT\", VAR16) {\nFUN5(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0x337e7416685a59af9ff844f4504d64a3a1eb4e43.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nfunction FUN10(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN11(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON4 {\naddress private VAR11;\nconstructor () internal {\nVAR11 = msg.sender;\n}\nmodifier FUN12() {\nrequire(isOwner());\n_;\n}\nfunction FUN13() public FUN12 {\nVAR11 = address(0);\n}\nfunction FUN14(address VAR12) public FUN12 {\nFUN15(VAR12);\n}\nfunction FUN15(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON5 is CON2, CON3, CON4 {\nstring public VAR13;\nstring public VAR14;\nuint8 public constant VAR15 = 18;\nuint256 public VAR16;\nconstructor(string memory VAR17, string memory VAR18, uint256 VAR19)\npublic {\nVAR13 = VAR17;\nVAR14 = VAR18;\nVAR16 = VAR19;\n}\nfunction FUN16(address VAR20, uint256 VAR21) public FUN12 returns (bool) {\nif (VAR16 > 0)\nrequire(totalSupply().add(VAR21) <= VAR16);\nFUN7(VAR20, VAR21);\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nconstructor(string memory VAR17, string memory VAR18, uint VAR19) public CON5(VAR17, VAR18, VAR19) {}\n}",
        "label": false,
        "name": "0x93198d742da2a3ae77a3e49bc92adcd2f13b9863.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) private VAR3;\nfunction FUN5(address VAR4) public FUN1 {\nrequire(VAR4 != address(0), \"Invalid wallet\");\nVAR3[VAR4] = true;\n}\nfunction FUN6(address VAR4) public FUN1 {\nVAR3[VAR4] = false;\n}\n}",
        "label": false,
        "name": "0xa7c58385b66e5d9905fef9dc43d7fb270e527497.sol"
    },
    {
        "source": "contract CON1{\nmapping (address => uint256) public VAR1;\nmapping (address => uint256) public VAR2;\nmapping (address => uint256) public VAR3;\naddress VAR4 = 0xaF9C025Ce6322A23ac00301C714f4F42895c9818;\naddress VAR5 = 0xaF9C025Ce6322A23ac00301C714f4F42895c9818;\nfunction FUN1(address VAR6) public payable {\nrequire(msg.value >= 0.01 ether);\nif(getProfit(msg.sender) > 0){\nuint256 VAR7 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nuint256 VAR8 = msg.value;\nuint256 VAR9 = SafeMath.div(VAR8, 20);\nif(VAR6 != msg.sender && VAR6 != 0x1 && VAR6 != VAR4 && VAR6 != VAR5){\nVAR3[VAR6] = SafeMath.add(VAR3[VAR6], VAR9);\n}\nVAR3[VAR4] = SafeMath.add(VAR3[VAR4], VAR9);\nVAR3[VAR5] = SafeMath.add(VAR3[VAR5], VAR9);\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR8);\nVAR2[msg.sender] = now;\n}\nfunction FUN2() public {\nuint256 VAR7 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nuint256 VAR10 = VAR1[msg.sender];\nuint256 VAR11 = SafeMath.div(VAR10, 5);\nVAR10 = SafeMath.sub(VAR10, VAR11);\nuint256 VAR12 = SafeMath.add(VAR10, VAR7);\nrequire(VAR12 > 0);\nVAR1[msg.sender] = 0;\nmsg.sender.transfer(VAR12);\n}\nfunction FUN3() public{\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nfunction FUN4() public {\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR7);\n}\nfunction FUN5() public {\nrequire(VAR3[msg.sender] > 0);\nuint256 VAR9 = VAR3[msg.sender];\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR9);\n}\n}",
        "label": false,
        "name": "0x72ee07223ad92dfd9e37ce03ad795b1aeddd28b4.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0), \"ERC20: FUN1 VAR4 the zero address\");\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"ERC20: mint VAR4 the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"ERC20: burn VAR7 the zero address\");\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN2 VAR7 the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 VAR4 the zero address\");\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 210000000000 * (10 ** uint256(VAR18));\nconstructor (address VAR11) public CON3(\"EVEOToken\", \"EVEO\", VAR18) {\nFUN7(VAR11, VAR19);\n}\n}",
        "label": false,
        "name": "0x6b40d317bc1de4b0938519ac707ae36464f49171.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nfunction CON1() internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(VAR1 == msg.sender);\n_;\n}\nfunction FUN2(address VAR3) FUN1 public {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(VAR2 != address(0));\nrequire(VAR2 == msg.sender);\nVAR1 = VAR2;\ndelete VAR2;\n}\n}\ncontract CON2 {\nuint public VAR4;\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint;\nstring public VAR5 = \"Skraps\";\nstring public VAR6 = \"SKRP\";\nuint8 public VAR7 = 18;\nuint public VAR4;\nmapping (address => uint) private VAR8;\nmapping (address => mapping (address => uint)) private VAR9;\nfunction FUN4(address VAR10) public constant returns (uint) {\nreturn VAR8[VAR10];\n}\nfunction FUN5(address VAR3, address VAR11) public constant returns (uint VAR12) {\nreturn VAR9[VAR3][VAR11];\n}\nfunction CON3() public {\nVAR4 = 110000000 * 1 ether;\nVAR8[msg.sender] = VAR4;\n}\nfunction FUN6(address VAR13, uint VAR14) public returns (bool VAR15) {\nrequire(VAR13 != address(0));\nrequire(VAR8[msg.sender] >= VAR14);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN7(address VAR16, address VAR13, uint VAR14) public returns (bool VAR15) {\nrequire(VAR13 != address(0));\nrequire(VAR8[VAR16] >= VAR14 && VAR9[VAR16][msg.sender] >= VAR14);\nVAR9[VAR16][msg.sender] = VAR9[VAR16][msg.sender].sub(VAR14);\nVAR8[VAR16] = VAR8[VAR16].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR11, uint VAR14) public returns (bool VAR15) {\nrequire(VAR11 != address(0));\nrequire((VAR14 == 0) || (VAR9[msg.sender][VAR11] == 0));\nVAR9[msg.sender][VAR11] = VAR14;\nreturn true;\n}\nfunction FUN9(uint VAR14) public FUN1 {\nrequire(VAR8[this] > 0 && VAR8[this] >= VAR14);\nVAR8[this] = VAR8[this].sub(VAR14);\nVAR8[msg.sender] = VAR8[msg.sender].add(VAR14);\n}\n}",
        "label": false,
        "name": "0xe0bc22509a17bf43e3fe61adcf9be25274cd9232.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR8, uint256 VAR7) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(VAR9, VAR6, VAR7);\nFUN13(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN8(address VAR8, uint256 VAR10) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR11) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN12(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR7);\n}\nfunction FUN13(address VAR13, address VAR8, uint256 VAR7) internal {\nrequire(VAR8 != address(0));\nrequire(VAR13 != address(0));\nVAR4[VAR13][VAR8] = VAR7;\n}\nfunction FUN14(address VAR12, uint256 VAR7) internal {\nFUN12(VAR12, VAR7);\nFUN13(VAR12, msg.sender, VAR4[VAR12][msg.sender].sub(VAR7));\n}\n}\ncontract CON4 is CON3, CON1 {\nstring public VAR14;\nstring public VAR15;\nuint8 public VAR16;\nMarketSide public VAR17; enum MarketSide { Long, Short}\nconstructor(string memory VAR18,string memory VAR19,uint8 VAR20) public\n{\nVAR14 = VAR18;\nVAR15 = VAR19;\nVAR16 = 5;\nVAR17 = MarketSide(VAR20);\n}\nfunction FUN15(uint256 VAR21,address VAR22) external FUN1\n{\nFUN11(VAR22, VAR21);\n}\nfunction FUN16(uint256 VAR23,address VAR24) external FUN1\n{\nFUN12(VAR24, VAR23);\n}\n}\ncontract CON5 is CON1 {\nusing StringLib for *;\nstring public VAR25;\naddress public VAR26;\naddress public VAR27;\nuint public VAR28;\nuint public VAR29;\nuint public VAR30; uint public VAR31; uint public VAR32; uint public VAR33;\nuint public VAR34;\nuint public VAR35;\nuint public VAR36 = 1 days;\naddress public VAR37;\naddress public VAR38;\nuint public VAR39;\nuint public VAR40;\nuint public VAR41;\nbool public VAR42 = false;\nconstructor(bytes32[3] memory VAR43,address[3] memory VAR44,uint[7] memory VAR45) public\n{\nVAR29 = VAR45[0];\nVAR28 = VAR45[1];\nrequire(VAR28 > VAR29, \"PRICE_CAP must be greater than PRICE_FLOOR\");\nVAR30 = VAR45[2];\nVAR31 = VAR45[3];\nVAR35 = VAR45[6];\nrequire(VAR35 > now, \"EXPIRATION must be in the future\");\nrequire(VAR31 != 0,\"QTY_MULTIPLIER cannot be 0\");\nVAR26 = VAR44[1];\nVAR27 = VAR44[2];\nVAR32 = MathLib.calculateTotalCollateral(VAR29, VAR28, VAR31);\nVAR33 = MathLib.calculateFeePerUnit(VAR29,VAR28,VAR31,VAR45[4]);\nVAR34 = MathLib.calculateFeePerUnit(VAR29,VAR28,VAR31,VAR45[5]);\nVAR25 = VAR43[0].bytes32ToString();\nCON4 VAR46 = new CON4(\"MARKET Protocol Long Position Token\",VAR43[1].bytes32ToString(),uint8(CON4.MarketSide.Long));\nCON4 VAR47 = new CON4(\"MARKET Protocol Short Position Token\",VAR43[2].bytes32ToString(),uint8(CON4.MarketSide.Short));\nVAR37 = address(VAR46);\nVAR38 = address(VAR47);\nFUN3(VAR44[0]);\n}\nfunction FUN17(uint256 VAR21,address VAR48) external FUN22\n{\nCON4(VAR37).FUN15(VAR21, VAR48);\nCON4(VAR38).FUN15(VAR21, VAR48);\n}\nfunction FUN18(uint256 VAR23,address VAR24) external FUN22\n{\nCON4(VAR37).FUN16(VAR23, VAR24);\n}\nfunction FUN19(uint256 VAR23,address VAR24) external FUN22\n{\nCON4(VAR38).FUN16(VAR23, VAR24);\n}\nfunction FUN20() internal {\nrequire(!VAR42, \"Contract is already settled\");\nuint VAR49;\nif (now > VAR35) { VAR42 = true; VAR49 = VAR39;\n} else if (VAR39 >= VAR28) { VAR42 = true;\nVAR49 = VAR28;\n} else if (VAR39 <= VAR29) { VAR42 = true;\nVAR49 = VAR29;\n}\nif (VAR42) {\nFUN21(VAR49);\n}\n}\nfunction FUN21(uint VAR50) internal {\nVAR41 = now;\nVAR40 = VAR50;\n}\nmodifier FUN22 {\nrequire(msg.sender == VAR27, \"Only callable VAR9 the collateral pool\");\n_;\n}\n}\ncontract CON6 is CON5 {\naddress public VAR51;\nstring public VAR52;\nstring public VAR53;\nconstructor(bytes32[3] memory VAR43,address[3] memory VAR44,address VAR54,uint[7] memory VAR45,string memory VAR55,string memory VAR56) CON5(VAR43,VAR44,VAR45) public\n{\nVAR52 = VAR55;\nVAR53 = VAR56;\nVAR51 = VAR54;\n}\nfunction FUN23(uint256 VAR57) public FUN25 {\nrequire(!VAR42);\nVAR39 = VAR57;\nFUN20(); }\nfunction FUN24(uint256 VAR57) public FUN1 {\nrequire(VAR57 >= VAR29 && VAR57 <= VAR28, \"arbitration VAR57 must be within contract bounds\");\nVAR39 = VAR57;\nFUN21(VAR57);\nVAR42 = true;\n}\nmodifier FUN25() {\nrequire(msg.sender == VAR51, \"only callable by the oracle hub\");\n_;\n}\nfunction FUN26(address VAR54) public FUN1 {\nrequire(VAR54 != address(0), \"cannot set VAR54 VAR6 null address\");\nVAR51 = VAR54;\n}\n}\ncontract CON7 {\n}\ncontract CON8 is CON1 {\naddress public VAR58;\naddress public VAR59;\naddress public VAR60;\nconstructor(address VAR61,address VAR62,address VAR54) public {\nrequire(VAR61 != address(0), \"registryAddress can not be null\");\nrequire(VAR62 != address(0), \"collateralPoolAddress can not be null\");\nrequire(VAR54 != address(0), \"oracleHubAddress can not be null\");\nVAR58 = VAR61;\nVAR60 = VAR62;\nVAR59 = VAR54;\n}\nfunction FUN27(bytes32[3] calldata VAR43,address VAR63,uint[7] calldata VAR45,string calldata VAR55,string calldata VAR56) external FUN1\n{\nCON6 VAR64 = new CON6(VAR43,[VAR13(),VAR63,VAR60],VAR59,VAR45,VAR55,VAR56);\nCON7(VAR58).addAddressToWhiteList(address(VAR64));\n}\nfunction FUN28(address VAR61) external FUN1 {\nrequire(VAR61 != address(0), \"registryAddress can not be null\");\nVAR58 = VAR61;\n}\nfunction FUN26(address VAR54) external FUN1 {\nrequire(VAR54 != address(0), \"oracleHubAddress can not be null\");\nVAR59 = VAR54;\n}\n}",
        "label": false,
        "name": "0x3457905deea11ddc085bc7bfaa8813aab26b2ded.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\nmapping(address => uint256) internal VAR2;\nmapping(address => mapping(address => uint256)) internal VAR3;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR4] = VAR5;\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR6] = VAR2[VAR6].add(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR3[VAR7][msg.sender] = VAR3[VAR7][msg.sender].sub(VAR5);\nVAR2[VAR7] = VAR2[VAR7].sub(VAR5);\nVAR2[VAR6] = VAR2[VAR6].add(VAR5);\nreturn true;\n}\nfunction FUN4(uint256 VAR5) public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR1 = VAR1.sub(VAR5);\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR8 = 'Coomi';\nstring public constant VAR9 = 'COOMI';\nuint8 public constant VAR10 = 18;\nconstructor(uint256 VAR11) public {\nVAR1 = VAR11;\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x3062671bc05443e3e516fb9c8ad9482346f86980.sol"
    },
    {
        "source": "{\"LinkedList.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract LinkedList{\\n    mapping(address=\\u003emapping(bool=\\u003eaddress)) dllIndex;\\n    mapping(address =\\u003e uint) balances;\\n    address head;\\n    address tail;\\n    uint arraySize = 0;\\n    \\n    constructor(address _owner) public{\\n        head=_owner;\\n        dllIndex[head][true]=_owner;\\n        dllIndex[head][false]=_owner;\\n        tail=_owner;\\n        dllIndex[tail][true]=_owner;\\n        dllIndex[tail][false]=_owner;\\n        arraySize++;\\n    }\\n    \\n    function add(address _addr) public\\n    {\\n        address nullAddress;\\n        \\n        if (dllIndex[_addr][false]==nullAddress \\u0026\\u0026 dllIndex[_addr][true]==nullAddress){\\n            //false==PREV\\n            //true==NEXT\\n            dllIndex[_addr][false] = tail;\\n            dllIndex[_addr][true] = _addr;\\n        \\n            // Insert the new node\\n            dllIndex[tail][true] = _addr;\\n            tail=_addr;\\n            arraySize++;\\n            getList();\\n        }\\n        \\n    }\\n\\n    function remove(address _addr) public\\n    {\\n        if (arraySize\\u003e1){\\n            address previous = dllIndex[_addr][false];\\n            address next = dllIndex[_addr][true];\\n            \\n        \\n            if (_addr == head){\\n                head=next;\\n                dllIndex[previous][false]=next;\\n            } else if(_addr == tail){\\n                tail=previous;\\n                dllIndex[next][false]=previous;\\n            }else{\\n                dllIndex[dllIndex[_addr][false]][true] = next;\\n                dllIndex[dllIndex[_addr][true]][false] = previous;\\n            }\\n            //Delete state storage\\n            delete dllIndex[_addr][false];\\n            delete dllIndex[_addr][true];\\n            delete balances[_addr];\\n            arraySize--;\\n        }\\n        \\n    }\\n    \\n    function getList() public view returns(address[] memory){\\n        address[] memory addressList = new address[](arraySize);\\n        addressList[0]=head;\\n        if(arraySize==1){\\n            return addressList;\\n        }else{\\n            buildList(head, addressList, 1);\\n            return addressList;\\n        }\\n    }\\n    \\n    function buildList(address currentLink, address[] memory currentList, uint currentIndex) public view{\\n        if (currentLink != dllIndex[currentLink][true]){\\n            currentList[currentIndex]=dllIndex[currentLink][true];\\n            currentIndex++;\\n            buildList(dllIndex[currentLink][true], currentList, currentIndex);\\n        }\\n    }\\n    \\n    function getElement(address itemAddress) public view returns(address previous, address next){\\n        previous = dllIndex[itemAddress][false];\\n        next = dllIndex[itemAddress][true];\\n    }\\n}\"},\"tfys.sol\":{\"content\":\"pragma solidity ^0.5.0;\\nimport \\\"./LinkedList.sol\\\";\\n\\n\\n\\ncontract ERC223ReceivingContract { \\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\\n}\\n\\n\\ncontract tfys{\\n    mapping (string =\\u003e int[]) public resultados;\\n    \\n    function getResultado(string memory auction) public view returns(int[] memory resultado){\\n        resultado=resultados[auction];\\n    }\\n    \\n    function salvarResultados(string memory auction, int[] memory numeros) public{\\n        require(isOwner[msg.sender]);\\n        resultados[auction]=numeros;\\n    }\\n    \\n    using SafeMath for uint256;\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    mapping(uint=\\u003emapping (uint=\\u003e LinkedList)) public listasDeEscolhas;\\n    \\n    mapping (uint=\\u003evotacao) public listaDeVotacoes;\\n    uint public votacaoAtual=0;\\n    struct votacao{\\n        mapping(address=\\u003ebool) votou;\\n        mapping(address=\\u003euint) votouOnde;\\n        mapping(uint=\\u003euint) votosNaOpcao;\\n        uint blocoInicial;\\n        uint blocoFinal;\\n        string titulo;\\n        escolha[] escolhas;\\n        uint quantidadeEscolhas;\\n    }\\n    struct escolha{\\n        string titulo;\\n        LinkedList votos;\\n    }\\n    \\n    function abrirVotacao(uint blocoInicial, uint blocoFinal, string memory titulo) public{\\n        require(isOwner[msg.sender]);\\n        require(blocoInicial \\u003e= block.number);\\n        require(blocoFinal \\u003e blocoInicial);\\n        uint inteiroNulo;\\n        uint votacaoAtualBlocoFinal = listaDeVotacoes[votacaoAtual].blocoFinal;\\n        if (votacaoAtualBlocoFinal != inteiroNulo){\\n            require(votacaoAtualBlocoFinal\\u003cblock.number);\\n        }\\n        \\n        listaDeVotacoes[votacaoAtual].blocoInicial=blocoInicial;\\n        listaDeVotacoes[votacaoAtual].blocoFinal=blocoFinal;\\n        listaDeVotacoes[votacaoAtual].titulo=titulo;\\n        listaDeVotacoes[votacaoAtual].quantidadeEscolhas=0;\\n        \\n        votacaoAtual++;\\n    }\\n    function editarVotacao(uint blocoInicial, uint blocoFinal, string memory titulo) public{\\n        require(isOwner[msg.sender]);\\n        require(blocoFinal \\u003e blocoInicial);\\n        listaDeVotacoes[votacaoAtual-1].blocoInicial=blocoInicial;\\n        listaDeVotacoes[votacaoAtual-1].blocoFinal=blocoFinal;\\n        listaDeVotacoes[votacaoAtual-1].titulo=titulo;\\n    }\\n    \\n    function adicionarUmaEscolha(string memory titulo) public{\\n        require(isOwner[msg.sender]);\\n        // require(listaDeVotacoes[votacaoAtual-1].blocoInicial\\u003e=block.number);\\n        uint inteiroNulo;\\n        if (listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas==inteiroNulo){\\n            listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas=0;\\n        }\\n        listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas++;\\n\\n        LinkedList votos;\\n        listaDeVotacoes[votacaoAtual-1].escolhas.push(escolha({titulo: titulo, votos:votos}));\\n    }\\n    \\n    function getResultadoDaEscolha(uint _escolha, uint _votacao) public view returns(string memory escolhaTitulo, uint votos){\\n        escolhaTitulo = listaDeVotacoes[_votacao].escolhas[_escolha].titulo;\\n        votos = listaDeVotacoes[_votacao].votosNaOpcao[_escolha];\\n    }\\n    \\n    function votar(uint _escolha) public {\\n        require(listaDeVotacoes[votacaoAtual-1].blocoInicial\\u003c=block.number);\\n        require(listaDeVotacoes[votacaoAtual-1].blocoFinal\\u003e=block.number);\\n        listaDeVotacoes[votacaoAtual-1].votosNaOpcao[_escolha]+=users[msg.sender].balance;\\n        listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]=_escolha;\\n        listaDeVotacoes[votacaoAtual-1].votou[msg.sender]=true;\\n        LinkedList votos;\\n        if (listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos==votos){\\n            listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos = new LinkedList(msg.sender);\\n        }else{\\n            listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos.add(msg.sender);\\n        }\\n        \\n    }\\n    \\n    function name() public pure returns (string memory _name){\\n        _name = \\\"TradeForYou-S\\\";\\n    }\\n    \\n    function symbol() public pure returns (bytes32 _symbol){\\n        _symbol = \\\"TFYS\\\";\\n    }\\n    \\n    function decimals() public pure returns (uint8 _decimals){\\n        _decimals = 0;\\n    }\\n    \\n    uint public janelaAtual=0;\\n    mapping(uint=\\u003ejanela) public listaDeJanelas;\\n    struct janela{\\n        uint blocoInicial;\\n        uint blocoFinal;\\n        uint ethEmWei;\\n        uint totalTokensTravados;\\n        mapping (address=\\u003euint) saldoTravado;\\n    }\\n\\n    function abrirJanela(uint blocoInicial, uint blocoFinal, uint ethEmWei) public payable{\\n        \\n        require(msg.value==ethEmWei);\\n        require(isOwner[msg.sender]);\\n        require(blocoInicial \\u003e= block.number);\\n        require(blocoFinal \\u003e blocoInicial);\\n        uint inteiroNulo;\\n        uint janelaAtualBlocoFinal = listaDeJanelas[janelaAtual].blocoFinal;\\n        if (janelaAtualBlocoFinal != inteiroNulo){\\n            require(janelaAtualBlocoFinal\\u003cblock.number);\\n        }\\n        janelaAtual++;\\n        listaDeJanelas[janelaAtual].blocoInicial=blocoInicial;\\n        listaDeJanelas[janelaAtual].blocoFinal=blocoFinal;\\n        listaDeJanelas[janelaAtual].ethEmWei=ethEmWei;\\n        \\n    }\\n    function editarJanela(uint blocoInicial, uint blocoFinal, uint ethEmWei) public payable{\\n        require(msg.value==ethEmWei);\\n        require(isOwner[msg.sender]);\\n        require(blocoFinal \\u003e blocoInicial);\\n        listaDeJanelas[janelaAtual].blocoInicial=blocoInicial;\\n        listaDeJanelas[janelaAtual].blocoFinal=blocoFinal;\\n        uint saldoASacar = listaDeJanelas[janelaAtual].ethEmWei;\\n        listaDeJanelas[janelaAtual].ethEmWei=ethEmWei;\\n        msg.sender.transfer(saldoASacar);\\n    }\\n    \\n    mapping (address =\\u003e bool) public isOwner;\\n    uint private _quantidadeOwners = 0;\\n    LinkedList private _owners;\\n    \\n    mapping(address=\\u003eaccount) users;\\n    \\n    struct account{\\n        uint balance;\\n        uint headDividendos;\\n        uint[] dividendos;\\n    }\\n    \\n    function participarDaJanela() public{\\n        require(listaDeJanelas[janelaAtual].blocoInicial\\u003c=block.number);\\n        require(listaDeJanelas[janelaAtual].blocoFinal\\u003e=block.number);\\n        uint inteiroNulo;\\n        if(listaDeJanelas[janelaAtual].saldoTravado[msg.sender]==inteiroNulo){\\n            listaDeJanelas[janelaAtual].saldoTravado[msg.sender]=0;\\n        }\\n        require(users[msg.sender].balance\\u003elistaDeJanelas[janelaAtual].saldoTravado[msg.sender]);\\n        listaDeJanelas[janelaAtual].saldoTravado[msg.sender]=users[msg.sender].balance;\\n        listaDeJanelas[janelaAtual].totalTokensTravados+=users[msg.sender].balance;\\n        users[msg.sender].dividendos.push(janelaAtual);\\n    }\\n    function reclamarDividendos() public payable{\\n        require(users[msg.sender].dividendos.length\\u003e0);\\n        uint head = users[msg.sender].headDividendos;\\n        uint dividendos=0;\\n        for(uint i=head; i\\u003cusers[msg.sender].dividendos.length; i++){\\n            janela storage janelaContagem = listaDeJanelas[users[msg.sender].dividendos[i]];\\n            if(janelaContagem.blocoFinal\\u003cblock.number){\\n                users[msg.sender].headDividendos++;\\n                uint totalTrancado = janelaContagem.totalTokensTravados;\\n                uint meuTrancado = janelaContagem.saldoTravado[msg.sender];\\n                uint totalWei = janelaContagem.ethEmWei;\\n                dividendos += (totalWei/totalTrancado)*meuTrancado;\\n            }\\n        }\\n        msg.sender.transfer(dividendos);\\n    }\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n    constructor() public{\\n        _totalSupply=10000000;\\n        users[msg.sender].balance=_totalSupply;\\n        isOwner[msg.sender]=true;\\n        _quantidadeOwners++;\\n        _owners = new LinkedList(msg.sender);\\n        \\n    }\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return users[owner].balance;\\n    }\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        bytes memory empty;\\n        transfer(to, value, empty);\\n        return true;\\n    }\\n    function transfer(address to, uint256 value, bytes memory data) public returns (bool) {\\n        _transfer(msg.sender, to, value, data);\\n        return true;\\n    }\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        bytes memory empty;\\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\\n        _transfer(from, to, value, empty);\\n        return true;\\n    }\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n    function _transfer(address from, address to, uint256 value, bytes memory data) internal {\\n        if(listaDeJanelas[janelaAtual].blocoFinal\\u003e=block.number){\\n            uint inteiroNulo;\\n            if(listaDeJanelas[janelaAtual].saldoTravado[from]==inteiroNulo){\\n                listaDeJanelas[janelaAtual].saldoTravado[from]=0;\\n            }\\n            uint saldoLivre = users[from].balance.sub(listaDeJanelas[janelaAtual].saldoTravado[from]);\\n            require(saldoLivre\\u003e=value);\\n        }\\n        if (listaDeVotacoes[votacaoAtual-1].votou[msg.sender]){\\n            uint valorDoVoto=listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]];\\n            listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]]= valorDoVoto.sub(value);\\n        } if (listaDeVotacoes[votacaoAtual-1].votou[to]){\\n            uint valorDoVoto = listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[to]];\\n            listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[to]] = valorDoVoto.add(value);\\n        }\\n        uint codeLength;\\n        assembly {\\n            // Retrieve the size of the code on target address, this needs assembly .\\n            codeLength := extcodesize(to)\\n        }\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        users[from].balance = users[from].balance.sub(value);\\n        users[to].balance = users[to].balance.add(value);\\n        emit Transfer(from, to, value);\\n        if(codeLength\\u003e0) {\\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\\n            receiver.tokenFallback(msg.sender, value, data);\\n        }\\n        \\n    }\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n    \\n    function getOwnersList() public view returns(address[] memory){\\n         return _owners.getList();\\n    }\\n    \\n    function addOwner(address _newOwner) public returns(bool){\\n        require(isOwner[msg.sender]);\\n        isOwner[_newOwner]=true;\\n        _quantidadeOwners++;\\n        _owners.add(_newOwner);\\n        return true;\\n    }\\n    function removeOwner(address _oldOwner) public returns(bool){\\n        require(isOwner[msg.sender]);\\n        require(_quantidadeOwners\\u003e1);\\n        isOwner[_oldOwner]=false;\\n        _quantidadeOwners--;\\n        _owners.remove(_oldOwner);\\n        return true;\\n    }\\n    \\n    \\n}\"}}",
        "label": false,
        "name": "0x9e78ab50ddb57334c73f0475c0c5cf33417f238a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR2)\npublic\nFUN1\n{\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON1, CON3 {\nmapping(address => VestingSchedule) public VAR3; mapping(address => address) public VAR4;\nCON2 VAR5;\nstruct VestingSchedule {\nuint VAR6;\nuint VAR7;\nuint VAR8;\nuint VAR9;\nuint VAR10;\naddress VAR11;\nbool VAR12;\n}\nmodifier FUN3(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR11 != address(0));\n_;\n}\nmodifier FUN4(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR11 == address(0));\n_;\n}\nmodifier FUN5(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR12);\n_;\n}\nmodifier FUN6(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(!VAR14.VAR12);\n_;\n}\nmodifier FUN7(address VAR13) {\nrequire(VAR4[VAR13] != address(0));\n_;\n}\nmodifier FUN8(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(block.timestamp > VAR14.VAR7);\n_;\n}\nmodifier FUN9(uint VAR6, uint VAR7, uint VAR8) {\nrequire(VAR7 >= VAR6);\nrequire(VAR8 >= VAR7);\n_;\n}\nmodifier FUN10(address VAR13) {\nrequire(VAR13 != address(0));\n_;\n}\nconstructor(address VAR15) public {\nVAR5 = CON2(VAR15);\n}\nfunction FUN11(address VAR16,address VAR17,uint VAR18,uint VAR19,uint VAR20,uint VAR21)\npublic\nFUN1\nFUN10(VAR17)\nFUN6(VAR16)\nFUN9(VAR18, VAR19, VAR20)\n{\nVAR3[VAR16] = VestingSchedule({VAR6: VAR18,VAR7: VAR19,VAR8: VAR20,VAR9: VAR21,VAR10: 0,VAR11: VAR17,VAR12: false});\n}\nfunction FUN12(uint VAR18,uint VAR19,uint VAR20,uint VAR21)\npublic\nFUN3(msg.sender)\nFUN6(msg.sender)\n{\nVestingSchedule storage VAR14 = VAR3[msg.sender];\nrequire(VAR14.VAR6 == VAR18);\nrequire(VAR14.VAR7 == VAR19);\nrequire(VAR14.VAR8 == VAR20);\nrequire(VAR14.VAR9 == VAR21);\nVAR14.VAR12 = true;\nrequire(VAR5.transferFrom(VAR14.VAR11, address(this), VAR21));\n}\nfunction FUN13()\npublic\nFUN5(msg.sender)\nFUN8(msg.sender)\n{\nVestingSchedule storage VAR14 = VAR3[msg.sender];\nuint VAR22 = getTotalAmountVested(VAR14);\nuint VAR23 = safeSub(VAR22, VAR14.VAR10);\nVAR14.VAR10 = VAR22;\nif (VAR23 > 0) {\nrequire(VAR5.transfer(msg.sender, VAR23));\n}\n}\nfunction FUN14(address VAR24)\npublic\nFUN5(msg.sender)\nFUN4(VAR24)\nFUN10(VAR24)\n{\nVAR4[msg.sender] = VAR24;\n}\nfunction FUN15(address VAR25, address VAR24)\npublic\nFUN1\nFUN7(VAR25)\nFUN4(VAR24)\n{\naddress VAR26 = VAR4[VAR25];\nrequire(VAR26 == VAR24);\nVestingSchedule memory VAR14 = VAR3[VAR25];\nVAR3[VAR26] = VAR14;\ndelete VAR3[VAR25];\ndelete VAR4[VAR25];\n}\n}",
        "label": false,
        "name": "0xac1886906baa783e634b2c6c392082e0dee5f465.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\nbytes32 internal constant VAR1 = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\n}\ncontract CON4 is CON2, CON3 {\nCON1 private VAR2;\nmodifier FUN1(bytes32 VAR3) {\nrequire(VAR2.allowed(msg.sender, VAR3, this, msg.sig));\n_;\n}\nfunction CON4(CON1 VAR4) internal {\nrequire(address(VAR4) != 0x0);\nVAR2 = VAR4;\n}\nfunction FUN2(CON1 VAR5, address VAR6)\npublic\nFUN1(VAR1)\n{\nrequire(VAR5.allowed(VAR6, VAR1, this, msg.sig));\nCON1 VAR7 = VAR2;\nVAR2 = VAR5;\n}\nfunction FUN3()\npublic\nconstant\nreturns (CON1)\n{\nreturn VAR2;\n}\n}\ncontract CON5 {\nfunction FUN4(address VAR8)\ninternal\nconstant\nreturns (bool)\n{\nuint256 VAR9;\nassembly { VAR9 := extcodesize(VAR8) }\nreturn VAR9 > 0;\n}\n}\ncontract CON6 {\nbytes32 internal constant VAR10 = 0x4675da546d2d92c5b86c4f726a9e61010dce91cccc2491ce6019e78b09d2572e;\nbytes32 internal constant VAR11 = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;\nbytes32 internal constant VAR12 = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\nbytes32 internal constant VAR13 = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\nbytes32 internal constant VAR14 = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\nbytes32 internal constant VAR15 = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\nbytes32 internal constant VAR16 = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\nbytes32 internal constant VAR17 = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\nbytes32 internal constant VAR18 = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\n}\ncontract CON7 {\n}\ncontract CON8 is CON4, CON6 {\nCON7 constant internal VAR19 = CON7(0x0);\nfunction FUN5(CON7 VAR20)\npublic\nFUN1(VAR16)\n{\naddress VAR21 = msg.sender;\nif(VAR20 == VAR19) {\nVAR21.FUN18(this.VAR22);\n} else {\nuint256 VAR22 = VAR20.FUN20(this);\nrequire(VAR20.FUN18(VAR21, VAR22));\n}\n}\n}\ncontract CON9 {\n}\ncontract CON10 is CON9 {\nstring private VAR23;\nstring private VAR24;\nuint8 private VAR25;\nstring private VAR26;\nfunction CON10(string VAR27,uint8 VAR28,string VAR29,string VAR30)\npublic\n{\nVAR23 = VAR27; VAR24 = VAR29; VAR25 = VAR28; VAR26 = VAR30;\n}\nfunction FUN6()\npublic\nconstant\nreturns (string)\n{\nreturn VAR23;\n}\nfunction FUN7()\npublic\nconstant\nreturns (string)\n{\nreturn VAR24;\n}\nfunction FUN8()\npublic\nconstant\nreturns (uint8)\n{\nreturn VAR25;\n}\nfunction VAR30()\npublic\nconstant\nreturns (string)\n{\nreturn VAR26;\n}\n}\ncontract CON11 {\n}\ncontract CON12 is CON7 {\n}\ncontract CON13 {\n}\ncontract CON14 is CON7, CON13 {\n}\ncontract CON15 {\n}\ncontract CON16 is CON13 {\n}\ncontract CON17 is CON14, CON16 {\n}\ncontract CON18 {\nfunction FUN9(uint256 VAR31, uint256 VAR32)\ninternal\nconstant\nreturns(uint256)\n{\nreturn VAR31 > VAR32 ? VAR31 - VAR32 : VAR32 - VAR31;\n}\nfunction FUN10(uint256 VAR33, uint256 VAR34)\ninternal\nconstant\nreturns(uint256)\n{\nreturn FUN15(VAR33, VAR34/2) / VAR34;\n}\nfunction FUN11(uint256 VAR35, uint256 VAR36)\ninternal\nconstant\nreturns(uint256)\n{\nreturn FUN12(VAR35, VAR36, 10**18);\n}\nfunction FUN12(uint256 VAR35, uint256 VAR37, uint256 VAR38)\ninternal\nconstant\nreturns(uint256)\n{\nreturn FUN10(FUN13(VAR35, VAR37), VAR38);\n}\nfunction FUN13(uint256 VAR39, uint256 VAR40)\ninternal\nconstant\nreturns (uint256)\n{\nuint256 VAR41 = VAR39 * VAR40;\nassert(VAR39 == 0 || VAR41 / VAR39 == VAR40);\nreturn VAR41;\n}\nfunction FUN14(uint256 VAR39, uint256 VAR40)\ninternal\nconstant\nreturns (uint256)\n{\nassert(VAR40 <= VAR39);\nreturn VAR39 - VAR40;\n}\nfunction FUN15(uint256 VAR39, uint256 VAR40)\ninternal\nconstant\nreturns (uint256)\n{\nuint256 VAR41 = VAR39 + VAR40;\nassert(VAR41 >= VAR39);\nreturn VAR41;\n}\nfunction FUN16(uint256 VAR39, uint256 VAR40)\ninternal\nconstant\nreturns (uint256)\n{\nreturn VAR39 < VAR40 ? VAR39 : VAR40;\n}\nfunction FUN17(uint256 VAR39, uint256 VAR40)\ninternal\nconstant\nreturns (uint256)\n{\nreturn VAR39 > VAR40 ? VAR39 : VAR40;\n}\n}\ncontract CON19 is CON7, CON18 {\nmapping(address => uint256) internal VAR42;\nuint256 internal VAR43;\nfunction FUN18(address VAR44, uint256 VAR35)\npublic\nreturns (bool)\n{\nFUN21(msg.sender, VAR44, VAR35);\nreturn true;\n}\nfunction FUN19()\npublic\nconstant\nreturns (uint256)\n{\nreturn VAR43;\n}\nfunction FUN20(address VAR45)\npublic\nconstant\nreturns (uint256 VAR22)\n{\nreturn VAR42[VAR45];\n}\nfunction FUN21(address VAR46, address VAR44, uint256 VAR35)\ninternal\n{\nrequire(VAR44 != address(0));\nVAR42[VAR46] = FUN14(VAR42[VAR46], VAR35);\nVAR42[VAR44] = FUN15(VAR42[VAR44], VAR35);\n}\n}\ncontract CON20 is\nCON14,\nCON19,\nCON17\n{\nmapping (address => mapping (address => uint256)) private VAR47;\nfunction FUN22(address VAR46, address VAR44, uint256 VAR35)\npublic\nreturns (bool)\n{\nvar VAR48 = VAR47[VAR46][msg.sender];\nVAR47[VAR46][msg.sender] = FUN14(VAR48, VAR35);\nFUN21(VAR46, VAR44, VAR35);\nreturn true;\n}\nfunction FUN23(address VAR49, uint256 VAR35)\npublic\nreturns (bool)\n{\nrequire((VAR35 == 0) || (VAR47[msg.sender][VAR49] == 0));\nVAR47[msg.sender][VAR49] = VAR35;\nreturn true;\n}\nfunction VAR48(address VAR45, address VAR49)\npublic\nconstant\nreturns (uint256 VAR50)\n{\nreturn VAR47[VAR45][VAR49];\n}\nfunction FUN24(address VAR49,uint256 VAR35,bytes VAR51)\npublic\nreturns (bool)\n{\nrequire(FUN23(VAR49, VAR35));\nbool VAR52 = CON15(VAR49).receiveApproval(msg.sender,VAR35,this,VAR51);\nrequire(VAR52);\nreturn true;\n}\n}\ncontract CON21 is\nCON5,\nCON4,\nCON20,\nCON10,\nCON8\n{\nstring private constant VAR23 = \"Ether Token\";\nstring private constant VAR24 = \"ETH-T\";\nuint8 private constant VAR25 = 18;\nfunction CON21(CON1 FUN3)\nCON4(FUN3)\nCON20()\nCON10(VAR23, VAR25, VAR24, \"\")\nCON8()\npublic\n{\n}\nfunction FUN25()\npayable\npublic\n{\nVAR42[msg.sender] = FUN15(VAR42[msg.sender], msg.value);\nVAR43 = FUN15(VAR43, msg.value);\n}\nfunction FUN26(uint256 VAR35)\npublic\n{\nrequire(VAR42[msg.sender] >= VAR35);\nVAR42[msg.sender] = FUN14(VAR42[msg.sender], VAR35);\nVAR43 = FUN14(VAR43, VAR35);\nmsg.sender.FUN18(VAR35);\n}\nfunction FUN18(address VAR44, uint256 VAR35, bytes VAR53)\npublic\nreturns (bool)\n{\nFUN21(msg.sender, VAR44, VAR35);\nif (FUN4(VAR44)) {\nCON11(VAR44).onTokenTransfer(msg.sender, VAR35, VAR53);\n}\nreturn true;\n}\nfunction FUN5(CON7 VAR20)\npublic\n{\nrequire(VAR20 != VAR19);\nCON8.FUN5(VAR20);\n}\n}",
        "label": false,
        "name": "0xb59a226a2b8a2f2b0512baa35cc348b6b213b671.sol"
    },
    {
        "source": "contract CON1{\nuint256 public VAR1=86400; uint256 public VAR2=0;\nuint256 VAR3=10000;\nuint256 VAR4=5000;\nbool public VAR5=false;\naddress public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => uint256) public VAR9;\nmapping (address => address) public VAR10;\nuint256 public VAR11;\nfunction CON1() public{\nVAR6=msg.sender;\n}\nfunction FUN1(address VAR12) public{\nrequire(VAR5);\nif(VAR10[msg.sender]==0 && VAR10[msg.sender]!=msg.sender){\nVAR10[msg.sender]=VAR12;\n}\nuint256 VAR13=getMyEggs();\nuint256 VAR14=SafeMath.div(VAR13,VAR1);\nVAR7[msg.sender]=SafeMath.add(VAR7[msg.sender],VAR14);\nVAR8[msg.sender]=0;\nVAR9[msg.sender]=now;\nVAR8[VAR10[msg.sender]]=SafeMath.add(VAR8[VAR10[msg.sender]],SafeMath.div(VAR13,5));\nVAR11=SafeMath.add(VAR11,SafeMath.div(VAR13,10));\n}\nfunction FUN2() public{\nrequire(VAR5);\nuint256 VAR15=getMyEggs();\nuint256 VAR16=calculateEggSell(VAR15);\nuint256 VAR17=devFee(VAR16);\nVAR8[msg.sender]=0;\nVAR9[msg.sender]=now;\nVAR11=SafeMath.add(VAR11,VAR15);\nVAR6.transfer(VAR17);\nmsg.sender.transfer(SafeMath.sub(VAR16,VAR17));\n}\nfunction FUN3() public payable{\nrequire(VAR5);\nuint256 VAR18=calculateEggBuy(msg.value,SafeMath.sub(this.balance,msg.value));\nVAR18=SafeMath.sub(VAR18,devFee(VAR18));\nVAR6.transfer(devFee(msg.value));\nVAR8[msg.sender]=SafeMath.add(VAR8[msg.sender],VAR18);\n}\nfunction FUN4(uint256 VAR19) public payable{\nrequire(VAR11==0);\nVAR5=true;\nVAR11=VAR19;\n}\nfunction FUN5() public{\nrequire(VAR5);\nrequire(VAR7[msg.sender]==0);\nVAR9[msg.sender]=now;\nVAR7[msg.sender]=VAR2;\n}\n}",
        "label": false,
        "name": "0x7332077db22f7c1df320e757a77e8871377976da.sol"
    },
    {
        "source": "contract CON1 {\nuint16 constant internal VAR1 = 0;\nuint16 constant internal VAR2 = 1;\nuint16 constant internal VAR3 = 2;\naddress public VAR4;\nuint public VAR5 = 0;\nmodifier FUN1 {\nrequire(msg.sender == VAR4);\n_;\n}\nconstructor() public {\nVAR4 = msg.sender;\n}\nfunction () public {\nrevert();\n}\nfunction FUN3() public FUN1 {\nselfdestruct(VAR4);\n}\nfunction FUN4(uint VAR6, string VAR7) public {\nVAR5++;\n}\nfunction FUN5(uint VAR6, string VAR7) public {\nVAR5++;\n}\n}",
        "label": false,
        "name": "0xde29140943dd13fdcf782d51854b5042fd640d99.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN18() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN19() {\nrequire(VAR13);\n_;\n}\nfunction FUN20() public FUN13 FUN18 {\nVAR13 = true;\n}\nfunction FUN21() public FUN13 FUN19 {\nVAR13 = false;\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN18 returns (bool VAR14) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN18 returns (bool VAR14) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR15;\nconstructor () internal {\nFUN25(msg.sender);\n}\nmodifier FUN22() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN23(address VAR10) public FUN22 {\nFUN25(VAR10);\n}\nfunction FUN24() public {\nFUN26(msg.sender);\n}\nfunction FUN25(address VAR10) internal {\nVAR15.add(VAR10);\n}\nfunction FUN26(address VAR10) internal {\nVAR15.remove(VAR10);\n}\n}\ncontract CON8 is CON2, CON7 {\nfunction FUN27(address VAR4, uint256 VAR5) public FUN22 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON9 is CON1, CON3, CON6, CON8 {\nstring private VAR16;\nstring private VAR17;\nuint8 private VAR18;\nconstructor (string memory VAR19, string memory VAR20, uint8 VAR21) public {\nVAR16 = VAR19;\nVAR17 = VAR20;\nVAR18 = VAR21;\n}\n}",
        "label": false,
        "name": "0xafa9ec5eddaa50db06e8ed2c680ac6c81a32e9b7.sol"
    },
    {
        "source": "contract CON1 {\nuint VAR1;\naddress VAR2;\nconstructor() public {\nVAR2 = msg.sender;\n}\nfunction FUN1(uint VAR3) public {\nif (VAR2 == msg.sender) {\nVAR1 = VAR3;\n}\n}\n}",
        "label": false,
        "name": "0x1c0addffeb8a2c63de6ec734ad1728240cd8d877.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nusing SafeMath for uint256;\naddress public VAR1;\naddress public VAR2;\nuint256 public VAR3 = 1650;\nCON1 VAR4;\nuint256 public VAR5;\nconstructor () public {\nVAR1 = 0x237625d599dd5F30E51ccd0F51B5Ee564d31Bd7b;\nVAR2 = 0x4a74Df6113E3d38d8e184273341Cb6BBb6885152;\nVAR4 = CON1(VAR2);\n}\nbool public VAR6 = true;\nfunction FUN1() public {\nrequire (msg.sender == VAR1);\nVAR6 = true;\n}\nfunction FUN2() public {\nrequire(msg.sender == VAR1);\nVAR6 = false;\n}\nfunction FUN3(uint256 VAR7) public {\nrequire(msg.sender == VAR1);\nVAR3 = VAR7;\n}\nfunction FUN4(address VAR8) public {\nrequire (msg.sender == VAR1);\nVAR1 = VAR8;\n}\nfunction () payable public {\nFUN6(msg.sender);\n}\nfunction FUN6(address VAR9) payable public {\nrequire(VAR9 != 0x0);\nrequire(FUN8());\nuint256 VAR10 = msg.value;\nuint256 VAR11 = (VAR10) * VAR3;\nVAR5 = VAR5.add(VAR10);\nVAR4.transfer(VAR9, VAR11);\nFUN7();\n}\nfunction FUN7() internal {\nVAR1.transfer(msg.value);\n}\nfunction FUN8() internal constant returns (bool) {\nbool VAR12 = VAR6;\nbool VAR13 = msg.value != 0;\nreturn VAR12 && VAR13;\n}\nfunction FUN9(uint256 VAR14) public {\nrequire (msg.sender == VAR1);\nVAR4.transfer(VAR1,VAR14);\n}\n}",
        "label": false,
        "name": "0x484fa8db2f005a7c19f4e3049fcc0fa363384cb5.sol"
    },
    {
        "source": "\r\n\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    \r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    \r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    \r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    \r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    \r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    \r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface INiftyTradingCardCreator {\r\n    function mintCard(\r\n        uint256 _cardType,\r\n        uint256 _nationality,\r\n        uint256 _position,\r\n        uint256 _ethnicity,\r\n        uint256 _kit,\r\n        uint256 _colour,\r\n        address _to\r\n    ) external returns (uint256 _tokenId);\r\n\r\n    function setAttributes(\r\n        uint256 _tokenId,\r\n        uint256 _strength,\r\n        uint256 _speed,\r\n        uint256 _intelligence,\r\n        uint256 _skill\r\n    ) external returns (bool);\r\n\r\n    function setName(\r\n        uint256 _tokenId,\r\n        uint256 _firstName,\r\n        uint256 _lastName\r\n    ) external returns (bool);\r\n\r\n    function setAttributesAndName(\r\n        uint256 _tokenId,\r\n        uint256 _strength,\r\n        uint256 _speed,\r\n        uint256 _intelligence,\r\n        uint256 _skill,\r\n        uint256 _firstName,\r\n        uint256 _lastName\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract INiftyFootballTradingCardGenerator {\r\n    function generateCard(address _sender) external returns (uint256 _nationality, uint256 _position, uint256 _ethnicity, uint256 _kit, uint256 _colour);\r\n\r\n    function generateAttributes(address _sender, uint256 _base) external returns (uint256 strength, uint256 speed, uint256 intelligence, uint256 skill);\r\n\r\n    function generateName(address _sender) external returns (uint256 firstName, uint256 lastName);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract NiftyFootballAdmin is Ownable, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    INiftyFootballTradingCardGenerator public generator;\r\n    INiftyTradingCardCreator public creator;\r\n\r\n    uint256 public cardTypeDefault = 100;\r\n    uint256 public attributesBase = 50;\r\n\r\n    constructor (\r\n        INiftyFootballTradingCardGenerator _generator,\r\n        INiftyTradingCardCreator _creator\r\n    ) public {\r\n        generator = _generator;\r\n        creator = _creator;\r\n    }\r\n\r\n    function generateAndAssignCard(\r\n        uint256 _nationality,\r\n        uint256 _position,\r\n        uint256 _ethnicity,\r\n        uint256 _kit,\r\n        uint256 _colour,\r\n        uint256 _firstName,\r\n        uint256 _lastName,\r\n        address _to\r\n    ) public onlyOwner returns (uint256) {\r\n\r\n                uint256 tokenId = creator.mintCard(cardTypeDefault, _nationality, _position, _ethnicity, _kit, _colour, _to);\r\n        \r\n                (uint256 _strength, uint256 _speed, uint256 _intelligence, uint256 _skill) = generator.generateAttributes(msg.sender, attributesBase);\r\n\r\n        creator.setAttributesAndName(tokenId, _strength, _speed, _intelligence, _skill, _firstName, _lastName);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function setCardTypeDefault(uint256 _newDefaultCardType) public onlyOwner returns (bool) {\r\n        cardTypeDefault = _newDefaultCardType;\r\n        return true;\r\n    }\r\n\r\n    function setAttributesBase(uint256 _newAttributesBase) public onlyOwner returns (bool) {\r\n        attributesBase = _newAttributesBase;\r\n        return true;\r\n    }\r\n\r\n    function setFutballCardsGenerator(INiftyFootballTradingCardGenerator _futballCardsGenerator) public onlyOwner returns (bool) {\r\n        generator = _futballCardsGenerator;\r\n        return true;\r\n    }\r\n}",
        "label": false,
        "name": "0x20b1bc618f79d9977b7cce3f0523128178ea6a7b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nmapping(address=>uint) VAR3;\nfunction CON2() {}\nfunction FUN3( address VAR4, uint VAR5 ) FUN1 {\nVAR3[VAR4] = VAR5;\n}\nfunction FUN4( address VAR4 ) constant returns(uint) {\nreturn VAR3[VAR4];\n}\n}",
        "label": false,
        "name": "0xed943d75b2ff94d76f4eda892513255ef841261c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1)\nrevert();\n_; }\nfunction FUN2(address VAR2) FUN1 returns (bool VAR3) {\nif (msg.sender != VAR1)\nrevert();\nVAR1 = VAR2;\nreturn true;\n}\n}\ncontract CON2 {\nfunction FUN3(uint256 VAR4, uint256 VAR5) internal constant returns (uint256) {\nuint256 VAR6 = VAR4 * VAR5;\nrequire(VAR4 == 0 || VAR6 / VAR4 == VAR5);\nreturn VAR6;\n}\nfunction FUN4(uint256 VAR4, uint256 VAR5) internal constant returns (uint256) {\nuint256 VAR6 = VAR4 / VAR5;\nreturn VAR6;\n}\nfunction FUN5(uint256 VAR4, uint256 VAR5) internal constant returns (uint256) {\nrequire(VAR5 <= VAR4);\nreturn VAR4 - VAR5;\n}\nfunction FUN6(uint256 VAR4, uint256 VAR5) internal constant returns (uint256) {\nuint256 VAR6 = VAR4 + VAR5;\nrequire(VAR6 >= VAR4);\nreturn VAR6;\n}\n}\ncontract CON3 is CON1, CON2 {\naddress[] public VAR7;\nuint256 public VAR8;\nuint256 public VAR9;\nuint8 public VAR10;\nstring public VAR11;\nstring public VAR12;\nbool public VAR13;\nbool public VAR14;\nbool public VAR15;\nstruct AlertCreatorStruct {\naddress VAR16;\nuint256 VAR17;\n}\nAlertCreatorStruct[] public VAR18;\nmapping (address => bool) public VAR19;\nmapping (address => mapping (address => uint256)) public VAR20;\nmapping (address => uint256) public VAR21;\nfunction CON3() {\nVAR12 = \"CMA\";\nVAR11 = \"Coin Market Alert\";\nVAR10 = 18;\nVAR8 = 50000000000000000000000000;\nVAR21[msg.sender] = FUN6(VAR21[msg.sender], VAR8);\nVAR13 = true;\nVAR14 = false;\n}\nfunction FUN7() FUN1 returns (bool VAR22) {\nrequire(!VAR15);\nVAR13 = false;\nVAR14 = true;\nVAR15 = true;\nreturn true;\n}\nfunction FUN8(address VAR23) private returns (bool VAR24) {\nVAR9 = FUN6(VAR9, 1);\nAlertCreatorStruct memory VAR25;\nVAR25.VAR16 = VAR23;\nVAR18.push(VAR25);\nVAR7.push(VAR23);\nVAR19[VAR23] = true;\nreturn true;\n}\nfunction FUN9(address VAR23, uint256 VAR26) FUN1 returns (bool VAR27) {\nrequire(!VAR13);\nrequire(VAR26 > 0);\nrequire(FUN18(VAR1, VAR23, VAR26));\nif (!VAR19[VAR23]) {\nFUN8(VAR23);\n}\nVAR21[VAR23] = FUN6(VAR21[VAR23], VAR26);\nVAR21[VAR1] = FUN5(VAR21[VAR1], VAR26);\nreturn true;\n}\nfunction FUN10(address VAR28, uint256 VAR26) private returns (bool VAR29) {\nrequire(FUN6(VAR21[VAR1], VAR26) > VAR21[VAR1]);\nrequire(FUN6(VAR21[VAR1], VAR26) > 0);\nrequire(FUN6(VAR8, VAR26) > 0);\nrequire(FUN6(VAR8, VAR26) > VAR8);\nVAR8 = FUN6(VAR8, VAR26);\nVAR21[VAR1] = FUN6(VAR21[VAR1], VAR26);\nreturn true;\n}\nfunction FUN11(uint256 VAR26) FUN1 returns (bool VAR3) {\nrequire(VAR26 > 0);\nrequire(VAR14);\nif (!FUN10(msg.sender, VAR26))\nrevert();\nreturn true;\n}\nfunction FUN12(uint256 VAR26) FUN1 returns (bool VAR30) {\nrequire(VAR26 > 0);\nrequire(VAR26 < VAR8);\nrequire(VAR21[VAR1] > VAR26);\nrequire(FUN5(VAR21[VAR1], VAR26) > 0);\nrequire(FUN5(VAR8, VAR26) > 0);\nVAR21[VAR1] = FUN5(VAR21[VAR1], VAR26);\nVAR8 = FUN5(VAR8, VAR26);\nreturn true;\n}\nfunction FUN13() FUN1 returns (bool VAR31) {\nVAR13 = true;\nreturn true;\n}\nfunction FUN14() FUN1 returns (bool VAR32) {\nVAR13 = false;\nreturn true;\n}\nfunction FUN15(address VAR33, uint256 VAR26) {\nrequire(!VAR13);\nif (FUN18(msg.sender, VAR33, VAR26)) {\nVAR21[msg.sender] = FUN5(VAR21[msg.sender], VAR26);\nVAR21[VAR33] = FUN6(VAR21[VAR33], VAR26);\n} else {\nrevert();\n}\n}\nfunction FUN16(address VAR34, address VAR33, uint256 VAR26) {\nrequire(!VAR13);\nrequire(FUN5(VAR20[VAR34][msg.sender], VAR26) >= 0);\nif (FUN18(VAR34, VAR33, VAR26)) {\nVAR21[VAR34] = FUN5(VAR21[VAR34], VAR26);\nVAR21[VAR33] = FUN6(VAR21[VAR33], VAR26);\nVAR20[VAR34][VAR33] = FUN5(VAR20[VAR34][VAR33], VAR26);\n} else {\nrevert();\n}\n}\nfunction FUN17(address VAR35, uint256 VAR26) returns (bool VAR36) {\nrequire(VAR26 > 0);\nrequire(VAR21[msg.sender] > 0);\nVAR20[msg.sender][VAR35] = VAR26;\nreturn true;\n}\nfunction FUN18(address VAR37, address VAR33, uint256 VAR38)\nprivate\nconstant\nreturns (bool VAR39)\n{\nrequire(VAR38 > 0);\nrequire(VAR33 != address(0));\nrequire(FUN5(VAR21[VAR37], VAR38) >= 0);\nrequire(FUN6(VAR21[VAR33], VAR38) > VAR21[VAR33]);\nreturn true;\n}\nfunction VAR8() constant returns (uint256 VAR40) {\nreturn VAR8;\n}\nfunction FUN19(address VAR41) constant returns (uint256 VAR42) {\nreturn VAR21[VAR41];\n}\nfunction VAR20(address VAR34, address VAR35) constant returns (uint256 VAR43) {\nreturn VAR20[VAR34][VAR35];\n}\n}",
        "label": false,
        "name": "0xafedea9dba7d644572aa7c443198c65514faaef2.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nfunction FUN10(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN11(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor() internal {\nFUN15(msg.sender);\n}\nmodifier FUN12() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN13(address VAR10) public FUN12 {\nFUN15(VAR10);\n}\nfunction FUN14() public {\nFUN16(msg.sender);\n}\nfunction FUN15(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN16(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR12;\nconstructor() internal {\nVAR12 = false;\n}\nmodifier FUN17() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN18() {\nrequire(VAR12);\n_;\n}\nfunction FUN19() public FUN12 FUN17 {\nVAR12 = true;\n}\nfunction FUN20() public FUN12 FUN18 {\nVAR12 = false;\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN1(address VAR4,uint256 VAR5)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6,uint256 VAR5)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6,uint VAR8)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6,uint VAR9)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON7 is CON6, CON3 {\nstring public constant VAR14 = \"Jarvis Reward Token\";\nstring public constant VAR15 = \"JRT\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 420000000 * 1E18;\nconstructor() public {\nFUN7(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0xeef338c585ee3cf674f717937f12e6f52accf5e1.sol"
    },
    {
        "source": "contract CON1 {\naddress internal VAR1;\naddress private VAR2;\nmodifier FUN1() {\nrequire(isOwner(), \"The caller must be owner\");\n_;\n}\nfunction FUN2(address VAR3) internal {\nrequire(VAR3 != address(0), \"Cannot transfer control of the contract to the zero address\");\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON2 is CON1 {\naddress private VAR4;\nmodifier FUN4() {\nrequire(msg.sender == VAR4, \"msg.sender should be operator\");\n_;\n}\nfunction FUN5(address VAR5) public FUN1 {\nrequire(VAR5 != address(0), \"Cannot change the newOperator to the zero address\");\nrequire(isContract(VAR5), \"New operator must be contract address\");\nVAR4 = VAR5;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nbool private VAR6 = false;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nmapping (address=>bool) private VAR9;\nstring private constant VAR10 = \"Digital USD\";\nstring private constant VAR11 = \"DUSD\";\nuint8 private constant VAR12 = 18;\nuint256 private VAR13;\nconstructor() public {\nVAR1 = 0xfe30e619cc2915C905Ca45C1BA8311109A3cBdB1;\n}\nfunction FUN6(address VAR14, uint256 VAR15) public FUN4 {\nVAR7[VAR14] = VAR7[VAR14].add(VAR15);\n}\nfunction FUN7(address VAR14, uint256 VAR15) public FUN4 {\nVAR7[VAR14] = VAR7[VAR14].sub(VAR15);\n}\nfunction FUN8(address VAR14, uint256 VAR15) public FUN4 {\nVAR7[VAR14] = VAR15;\n}\nfunction FUN9(address VAR14, address VAR16, uint256 VAR15) public FUN4 {\nVAR8[VAR14][VAR16] = VAR8[VAR14][VAR16].add(VAR15);\n}\nfunction FUN10(address VAR14, address VAR16, uint256 VAR15) public FUN4 {\nVAR8[VAR14][VAR16] = VAR8[VAR14][VAR16].sub(VAR15);\n}\nfunction FUN11(address VAR14, address VAR16, uint256 VAR15) public FUN4 {\nVAR8[VAR14][VAR16] = VAR15;\n}\nfunction FUN12(uint256 VAR15) public FUN4 {\nVAR13 = VAR13.add(VAR15);\n}\nfunction FUN13(uint256 VAR15) public FUN4 {\nVAR13 = VAR13.sub(VAR15);\n}\nfunction FUN14(uint256 VAR15) public FUN4 {\nVAR13 = VAR15;\n}\nfunction FUN15(address VAR17) public FUN4 {\nVAR9[VAR17] = true;\n}\nfunction FUN16 (address VAR17) public FUN4 {\nVAR9[VAR17] = false;\n}\nfunction FUN17() public FUN4 {\nVAR6 = true;\n}\nfunction FUN18() public FUN4 {\nVAR6 = false;\n}\n}",
        "label": false,
        "name": "0x822ac26c84eb99f5238746fd3adf8f7697c01341.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\nCON1 constant public VAR2 = CON1(0x5c40ef6f527f4fba68368774e6130ce6515123f2);\naddress constant public VAR3 = 0xda4a4626d3e16e094de3225a751aab7128e96526;\nfunction FUN1(){\nuint VAR4 = VAR2.balanceOf(msg.sender);\nif (!VAR2.transferFrom(msg.sender, this, VAR4) || !msg.sender.send(VAR4))\nthrow;\n}\nfunction FUN2() external {\nif (msg.sender != VAR3) throw;\nif (!VAR3.send(this.VAR4)) throw;\n}\n}",
        "label": false,
        "name": "0x755cdba6ae4f479f7164792b318b2a06c759833b.sol"
    },
    {
        "source": "contract CON1{\nusing ERC20Lib for ERC20Lib.Token;\nusing SafeMath for uint256;\nmapping(address=>bool) VAR1;\nmapping(address=>bool) VAR2;\nmapping(address=>bool) VAR3;\nERC20Lib.Token VAR4;\nERC20Lib.Token VAR5;\nuint256 VAR6;\naddress VAR7;\naddress VAR8;\nbool VAR9;\nconstructor(address VAR10,address VAR11)\npublic {\nVAR7 = VAR11;\nVAR8 = VAR10;\n}\nmodifier FUN1(){\nrequire(msg.sender == VAR7);\n_;\n}\nmodifier FUN2(){\nrequire(msg.sender == VAR8 || msg.sender == VAR7);\n_;\n}\nmodifier FUN3(){\nrequire(VAR1[msg.sender]);\n_;\n}\nmodifier FUN4(){\nrequire(VAR3[msg.sender]);\n_;\n}\nmodifier FUN5(){\nrequire(!VAR9);\n_;\n}\nfunction FUN6(address VAR11)\npublic\nFUN1{\nVAR7 = VAR11;\n}\nfunction FUN7(address VAR10)\npublic\nFUN2{\nVAR8 = VAR10;\n}\nfunction FUN8(address VAR12)\npublic\nFUN2\nFUN5\nreturns (bool) {\nVAR3[VAR12] = true;\nreturn true;\n}\nfunction FUN9(address VAR12)\npublic\nFUN2\nreturns (bool) {\nVAR3[VAR12] = false;\nreturn true;\n}\nfunction FUN10(address VAR13)\npublic\nFUN2\nFUN5\nreturns (bool) {\nVAR1[VAR13] = true;\nreturn true;\n}\nfunction FUN11(address VAR13)\npublic\nFUN2\nreturns (bool) {\nVAR1[VAR13] = false;\nreturn true;\n}\nfunction FUN12()\npublic\nFUN2\nFUN5\nreturns (bool) {\nVAR9 = true;\nreturn true;\n}\nfunction FUN13()\npublic\nFUN1\nreturns (bool) {\nVAR9 = false;\nreturn true;\n}\nfunction FUN14()\npublic\nFUN1\nreturns (bool) {\nFUN12();\nFUN7(address(this));\nFUN6(address(this));\nreturn true;\n}\nfunction FUN15(address VAR14, uint256 VAR15)\npublic\nFUN5\nreturns (bool) {\nVAR4.FUN15(msg.sender, VAR14, VAR15);\nreturn true;\n}\nfunction FUN16(address VAR16, uint256 VAR15)\npublic\nFUN5\nreturns (bool) {\nVAR4.FUN16(msg.sender,VAR16,VAR15);\nreturn true;\n}\nfunction FUN17(address VAR17, address VAR14, uint256 VAR15)\npublic\nFUN5\nreturns (bool) {\nVAR4.FUN17(msg.sender,VAR17,VAR14,VAR15);\nreturn true;\n}\nfunction FUN18(address VAR16, uint256 VAR18)\npublic\nFUN5\nreturns (bool) {\nVAR4.FUN18(msg.sender,VAR16,VAR18);\nreturn true;\n}\nfunction FUN19(address VAR16, uint256 VAR19)\npublic\nFUN5\nreturns (bool) {\nVAR4.FUN19(msg.sender,VAR16,VAR19);\nreturn true;\n}\nfunction FUN20(address VAR20, uint256 VAR15)\npublic\nFUN5\nFUN3\nreturns (bool) {\nVAR5.mint(VAR20,VAR15);\nVAR6+=1;\nreturn true;\n}\nfunction FUN21(address VAR20, uint256 VAR15)\npublic\nFUN5\nFUN4\nreturns (bool) {\nVAR5.burn(VAR20,VAR15);\nVAR4.mint(VAR20,VAR15);\nVAR6+=1;\nreturn true;\n}\nfunction FUN22(address VAR20, uint256 VAR15)\npublic\nFUN5\nFUN4\nreturns (bool) {\nVAR5.burn(VAR20,VAR15);\nVAR6+=1;\nreturn true;\n}\nfunction FUN23(uint256 VAR15)\npublic\nFUN5\nreturns (bool) {\nrequire(VAR2[msg.sender]);\nVAR4.burn(msg.sender,VAR15);\nVAR6+=1;\nreturn true;\n}\nfunction FUN24(bytes32 VAR21, uint8 VAR22, bytes32 VAR23, bytes32 VAR24)\npublic\nFUN5\nreturns (bool) {\nrequire(VAR1[ecrecover(keccak256(abi.encodePacked(msg.sender,VAR21)),VAR22,VAR23,VAR24)]);\nVAR2[msg.sender]=true;\nVAR6+=1;\nreturn true;\n}\nfunction FUN25(address VAR25)\npublic\nFUN5\nFUN3\nreturns (bool) {\nVAR2[VAR25] = false;\nVAR6+=1;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4fce5178346fc58a0a1261ec2306acc39ed801ab.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nuint256 constant private VAR1 = 2**256 - 1;\nstring public VAR2;\nstring public VAR3;\nuint8 public VAR4;\nuint256 public VAR5;\naddress public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9, string memory VAR10, uint8 VAR11, string memory VAR12) public {\nVAR2 = VAR10;\nVAR3 = VAR12;\nVAR4 = VAR11;\nVAR5 = VAR9;\nVAR7[msg.sender] = VAR9;\nVAR6 = msg.sender;\n}\nfunction FUN1(address VAR13, uint256 VAR14) public returns (bool VAR15) {\nrequire(VAR13 != address(0x0));\nrequire(VAR14 > 0);\nrequire(VAR7[msg.sender] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 >= VAR7[VAR13]);\nVAR7[msg.sender] = SafeMath.sub(VAR7[msg.sender], VAR14);\nVAR7[VAR13] = SafeMath.add(VAR7[VAR13], VAR14);\nreturn true;\n}\nfunction FUN2(address VAR16, address VAR13, uint256 VAR14) public returns (bool VAR15) {\nrequire(VAR13 != address(0x0));\nrequire(VAR14 > 0);\nrequire(VAR7[msg.sender] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 >= VAR7[VAR13]);\nrequire(VAR14 <= VAR8[VAR16][msg.sender]);\nVAR7[VAR16] = SafeMath.sub(VAR7[VAR16], VAR14);\nVAR7[VAR13] = SafeMath.add(VAR7[VAR13], VAR14);\nrequire(VAR8[VAR16][msg.sender] < VAR1);\nVAR8[VAR16][msg.sender] = SafeMath.sub(VAR8[VAR16][msg.sender], VAR14);\nreturn true;\n}\nfunction FUN3(address VAR17, uint256 VAR14) public returns (bool VAR15) {\nrequire(VAR14 > 0);\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN4(uint256 VAR14) public returns (bool VAR15) {\nrequire(VAR7[msg.sender] >= VAR14);\nrequire(VAR14 > 0);\nVAR7[msg.sender] = SafeMath.sub(VAR7[msg.sender], VAR14);\nVAR5 = SafeMath.sub(VAR5,VAR14);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xeccfc350de76b86c0c69dd04ac0fe7abcf3a852b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 8;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x9ec8d44af808d7cca2ec23c0dc0d1f49a3386ea4.sol"
    },
    {
        "source": "contract CON1\n{\naddress VAR1=0x46Feeb381e90f7e30635B4F33CE3F6fA8EA6ed9b;\naddress VAR2;\nuint256 public VAR3= 1000000000000000001;\naddress VAR4 = 0xa6f6b06538348614d98f1c12b6b2becc27886ced;\nfunction FUN1(address VAR5, uint256 VAR6)\n{\nrequire(msg.sender == VAR1); VAR3 = VAR6;\nVAR4 = VAR5;\n}\nfunction FUN2(address VAR2){\n}\nfunction()payable{}\nfunction FUN4()\npayable public\n{\nVAR2=msg.sender;\nif(msg.value>VAR3)\n{\nVAR4.delegatecall(bytes4(sha3(\"logEvent()\")));\nVAR2.send(this.balance);\n}\n}\nfunction FUN5() {\nrequire(msg.sender == VAR1);\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0xc013a9119b4aaef512b2338026183db9cd0c4029.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"CYB\";\nVAR5 = \"Cyiber\";\nVAR6 = 18;\nVAR7 = 1000000000 * 10**uint(VAR6);\nVAR8[0x9B39e806Da554aCa2ccdb03E6E7b37ac6369ee7D] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xfa90d6a9a8b7fcdcbbb06e441c0ecaa57f55b11e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nenum Action {\nNone,\nFUN1\n}\nstruct Proposal {\nAction VAR3;\naddress VAR4;\nuint256 VAR5;\n}\nProposal public VAR6;\nProposal public VAR7;\nfunction CON1(address VAR8,address VAR9) {\nVAR1 = VAR8;\nVAR2 = VAR9;\nVAR6.VAR3 = Action.None;\nVAR7.VAR3 = Action.None;\n}\nfunction FUN1(address VAR10,uint256 VAR11) {\nif (VAR11 > this.balance) { throw; }\nif (msg.sender == VAR1) {\nVAR6.VAR3 = Action.FUN1;\nVAR6.VAR4 = VAR10;\nVAR6.VAR5 = VAR11;\n} else if (msg.sender == VAR2) {\nVAR7.VAR3 = Action.FUN1;\nVAR7.VAR4 = VAR10;\nVAR7.VAR5 = VAR11;\n} else { throw; }\nFUN2();\n}\nfunction FUN2() internal {\nif (VAR6.VAR3 == Action.FUN1&& VAR7.VAR3 == Action.FUN1&& VAR6.VAR5 == VAR7.VAR5&& VAR6.VAR4 == VAR7.VAR4) {\nVAR6.VAR3 = Action.None;\nVAR7.VAR3 = Action.None;\nVAR6.VAR4.transfer(VAR6.VAR5);\n}\n}\n}",
        "label": false,
        "name": "0x7fe4d5e37b83c0df81e370c95ae814e23c378e4a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON1 {\nbool public VAR4 = false;\nmodifier FUN3() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4);\n_;\n}\nfunction VAR4() FUN1 FUN3 public {\nVAR4 = true;\n}\nfunction FUN5() FUN1 FUN4 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) VAR6;\nfunction FUN6(address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR7 != address(0));\nuint256 VAR10 = VAR6[VAR9][msg.sender];\nVAR5[VAR9] = VAR5[VAR9].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nVAR6[VAR9][msg.sender] = VAR10.sub(VAR8);\nreturn true;\n}\nfunction FUN8(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\nfunction FUN9(address VAR13, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN10(address VAR11, address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR6[VAR11][VAR13];\n}\nfunction FUN11(uint256 VAR8) FUN1 public returns (bool VAR15) {\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].add(VAR8);\nVAR3 = VAR3.add(VAR8);\nreturn true;\n}\nfunction FUN12(uint256 VAR8) public returns (bool VAR15) {\nrequire(VAR8 > 0);\nrequire(VAR5[msg.sender] >= VAR8);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR16 = \"PAPERA Coin\";\nstring public VAR17 = \"PAPERA\";\nuint public VAR18 = 18;\nuint public constant VAR19 = 10000e18;\naddress public constant VAR20 = 0x6a0Dc4629C0a6A655e8E4DC80b017145b1774622;\nfunction CON5() public {\nVAR5[msg.sender] = VAR19;\nVAR3 = VAR19;\nFUN6(VAR20, VAR19);\n}\nfunction() payable public { }\nfunction FUN14() public {\nif (address(this).VAR12 > 0)\nVAR1.send(address(this).VAR12);\n}\nfunction FUN15() public {\nif(FUN8(this) > 0)\nthis.FUN6(VAR20, FUN8(this));\n}\nfunction FUN16() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0xad45f9a27a1f9fb19bfa6d2c877c4133fe95ee0f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 {\nstring public VAR2;\nstring public VAR3;\nuint8 public VAR4 = 18;\nuint256 public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => mapping (address => uint256)) public VAR7;\nconstructor(uint256 VAR8,string memory VAR9,string memory VAR10) public {\nVAR5 = VAR8 * 10 ** uint256(VAR4); VAR6[msg.sender] = VAR5; VAR2 = VAR9; VAR3 = VAR10; }\nfunction FUN2(address VAR11, address VAR12, uint VAR13) internal {\nrequire(VAR12 != address(0x0));\nrequire(VAR6[VAR11] >= VAR13);\nrequire(VAR6[VAR12] + VAR13 > VAR6[VAR12]);\nuint VAR14 = VAR6[VAR11] + VAR6[VAR12];\nVAR6[VAR11] -= VAR13;\nVAR6[VAR12] += VAR13;\nassert(VAR6[VAR11] + VAR6[VAR12] == VAR14);\n}\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool VAR15) {\nFUN2(msg.sender, VAR12, VAR13);\nreturn true;\n}\nfunction FUN4(address VAR11, address VAR12, uint256 VAR13) public returns (bool VAR15) {\nrequire(VAR13 <= VAR7[VAR11][msg.sender]); VAR7[VAR11][msg.sender] -= VAR13;\nFUN2(VAR11, VAR12, VAR13);\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR13) public\nreturns (bool VAR15) {\nVAR7[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN6(uint256 VAR13) public returns (bool VAR15) {\nrequire(VAR6[msg.sender] >= VAR13); VAR6[msg.sender] -= VAR13; VAR5 -= VAR13;\nreturn true;\n}\n}\ncontract CON3 is CON1, CON2 {\nmapping (address => bool) public VAR17;\nconstructor(uint256 VAR8,string memory VAR9,string memory VAR10) CON2(VAR8, VAR9, VAR10) public {}\nfunction FUN2(address VAR11, address VAR12, uint VAR13) internal {\nrequire (VAR12 != address(0x0)); require (VAR6[VAR11] >= VAR13); require (VAR6[VAR12] + VAR13 >= VAR6[VAR12]); require(!VAR17[VAR11]); require(!VAR17[VAR12]); VAR6[VAR11] -= VAR13; VAR6[VAR12] += VAR13;\n}\nfunction FUN7(address VAR18, uint256 VAR19) FUN1 public {\nVAR6[VAR18] += VAR19;\nVAR5 += VAR19;\n}\nfunction FUN8(address VAR18, bool VAR20) FUN1 public {\nVAR17[VAR18] = VAR20;\n}\n}",
        "label": false,
        "name": "0x92c1559f2c60e90b5ca9ac8067b64b650c2c8be6.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"Prospectors Obligation Token\";\nstring public constant VAR2 = \"OBG\";\nuint8 public constant VAR3 = 18;\nuint256 public constant VAR4 = 1000;\nuint256 public constant VAR5 = 1 ether * VAR4;\nuint256 public constant VAR6 = 0.5 ether * VAR4;\nuint256 public VAR7;\nuint256 public VAR8;\nbool public VAR9 = true;\naddress public VAR10;\naddress public VAR11;\nCON3 VAR12;\nuint256 VAR13;\nmapping (address => uint256) VAR14;\naddress public VAR15;\nuint256 public VAR16;\nfunction CON1() {\nVAR10 = 0xCCe6DA2086DD9348010a2813be49E58530852b46;\nVAR11 = 0xCCe6DA2086DD9348010a2813be49E58530852b46;\nVAR7 = block.number + 10;\nVAR8 = block.number + 30;\nVAR12 = new CON3(VAR10);\n}\nfunction FUN1(address VAR17, uint256 VAR18) returns (bool) {\nif (VAR9) throw;\nvar VAR19 = VAR14[msg.sender];\nif (VAR19 >= VAR18 && VAR18 > 0) {\nVAR19 -= VAR18;\nVAR14[msg.sender] = VAR19;\nVAR14[VAR17] += VAR18;\nreturn true;\n}\nreturn false;\n}\nfunction FUN2() external constant returns (uint256) {\nreturn VAR13;\n}\nfunction FUN3(address VAR20) external constant returns (uint256) {\nreturn VAR14[VAR20];\n}\nfunction FUN4(uint256 VAR18) external {\nif (VAR9) throw;\nif (VAR15 == 0) throw;\nif (VAR18 == 0) throw;\nif (VAR18 > VAR14[msg.sender]) throw;\nVAR14[msg.sender] -= VAR18;\nVAR13 -= VAR18;\nVAR16 += VAR18;\nCON2(VAR15).migrateFrom(msg.sender, VAR18);\n}\nfunction FUN5(address VAR21) external {\nif (VAR9) throw;\nif (VAR15 != 0) throw;\nif (msg.sender != VAR11) throw;\nVAR15 = VAR21;\n}\nfunction FUN6(address VAR22) external {\nif (msg.sender != VAR11) throw;\nif (VAR22 == 0) throw;\nVAR11 = VAR22;\n}\nfunction () payable external {\nif (!VAR9) throw;\nif (block.number < VAR7) throw;\nif (block.number > VAR8) throw;\nif (msg.value == 0) throw;\nif (msg.value > (VAR5 - VAR13) / VAR4)\nthrow;\nvar VAR23 = msg.value * VAR4;\nVAR13 += VAR23;\nVAR14[msg.sender] += VAR23;\n}\nfunction FUN8() external {\nif (!VAR9) throw;\nif ((block.number <= VAR8 ||VAR13 < VAR6) &&VAR13 < VAR5) throw;\nVAR9 = false;\nuint256 VAR24 = 18;\nuint256 VAR25 =\nVAR13 * VAR24 / (100 - VAR24);\nVAR13 += VAR25;\nVAR14[VAR12] += VAR25;\nif (!VAR10.send(this.balance)) throw;\n}\nfunction FUN9() external {\nif (!VAR9) throw;\nif (block.number <= VAR8) throw;\nif (VAR13 >= VAR6) throw;\nvar VAR26 = VAR14[msg.sender];\nif (VAR26 == 0) throw;\nVAR14[msg.sender] = 0;\nVAR13 -= VAR26;\nvar VAR27 = VAR26 / VAR4;\nif (!msg.sender.send(VAR27)) throw;\n}\nfunction FUN10()\n{\nVAR12.FUN10();\nsuicide(VAR10);\n}\n}\ncontract CON2 {\n}\ncontract CON3 {\nuint256 constant VAR28 = 30000;\nmapping (address => uint256) VAR29;\nCON1 VAR30;\nuint256 VAR31;\nuint256 VAR32 = 0;\nfunction CON3(address VAR33) internal {\nVAR30 = CON1(msg.sender);\nVAR31 = now + 6 * 30 days;\nVAR29[VAR33] = 30000; }\nfunction FUN11() external {\nif (now < VAR31) throw;\nif (VAR32 == 0)\nVAR32 = VAR30.FUN3(this);\nvar VAR34 = VAR29[msg.sender];\nVAR29[msg.sender] = 0;\nvar VAR35 = VAR32 * VAR34 / VAR28;\nif (!VAR30.FUN1(msg.sender, VAR35)) throw;\n}\nfunction FUN10()\n{\nsuicide(0);\n}\n}",
        "label": false,
        "name": "0x74e5f1a34a651c052d86dbd25042d6f710187f0a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\nuint256 public VAR4;\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[msg.sender]);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR5[VAR9] = VAR5[VAR9].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10, uint VAR11) public FUN3 returns (bool VAR14) {\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10, uint VAR12) public FUN3 returns (bool VAR14) {\nreturn super.FUN11(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nstring public constant VAR15 = \"BrickblockToken\";\nstring public constant VAR16 = \"BBK\";\nuint256 public constant VAR17 = 500 * (10 ** 6) * (10 ** uint256(VAR21));\nuint8 public constant VAR18 = 51;\nuint8 public constant VAR19 = 35;\nuint8 public constant VAR20 = 14;\nuint8 public constant VAR21 = 18;\naddress public VAR22;\naddress public VAR23;\naddress public VAR24;\naddress public VAR25;\nbool public VAR26;\nbool public VAR27;\nmodifier FUN12(address VAR28) {\nrequire(msg.sender == VAR28);\n_;\n}\nmodifier FUN13(uint256 VAR7) {\nuint256 VAR29 = VAR17.sub(VAR5[this]);\nuint256 VAR30 = VAR17.mul(VAR18).div(100);\nrequire(VAR29.add(VAR7) <= VAR30);\n_;\n}\nfunction CON8(address VAR31)\npublic\n{\nVAR3 = true;\nif (VAR31 != address(0)) {\nVAR25 = VAR31;\nCON8 VAR32 = CON8(VAR31);\nVAR5[this] = VAR32.balanceOf(VAR31);\nVAR4 = VAR32.balanceOf(VAR31);\nVAR26 = VAR32.VAR26();\nVAR22 = VAR32.VAR22();\nVAR23 = VAR32.VAR23();\n} else {\nVAR4 = VAR17;\nVAR5[this] = VAR17;\nVAR26 = true;\n}\n}\nfunction FUN6()\npublic\nFUN1\nFUN4\n{\nrequire(VAR27 == false);\nsuper.FUN6();\n}\nfunction FUN14(address VAR33)\npublic\nFUN1\nreturns (bool)\n{\nrequire(VAR33 != address(this));\nVAR22 = VAR33;\nreturn true;\n}\nfunction FUN15(address VAR33)\npublic\nFUN1\nreturns (bool)\n{\nrequire(isContract(VAR33));\nrequire(VAR33 != address(this));\nrequire(VAR33 != VAR1);\nVAR23 = VAR33;\nreturn true;\n}\nfunction FUN16(address VAR34, uint256 VAR7)\npublic\nFUN1\nFUN13(VAR7)\nreturns (bool)\n{\nrequire(VAR26 == true);\nrequire(VAR34 != address(0));\nrequire(VAR34 != VAR1);\nVAR5[this] = VAR5[this].sub(VAR7);\nVAR5[VAR34] = VAR5[VAR34].add(VAR7);\nreturn true;\n}\nfunction FUN17()\npublic\nFUN1\nreturns (bool)\n{\nrequire(VAR26 == true);\nrequire(VAR22 != address(0));\nrequire(VAR23 != address(0));\nuint256 VAR29 = VAR17.sub(VAR5[this]);\nuint256 VAR35 = VAR17.mul(VAR19).div(100);\nuint256 VAR36 = VAR17.mul(VAR20).div(100);\nuint256 VAR37 = VAR29.add(VAR36.add(VAR35));\nuint256 VAR38 = VAR4.sub(VAR37);\nVAR5[this] = VAR5[this].sub(VAR36);\nVAR5[VAR22] = VAR5[VAR22].add(VAR36);\nVAR5[this] = VAR5[this].sub(VAR38);\nVAR8[this][VAR23] = VAR35;\nVAR4 = VAR37;\nVAR26 = false;\nreturn true;\n}\nfunction FUN18(address VAR39)\npublic\nFUN12(VAR24)\nreturns (bool)\n{\nrequire(VAR27);\nuint256 VAR40 = VAR5[VAR39];\nVAR5[VAR39] = 0;\nVAR4 = VAR4.sub(VAR40);\nreturn true;\n}\nfunction FUN19(address VAR41)\npublic\nFUN1\nreturns (bool)\n{\nrequire(VAR41 != address(0));\nrequire(isContract(VAR41));\nVAR24 = VAR41;\nVAR27 = true;\nVAR3 = true;\nreturn true;\n}\nfunction FUN20()\npublic\nreturns (bool)\n{\nrequire(VAR25 != address(0));\naddress VAR39 = msg.sender;\nCON8 VAR32 = CON8(VAR25);\nuint256 VAR42 = VAR32.balanceOf(VAR39);\nif (VAR42 > 0) {\nVAR5[VAR39] = VAR5[VAR39].add(VAR42);\nVAR4 = VAR4.add(VAR42);\nVAR32.FUN18(VAR39);\nreturn true;\n}\nreturn false;\n}\nfunction()\npublic\n{\nrevert();\n}\n}",
        "label": false,
        "name": "0x59d8c5a3e2d25a550e294d82dfb2a3128d324bbc.sol"
    },
    {
        "source": "{\"ERC20Interface.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n// ----------------------------------------------------------------------------\\n// ERC Token Standard #20 Interface\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n// ----------------------------------------------------------------------------\\ncontract ERC20Interface {\\n    function totalSupply() public view returns (uint);\\n    function balanceOf(address tokenOwner) public view returns (uint balance);\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n    function transfer(address to, uint tokens) public returns (bool success);\\n    function approve(address spender, uint tokens) public returns (bool success);\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\\n\"},\"RMBT.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20Interface.sol\\\";\\n\\n// ----------------------------------------------------------------------------\\n// \\u0027RMBT\\u0027 \\u0027RMBT\\u0027 token contract\\n//\\n// Symbol       : RMBT\\n// Name         : RMBT\\n// Total supply : 1,000,000,000,000.000000000000000000\\n// Decimals     : 18\\n//\\n// ----------------------------------------------------------------------------\\n\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of symbol, name and decimals and an\\n// initial fixed supply\\n// ----------------------------------------------------------------------------\\ncontract RMBT is ERC20Interface {\\n    using SafeMath for uint;\\n\\n    string public symbol   = \\\"RMBT\\\";\\n    string public name     = \\\"RMBT\\\";\\n    uint8  public decimals = 18;\\n    uint _totalSupply      = 1000000000000e18;\\n\\n\\n    address payable owner;\\n    address admin;\\n\\n\\n    mapping(address =\\u003e uint) balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n\\n\\n    modifier isOwner() {\\n        require(msg.sender == owner, \\\"must be contract owner\\\");\\n        _;\\n    }\\n\\n\\n    modifier isAdmin() {\\n        require(msg.sender == admin || msg.sender == owner, \\\"must be admin\\\");\\n        _;\\n    }\\n\\n\\n    event Topup(address indexed _admin, uint tokens, uint _supply);\\n    event ChangeAdmin(address indexed from, address indexed to);\\n    event AdminTransfer(address indexed from, uint tokens);\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(address _admin) public {\\n        owner           = msg.sender;\\n        admin           = _admin;\\n        balances[admin] = _totalSupply;\\n        emit Transfer(address(0x0), admin, _totalSupply);\\n    }\\n\\n\\n    function topupSupply(uint tokens) external isAdmin returns (uint newSupply) {\\n        _totalSupply    = _totalSupply.add(tokens);\\n        balances[admin] = balances[admin].add(tokens);\\n        newSupply       = _totalSupply;\\n\\n        emit Transfer(address(0x0), admin, tokens);\\n        emit Topup(msg.sender, tokens, _totalSupply);\\n    }\\n\\n\\n    function withdrawFrom(address _address, uint tokens) external isAdmin returns(uint, uint) {\\n        balances[_address] = balances[_address].sub(tokens);\\n        balances[admin]    = balances[admin].add(tokens);\\n        emit Transfer(_address, admin, tokens);\\n        emit AdminTransfer(_address, tokens);\\n\\n        return (balances[_address], balances[msg.sender]);\\n    }\\n\\n\\n    function changeAdmin(address _address) external isOwner {\\n        uint _tokens       = balances[admin];\\n        balances[admin]    = balances[admin].sub(_tokens);\\n        balances[_address] = balances[_address].add(_tokens);\\n\\n        emit Transfer(admin, _address, _tokens);\\n        emit ChangeAdmin(admin, _address);\\n\\n        admin              = _address;\\n    }\\n\\n\\n    function withdrawEther(uint _amount) external isOwner {\\n        owner.transfer(_amount);\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\n        return balances[tokenOwner];\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint tokens) public returns (bool success) {\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n        balances[to]         = balances[to].add(tokens);\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces\\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint tokens) public returns (bool success) {\\n        allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    //\\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\\n        balances[from]            = balances[from].sub(tokens);\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n        balances[to]              = balances[to].add(tokens);\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender\\u0027s account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\n        return allowed[tokenOwner][spender];\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // accept ETH\\n    // ------------------------------------------------------------------------\\n    function () external payable {\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\n\\n\"}}",
        "label": false,
        "name": "0xa79b61c095aa277743f1789dedc6d259b467cb86.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 10000000000000000000000000;\nVAR6 = 10000000000000000000000000;\nVAR3 = \"Thundercoin\";\nVAR4 = \"TDC\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4c39828c426ca8128ed4cbc733bf3a9934a87288.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 1000000000 * (10**18);\naddress public VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Bangkok Taxi Coin\";\nstring constant public VAR14 = \"BATC\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x2ef54146f130d428df4ff57775439ca5bae36bac.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"PNSH\";\nVAR5 = \"PUNISHMENT\";\nVAR6 = 8;\nVAR7 = 1000000000000000;\nVAR8[0x6ba16345DFddB01fe01fF7BADA4458243C1c0F53] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = safeSub(VAR8[VAR14], VAR11);\nVAR9[VAR14][msg.sender] = safeSub(VAR9[VAR14][msg.sender], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON3(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON2(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x27eba2a67b906eb4341dfe54ce78083a611a0222.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON4, CON1 {\nfunction FUN8(uint256 VAR6) public {\nFUN9(msg.sender, VAR6);\n}\nfunction FUN9(address VAR13, uint256 VAR6) internal{\nrequire(VAR6 <= VAR4[VAR13]);\nVAR4[VAR13] = VAR4[VAR13].sub(VAR6);\nVAR3 = VAR3.sub(VAR6);\n}\n}\ncontract CON7 is CON5, CON1 {\nmodifier FUN10() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN11(address VAR5, uint256 VAR14)\nFUN10\npublic\nreturns (bool)\n{\nVAR3 = VAR3.add(VAR14);\nVAR4[VAR5] = VAR4[VAR5].add(VAR14);\nreturn true;\n}\n}\ncontract CON8 is CON1 {\nbool public VAR15 = false;\nmodifier FUN12() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN13() {\nrequire(VAR15);\n_;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR15 = true;\n}\nfunction FUN15() FUN1 FUN13 public {\nVAR15 = false;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN12 returns (bool VAR16) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN12 returns (bool VAR16) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON10 is CON9, CON7, CON6 {\nstring public constant VAR17 = \"SignalCoin\";\nstring public constant VAR18 = \"SGC\";\nuint8 public constant VAR19 = 6;\n}",
        "label": false,
        "name": "0x773dcefa15b47e77c7955e5d0383bafecd672734.sol"
    },
    {
        "source": "contract CON1 {\nmapping (uint256 => Mark) public VAR1;\nstring public constant VAR2 = \"One Crypto World\";\nstring public constant VAR3 = \"OCW\";\nuint8 public constant VAR4 = 0;\nstring public constant VAR5 = \"Introducing One Crypto World (CON1)\\n A blockchain is a ledger showing the quantity of something controlled by a user. It enables one to FUN3 control of that digital representation to someone else.\\nOne Crypto World (CON1) is created and designed by Taiwanese Crypto Congressman Jason Hsu, who is driving for innovative policies in crypto and blockchain. It will be designed as a utility token without the nature of securities. CON1 will not go on exchange; users will not be able to make any direct profit through CON1.\\nOne Crypto World is a Proof of Support(POS). The CON1 coin will only be distributed to global Key Opinion Leaders (KOLs), which makes it exclusive.\\nBy using CON1 coins, each KOL can contribute their valuable opinion to the Crypto Congressman\u00e2\u20ac\u2122s policies.\";\nmapping (address => uint256) private VAR6;\nmapping (address => uint256) private VAR7;\nuint256 private VAR8 = 1000;\nuint256 private VAR9 = 0;\nstruct Mark {\naddress VAR10;\nbytes VAR11;\n}\nconstructor() public {\nVAR6[msg.sender] = VAR8;\n}\nfunction () public {\nFUN2();\n}\nfunction FUN2() internal {\nrequire(1 + VAR7[msg.sender] <= VAR6[msg.sender]);\nVAR9 ++;\nVAR7[msg.sender] ++;\nMark memory VAR12;\nVAR12.VAR10 = msg.sender;\nVAR12.VAR11 = msg.data;\nVAR1[VAR9] = VAR12;\n}\nfunction FUN3(address VAR13, uint256 VAR14) public returns (bool) {\nrequire(VAR14 + VAR7[msg.sender] <= VAR6[msg.sender]);\nrequire(VAR14 <= VAR6[msg.sender]);\nrequire(VAR14 != 0);\nrequire(VAR13 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender] - VAR14;\nVAR6[VAR13] = VAR6[VAR13] + VAR14;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x57ff71ff2a508ddc8016f22d27e0a02fef9c0f88.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"ZEROCoin\";\nstring public constant VAR2 = \"ZERO\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 1295000000 * 10 ** 18; address public VAR5; uint256 public VAR6 = 38000; uint256 public VAR7= 24000; uint256 VAR8;\nuint256 VAR9;\nuint256 VAR10;\nbool VAR11 = false;\nuint256 public VAR12;\nuint256 public VAR13;\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\nuint256 VAR17;\nuint256 VAR18;\nuint256 public VAR19; uint256 VAR20 = 777000000 * 10 **18; mapping(address => uint) VAR21;\nmapping(address => mapping(address => uint)) VAR22;\nmapping (address => bool) private VAR23;\nuint public VAR24;\nenum Stages {\nNOTSTARTED,\nPREICO,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR25;\nmodifier FUN1(Stages VAR26) {\nif (VAR25 != VAR26)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction CON2() public\n{\nVAR5 = msg.sender;\nVAR21[VAR5] = 518000000 * 10 **18; VAR25 = Stages.NOTSTARTED;\n}\nfunction () public payable\n{\nrequire(VAR25 != Stages.ENDED);\nrequire(!VAR11 && msg.sender != VAR5);\nif( VAR25 == Stages.PREICO && now <= VAR18 )\n{\nrequire (VAR19 <= 1500 ether);\nVAR19 = (VAR19).add(msg.value);\nVAR8 =((msg.value).mul(VAR6));\nVAR9 = ((VAR8).mul(58)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(VAR25 == Stages.ICO && now <= VAR17 ){\nif( now < VAR14 )\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(15)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR14 && now < VAR15)\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(10)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR15 && now < VAR16)\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(5)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR16 && now < VAR17)\n{\nVAR8 =(msg.value).mul(VAR7); VAR10 = VAR8;\nFUN12(msg.sender,VAR10);\n}\n}\nelse\n{\nrevert();\n}\n}\nfunction FUN4() public FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR25 = Stages.PREICO;\nVAR11 = false;\nVAR21[address(this)] = VAR20;\nVAR12 = now;\nVAR18 = now + 16 days;\n}\nfunction FUN5() public FUN2 FUN1(Stages.PREICO)\n{\nrequire(now > VAR18 || VAR19 >= 1500 ether);\nVAR25 = Stages.ICO;\nVAR11 = false;\nVAR13 = now;\nVAR14 = now + 15 days;\nVAR15 = VAR14 + 15 days;\nVAR16 = VAR15 + 15 days;\nVAR17 = VAR16 + 15 days;\n}\nfunction FUN6() external FUN2\n{\nVAR11 = true;\n}\nfunction FUN7() external FUN2\n{\nVAR11 = false;\n}\nfunction FUN8() external FUN2 FUN1(Stages.ICO)\n{\nrequire(now > VAR17);\nVAR25 = Stages.ENDED;\nVAR4 = (VAR4).sub(VAR21[address(this)]);\nVAR21[address(this)] = 0;\n}\nfunction FUN9( address VAR27, address VAR28, uint256 VAR29 )public returns (bool VAR30) {\nrequire( VAR28 != 0x0);\nrequire(VAR25 == Stages.ENDED);\nrequire(VAR21[VAR27] >= VAR29 && VAR22[VAR27][msg.sender] >= VAR29 && VAR29 >= 0);\nif(FUN15(VAR28)) {\nrequire(now > VAR13 + 150 days);\n}\nVAR21[VAR27] = (VAR21[VAR27]).sub(VAR29);\nVAR22[VAR27][msg.sender] = (VAR22[VAR27][msg.sender]).sub(VAR29);\nVAR21[VAR28] = (VAR21[VAR28]).add(VAR29);\nreturn true;\n}\nfunction FUN10(address VAR31, uint256 VAR29)public returns (bool VAR30) {\nrequire( VAR31 != 0x0);\nVAR22[msg.sender][VAR31] = VAR29;\nreturn true;\n}\nfunction FUN11(address VAR28, uint256 VAR29)public returns (bool VAR30) {\nrequire( VAR28 != 0x0);\nrequire(VAR25 == Stages.ENDED);\nrequire(VAR21[msg.sender] >= VAR29 && VAR29 >= 0);\nVAR21[msg.sender] = (VAR21[msg.sender]).sub(VAR29);\nVAR21[VAR28] = (VAR21[VAR28]).add(VAR29);\nreturn true;\n}\nfunction FUN12(address VAR28, uint256 VAR29) private returns(bool VAR30) {\nrequire( VAR28 != 0x0);\nrequire(VAR21[address(this)] >= VAR29 && VAR29 > 0);\nVAR21[address(this)] = (VAR21[address(this)]).sub(VAR29);\nVAR21[VAR28] = (VAR21[VAR28]).add(VAR29);\nreturn true;\n}\nfunction FUN13(address VAR28, uint256 VAR29) private returns(bool VAR30) {\nrequire( VAR28 != 0x0);\nrequire(VAR21[address(this)] >= VAR29 && VAR29 > 0);\nVAR21[address(this)] = (VAR21[address(this)]).sub(VAR29);\nif(!FUN15(VAR28)) {\nFUN14(VAR28);\nVAR24++;\n}\nVAR21[VAR28] = (VAR21[VAR28]).add(VAR29);\nreturn true;\n}\nfunction FUN14(address VAR32) public {\nVAR23[VAR32]=true;\n}\nfunction FUN15(address VAR32) public returns(bool ){\nreturn VAR23[VAR32];\n}\nfunction FUN16() external FUN2 {\nVAR5.FUN11(this.balance);\n}\n}",
        "label": false,
        "name": "0xb95f51faa72f154092b9ff84fd723452f13e575e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != VAR1);\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\nfunction FUN4(address VAR4) FUN1 public {\nrequire(VAR4 != VAR1);\nVAR1 = VAR4;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON1 {\n}\ncontract CON5 is CON2, CON4 {\nmapping (address => uint256) public VAR5;\nmapping (address => uint256) public VAR6;\nuint public VAR7;\nuint public VAR8;\nuint public VAR9;\nmapping (uint256 => uint256) public VAR10;\nmapping (uint256 => uint256) public VAR11;\nmapping (uint256 => address) public VAR12;\nfunction FUN5(address VAR13, address VAR14, uint VAR15) public FUN1 returns(bool VAR16) {\nCON3 VAR17 = CON3(VAR13);\nreturn VAR17.transfer(VAR14, VAR15);\n}\nfunction FUN6(uint VAR18, address VAR19) public FUN1 {\nVAR5[VAR19] = VAR18;\n}\nfunction FUN7(uint VAR20) public FUN1 {\nVAR7 = VAR20;\n}\nfunction FUN8(uint VAR21, address VAR19) public FUN1 {\nVAR6[VAR19] = VAR21;\n}\nfunction FUN9(uint VAR22, uint VAR23) public FUN1 {\nVAR10[VAR22] = VAR23;\n}\nfunction FUN10(uint VAR22, uint VAR23) public FUN1 {\nVAR11[VAR22] = VAR23;\n}\nfunction FUN11(uint VAR22, address VAR24) public FUN1 {\nVAR12[VAR22] = VAR24;\n}\nfunction FUN12(uint VAR23) public FUN1 {\nVAR8 = VAR23;\n}\nfunction FUN13(uint VAR23) public FUN1 {\nVAR9 = VAR23;\n}\n}",
        "label": false,
        "name": "0xefa0f12ea4e96027dc575a3e0fedfbe5bc93b0fe.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nif (msg.sender != VAR1) throw;\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 { }\ncontract CON3 {\nstring public VAR3 = 'Token 0.1';\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction CON3(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) {\nVAR8[msg.sender] = VAR10;\nVAR7 = VAR10;\nVAR4 = VAR11;\nVAR5 = VAR13;\nVAR6 = VAR12;\n}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN4(address VAR16, uint256 VAR15)\nreturns (bool VAR17) {\nVAR9[msg.sender][VAR16] = VAR15;\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR15, bytes VAR18)\nreturns (bool VAR17) {\nCON2 VAR19 = CON2(VAR16);\nif (FUN4(VAR16, VAR15)) {\nVAR19.receiveApproval(msg.sender, VAR15, this, VAR18);\nreturn true;\n}\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction () {\nthrow;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR21;\nbool VAR22 = false;\nfunction CON4(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) CON3 (VAR10, VAR11, VAR12, VAR13) {}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR21[msg.sender]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR21[VAR20]) throw;\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction FUN8(address VAR23, uint256 VAR24) FUN1 {\nVAR8[VAR23] += VAR24;\nVAR7 += VAR24;\n}\nfunction FUN9(address VAR23, bool VAR25) FUN1 {\nVAR21[VAR23] = VAR25;\n}\nfunction FUN10(address VAR23, bool VAR25) FUN1 {\nVAR21[VAR23] = !VAR25;\n}\nfunction FUN11 () {\nrequire (msg.sender == VAR1);\nif (!VAR22) {\nVAR22 = true;\nFreeze ();\n}\n}\nfunction FUN12 () {\nrequire (msg.sender == VAR1);\nif (VAR22) {\nVAR22 = false;\nUnfreeze ();\n}\n}\nfunction FUN13(uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[msg.sender] >= VAR15);\nVAR8[msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\nfunction FUN14(address VAR20, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[VAR20] >= VAR15);\nrequire(VAR15 <= VAR9[VAR20][msg.sender]);\nVAR8[VAR20] -= VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\nfunction FUN15(string VAR26) FUN1 {\nVAR4 = VAR26;\n}\nfunction FUN16(string VAR27) FUN1 {\nVAR5 = VAR27;\n}\n}",
        "label": false,
        "name": "0xea92e35076000576aefe01b4a6d1ca55b8ade121.sol"
    },
    {
        "source": "\r\n\r\n\r\ncontract KnowsConstants {\r\n        uint public constant GAME_START_TIME = 1517787000;\r\n}\r\n\r\n\r\ncontract KnowsSquares {\r\n    modifier isValidSquare(uint home, uint away) {\r\n        require(home >= 0 && home < 10);\r\n        require(away >= 0 && away < 10);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ninterface IKnowsTime {\r\n    function currentTime() public view returns (uint);\r\n}\r\n\r\n\r\ncontract KnowsTime is IKnowsTime {\r\n    function currentTime() public view returns (uint) {\r\n        return now;\r\n    }\r\n}\r\n\r\n\r\ninterface IKnowsVoterStakes {\r\n    function getVoterStakes(address voter, uint asOfBlock) public view returns (uint);\r\n}\r\n\r\n\r\ninterface IScoreOracle {\r\n    function getSquareWins(uint home, uint away) public view returns (uint numSquareWins, uint totalWins);\r\n    function isFinalized() public view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Squares is KnowsConstants, KnowsTime, KnowsSquares, IKnowsVoterStakes {\r\n    using SafeMath for uint;\r\n\r\n    function Squares(IScoreOracle _oracle, address _developer) public {\r\n        oracle = _oracle;\r\n        developer = _developer;\r\n    }\r\n\r\n        IScoreOracle public oracle;\r\n\r\n        address public developer;\r\n\r\n        mapping(address => uint[10][10]) public totalSquareStakesByUser;\r\n\r\n        uint[10][10] public totalSquareStakes;\r\n\r\n        mapping(address => uint) public totalUserStakes;\r\n\r\n        uint public totalStakes;\r\n\r\n    event LogBet(address indexed better, uint indexed home, uint indexed away, uint stake);\r\n\r\n    function bet(uint home, uint away) public payable isValidSquare(home, away) {\r\n        require(msg.value > 0);\r\n        require(currentTime() < GAME_START_TIME);\r\n\r\n                uint stake = msg.value;\r\n\r\n                totalStakes = totalStakes.add(stake);\r\n\r\n                totalUserStakes[msg.sender] = totalUserStakes[msg.sender].add(stake);\r\n\r\n                totalSquareStakesByUser[msg.sender][home][away] = totalSquareStakesByUser[msg.sender][home][away].add(stake);\r\n\r\n                totalSquareStakes[home][away] = totalSquareStakes[home][away].add(stake);\r\n\r\n        LogBet(msg.sender, home, away, stake);\r\n    }\r\n\r\n    event LogPayout(address indexed winner, uint payout, uint donation);\r\n\r\n        function getWinnings(address user, uint home, uint away) public view returns (uint winnings) {\r\n                        var (numSquareWins, totalWins) = oracle.getSquareWins(home, away);\r\n\r\n        return totalSquareStakesByUser[user][home][away]\r\n            .mul(totalStakes)\r\n            .mul(numSquareWins)\r\n            .div(totalWins)\r\n            .div(totalSquareStakes[home][away]);\r\n    }\r\n\r\n        function collectWinnings(uint home, uint away, uint donationPercentage) public isValidSquare(home, away) {\r\n                require(oracle.isFinalized());\r\n\r\n                require(donationPercentage <= 100);\r\n\r\n                                        uint winnings = Math.min256(this.balance, getWinnings(msg.sender, home, away));\r\n\r\n        require(winnings > 0);\r\n\r\n                uint donation = winnings.mul(donationPercentage).div(100);\r\n\r\n        uint payout = winnings.sub(donation);\r\n\r\n                totalSquareStakesByUser[msg.sender][home][away] = 0;\r\n\r\n        msg.sender.transfer(payout);\r\n        developer.transfer(donation);\r\n\r\n        LogPayout(msg.sender, payout, donation);\r\n    }\r\n\r\n    function getVoterStakes(address voter, uint asOfBlock) public view returns (uint) {\r\n        return totalUserStakes[voter];\r\n    }\r\n}",
        "label": false,
        "name": "0x96e9ace417632353da8133f8471769c796641c30.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 {\naddress public VAR2;\nfunction CON2() public {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON2 {\nstring public constant VAR13 = \"REA\";\nstring public constant VAR14 = \"rea\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 2100000000 * (10 ** uint256(VAR15));\nfunction CON6() public {\nVAR1 = VAR16;\nVAR4[msg.sender] = VAR16;\n}\n}",
        "label": false,
        "name": "0x5562e0f8799684cb1cea307b9db1ad6dfc0e07bb.sol"
    },
    {
        "source": "{\"BitbookCrowdsale.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\nimport \\\"./RefundableCrowdsale.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BitbookCrowdsale is Ownable, RefundableCrowdsale {\\n    \\n    // amount of tokens sold\\n    uint256 private _totalTokensSold;\\n    \\n    ////////////////////////////////////\\n    //        DATES AND LIMITS\\n    ////////////////////////////////////\\n    \\n    mapping (uint8 =\\u003e uint256) private _hardcaps;\\n    mapping (uint8 =\\u003e uint256) private _minInvestments;\\n    mapping (uint8 =\\u003e uint8) private _bonuses;\\n    mapping (uint8 =\\u003e uint256) private _tokensSold;\\n    \\n    // private sale timestamps\\n    // uint256 private _privateSaleStartTime; -\\u003e  openingTime()\\n    uint256 private _privateSaleEndTime = 1548979200;\\n    \\n    // pre-sale timestamps\\n    // uint256 private _preSaleStartTime = 1543336832; -\\u003e _privateSaleEndTime\\n    uint256 private _preSaleEndTime = 1550275200;\\n    \\n    // main-sale timestamps\\n    // uint256 private _mainSaleStartTime = 1543337132; not used\\n    // uint256 private _mainSaleEndTime; -\\u003e  closingTime()\\n\\n    //       END OF DATES AND LIMITS\\n    \\n    \\n    constructor (uint256 rate, address wallet, IERC20 tokenAddress) public \\n    Crowdsale(rate, wallet, tokenAddress)\\n    TimedCrowdsale(1547553600, 1554076800)\\n    RefundableCrowdsale(60 * 10 ** 6 * (10 ** 18))\\n    {\\n        \\n        _hardcaps[0] = 120 * 10 ** 6 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n        _hardcaps[1] = 80 * 10 ** 6 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n        _hardcaps[2] = 220 * 10 ** 6 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n        \\n        _minInvestments[0] = 1 * 10 ** 6 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n        _minInvestments[1] = 2 * 10 ** 4 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n        //_minInvestments[0] = 10000;\\n        //_minInvestments[1] = 20000;\\n        // _minInvestments[2] = 0;\\n        \\n        _bonuses[0] = 0;\\n        _bonuses[1] = 0;\\n        _bonuses[2] = 0;\\n    }\\n    \\n    \\n    function getStage() public view onlyWhileOpen returns (uint8) {\\n        uint256 currentTime = block.timestamp;\\n        if (currentTime \\u003e= openingTime() \\u0026\\u0026 currentTime \\u003c= _privateSaleEndTime) {\\n            // private sale\\n            return 0;\\n        }\\n        else if (currentTime \\u003e _privateSaleEndTime \\u0026\\u0026 currentTime \\u003c _preSaleEndTime) {\\n            // pre-sale\\n            return 1;\\n        }\\n        else {\\n            // no condition needed because end of crowdsale checks in onlyWhileOpen modifier\\n            // main sale\\n            return 2;\\n        }\\n    }\\n    \\n    \\n    function totalTokensSold() public view returns (uint256) {\\n        return _totalTokensSold;\\n    }\\n    \\n    \\n    function tokensSoldOnCurrentStage() public view returns (uint256) {\\n        return _tokensSold[getStage()];\\n    }\\n    \\n    \\n    function hardcapOnCurrentStage() public view returns (uint256) {\\n        return _hardcaps[getStage()];\\n    }\\n    \\n    \\n    function goal() public view returns (uint256) {\\n        return 60 * 10 ** 6 * (10 ** uint256(ERC20Detailed(token()).decimals()));\\n    }\\n    \\n    \\n    function goalReached() public view returns (bool) {\\n        return totalTokensSold() \\u003e= goal();\\n    }\\n    \\n    \\n    function setRate(uint256 rate) external onlyOwner {\\n        require(rate != 0);\\n        _rate = rate;\\n    }\\n    \\n    \\n    function _finalization() internal {\\n        super._finalization();\\n        ERC20Burnable(token()).burn(token().balanceOf(address(this)));\\n    }\\n    \\n    \\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\\n        super._deliverTokens(beneficiary, tokenAmount);\\n        _totalTokensSold = _totalTokensSold.add(tokenAmount);\\n        uint8 stage = getStage();\\n        _tokensSold[stage] = _tokensSold[stage].add(tokenAmount);\\n    }\\n    \\n    \\n    function _validateMinInvestment(uint256 tokenAmount, uint8 stage) internal view {\\n        require(tokenAmount \\u003e= _minInvestments[stage]);\\n    }\\n    \\n    \\n    function _validateCap(uint256 tokenAmount, uint8 stage) internal view {\\n        require(_tokensSold[stage] + tokenAmount \\u003c= _hardcaps[stage]);\\n    }\\n    \\n    \\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\\n        uint256 tokenAmount = super._getTokenAmount(weiAmount);\\n        uint8 stage = getStage();\\n        \\n        _validateMinInvestment(tokenAmount, stage);\\n        \\n        uint256 purchaseBonus = 0;\\n        if (_bonuses[stage] != 0) {\\n            purchaseBonus = tokenAmount.mul(_bonuses[stage]).div(100);\\n        }\\n        tokenAmount = tokenAmount.add(purchaseBonus);\\n        \\n        _validateCap(tokenAmount, stage);\\n        \\n        return tokenAmount;\\n    }\\n    \\n    \\n    function buyTokensExternally(address beneficiary, uint256 tokenAmount) external onlyOwner onlyWhileOpen {\\n        require(! finalized());\\n        uint8 stage = getStage();\\n        _validateMinInvestment(tokenAmount, stage);\\n        _validateCap(tokenAmount, stage);\\n        _deliverTokens(beneficiary, tokenAmount);\\n        emit TokensPurchased(beneficiary, beneficiary, 0, tokenAmount);\\n    }\\n}\\n\"},\"BitbookToken.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract BitbookToken is ERC20Detailed, ERC20Burnable {\\n    \\n    \\n    constructor(address tokensOwner) public ERC20Detailed(\\\"Bitbook Gambling\\\", \\\"BXK\\\", 18) {\\n        _mint(tokensOwner, 750 * 10 ** 6 * (10 ** uint256(decimals())));  // 750M Tokens\\n    }\\n}\\n\\n\\n\"},\"ConditionalEscrow.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./Escrow.sol\\\";\\n\\n\\ncontract ConditionalEscrow is Escrow {\\n    \\n    function withdrawalAllowed(address payee) public view returns (bool);\\n\\n    function withdraw(address payee) public {\\n        require(withdrawalAllowed(payee));\\n        super.withdraw(payee);\\n    }\\n}\"},\"Crowdsale.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\n\\ncontract Crowdsale is ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // The token being sold\\n    IERC20 private _token;\\n\\n    // Address where funds are collected\\n    address private _wallet;\\n\\n    // How many token units a buyer gets per wei.\\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\\n    // 1 wei will give you 1 unit, or 0.001 TOK.\\n    uint256 internal _rate;\\n\\n    // Amount of wei raised\\n    uint256 private _weiRaised;\\n\\n    \\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\\n\\n    \\n    constructor (uint256 rate, address wallet, IERC20 token) internal {\\n        require(rate \\u003e 0);\\n        require(wallet != address(0));\\n        require(token != address(0));\\n\\n        _rate = rate;\\n        _wallet = wallet;\\n        _token = token;\\n    }\\n\\n    // -----------------------------------------\\n    // Crowdsale external interface\\n    // -----------------------------------------\\n\\n    \\n    function () external payable {\\n        buyTokens(msg.sender);\\n    }\\n\\n    \\n    function token() public view returns (IERC20) {\\n        return _token;\\n    }\\n\\n    \\n    function wallet() public view returns (address) {\\n        return _wallet;\\n    }\\n\\n    \\n    function rate() public view returns (uint256) {\\n        return _rate;\\n    }\\n\\n    \\n    function weiRaised() public view returns (uint256) {\\n        return _weiRaised;\\n    }\\n\\n    \\n    function buyTokens(address beneficiary) public nonReentrant payable {\\n        uint256 weiAmount = msg.value;\\n        _preValidatePurchase(beneficiary, weiAmount);\\n\\n        // calculate token amount to be created\\n        uint256 tokens = _getTokenAmount(weiAmount);\\n\\n        // update state\\n        _weiRaised = _weiRaised.add(weiAmount);\\n\\n        _processPurchase(beneficiary, tokens);\\n        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);\\n\\n        _updatePurchasingState(beneficiary, weiAmount);\\n\\n        _forwardFunds();\\n        _postValidatePurchase(beneficiary, weiAmount);\\n    }\\n\\n    // -----------------------------------------\\n    // Internal interface (extensible)\\n    // -----------------------------------------\\n\\n    \\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\\n        require(beneficiary != address(0));\\n        require(weiAmount != 0);\\n    }\\n\\n    \\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\\n        // optional override\\n    }\\n\\n    \\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\\n        _token.safeTransfer(beneficiary, tokenAmount);\\n    }\\n\\n    \\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\\n        _deliverTokens(beneficiary, tokenAmount);\\n    }\\n\\n    \\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\\n        // optional override\\n    }\\n\\n    \\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\\n        return weiAmount.mul(_rate);\\n    }\\n\\n    \\n    function _forwardFunds() internal {\\n        _wallet.transfer(msg.value);\\n    }\\n}\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n        // this function needs to emit an event with the updated approval.\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\n        _burn(account, value);\\n    }\\n}\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract ERC20Burnable is ERC20 {\\n    \\n    function burn(uint256 value) public {\\n        _burn(msg.sender, value);\\n    }\\n\\n    \\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string name, string symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    \\n    function name() public view returns (string) {\\n        return _name;\\n    }\\n\\n    \\n    function symbol() public view returns (string) {\\n        return _symbol;\\n    }\\n\\n    \\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\"},\"Escrow.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Secondary.sol\\\";\\n\\n \\ncontract Escrow is Secondary {\\n    using SafeMath for uint256;\\n\\n    event Deposited(address indexed payee, uint256 weiAmount);\\n    event Withdrawn(address indexed payee, uint256 weiAmount);\\n\\n    mapping(address =\\u003e uint256) private _deposits;\\n\\n    function depositsOf(address payee) public view returns (uint256) {\\n        return _deposits[payee];\\n    }\\n\\n    \\n    function deposit(address payee) public onlyPrimary payable {\\n        uint256 amount = msg.value;\\n        _deposits[payee] = _deposits[payee].add(amount);\\n\\n        emit Deposited(payee, amount);\\n    }\\n\\n    \\n    function withdraw(address payee) public onlyPrimary {\\n        uint256 payment = _deposits[payee];\\n\\n        _deposits[payee] = 0;\\n\\n        payee.transfer(payment);\\n\\n        emit Withdrawn(payee, payment);\\n    }\\n}\\n\"},\"FinalizableCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TimedCrowdsale.sol\\\";\\n\\n\\ncontract FinalizableCrowdsale is TimedCrowdsale {\\n    using SafeMath for uint256;\\n\\n    bool private _finalized;\\n\\n    event CrowdsaleFinalized();\\n\\n    constructor () internal {\\n        _finalized = false;\\n    }\\n\\n    \\n    function finalized() public view returns (bool) {\\n        return _finalized;\\n    }\\n\\n    \\n    function finalize() public {\\n        require(!_finalized);\\n        require(hasClosed());\\n\\n        _finalized = true;\\n\\n        _finalization();\\n        emit CrowdsaleFinalized();\\n    }\\n\\n    \\n    function _finalization() internal {}\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    \\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    \\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    \\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    \\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    \\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    \\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    \\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter);\\n    }\\n}\\n\"},\"RefundableCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./FinalizableCrowdsale.sol\\\";\\nimport \\\"./RefundEscrow.sol\\\";\\n\\n\\ncontract RefundableCrowdsale is FinalizableCrowdsale {\\n    using SafeMath for uint256;\\n\\n    // minimum amount of funds to be raised in weis\\n    uint256 private _goal;\\n\\n    // refund escrow used to hold funds while crowdsale is running\\n    RefundEscrow private _escrow;\\n\\n    \\n    constructor (uint256 goal) internal {\\n        require(goal \\u003e 0);\\n        _escrow = new RefundEscrow(wallet());\\n        _goal = goal;\\n    }\\n\\n    \\n    function goal() public view returns (uint256) {\\n        return _goal;\\n    }\\n\\n    \\n    function claimRefund(address refundee) public {\\n        require(finalized());\\n        require(!goalReached());\\n\\n        _escrow.withdraw(refundee);\\n    }\\n\\n    \\n    function goalReached() public view returns (bool) {\\n        return weiRaised() \\u003e= _goal;\\n    }\\n\\n    \\n    function _finalization() internal {\\n        if (goalReached()) {\\n            _escrow.close();\\n            _escrow.beneficiaryWithdraw();\\n        } else {\\n            _escrow.enableRefunds();\\n        }\\n\\n        super._finalization();\\n    }\\n\\n    \\n    function _forwardFunds() internal {\\n        _escrow.deposit.value(msg.value)(msg.sender);\\n    }\\n}\"},\"RefundEscrow.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./ConditionalEscrow.sol\\\";\\n\\n\\ncontract RefundEscrow is ConditionalEscrow {\\n    enum State { Active, Refunding, Closed }\\n\\n    event RefundsClosed();\\n    event RefundsEnabled();\\n\\n    State private _state;\\n    address private _beneficiary;\\n\\n    \\n    constructor (address beneficiary) public {\\n        require(beneficiary != address(0));\\n        _beneficiary = beneficiary;\\n        _state = State.Active;\\n    }\\n\\n    \\n    function state() public view returns (State) {\\n        return _state;\\n    }\\n\\n    \\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    \\n    function deposit(address refundee) public payable {\\n        require(_state == State.Active);\\n        super.deposit(refundee);\\n    }\\n\\n    \\n    function close() public onlyPrimary {\\n        require(_state == State.Active);\\n        _state = State.Closed;\\n        emit RefundsClosed();\\n    }\\n\\n    \\n    function enableRefunds() public onlyPrimary {\\n        require(_state == State.Active);\\n        _state = State.Refunding;\\n        emit RefundsEnabled();\\n    }\\n\\n    \\n    function beneficiaryWithdraw() public {\\n        require(_state == State.Closed);\\n        _beneficiary.transfer(address(this).balance);\\n    }\\n\\n    \\n    function withdrawalAllowed(address payee) public view returns (bool) {\\n        return _state == State.Refunding;\\n    }\\n}\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\n\\n\\n\"},\"Secondary.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n\\ncontract Secondary {\\n    address private _primary;\\n\\n    event PrimaryTransferred(\\n        address recipient\\n    );\\n\\n    \\n    constructor () internal {\\n        _primary = msg.sender;\\n        emit PrimaryTransferred(_primary);\\n    }\\n\\n    \\n    modifier onlyPrimary() {\\n        require(msg.sender == _primary);\\n        _;\\n    }\\n\\n    \\n    function primary() public view returns (address) {\\n        return _primary;\\n    }\\n\\n    \\n    function transferPrimary(address recipient) public onlyPrimary {\\n        require(recipient != address(0));\\n        _primary = recipient;\\n        emit PrimaryTransferred(_primary);\\n    }\\n}\\n\"},\"TimedCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Crowdsale.sol\\\";\\n\\n\\ncontract TimedCrowdsale is Crowdsale {\\n    using SafeMath for uint256;\\n\\n    uint256 private _openingTime;\\n    uint256 private _closingTime;\\n\\n    \\n    modifier onlyWhileOpen {\\n        require(isOpen());\\n        _;\\n    }\\n\\n    \\n    constructor (uint256 openingTime, uint256 closingTime) internal {\\n        // solium-disable-next-line security/no-block-members\\n        require(openingTime \\u003e= block.timestamp);\\n        require(closingTime \\u003e openingTime);\\n\\n        _openingTime = openingTime;\\n        _closingTime = closingTime;\\n    }\\n\\n    \\n    function openingTime() public view returns (uint256) {\\n        return _openingTime;\\n    }\\n\\n    \\n    function closingTime() public view returns (uint256) {\\n        return _closingTime;\\n    }\\n\\n    \\n    function isOpen() public view returns (bool) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp \\u003e= _openingTime \\u0026\\u0026 block.timestamp \\u003c= _closingTime;\\n    }\\n\\n    \\n    function hasClosed() public view returns (bool) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp \\u003e _closingTime;\\n    }\\n\\n    \\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\\n        super._preValidatePurchase(beneficiary, weiAmount);\\n    }\\n}\\n\\n\"}}",
        "label": false,
        "name": "0xeb6985acd6d0cbff60b88032b0b29ac1d9d66a1b.sol"
    },
    {
        "source": "contract CON1 {\nuint constant VAR1 = 10;\nuint constant VAR2 = 50 finney;\nuint constant VAR3 = 1 ether;\nuint constant VAR4 = 1100 finney;\nuint constant VAR5 = 1500 wei;\nuint constant VAR6 = 29000 wei;\nuint constant VAR7 = 30000 wei;\nuint constant VAR8 = 1700 wei;\nuint constant VAR9 = 34000 wei;\nuint constant VAR10 = 35000 wei;\nuint constant VAR11 = 1300 wei;\nuint constant VAR12 = 25000 wei;\nuint constant VAR13 = 270 wei;\nuint constant VAR14 = 60 ether;\nuint8 constant VAR15 = 2;\nuint8 constant VAR16 = 1;\nuint8[6] VAR17 = [\n0,\n10,\n20,\n30,\n50,\n50\n];\nuint constant VAR18 = 24 hours; uint constant VAR19 = 15 minutes;\nuint constant VAR20 = 2 days;\nuint constant VAR21 = 1922396399;\nuint constant VAR22 = 700000;\nuint constant VAR23 = 4000000000;\nstring constant VAR24 =\n\"[URL] json(https: string constant ORACLIZE_RATINGS_QUERY =\"?${[decrypt] BAr6Z9QolM2PQimF/pNC6zXldOvZ2qquOSKm/qJkJWnSGgAeRw21wBGnBbXiamr/ISC5SlcJB6wEPKthdc6F+IpqM/iXavKsalRUrGNuBsGfaMXr8fRQw6gLzqk0ecOFNeCa48/yqBvC/kas+jTKHiYxA3wTJrVZCq76Y03lZI2xxLaoniRk}).ratings[0]['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode','departureAirportFsCode']\";\nstring constant VAR25 =\n\"[URL] json(https: string constant ORACLIZE_STATUS_QUERY =\"?${[decrypt] BJxpwRaHujYTT98qI5slQJplj/VbfV7vYkMOp/Mr5D/5+gkgJQKZb0gVSCa6aKx2Wogo/cG7yaWINR6vnuYzccQE5yVJSr7RQilRawxnAtZXt6JB70YpX4xlfvpipit4R+OmQTurJGGwb8Pgnr4LvotydCjup6wv2Bk/z3UdGA7Sl+FU5a+0}&utc=true).flightStatuses[0]['status','delays','operationalTimes']\";\n}\ncontract CON2 {\n}\ncontract CON3 {\nenum Acc {\nPremium, RiskFund, Payout, Balance, Reward, OraclizeCosts }\nenum policyState { Applied, Accepted, Revoked, PaidOut, Expired, Declined, SendFailed }\nenum oraclizeState { ForUnderwriting, ForPayout }\nenum Currency { ETH, EUR, USD, GBP }\nstruct Policy {\naddress VAR26;\nuint VAR27;\nbytes32 VAR28;\nuint VAR29;\nuint VAR30;\nuint VAR31;\npolicyState VAR32;\nuint VAR33;\nbytes32 VAR34;\nbytes VAR35;\nCurrency VAR36;\nbytes32 VAR37;\n}\nstruct Risk {\nbytes32 VAR38;\nbytes32 VAR39;\nuint VAR40;\nuint VAR41;\nuint8 VAR42;\nuint VAR43;\nuint VAR44;\n}\nstruct OraclizeCallback {\nuint VAR45;\noraclizeState VAR46;\nuint VAR47;\n}\nstruct Customer {\nbytes32 VAR37;\nbool VAR48;\n}\n}\ncontract CON4 is CON3 {\naddress public VAR49;\nCON2 VAR50;\nmodifier FUN1() {\nrequire(msg.sender == VAR49);\n_;\n}\nfunction FUN2(address VAR51) internal returns (bool VAR52) {\nVAR49 = VAR51;\nVAR50 = CON2(VAR51);\nVAR52 = true;\n}\nfunction FUN3() public FUN1 {\nselfdestruct(VAR49);\n}\nfunction FUN4() public FUN1 {}\nfunction FUN5(bytes32 VAR53) internal returns (address VAR54) {\nVAR54 = VAR50.FUN5(VAR53);\n}\n}\ncontract CON5 is CON3 {\nuint public VAR55;\nuint public VAR56;\nbytes32[] public VAR57;\nbytes32[] public VAR58;\n}\ncontract CON6 is CON4, CON1 {\nCON5 VAR59;\nmodifier FUN6() {\nrequire(msg.sender == VAR50.FUN5('FD.Emergency'));\n_;\n}\nfunction CON6(address VAR51) public {\nFUN2(VAR51);\n}\nfunction FUN4() public FUN1 {\nVAR59 = CON5(FUN5(\"FD.Database\"));\n}\nfunction FUN7(uint8 VAR60, bytes32 VAR53) public {\nVAR59.setAccessControl(msg.sender, VAR50.FUN5(VAR53), VAR60);\n}\nfunction FUN8(address VAR61, address VAR62, uint8 VAR60, bool VAR63) public FUN6 {\nVAR59.setAccessControl(VAR61,VAR62,VAR60,VAR63);\n}\nfunction FUN7(uint8 VAR60, bytes32 VAR53, bool VAR63) public {\nVAR59.setAccessControl(msg.sender,VAR50.FUN5(VAR53),VAR60,VAR63);\n}\nfunction FUN9(uint8 VAR60, address VAR54) public {\nVAR59.setAccessControl(msg.sender, VAR54, VAR60);\n}\nfunction FUN9(uint8 VAR60, address VAR54, bool VAR63) public {\nVAR59.setAccessControl(msg.sender,VAR54,VAR60,VAR63);\n}\nfunction FUN10(uint8 VAR60, address VAR54) public returns (bool VAR64) {\nVAR64 = VAR59.getAccessControl(msg.sender, VAR54, VAR60);\n}\n}",
        "label": false,
        "name": "0x8e2ce47a011669d264caa4c073d0a8fced9dc677.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nstring public constant VAR4 = \"AlexCoin\";\nstring public constant VAR5 = \"ABC\";\nuint8 public constant VAR6 = 0;\nconstructor() public {\nVAR1[msg.sender] = 128;\nVAR3 = 128;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR8);\nFUN6(VAR10, VAR7, VAR8);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR11) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR2[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR12) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR2[msg.sender][VAR9].sub(VAR12);\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\n}\nfunction FUN7(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0));\nVAR3 = VAR3.sub(VAR8);\nVAR1[VAR13] = VAR1[VAR13].sub(VAR8);\n}\nfunction FUN8(address VAR13, uint256 VAR8) internal {\nVAR2[VAR13][msg.sender] = VAR2[VAR13][msg.sender].sub(VAR8);\nFUN7(VAR13, VAR8);\n}\n}",
        "label": false,
        "name": "0x7c189b699ebadde484195b0f17df2362344704df.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xf5fe587eb6f955b3a770f71de2217e30f6f7234d.sol"
    },
    {
        "source": "contract TheDaoHardForkOracle {\r\n        function forked() constant returns (bool);\r\n}\r\n\r\n\r\ncontract ReversibleDemo {\r\n        uint public numcalls;\r\n    uint public numcallsinternal;\r\n    uint public numfails;\r\n    uint public numsuccesses;\r\n\r\n    address owner;\r\n\r\n        address constant withdrawdaoaddr = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\r\n    TheDaoHardForkOracle oracle = TheDaoHardForkOracle(0xe8e506306ddb78ee38c9b0d86c257bd97c2536b3);\r\n\r\n    event logCall(uint indexed _numcalls,\r\n                  uint indexed _numfails,\r\n                  uint indexed _numsuccesses);\r\n\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _ }\r\n    modifier onlyThis { if (msg.sender != address(this)) throw; _ }\r\n\r\n        function ReversibleDemo() { owner = msg.sender; }\r\n\r\n    \r\n    \r\n    function sendIfNotForked() external onlyThis returns (bool) {\r\n        numcallsinternal++;\r\n\r\n        \r\n                        if (withdrawdaoaddr.balance < 3000000 ether) {\r\n            \r\n            owner.send(42);\r\n        }\r\n\r\n        \r\n        if (oracle.forked()) throw;\r\n\r\n                return true;\r\n    }\r\n\r\n        function doCall(uint _gas) onlyOwner {\r\n        numcalls++;\r\n\r\n        if (!this.sendIfNotForked.gas(_gas)()) {\r\n            numfails++;\r\n        }\r\n        else {\r\n            numsuccesses++;\r\n        }\r\n        logCall(numcalls, numfails, numsuccesses);\r\n    }\r\n\r\n    function selfDestruct() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n        function() {}\r\n}",
        "label": false,
        "name": "0xfbd9986b21fbc0d718d3999a640fe41391b5694d.sol"
    },
    {
        "source": "contract CON1{\n}",
        "label": false,
        "name": "0x24171bcfb9d600ff8392387f5cc3171d07ebb266.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"CAPITAL GAS\";\nstring public VAR16 = \"CALLG\";\nuint8 public VAR17 = 18;\n}",
        "label": false,
        "name": "0x1cb3d8997bc39667e9cbb2aa70203f94ecda1422.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN18() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN19() {\nrequire(VAR13);\n_;\n}\nfunction FUN20() public FUN13 FUN18 {\nVAR13 = true;\n}\nfunction FUN21() public FUN13 FUN19 {\nVAR13 = false;\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN18 returns (bool VAR14) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN18 returns (bool VAR14) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR15;\nconstructor () internal {\nFUN25(msg.sender);\n}\nmodifier FUN22() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN23(address VAR10) public FUN22 {\nFUN25(VAR10);\n}\nfunction FUN24() public {\nFUN26(msg.sender);\n}\nfunction FUN25(address VAR10) internal {\nVAR15.add(VAR10);\n}\nfunction FUN26(address VAR10) internal {\nVAR15.remove(VAR10);\n}\n}\ncontract CON8 is CON2, CON7 {\nfunction FUN27(address VAR4, uint256 VAR5) public FUN22 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON9 is CON1, CON3, CON6, CON8 {\nstring private VAR16;\nstring private VAR17;\nuint8 private VAR18;\nconstructor (string memory VAR19, string memory VAR20, uint8 VAR21) public {\nVAR16 = VAR19;\nVAR17 = VAR20;\nVAR18 = VAR21;\n}\n}",
        "label": false,
        "name": "0x84bd485e3a7e46efddf39f5f65be1ebf61840fd1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR7[VAR8][msg.sender] >= VAR6);\nrequire(VAR4[VAR8] >= VAR6);\nrequire(VAR4[VAR5].add(VAR6) > VAR4[VAR5]); VAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nrequire((VAR6 == 0) || (VAR7[msg.sender][VAR9] == 0));\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6 (address VAR9, uint VAR10) public returns (bool VAR11) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR7[msg.sender][VAR9];\nif (VAR12 > VAR13) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR14 = false;\naddress public VAR15;\nmodifier FUN8() {\nrequire(!VAR14 || msg.sender == VAR15);\n_;\n}\nmodifier FUN9() {\nrequire(VAR14);\n_;\n}\nfunction FUN10() public FUN1 FUN8 {\nVAR14 = true;\n}\nfunction FUN11() public FUN1 FUN9 {\nVAR14 = false;\n}\n}\ncontract CON7 is CON6 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN8 returns (bool VAR11) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR12) public FUN8 returns (bool VAR11) {\nreturn super.FUN7(VAR9, VAR12);\n}\n}\ncontract CON8 is CON7 {\nstring public VAR16;\nstring public VAR17;\nuint8 public VAR18;\nconstructor() public {\nVAR16 = \"Electronic Energy Coin\";\nVAR17 = \"E2C\";\nVAR18 = 18;\nVAR3 = 131636363e18;\nVAR15 = 0xAcff30a602b75b25083c151292E5E4F7A06800e3;\nVAR4[msg.sender] = VAR3;\n}\n}",
        "label": false,
        "name": "0x983bc5c5a322ec321908e21bd8bad2cd7780d23c.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 {\naddress public VAR2;\nconstructor() public {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) FUN1 public {\nif (VAR3 != address(0)) {\nVAR2 = VAR3;\n}\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR6 > 0);\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR6 > 0);\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nrequire(VAR6 > 0);\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nrequire(VAR10 > 0);\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nrequire(VAR11 > 0);\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON2 {\nbool public VAR13 = true;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN9() {\nrequire(VAR13);\n_;\n}\nfunction FUN10() FUN1 FUN8 public {\nVAR13 = true;\n}\nfunction FUN11() FUN1 FUN9 public {\nVAR13 = false;\n}\n}\ncontract CON7 is CON5, CON6 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN8 returns (bool VAR14) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN8 returns (bool VAR14) {\nreturn super.FUN7(VAR9, VAR11);\n}\nfunction FUN12(address VAR5, uint256 VAR6) public FUN1 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\n}\ncontract CON8 is CON7 {\nstring public constant VAR15 = \"LogisticsX\";\nstring public constant VAR16 = \"PNP\";\nuint8 public constant VAR17 = 18;\nuint256 public constant VAR18 = 1000000000 * (10 ** uint256(VAR17));\nconstructor(address VAR19) public {\nVAR1 = VAR18;\nVAR4[VAR19] = VAR18;\n}\n}",
        "label": false,
        "name": "0xb34d3525612caa1c44f7dc4cfdd3f57c4f239e68.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nfunction CON3() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nstring public constant VAR3 = \"FootStar Token\";\nstring public constant VAR4 = \"FTST\";\nuint8 public constant VAR5 = 18;\nmapping (address => uint256) private VAR6;\nmapping (address => mapping (address => uint256)) internal VAR7;\nbool public VAR8 = false;\nuint256 private VAR9;\nmodifier FUN3() {\nrequire(VAR8);\n_;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[msg.sender]);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[VAR12]);\nrequire(VAR11 <= VAR7[VAR12][msg.sender]);\nVAR6[VAR12] = VAR6[VAR12].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR11) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR14) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR7[msg.sender][VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR13, uint VAR15) public returns (bool) {\nuint VAR16 = VAR7[msg.sender][VAR13];\nif (VAR15 > VAR16) {\nVAR7[msg.sender][VAR13] = 0;\n} else {\nVAR7[msg.sender][VAR13] = VAR16.sub(VAR15);\n}\nreturn true;\n}\nmodifier FUN9() {\nrequire(!VAR8);\n_;\n}\nfunction FUN10(address VAR10, uint256 VAR17) public FUN1 FUN9 returns (bool) {\nVAR9 = VAR9.add(VAR17);\nVAR6[VAR10] = VAR6[VAR10].add(VAR17);\nreturn true;\n}\nfunction FUN11() public FUN1 FUN9 returns (bool) {\nVAR8 = true;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4509fcbbe90f82b6e10de7ba1c88d9524d1046c7.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = 0xfc0281163cFeDA9FbB3B18A72A27310B1725fD65;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new VAR13 is the zero address\");\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR8, uint256 VAR7) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(VAR9, VAR6, VAR7);\nFUN12(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN8(address VAR8, uint256 VAR10) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR11) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR9 != address(0), \"ERC20: FUN5 VAR9 the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN5 VAR6 the zero address\");\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN17 VAR6 the zero address\");\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN12(address VAR13, address VAR8, uint256 VAR7) internal {\nrequire(VAR13 != address(0), \"ERC20: FUN6 VAR9 the zero address\");\nrequire(VAR8 != address(0), \"ERC20: FUN6 VAR6 the zero address\");\nVAR4[VAR13][VAR8] = VAR7;\n}\n}\ncontract CON4 is CON3, CON1 {\nusing SafeMath for uint256;\nstring public constant VAR14 = \"Crypto Service Capital Token\";\nstring public constant VAR15 = \"CSCT\";\nuint8 public constant VAR16 = 18;\nbool public VAR17 = false;\nmapping (address => bool) private VAR18;\nmodifier FUN13() {\nrequire(!VAR17);\n_;\n}\nmodifier FUN14() {\nrequire(isMinter(msg.sender), \"Minter: caller is not the minter\");\n_;\n}\nfunction FUN15(address VAR19) external FUN1 returns (bool) {\nrequire(VAR19 != address(0));\nVAR18[VAR19] = true;\nreturn true;\n}\nfunction FUN16(address VAR19) external FUN1 returns (bool) {\nrequire(VAR19 != address(0));\nVAR18[VAR19] = false;\nreturn true;\n}\nfunction FUN17(address VAR6, uint256 VAR7) public FUN14 returns (bool) {\nFUN11(VAR6, VAR7);\nreturn true;\n}\nfunction FUN18() FUN1 FUN13 external returns (bool) {\nVAR17 = true;\nreturn true;\n}\n}\ncontract CON5 is CON1 {\nusing SafeMath for uint256;\nuint256 public constant VAR20 = 1000; uint256 public constant VAR21 = 10000 ether;\nbool public VAR22 = false; uint256 public VAR23 = 1559347199; uint256 public VAR24 = 1577836799;\nCON4 public VAR25; address payable public VAR26 = 0x1524Aa69ef4BA327576FcF548f7dD14aEaC8CA18; uint256 public VAR27;\nuint256 public VAR28 = 30; uint256 public VAR29 = 50;\nconstructor (CON4 VAR30) public {\nassert(address(VAR30) != address(0));\nVAR25 = VAR30;\n}\nfunction () external payable {\nFUN20(msg.sender);\n}\nfunction FUN20(address VAR31) public payable {\nrequire(VAR31 != address(0));\nrequire(validPurchase());\nuint256 VAR32 = msg.VAR7;\nuint256 VAR33 = tokensForWei(VAR32);\nVAR27 = VAR27.add(VAR32);\nVAR25.FUN17(VAR31, VAR33);\nVAR26.FUN5(msg.VAR7);\n}\nfunction FUN21(uint256 VAR34) FUN1 external {\nVAR28 = VAR34;\n}\nfunction FUN22(uint256 VAR34) FUN1 external {\nVAR29 = VAR34;\n}\nfunction FUN23(uint256 VAR35) FUN1 external {\nrequire(VAR24 >= now);\nVAR24 = VAR35;\n}\nfunction FUN24() FUN1 external {\nrequire(!VAR22);\nVAR24 = now;\nVAR22 = true;\n}\n}",
        "label": false,
        "name": "0x48271aa08d6309895447c067e728e8b140ddf2b4.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\naddress private VAR2 = 0x0;\naddress private VAR3 = 0x0;\nuint256 public VAR4 = 150;\nuint256 public VAR5 = 1506052800; uint256 public VAR6 = 1508731200;\nuint256 public VAR7 = 0;\nuint256 public VAR8 = 330000000 * (10 ** 18) * 2 / 100;\nfunction CON1 () public {\nVAR1 = msg.sender;\n}\nfunction FUN1 (string VAR9, string VAR10) payable public returns (bool) {\nrequire(VAR2 != 0x0); require(VAR3 != 0x0); require(msg.value >= 1 ether); require(now >= VAR5 && now <= VAR6); require(VAR7 <= VAR8);\nuint256 VAR11 = msg.value * VAR4;\nif (keccak256(VAR10) == 0xde7683d6497212fbd59b6a6f902a01c91a09d9a070bba7506dcc0b309b358eed) {\nVAR11 = VAR11 * 135 / 100;\n}\nif (keccak256(VAR10) == 0x65b236bfb931f493eb9e6f3db8d461f1f547f2f3a19e33a7aeb24c7e297c926a) {\nVAR11 = VAR11 * 130 / 100;\n}\nif (keccak256(VAR10) == 0x274125681e11c33f71574f123a20cfd59ed25e64d634078679014fa3a872575c) {\nVAR11 = VAR11 * 125 / 100;\n}\nif (VAR2.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), VAR3, msg.sender, VAR11) != true) {\nrevert();\n}\nVAR7 = VAR7 + VAR11;\nreturn true;\n}\nfunction FUN2 (address VAR12, uint256 VAR13) public returns (bool) {\nrequire(msg.sender == VAR1);\nVAR12.transfer(VAR13);\nreturn true;\n}\nfunction FUN3 (address VAR14) public returns (bool) {\nrequire(msg.sender == VAR1);\nVAR2 = VAR14;\nreturn true;\n}\nfunction FUN4 (address VAR15) public returns (bool) {\nrequire(msg.sender == VAR1);\nVAR3 = VAR15;\nreturn true;\n}\nfunction () public {}\n}",
        "label": false,
        "name": "0xea68d87ae3a55ba91c1a8e6488627a175be81588.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR3;\nuint256 internal VAR4;\nfunction FUN5(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR6 <= VAR3[msg.sender]);\nrequire(VAR5 != address(0));\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN6(address VAR8,address VAR5,uint256 VAR6)\npublic\nreturns (bool)\n{\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nrequire(VAR5 != address(0));\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN7(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nVAR7[msg.sender][VAR9] = (VAR7[msg.sender][VAR9].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR9,uint256 VAR11)\npublic\nreturns (bool)\n{\nuint256 VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 >= VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN12(address VAR5,uint256 VAR14)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN13() public FUN1 FUN10 returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR15 = \"Jerusalem Chain\";\nstring public constant VAR16 = \"JERU\";\nuint8 public constant VAR17 = 0;\nconstructor(address VAR18, uint256 VAR19) public {\nFUN12(VAR18, VAR19);\nFUN13();\n}\n}",
        "label": false,
        "name": "0x4a73ce2a1d78dee1000e87f7218791253aa66b1c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 {\naddress private VAR17;\nconstructor () internal {\nVAR17 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR17 = address(0);\n}\nfunction FUN12(address VAR18) public FUN10 {\nFUN13(VAR18);\n}\nfunction FUN13(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON5 is CON3, CON2, CON4 {\nusing SafeMath for uint256;\nconstructor(address VAR19)\npublic\nCON3(\"ExtraTerrestrial\", \"ETER\", 18)\n{\nFUN7(VAR19, 30000000000000000000000000);\n}\n}",
        "label": false,
        "name": "0xfe60cef62294f4efb43ab65b47558113cbe19fbc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"Ojooo Coin\";\nstring public VAR16 = \"OJX\";\nuint8 public VAR17 = 18;\n}",
        "label": false,
        "name": "0xbeef546ac8a4e0a80dc1e2d696968ef54138f1d4.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nmapping (address => uint256) public VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool VAR6) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[msg.sender]);\nrequire(VAR2[VAR4] + VAR5 > VAR2[VAR4]);\nVAR2[msg.sender] = SafeMath.safeSub(VAR2[msg.sender], VAR5);\nVAR2[VAR4] = SafeMath.safeAdd(VAR2[VAR4], VAR5);\nreturn true;\n}\nfunction FUN2(address VAR7, address VAR4, uint256 VAR5) public returns (bool VAR6) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[VAR7]);\nrequire(VAR5 <= VAR3[VAR7][msg.sender]);\nrequire(VAR2[VAR4] + VAR5 > VAR2[VAR4]);\nVAR2[VAR4] = SafeMath.safeAdd(VAR2[VAR4], VAR5);\nVAR2[VAR7] = SafeMath.safeSub(VAR2[VAR7], VAR5);\nVAR3[VAR7][msg.sender] = SafeMath.safeSub(VAR3[VAR7][msg.sender], VAR5);\nreturn true;\n}\nfunction VAR2(address VAR8) constant public returns (uint256 VAR9) {\nreturn VAR2[VAR8];\n}\nfunction FUN3(address VAR10, uint256 VAR5) public returns (bool VAR6) {\nrequire((VAR5 == 0) || (VAR3[msg.sender][VAR10] == 0));\nVAR3[msg.sender][VAR10] = VAR5;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR10) constant public returns (uint256 VAR11) {\nreturn VAR3[VAR8][VAR10];\n}\n}\ncontract CON3 is CON2 {\nfunction () public {\nrevert();\n}\nstring public VAR12 = \"Kino CON1 ETH\";\nuint8 public VAR13 = 8;\nstring public VAR14 = \"KTETH\";\nuint256 public VAR1 = 1*10**17;\nconstructor() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x2f90599ab7d47a7eeb25017b5429d7305794257b.sol"
    },
    {
        "source": "contract CON1 {\nstruct TKN {\naddress VAR1;\nuint256 VAR2;\nbytes VAR3;\nbytes4 VAR4;\n}\n}\ncontract CON2 {\nusing SafeMath for uint256;\naddress public VAR5;\naddress public VAR6;\nstring public VAR7;\nstring public VAR8;\nuint8 public VAR9;\naddress public VAR10;\naddress public VAR11;\naddress public VAR12;\naddress public VAR13;\naddress public VAR14;\naddress public VAR15;\nuint256 public VAR16 = 1000000; struct feeStruct {\nuint256 VAR17;\nuint256 VAR18;\n}\nfeeStruct public VAR19;\nfeeStruct public VAR20;\nfeeStruct public VAR21;\nuint256 public VAR22;\nuint256 public VAR23;\nstruct approveMintStruct {\nuint256 VAR24;\naddress VAR25;\naddress VAR26;\naddress VAR27;\n}\nmapping (address => approveMintStruct) public VAR28;\nstruct approveBurnStruct {\nuint256 VAR24;\naddress VAR25;\n}\nmapping (address => approveBurnStruct) public VAR29;\nuint256 public VAR30;\nuint256 public VAR31;\nuint256 public VAR32;\nbool public VAR33;\nconstructor(address VAR34, string VAR35, string VAR36,uint256 VAR37, uint256 VAR38,uint256 VAR39, uint256 VAR40) public {\nVAR9 = 18;\nVAR5 = msg.VAR1;\nVAR7 = VAR35;\nVAR8 = VAR36;\nVAR22 = VAR37;\nVAR23 = VAR38;\nVAR6 = VAR34;\nVAR30 = VAR39;\nVAR31 = VAR40;\nVAR32 = 0;\nVAR33 = false;\n}\nmodifier FUN1() {\nrequire(msg.VAR1 == VAR10, \"Only admin\");\n_;\n}\nmodifier FUN2() {\nrequire(msg.VAR1 == VAR11, \"Only audit\");\n_;\n}\nmodifier FUN3() {\nrequire(msg.VAR1 == VAR12, \"Only market maker\");\n_;\n}\nmodifier FUN4() {\nrequire(!VAR33, \"Speed bump activated\");\n_;\n}\nmodifier FUN5(address VAR41) {\nrequire(VAR28[VAR41].VAR25 != 0x0, \"Require VAR25 approval\");\nrequire(VAR28[VAR41].VAR26 != 0x0, \"Require VAR26 approval\");\nrequire(VAR28[VAR41].VAR27 != 0x0, \"Require market maker approval\");\n_;\n}\nfunction FUN6(address VAR42, uint256 VAR43) public FUN5(VAR42) FUN34 FUN4 {\nuint256 VAR44 = calcMintFee (VAR43);\nuint256 VAR45 = VAR43.sub(VAR44);\nFUN36(VAR13, VAR44);\nFUN36(VAR42, VAR45);\nFUN22(VAR42);\n}\nfunction FUN7(address VAR42, uint256 VAR43) public returns (bool VAR46) {\nif (VAR33)\n{\nrequire (VAR43 <= VAR31, \"Speed bump activated, VAR24 exceeded\");\nrequire (now > (VAR32 + VAR30), \"Speed bump activated, frequency exceeded\");\nVAR32 = now;\n}\nuint256 VAR44 = calcTransferFee (VAR43);\nuint256 VAR45 = VAR43.sub(VAR44);\nFUN39(VAR14, VAR44);\nFUN39(VAR42, VAR45);\nreturn true;\n}\nfunction FUN8(uint256 VAR43) public FUN3 {\nuint256 VAR44 = calcBurnFee (VAR43);\nuint256 VAR47 = VAR43.sub(VAR44);\nFUN39(VAR15, VAR44);\nFUN37(msg.VAR1, VAR47);\n}\nfunction FUN9(address VAR41) public FUN30 returns (address) {\nVAR10 = VAR41;\nreturn VAR10;\n}\nfunction FUN10(address VAR41) public FUN30 returns (address) {\nVAR11 = VAR41;\nreturn VAR11;\n}\nfunction FUN11(address VAR41) public FUN30 returns (address) {\nVAR12 = VAR41;\nreturn VAR12;\n}\nfunction FUN12(address VAR41) public FUN30 returns (bool) {\nVAR13 = VAR41;\nreturn true;\n}\nfunction FUN13(address VAR41) public FUN30 returns (bool) {\nVAR14 = VAR41;\nreturn true;\n}\nfunction FUN14(address VAR41) public FUN30 returns (bool) {\nVAR15 = VAR41;\nreturn true;\n}\nfunction FUN15(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR22, \"Must be less then maximum\");\nVAR19.VAR17 = VAR48;\nreturn true;\n}\nfunction FUN16(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR23, \"Must be less then maximum\");\nVAR19.VAR18 = VAR48;\nreturn true;\n}\nfunction FUN17(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR22, \"Must be less then maximum\");\nVAR20.VAR17 = VAR48;\nreturn true;\n}\nfunction FUN18(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR23, \"Must be less then maximum\");\nVAR20.VAR18 = VAR48;\nreturn true;\n}\nfunction FUN19(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR22, \"Must be less then maximum\");\nVAR21.VAR17 = VAR48;\nreturn true;\n}\nfunction FUN20(uint256 VAR48) external FUN30 returns (bool) {\nrequire(VAR48 < VAR23, \"Must be less then maximum\");\nVAR21.VAR18 = VAR48;\nreturn true;\n}\nfunction FUN21(address VAR41) public FUN30 {\nFUN22(VAR41);\n}\nfunction FUN22(address VAR41) internal {\nVAR28[VAR41].VAR24 = 0;\nVAR28[VAR41].VAR25 = 0x0;\nVAR28[VAR41].VAR26 = 0x0;\nVAR28[VAR41].VAR27 = 0x0;\n}\nfunction FUN23(address VAR41, uint256 VAR48) public FUN1 {\nif (VAR28[VAR41].VAR24 > 0) {\nrequire(VAR28[VAR41].VAR24 == VAR48, \"Value is diferent\");\n}\nelse {\nVAR28[VAR41].VAR24 = VAR48;\n}\nVAR28[VAR41].VAR25 = msg.VAR1;\nif ((VAR28[VAR41].VAR26 != 0x0) && (VAR28[VAR41].VAR27 != 0x0))\nFUN6(VAR41, VAR48);\n}\nfunction FUN24(address VAR41) public FUN1 {\nrequire(VAR28[VAR41].VAR25 == msg.VAR1, \"Only cancel if the address is the same admin\");\nVAR28[VAR41].VAR25 = 0x0;\n}\nfunction FUN25(address VAR41, uint256 VAR48) public FUN2 {\nif (VAR28[VAR41].VAR24 > 0) {\nrequire(VAR28[VAR41].VAR24 == VAR48, \"Value is diferent\");\n}\nelse {\nVAR28[VAR41].VAR24 = VAR48;\n}\nVAR28[VAR41].VAR26 = msg.VAR1;\nif ((VAR28[VAR41].VAR25 != 0x0) && (VAR28[VAR41].VAR27 != 0x0))\nFUN6(VAR41, VAR48);\n}\nfunction FUN26(address VAR41) public FUN2 {\nrequire(VAR28[VAR41].VAR26 == msg.VAR1, \"Only cancel if the address is the same audit\");\nVAR28[VAR41].VAR26 = 0x0;\n}\nfunction FUN27(address VAR41, uint256 VAR48) public FUN3 {\nif (VAR28[VAR41].VAR24 > 0) {\nrequire(VAR28[VAR41].VAR24 == VAR48, \"Value is diferent\");\n}\nelse {\nVAR28[VAR41].VAR24 = VAR48;\n}\nVAR28[VAR41].VAR27 = msg.VAR1;\nif ((VAR28[VAR41].VAR25 != 0x0) && (VAR28[VAR41].VAR26 != 0x0))\nFUN6(VAR41, VAR48);\n}\nfunction FUN28(address VAR41) public FUN3 {\nrequire(VAR28[VAR41].VAR27 == msg.VAR1, \"Only cancel if the address is the same marketMaker\");\nVAR28[VAR41].VAR27 = 0x0;\n}\nfunction FUN29 (bool VAR48) public FUN31 {\nVAR33 = VAR48;\n}\nmodifier FUN30() {\nrequire((msg.VAR1 == VAR5) || (msg.VAR1 == VAR6), \"Only owner\");\n_;\n}\nmodifier FUN31() {\nrequire(msg.VAR1 == VAR6, \"Only master owner\");\n_;\n}\nfunction FUN32(address VAR49) public FUN30 {\nFUN33(VAR49);\n}\nfunction FUN33(address VAR49) internal {\nrequire(VAR49 != address(0), \"newOwner must be not 0x0\");\nVAR5 = VAR49;\n}\nbool public VAR50 = false;\nmodifier FUN34() {\nrequire(!VAR50, \"Mint is finished\");\n_;\n}\nfunction FUN35() public FUN31 FUN34 returns (bool) {\nVAR50 = true;\nreturn true;\n}\nfunction FUN36(address VAR51, uint256 VAR43) internal FUN34 {\nrequire(VAR51 != 0, \"Address must not be zero\");\nVAR54 = VAR54.add(VAR43);\nVAR52[VAR51] = VAR52[VAR51].add(VAR43);\n}\nfunction FUN37(address VAR51, uint256 VAR43) internal {\nrequire(VAR51 != 0, \"Address must not be zero\");\nrequire(VAR43 <= VAR52[VAR51], \"Insuficient funds\");\nVAR54 = VAR54.sub(VAR43);\nVAR52[VAR51] = VAR52[VAR51].sub(VAR43);\n}\nmapping (address => uint256) private VAR52;\nmapping (address => mapping (address => uint256)) private VAR53;\nuint256 private VAR54;\nfunction FUN38(address VAR55, address VAR56) public constant returns (uint256 VAR57) {\nreturn VAR53[VAR55][VAR56];\n}\nfunction FUN39(address VAR42, uint256 VAR48, bytes VAR58, string VAR59) private returns (bool VAR46) {\nif (isContract(VAR42)) {\nif (balanceOf(msg.VAR1) < VAR48) revert(\"Insuficient funds\");\nVAR52[msg.VAR1] = balanceOf(msg.VAR1).sub(VAR48);\nVAR52[VAR42] = balanceOf(VAR42).add(VAR48);\nassert(VAR42.call.VAR2(0)(bytes4(keccak256(abi.encodePacked(VAR59))), msg.VAR1, VAR48, VAR58));\nreturn true;\n}\nelse {\nreturn FUN40(VAR42, VAR48, VAR58);\n}\n}\nfunction FUN39(address VAR42, uint256 VAR48, bytes VAR58) private returns (bool VAR46) {\nif(isContract(VAR42)) {\nreturn FUN41(VAR42, VAR48, VAR58);\n}\nelse {\nreturn FUN40(VAR42, VAR48, VAR58);\n}\n}\nfunction FUN39(address VAR42, uint256 VAR48) private returns (bool VAR46) {\nbytes memory VAR60;\nif(isContract(VAR42)) {\nreturn FUN41(VAR42, VAR48, VAR60);\n}\nelse {\nreturn FUN40(VAR42, VAR48, VAR60);\n}\n}\nfunction FUN40(address VAR42, uint256 VAR48, bytes VAR58) private returns (bool VAR46) {\nif (balanceOf(msg.VAR1) < VAR48) revert(\"Insuficient funds\");\nVAR52[msg.VAR1] = balanceOf(msg.VAR1).sub(VAR48);\nVAR52[VAR42] = balanceOf(VAR42).add(VAR48);\nreturn true;\n}\nfunction FUN41(address VAR42, uint256 VAR48, bytes VAR58) private returns (bool VAR46) {\nif (balanceOf(msg.VAR1) < VAR48) revert(\"Insuficient funds\");\nVAR52[msg.VAR1] = balanceOf(msg.VAR1).sub(VAR48);\nVAR52[VAR42] = balanceOf(VAR42).add(VAR48);\nCON1 VAR61 = CON1(VAR42);\nVAR61.tokenFallback(msg.VAR1, VAR48, VAR58);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4fc253577d582ab489dd7325e5e77ca2c3cfc3fe.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR3 = true;\n}\nfunction FUN8() FUN1 FUN6 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 public VAR6;\nfunction FUN9(address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR8) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(VAR10, VAR7, VAR8);\nFUN15(VAR10, msg.sender, VAR5[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN12(address VAR9, uint256 VAR11) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR9, uint256 VAR12) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN14(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\nfunction FUN15(address VAR13, address VAR9, uint256 VAR8) internal {\nrequire(VAR9 != address(0));\nrequire(VAR13 != address(0));\nVAR5[VAR13][VAR9] = VAR8;\n}\n}\ncontract CON5 is CON4, CON2 {\nfunction FUN9(address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN10(address VAR9, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR8);\n}\nfunction FUN12(address VAR9, uint VAR11) public FUN5 returns (bool VAR14) {\nreturn super.FUN12(VAR9, VAR11);\n}\nfunction FUN13(address VAR9, uint VAR12) public FUN5 returns (bool VAR14) {\nreturn super.FUN13(VAR9, VAR12);\n}\n}\ncontract CON6 is CON1 {\nCON7 public VAR15;\nuint256 constant public VAR16 = 18;\nuint256 public VAR6 = 90000000 * (10 ** uint256(VAR16));\nconstructor () public {\nVAR15 = FUN16();\nVAR15.FUN8();\n}\nfunction FUN16() internal returns (CON7) {\nreturn new CON7();\n}\nfunction FUN17() external FUN1 {\nVAR15.FUN8();\n}\nfunction FUN18() external FUN1 {\nVAR15.FUN7();\n}\nfunction FUN9(address VAR7, uint256 VAR8) external FUN1 returns (bool VAR17) {\nuint256 VAR18 = VAR8 * (10 ** uint256(VAR16));\nreturn VAR15.FUN9(VAR7, VAR18);\n}\n}\ncontract CON7 is CON5 {\nstring constant public VAR19 = \"MVIT Token\";\nstring constant public VAR20 = \"MVT\";\nuint8 constant public VAR21 = 18;\nuint256 constant VAR22 = 10 ** uint256(VAR21);\nuint256 constant VAR23 = 90000000 * VAR22;\nconstructor () public {\nVAR3 = true;\nVAR6 = VAR23;\nVAR4[msg.sender] = VAR23;\n}\n}",
        "label": false,
        "name": "0xb4450f8048dd4eaa6e24b6fdb4f8328b22b61bef.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nmapping (address => bool) public VAR9;\nconstructor(uint256 VAR10,string memory VAR11,string memory VAR12) public {\nVAR6 = VAR10 * 10 ** uint256(VAR5);\nVAR7[msg.sender] = VAR6;\nVAR3 = VAR11;\nVAR4 = VAR12;\n}\nfunction FUN3(address VAR13, address VAR14, uint VAR15) internal {\nrequire(VAR14 != address(0x0));\nrequire(VAR7[VAR13] >= VAR15);\nrequire(VAR7[VAR14] + VAR15 >= VAR7[VAR14]);\nrequire(!VAR9[VAR13]);\nrequire(!VAR9[VAR14]);\nuint VAR16 = VAR7[VAR13] + VAR7[VAR14];\nVAR7[VAR13] -= VAR15;\nVAR7[VAR14] += VAR15;\nassert(VAR7[VAR13] + VAR7[VAR14] == VAR16);\n}\nfunction FUN4(address VAR14, uint256 VAR15) public returns (bool VAR17) {\nFUN3(msg.sender, VAR14, VAR15);\nreturn true;\n}\nfunction FUN5(address VAR13, address VAR14, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR15 <= VAR8[VAR13][msg.sender]); VAR8[VAR13][msg.sender] -= VAR15;\nFUN3(VAR13, VAR14, VAR15);\nreturn true;\n}\nfunction FUN6(address VAR18, uint256 VAR15) public returns (bool VAR17) {\nVAR8[msg.sender][VAR18] = VAR15;\nreturn true;\n}\nfunction FUN7(uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR7[msg.sender] >= VAR15);\nVAR7[msg.sender] -= VAR15;\nVAR6 -= VAR15;\nreturn true;\n}\nfunction FUN8(address VAR13, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR7[VAR13] >= VAR15);\nrequire(VAR15 <= VAR8[VAR13][msg.sender]);\nVAR7[VAR13] -= VAR15;\nVAR8[VAR13][msg.sender] -= VAR15;\nVAR6 -= VAR15;\nreturn true;\n}\nfunction FUN9(address VAR19, bool VAR20) FUN1 public {\nVAR9[VAR19] = VAR20;\n}\n}",
        "label": false,
        "name": "0x662b67d00a13faf93254714dd601f5ed49ef2f51.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"PIN\";\nVAR5 = \"PinToken\";\nVAR6 = 18;\nVAR7 = 1000000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x69b405d404fdacab21909cffafee7f02c106e9dd.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint;\nmapping(address => uint) public VAR2;\nfunction FUN1(address VAR3, uint VAR4, bytes memory VAR5) public {\nuint VAR6;\nassembly {\nVAR6 := extcodesize(VAR3)\n}\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nif(VAR6>0) {\nCON2 VAR7 = CON2(VAR3);\nVAR7.tokenFallback(msg.sender, VAR4, VAR5);\n}\n}\nfunction FUN1(address VAR3, uint VAR4) public {\nuint VAR6;\nbytes memory VAR8;\nassembly {\nVAR6 := extcodesize(VAR3)\n}\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nif(VAR6>0) {\nCON2 VAR7 = CON2(VAR3);\nVAR7.tokenFallback(msg.sender, VAR4, VAR8);\n}\n}\n}\ncontract CON4 {\naddress private VAR9;\nconstructor () internal {\nVAR9 = msg.sender;\n}\nmodifier FUN2() {\nrequire(isOwner());\n_;\n}\nfunction FUN3() public FUN2 {\nVAR9 = address(0);\n}\nfunction FUN4(address VAR10) public FUN2 {\nFUN5(VAR10);\n}\nfunction FUN5(address VAR10) internal {\nrequire(VAR10 != address(0));\nVAR9 = VAR10;\n}\n}\ncontract CON5 is CON3, CON4 {\nstring public VAR11;\nstring public VAR12;\nuint8 public VAR13;\nuint256 public VAR1;\naddress VAR14;\nmodifier FUN6 {\nrequire(msg.sender == VAR14);\n_;\n}\nconstructor (string memory VAR15,string memory VAR16,uint8 VAR17) public {\nVAR12 = VAR16;\nVAR11 = VAR15;\nVAR13 = VAR17;\nVAR1 = 1000000000 * (10 ** uint256(VAR13));\nVAR2[msg.sender] = VAR1;\n}\nfunction FUN7(address VAR18) public FUN2 {\nVAR14 = VAR18;\n}\nfunction FUN8(address VAR19,address VAR3,uint VAR4,bytes memory VAR5) public FUN6 {\nuint VAR6;\nassembly {\nVAR6 := extcodesize(VAR3)\n}\nVAR2[VAR19] = VAR2[VAR19].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nif(VAR6>0) {\nCON2 VAR7 = CON2(VAR3);\nVAR7.tokenFallback(VAR19, VAR4, VAR5);\n}\n}\nfunction FUN8(address VAR19,address VAR3,uint VAR4) public FUN6 {\nuint VAR6;\nbytes memory VAR8;\nassembly {\nVAR6 := extcodesize(VAR3)\n}\nVAR2[VAR19] = VAR2[VAR19].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nif(VAR6>0) {\nCON2 VAR7 = CON2(VAR3);\nVAR7.tokenFallback(VAR19, VAR4, VAR8);\n}\n}\n}",
        "label": false,
        "name": "0x86fe9e7a7f481ff9c341220df7110d3dd04e2020.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nusing SafeMath for uint;\nenum JobStatus { Open, inProgress, Completed, Cancelled }\nstruct Job {\nstring VAR1; address VAR2; uint VAR3; address VAR4; JobStatus VAR5; uint VAR6; uint VAR7; uint VAR8; uint VAR9; address VAR10; bool VAR11; uint VAR12; mapping(address => uint) VAR13; address[] VAR14; uint VAR15; }\nJob[] public VAR16;\nmapping(address => uint[]) public VAR17; mapping(address => uint[]) public VAR18;\nCON2 public VAR19;\nuint public VAR20 = 0;\naddress public VAR21;\nconstructor(address VAR22, address VAR23) public{\nVAR19 = CON2(VAR22);\nVAR21 = VAR23;\n}\nmodifier FUN1{\nrequire(msg.sender == VAR21);\n_;\n}\nfunction FUN2(string VAR24, uint VAR25, uint VAR26, address VAR27) public {\nrequire(VAR25 > 0);\nrequire(VAR26 > 0);\naddress[] memory VAR28;\nuint VAR29 = VAR25.sub(VAR25.mul(1).div(10));\nJob memory VAR30 = Job(VAR24, msg.sender, VAR29, 0x0, JobStatus.Open, VAR26, 0, 0, 0, VAR27, false, 0, VAR28, 0);\nVAR16.push(VAR30);\nVAR17[msg.sender].push(VAR20);\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR25);\nVAR20++;\nVAR19.transferFrom(msg.sender, address(this), VAR25);\n}\nfunction FUN3(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(msg.sender != VAR32.VAR2);\nrequire(msg.sender != VAR32.VAR10);\nrequire(VAR32.VAR5 == JobStatus.Open);\nVAR32.VAR4 = msg.sender;\nVAR32.VAR5 = JobStatus.inProgress;\nVAR18[msg.sender].push(VAR31);\n}\nfunction FUN4(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(msg.sender != VAR32.VAR2);\nrequire(msg.sender != VAR32.VAR4);\nVAR32.VAR10 = msg.sender;\n}\nfunction FUN5(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nif(msg.sender != VAR21){\nrequire(VAR32.VAR2 == msg.sender);\nrequire(VAR32.VAR4 == 0x0);\nrequire(VAR32.VAR5 == JobStatus.Open);\n}\nVAR32.VAR5 = JobStatus.Cancelled;\nuint VAR33 = VAR32.VAR3;\nVAR19.transfer(VAR32.VAR2, VAR33);\n}\nfunction FUN6(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(VAR32.VAR4 == msg.sender);\nrequire(VAR32.VAR7 > 0);\nuint VAR34 = VAR32.VAR8;\nrequire(VAR34 > 0);\nVAR32.VAR8 = 0;\nVAR32.VAR9 = VAR32.VAR9 + VAR34;\nVAR19.transfer(msg.sender, VAR34);\n}\nfunction FUN7(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nif(msg.sender != VAR21){\nrequire(VAR32.VAR2 == msg.sender);\nrequire(VAR32.VAR11 == true);\n}\nrequire(VAR32.VAR6 > VAR32.VAR7);\nuint VAR35 = VAR32.VAR3.div(VAR32.VAR6);\nVAR32.VAR8 = VAR32.VAR8 + VAR35;\nVAR32.VAR7++;\nif(VAR32.VAR6 == VAR32.VAR7){\nVAR32.VAR5 = JobStatus.Completed;\n}\n}\nfunction FUN8(uint VAR31, uint VAR36) public {\nrequire(VAR31 >= 0);\nrequire(VAR36 > 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(msg.sender == VAR32.VAR2);\naddress VAR10 = VAR32.VAR10;\nrequire(VAR19.allowance(VAR32.VAR2, address(this)) >= VAR36);\nVAR19.transferFrom(VAR32.VAR2, VAR10, VAR36);\n}\nfunction FUN9(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(msg.sender == VAR32.VAR10);\nVAR32.VAR11 = true;\n}\nfunction FUN10(uint VAR31) public {\nrequire(VAR31 >= 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(msg.sender == VAR32.VAR4);\nVAR32.VAR11 = false;\n}\nfunction FUN11(address VAR37, uint VAR38) public {\nrequire(VAR37 != 0x0);\nrequire(VAR38 > 0);\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR38);\nVAR19.transferFrom(msg.sender, VAR37, VAR38);\n}\nfunction FUN12(uint VAR31, uint VAR38) public {\nrequire(VAR31 >= 0);\nrequire(VAR38 > 0);\nJob storage VAR32 = VAR16[VAR31];\nrequire(VAR32.VAR5 == JobStatus.inProgress);\nif(VAR32.VAR13[msg.sender] == 0){\nVAR32.VAR14.push(msg.sender);\n}\nVAR32.VAR13[msg.sender] = VAR32.VAR13[msg.sender] + VAR38;\nVAR32.VAR12 = VAR32.VAR12 + VAR38;\nVAR32.VAR8 = VAR32.VAR8 + VAR38;\nVAR32.VAR15 = VAR32.VAR15 + 1;\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR38);\nVAR19.transferFrom(msg.sender, address(this), VAR38);\n}\nfunction FUN13(address VAR39, uint VAR38) public FUN1 {\nrequire(VAR39 != 0x0);\nrequire(VAR38 > 0);\nrequire(VAR19.balanceOf(address(this)) >= VAR38);\nVAR19.transfer(VAR39, VAR38);\n}\n}",
        "label": false,
        "name": "0xffb3407cce3eb419273656022b6bb493e265c5db.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\nbool public VAR2;\n}\ncontract CON2 {\nuint256 public VAR1;\nbool public VAR2;\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nmodifier FUN1(uint VAR4) {\nassert(msg.data.length == VAR4 * 32 + 4);\n_;\n}\nfunction FUN2(address VAR5, uint256 VAR6) public FUN1(2) returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nrequire(VAR2);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\nfunction FUN3(address VAR7) public constant returns (uint256 VAR8) {\nreturn VAR3[VAR7];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping(address => mapping(address => uint256)) internal VAR9;\nfunction FUN4(address VAR10, address VAR5, uint256 VAR6) public FUN1(3) returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR10]);\nrequire(VAR6 <= VAR9[VAR10][msg.sender]);\nrequire(VAR2);\nVAR3[VAR10] = VAR3[VAR10].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR9[VAR10][msg.sender] = VAR9[VAR10][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR11, uint256 VAR6) public returns (bool) {\nVAR9[msg.sender][VAR11] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR11) public FUN1(2) constant returns (uint256 VAR12) {\nreturn VAR9[VAR7][VAR11];\n}\nfunction FUN7(address VAR11, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR11] = VAR9[msg.sender][VAR11].add(VAR13);\nreturn true;\n}\nfunction FUN8(address VAR11, uint VAR15) public returns (bool VAR14) {\nuint VAR16 = VAR9[msg.sender][VAR11];\nif (VAR15 > VAR16) {\nVAR9[msg.sender][VAR11] = 0;\n} else {\nVAR9[msg.sender][VAR11] = VAR16.sub(VAR15);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR17 = \"OrphanToken\";\nstring public constant VAR18 = \"ORP\";\nuint8 public constant VAR19 =18;\nuint256 public constant VAR20 = 1 * 10**8 * (10**uint256(VAR19));\nuint256 public VAR21;\nuint256 public VAR22;\naddress public VAR23;\nbool public VAR24 = true;\nfunction CON5(address VAR7) public {\nVAR1 = VAR20;\nVAR23 = VAR7;\nVAR3[VAR23] = VAR20;\nVAR22 = 0;\nVAR2 = true;\n}\nfunction() payable public {\nFUN10(msg.sender);\n}\nfunction FUN10(address VAR25) public payable returns (uint256){\nrequire(VAR25 != address(0));\nrequire(VAR24 == true);\naddress VAR26 = VAR23;\nuint256 VAR27 = msg.value;\nuint256 VAR28 = FUN11(VAR27);\nif (VAR28 == 0) {revert();}\nVAR21 = VAR21.add(VAR27);\nVAR22 = VAR22.add(VAR28);\nFUN12(VAR25, VAR28, VAR23);\nVAR26.FUN2(VAR27);\nreturn VAR28;\n}\nfunction FUN11(uint256 VAR29) public returns (uint256) {\nuint256 VAR30 = getTotalAmountOfTokens(VAR29);\nif (VAR30 > VAR3[VAR23]) {\nreturn 0;\n}\nreturn VAR30;\n}\nfunction FUN12(address VAR5, uint256 VAR31, address VAR7) internal returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR31 <= VAR3[VAR7]);\nVAR3[VAR5] = VAR3[VAR5].add(VAR31);\nVAR3[VAR7] = VAR3[VAR7].sub(VAR31);\nreturn true;\n}\nmodifier FUN13() {\nrequire(msg.sender == VAR23);\n_;\n}\nfunction FUN14(address VAR32) FUN13 public returns (bool){\nrequire(VAR32 != address(0));\nVAR23 = VAR32;\nreturn true;\n}\nfunction FUN15() public FUN13 {\nVAR24 = true;\n}\nfunction FUN16() public FUN13 {\nVAR24 = false;\n}\nfunction FUN17(bool VAR33) FUN13 public {\nVAR2 = VAR33;\n}\nfunction FUN18() public FUN13 {\nVAR23.FUN2(address(this).VAR8);\nuint256 VAR8 = FUN3(this);\nFUN2(VAR23, VAR8);\n}\n}",
        "label": false,
        "name": "0x9bebde538d404581e43438574082b3bc444d6c30.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1 = \"IGW\";\nstring public VAR2 = \"IGW\";\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 1000000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc6c819cabf4fc0c83db37b8c8768a4b7a6bf1b8b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR2 = msg.sender;\nmapping(address=>bool) public VAR3;\nmodifier FUN2() {\nrequire(msg.sender == VAR2 || msg.sender == VAR1);\n_;\n}\nfunction FUN3(address VAR4) public FUN1 {\nVAR2 = VAR4;\n}\nfunction FUN4(address VAR5) public FUN2 {\nrequire(VAR5 != address(0x0));\nrequire(!isWhitelisted(VAR5));\nVAR3[VAR5] = true;\n}\nfunction FUN5(address VAR5) public FUN1 {\nVAR3[VAR5] = false;\n}\n}",
        "label": false,
        "name": "0xc95a128348057607b7b53b86fcc8a9a7f88a8e3a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"ZEROCoin\";\nstring public constant VAR2 = \"ZERO\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 1295000000 * 10 ** 18; address public VAR5; uint256 public VAR6 = 38000; uint256 public VAR7= 24000; uint256 VAR8;\nuint256 VAR9;\nuint256 VAR10;\nbool VAR11 = false;\nuint256 public VAR12;\nuint256 public VAR13;\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\nuint256 VAR17;\nuint256 VAR18;\nuint256 public VAR19; uint256 VAR20 = 777000000 * 10 **18; mapping(address => uint) VAR21;\nmapping(address => mapping(address => uint)) VAR22;\nenum Stages {\nNOTSTARTED,\nPREICO,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR23;\nmodifier FUN1(Stages VAR24) {\nif (VAR23 != VAR24)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction CON2() public\n{\nVAR5 = msg.sender;\nVAR21[VAR5] = 518000000 * 10 **18; VAR23 = Stages.NOTSTARTED;\n}\nfunction () public payable\n{\nrequire(VAR23 != Stages.ENDED);\nrequire(!VAR11 && msg.sender != VAR5);\nif( VAR23 == Stages.PREICO && now <= VAR18 )\n{\nrequire (VAR19 <= 1500 ether);\nVAR19 = (VAR19).add(msg.value);\nVAR8 =((msg.value).mul(VAR6));\nVAR9 = ((VAR8).mul(58)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(VAR23 == Stages.ICO && now <= VAR17 ){\nif( now < VAR14 )\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(15)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR14 && now < VAR15)\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(10)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR15 && now < VAR16)\n{\nVAR8 =(msg.value).mul(VAR7);\nVAR9 = ((VAR8).mul(5)).div(100); VAR10 = VAR8 + VAR9;\nFUN12(msg.sender,VAR10);\n}\nelse if(now >= VAR16 && now < VAR17)\n{\nVAR8 =(msg.value).mul(VAR7); VAR10 = VAR8;\nFUN12(msg.sender,VAR10);\n}\n}\nelse\n{\nrevert();\n}\n}\nfunction FUN4() public FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR23 = Stages.PREICO;\nVAR11 = false;\nVAR21[address(this)] = VAR20;\nVAR12 = now;\nVAR18 = now + 16 days;\n}\nfunction FUN5() public FUN2 FUN1(Stages.PREICO)\n{\nrequire(now > VAR18 || VAR19 >= 1500 ether);\nVAR23 = Stages.ICO;\nVAR11 = false;\nVAR13 = now;\nVAR14 = now + 15 days;\nVAR15 = VAR14 + 15 days;\nVAR16 = VAR15 + 15 days;\nVAR17 = VAR16 + 15 days;\n}\nfunction FUN6() external FUN2\n{\nVAR11 = true;\n}\nfunction FUN7() external FUN2\n{\nVAR11 = false;\n}\nfunction FUN8() external FUN2 FUN1(Stages.ICO)\n{\nrequire(now > VAR17);\nVAR23 = Stages.ENDED;\nVAR4 = (VAR4).sub(VAR21[address(this)]);\nVAR21[address(this)] = 0;\n}\nfunction FUN9( address VAR25, address VAR26, uint256 VAR27 )public returns (bool VAR28) {\nrequire( VAR26 != 0x0);\nrequire(VAR21[VAR25] >= VAR27 && VAR22[VAR25][msg.sender] >= VAR27 && VAR27 >= 0);\nVAR21[VAR25] = (VAR21[VAR25]).sub(VAR27);\nVAR22[VAR25][msg.sender] = (VAR22[VAR25][msg.sender]).sub(VAR27);\nVAR21[VAR26] = (VAR21[VAR26]).add(VAR27);\nreturn true;\n}\nfunction FUN10(address VAR29, uint256 VAR27)public returns (bool VAR28) {\nrequire( VAR29 != 0x0);\nVAR22[msg.sender][VAR29] = VAR27;\nreturn true;\n}\nfunction FUN11(address VAR26, uint256 VAR27)public returns (bool VAR28) {\nrequire( VAR26 != 0x0);\nrequire(VAR21[msg.sender] >= VAR27 && VAR27 >= 0);\nVAR21[msg.sender] = (VAR21[msg.sender]).sub(VAR27);\nVAR21[VAR26] = (VAR21[VAR26]).add(VAR27);\nreturn true;\n}\nfunction FUN12(address VAR26, uint256 VAR27) private returns(bool VAR28) {\nrequire( VAR26 != 0x0);\nrequire(VAR21[address(this)] >= VAR27 && VAR27 > 0);\nVAR21[address(this)] = (VAR21[address(this)]).sub(VAR27);\nVAR21[VAR26] = (VAR21[VAR26]).add(VAR27);\nreturn true;\n}\nfunction FUN13() external FUN2 {\nVAR5.FUN11(this.balance);\n}\n}",
        "label": false,
        "name": "0x967081d634f01003b2c5b3d8ea5aa2c55000722e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint public VAR1 = 1250000000000000000000000000;\nbool public VAR2 = true;\nstring public constant VAR3 = \"BLA\";\nstring public constant VAR4 = \"BLABBER Token\";\nuint8 public constant VAR5 = 18;\naddress public VAR6 = 0xB6ED8e4b27928009c407E298C475F937054AE19D;\nmapping(address => uint256) VAR7;\nmapping(address => mapping(address => uint256)) VAR8;\nmodifier FUN1{\nrequire(msg.sender == 0x36Aa9a6E0595adfF3C42A23415758a1123381C23);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR2 = false;\n}\nconstructor() public {\nVAR7[VAR6] = VAR1;\n}\nfunction FUN3() public constant returns (uint256 VAR9) {\nreturn VAR1;\n}\nfunction FUN4(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR7[VAR10];\n}\nfunction FUN5(address VAR12, uint256 VAR13) public returns (bool VAR14) {\nrequire(VAR7[msg.sender] >= VAR13&& VAR13 > 0);\nrequire(!VAR2 || (msg.sender == VAR6));\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR13);\nVAR7[VAR12] = VAR7[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN6(address VAR15, address VAR12, uint256 VAR13) public returns (bool VAR14) {\nrequire(VAR8[VAR15][msg.sender] >= VAR13&& VAR7[VAR15] >= VAR13&& VAR13 > 0);\nrequire(!VAR2 || (msg.sender == VAR6));\nVAR7[VAR15] = VAR7[VAR15].sub(VAR13);\nVAR7[VAR12] = VAR7[VAR12].add(VAR13);\nVAR8[VAR15][msg.sender] = VAR8[VAR15][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN7(address VAR16, uint256 VAR13) public returns (bool VAR14) {\nVAR8[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, uint VAR17) public returns (bool) {\nVAR8[msg.sender][VAR16] = VAR8[msg.sender][VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN9(address VAR16, uint VAR18) public returns (bool) {\nuint VAR19 = VAR8[msg.sender][VAR16];\nif (VAR18 > VAR19) {\nVAR8[msg.sender][VAR16] = 0;\n} else {\nVAR8[msg.sender][VAR16] = VAR19.sub(VAR18);\n}\nreturn true;\n}\nfunction FUN10(address VAR10, address VAR16) public constant returns (uint256 VAR20) {\nreturn VAR8[VAR10][VAR16];\n}\nfunction FUN11(uint256 VAR13) public {\nrequire(VAR13 <= VAR7[msg.sender]);\nrequire(msg.sender == VAR6);\naddress VAR21 = msg.sender;\nVAR7[VAR21] = VAR7[VAR21].sub(VAR13);\nVAR1 = VAR1.sub(VAR13);\n}\n}",
        "label": false,
        "name": "0xb43d9d56f00e58ffeb2991a8c93ea9dbb2ebdfd8.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint;\nstring public constant VAR1 = \"BlocVehicle\";\nstring public constant VAR2 = \"VCL\";\nuint256 public constant VAR3 = 18;\nuint256 VAR4 = 1000000000 * (10 ** VAR3);\nmapping(address => uint256) VAR5;\nmapping(address => mapping (address => uint256)) VAR6;\nmapping(address => bool) public VAR7;\naddress public VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR8);\n_;\n}\nfunction FUN2(address VAR9) FUN1 public {\nrequire(VAR9 != address(0));\nVAR8 = VAR9;\n}\nfunction FUN3(address VAR10, uint256 VAR11) FUN1 public {\nrequire(VAR10 != address(0));\nrequire(VAR11 > 0);\nrequire(VAR11 <= VAR5[VAR10]);\nVAR5[VAR10] = VAR5[VAR10].sub(VAR11);\nVAR4 = VAR4.sub(VAR11);\n}\nfunction FUN4(address VAR12, bool VAR13) FUN1 public {\nVAR7[VAR12] = VAR13;\n}\nfunction FUN5(address VAR14) public constant returns (bool) {\nreturn VAR7[VAR14];\n}\nconstructor() public {\nVAR8 = msg.sender;\nVAR5[VAR8] = VAR4;\n}\nfunction FUN6(address VAR15, address VAR16, uint256 VAR17) internal {\nrequire(VAR16 != address(0));\nrequire(VAR5[VAR15] >= VAR17);\nrequire(VAR5[VAR16].add(VAR17) >= VAR5[VAR16]);\nrequire(!VAR7[VAR15]);\nrequire(!VAR7[VAR16]);\nuint VAR18 = VAR5[VAR15].add(VAR5[VAR16]);\nVAR5[VAR15] = VAR5[VAR15].sub(VAR17);\nVAR5[VAR16] = VAR5[VAR16].add(VAR17);\nassert(VAR5[VAR15].add(VAR5[VAR16]) == VAR18);\n}\nfunction FUN7(address VAR16, uint256 VAR17) public returns (bool VAR19) {\nFUN6(msg.sender, VAR16, VAR17);\nreturn true;\n}\nfunction FUN8(address VAR15, address VAR16, uint256 VAR17) public returns (bool VAR19) {\nrequire(VAR17 <= VAR6[VAR15][msg.sender]);\nVAR6[VAR15][msg.sender] = VAR6[VAR15][msg.sender].sub(VAR17);\nFUN6(VAR15, VAR16, VAR17);\nreturn true;\n}\nfunction FUN9() public constant returns (uint256 VAR20) {\nVAR20 = VAR4;\n}\nfunction FUN10(address VAR21) public constant returns (uint256 VAR22) {\nreturn VAR5[VAR21];\n}\nfunction FUN11(address VAR23, uint VAR24) public returns (bool VAR19) {\nVAR6[msg.sender][VAR23] = VAR6[msg.sender][VAR23].add(VAR24);\nreturn true;\n}\nfunction FUN12(address VAR23, uint VAR25) public returns (bool VAR19) {\nuint VAR26 = VAR6[msg.sender][VAR23];\nif (VAR25 > VAR26) {\nVAR6[msg.sender][VAR23] = 0;\n} else {\nVAR6[msg.sender][VAR23] = VAR26.sub(VAR25);\n}\nreturn true;\n}\nfunction FUN13(address VAR23, uint256 VAR17) public returns (bool VAR19) {\nVAR6[msg.sender][VAR23] = VAR17;\nreturn true;\n}\nfunction FUN14(address VAR21, address VAR23) public constant returns (uint256 VAR27) {\nreturn VAR6[VAR21][VAR23];\n}\n}",
        "label": false,
        "name": "0xf6aeac4e30c12eb3a69de72d089c07eaa380b3a0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON2 {\naddress public VAR3;\naddress public VAR4;\naddress public VAR5;\naddress public VAR6;\nuint public VAR7;\nconstructor() public {\nVAR7 = 4;\n}\nfunction FUN3(address VAR8, uint VAR9) public FUN1 returns (bool VAR10) {\nreturn CON3(VAR8).transfer(VAR1, VAR9);\n}\nfunction FUN4(address VAR11) public FUN1 {\nrequire(VAR11 != address(0));\nVAR3 = VAR11;\n}\nfunction FUN5(address VAR11) public FUN1 {\nrequire(VAR11 != address(0));\nVAR4 = VAR11;\n}\nfunction FUN6(address VAR11) public FUN1 {\nrequire(VAR11 != address(0));\nVAR5 = VAR11;\n}\nfunction FUN7(address VAR11) public FUN1 {\nrequire(VAR11 != address(0));\nVAR6 = VAR11;\n}\n}",
        "label": false,
        "name": "0x26a572eeb6036ae1af510d561f59520f626857b9.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x8705f865c2cd79157cd26b3e23548c89bcc0e227.sol"
    },
    {
        "source": "# @dev Implementation of ERC-20 token standard.\r\n# @author Takayuki Jimba (@yudetamago)\r\n# https:\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nname: public(string[64])\r\nsymbol: public(string[32])\r\ndecimals: public(uint256)\r\n\r\n# NOTE: By declaring `balanceOf` as public, vyper automatically generates a 'balanceOf()' getter\r\n#       method to allow access to account balances.\r\n#       The _KeyType will become a required parameter for the getter and it will return _ValueType.\r\n#       See: https:balanceOf: public(map(address, uint256))\r\nburninatedBy: public(map(address, uint256))\r\ntop_burninators: address[10]\r\nallowances: map(address, map(address, uint256))\r\ntotal_supply: uint256\r\ntotal_burninated: uint256\r\nminter: address\r\n\r\n\r\n@public\r\ndef __init__(_name: string[64], _symbol: string[32], _decimals: uint256, _supply: uint256):\r\n    init_supply: uint256 = _supply * 10 ** _decimals\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.total_supply = init_supply\r\n    self.minter = msg.sender\r\n    log.Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n@public\r\n@constant\r\ndef topBurninators() -> address[10]:\r\n    return self.top_burninators\r\n\r\n@public\r\n@constant\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @dev Total number of tokens in existence.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    @param _owner The address which owns the funds.\r\n    @param _spender The address which will spend the funds.\r\n    @return An uint256 specifying the amount of tokens still available for the spender.\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @dev Transfer tokens from one address to another.\r\n          Note that while this function emits a Transfer event, this is not required as per the specification,\r\n          and other compliant implementations may not emit the event.\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    # NOTE: vyper does not allow underflows\r\n    #      so the following subtraction would revert on insufficient allowance\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n         Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n         and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n         race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n         https:    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    \"\"\"\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@public\r\ndef mint(_to: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Mint an amount of the token and assigns it to an account. \r\n         This encapsulates the modification of balances such that the\r\n         proper events are emitted.\r\n    @param _to The account that will receive the created tokens.\r\n    @param _value The amount that will be created.\r\n    \"\"\"\r\n    assert msg.sender == self.minter\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply += _value\r\n    self.balanceOf[_to] += _value\r\n    log.Transfer(ZERO_ADDRESS, _to, _value)\r\n\r\n@private\r\ndef _burn(_to: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Internal function that burns an amount of the token of a given\r\n         account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply -= _value\r\n    self.balanceOf[_to] -= _value\r\n    self.burninatedBy[_to] += _value\r\n    log.Transfer(_to, ZERO_ADDRESS, _value)\r\n\r\n@public\r\ndef burn(_value: uint256):\r\n    \"\"\"\r\n    @dev Burn an amount of the token of msg.sender.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    self._burn(msg.sender, _value)\r\n\r\n@public\r\ndef burnFrom(_to: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Burn an amount of the token from a given account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    self.allowances[_to][msg.sender] -= _value\r\n    self._burn(_to, _value)\r\n\r\n@public\r\ndef claimVictory() -> bool:\r\n    weakest_burninator: int128  \r\n    for i in range(10):\r\n        if msg.sender == self.top_burninators[i]:\r\n            return True\r\n        if self.burninatedBy[self.top_burninators[weakest_burninator]] > self.burninatedBy[self.top_burninators[i]]:\r\n            weakest_burninator = i\r\n    assert self.burninatedBy[self.top_burninators[weakest_burninator]] < self.burninatedBy[msg.sender]\r\n    self.top_burninators[weakest_burninator] = msg.sender\r\n    return True",
        "label": false,
        "name": "0x2eb1e8fd394222df25638cfa8f0e5e7998a9dc1f.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor () internal {\nFUN8(msg.sender);\n}\nmodifier FUN5() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN6(address VAR4) public FUN5 {\nFUN8(VAR4);\n}\nfunction FUN7() public {\nFUN9(msg.sender);\n}\nfunction FUN8(address VAR4) internal {\nVAR3.add(VAR4);\n}\nfunction FUN9(address VAR4) internal {\nVAR3.remove(VAR4);\n}\n}\ncontract CON3 is CON2 {\nbool private VAR5;\nconstructor () internal {\nVAR5 = false;\n}\nmodifier FUN10() {\nrequire(!VAR5);\n_;\n}\nmodifier FUN11() {\nrequire(VAR5);\n_;\n}\nfunction FUN12() public FUN5 FUN10 {\nVAR5 = true;\n}\nfunction FUN13() public FUN5 FUN11 {\nVAR5 = false;\n}\n}\ncontract CON4 {\nuint256 public VAR6;\n}\ncontract CON5 is CON4 {\nstring public VAR7;\nstring public VAR8;\nuint8 public VAR9;\nconstructor (string memory VAR10, string memory VAR11, uint8 VAR12) public {\nVAR7 = VAR10;\nVAR8 = VAR11;\nVAR9 = VAR12;\n}\n}\ncontract CON6 is CON3, CON5, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) internal VAR14;\naddress public VAR15;\nconstructor(string memory VAR10, string memory VAR11, uint8 VAR12)\nCON5(VAR10, VAR11, VAR12)\nCON1()\npublic {\nVAR6 = 100 * (10**9) * 10**uint256(VAR9); }\nfunction FUN14(address VAR16) FUN1 public {\nVAR15 = VAR16;\n}\nfunction FUN15(address VAR17,uint256 VAR18) public returns (bool) {\nrequire(msg.sender == VAR15);\nVAR13[VAR17] = VAR13[VAR17].add(VAR18);\nreturn true;\n}\nfunction FUN16(address VAR19, uint256 VAR20) FUN10 public returns (bool) {\nrequire(VAR19 != address(0));\nrequire(VAR20 <= VAR13[msg.sender]);\nVAR13[msg.sender] = VAR13[msg.sender].sub(VAR20);\nVAR13[VAR19] = VAR13[VAR19].add(VAR20);\nreturn true;\n}\nfunction FUN17(address VAR21, address VAR19, uint256 VAR20) public FUN10 returns (bool) {\nrequire(VAR19 != address(0));\nrequire(VAR20 <= VAR13[VAR21]);\nrequire(VAR20 <= VAR14[VAR21][msg.sender]);\nVAR13[VAR21] = VAR13[VAR21].sub(VAR20);\nVAR13[VAR19] = VAR13[VAR19].add(VAR20);\nVAR14[VAR21][msg.sender] = VAR14[VAR21][msg.sender].sub(VAR20);\nreturn true;\n}\nfunction FUN18(address VAR22, uint256 VAR20) public FUN10 returns (bool) {\nVAR14[msg.sender][VAR22] = VAR20;\nreturn true;\n}\nfunction FUN19(address VAR22, uint VAR23) public FUN10 returns (bool) {\nVAR14[msg.sender][VAR22] = VAR14[msg.sender][VAR22].add(VAR23);\nreturn true;\n}\nfunction FUN20(address VAR22, uint VAR24) public FUN10 returns (bool) {\nuint VAR25 = VAR14[msg.sender][VAR22];\nif (VAR24 > VAR25) {\nVAR14[msg.sender][VAR22] = 0;\n} else {\nVAR14[msg.sender][VAR22] = VAR25.sub(VAR24);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0xcd58de6bb672c91aad944618f801ebb5c4c83136.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON3 {\nbool private VAR12;\nconstructor () internal {\nVAR12 = false;\n}\nmodifier FUN15() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN16() {\nrequire(VAR12);\n_;\n}\nfunction FUN17() public FUN10 FUN15 {\nVAR12 = true;\n}\nfunction FUN18() public FUN10 FUN16 {\nVAR12 = false;\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN15 returns (bool VAR13) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN15 returns (bool VAR13) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON6 is CON1 {\nstring private VAR14;\nstring private VAR15;\nuint8 private VAR16;\nconstructor (string memory VAR17, string memory VAR18, uint8 VAR19) public {\nVAR14 = VAR17;\nVAR15 = VAR18;\nVAR16 = VAR19;\n}\n}\ncontract CON7 is CON5, CON6 {\nconstructor (string memory VAR17, string memory VAR18, uint8 VAR19, uint256 VAR20)\npublic\nCON6 (VAR17, VAR18, VAR19) {\nFUN7(msg.sender, VAR20);\n}\n}",
        "label": false,
        "name": "0xfdd369d28168d4ea5eb83f098542a140002feaaa.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"JOKER\";\nVAR5 = \"Example JOKER Supply Token\";\nVAR6 = 18;\nVAR7 = 1000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x6b0f793067552dc9b59ddb98cdd440f85faff397.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint;\nenum AuditStatus { New, InProgress, InReview, Completed }\nstruct Auditor {\nbool VAR3;\naddress VAR4;\nuint VAR5;\nuint VAR6;\nuint[] VAR7; mapping(uint => bool) VAR8; mapping(uint => bool) VAR9; }\nstruct Audit {\nAuditStatus VAR10;\naddress VAR1;\nuint VAR11;\nuint VAR12; uint VAR13; uint VAR14; uint VAR15; uint VAR16; address[] VAR17; }\nuint public VAR18 = 90 days; uint public VAR19 = 365 days; Audit[] public VAR20;\nmapping(address => Auditor) public VAR21;\nfunction FUN5(address VAR22, uint VAR23) external FUN1 {\nrequire(address(this).balance > VAR23);\nVAR22.FUN5(VAR23);\n}\nfunction FUN6(uint VAR24) external FUN1 {\nVAR18 = VAR24 * 1 days;\n}\nfunction FUN7(uint VAR24) external FUN1 {\nVAR19 = VAR24 * 1 days;\n}\nfunction FUN8(address VAR25) external FUN1 {\nrequire(VAR21[VAR25].VAR4 == address(0));\nVAR21[VAR25].VAR3 = false;\nVAR21[VAR25].VAR4 = VAR25;\nVAR21[VAR25].VAR6 = 0;\nVAR21[VAR25].VAR5 = 0;\n}\nfunction FUN9(address VAR25) external FUN1 {\nrequire(VAR21[VAR25].VAR4 != address(0));\nVAR21[VAR25].VAR3 = true;\n}\nfunction FUN10(address VAR25) external FUN1 {\nrequire(VAR21[VAR25].VAR4 != address(0));\nVAR21[VAR25].VAR3 = false;\n}\nfunction FUN11(uint VAR26, uint VAR27, uint VAR28) external payable FUN1 {\nuint VAR15 = VAR27 * 1 days;\nrequire(VAR15 < VAR19);\nrequire(block.timestamp + VAR15 * 1 days > block.timestamp);\nrequire(msg.value > 0 && VAR28 > 0 && VAR26 > 0);\nAudit memory VAR29;\nVAR29.VAR10 = AuditStatus.New;\nVAR29.VAR1 = msg.sender;\nVAR29.VAR11 = VAR20.length;\nVAR29.VAR12 = msg.value;\nVAR29.VAR13 = VAR29.VAR12;\nVAR29.VAR14 = VAR26;\nVAR29.VAR15 = block.timestamp + VAR15;\nVAR29.VAR16 = VAR28;\nVAR20.push(VAR29);\n}\nfunction FUN12(uint VAR30) external FUN1 {\nrequire(VAR20[VAR30].VAR10 == AuditStatus.InProgress);\nrequire(block.timestamp >= VAR20[VAR30].VAR15);\nVAR20[VAR30].VAR15 = block.timestamp; VAR20[VAR30].VAR10 = AuditStatus.InReview;\n}\nfunction FUN13(uint VAR30, address VAR25, uint VAR31) external FUN1 {\nVAR20[VAR30].VAR13.sub(VAR31);\nVAR20[VAR30].VAR10 = AuditStatus.Completed;\nVAR21[VAR25].VAR5.add(VAR31);\nVAR21[VAR25].VAR6.add(1);\nVAR21[VAR25].VAR9[VAR30] = true; VAR25.FUN5(VAR31);\n}\nfunction FUN14(uint VAR30, address VAR25) external FUN1 {\nrequire(VAR21[VAR25].VAR4 != address(0));\nrequire(VAR21[VAR25].VAR8[VAR30]); VAR21[VAR25].VAR9[VAR30] = false;\n}\nfunction VAR14(uint VAR30) public payable {\nrequire(msg.value == VAR20[VAR30].VAR14);\nrequire(block.timestamp < VAR20[VAR30].VAR15);\nrequire(VAR20[VAR30].VAR17.length < VAR20[VAR30].VAR16);\nrequire(VAR20[VAR30].VAR10 == AuditStatus.New || VAR20[VAR30].VAR10 == AuditStatus.InProgress);\nrequire(VAR21[msg.sender].VAR4 == msg.sender && !VAR21[msg.sender].VAR3); require(!VAR21[msg.sender].VAR8[VAR30]);\nVAR20[VAR30].VAR10 = AuditStatus.InProgress;\nVAR20[VAR30].VAR17.push(msg.sender);\nVAR21[msg.sender].VAR8[VAR30] = true;\nVAR21[msg.sender].VAR7.push(VAR30);\n}\nfunction FUN15(uint VAR30) public {\nrequire(VAR20[VAR30].VAR10 == AuditStatus.Completed);\nrequire(VAR21[msg.sender].VAR9[VAR30]);\nrequire(block.timestamp >= VAR20[VAR30].VAR15 + VAR18);\nVAR21[msg.sender].VAR9[VAR30] = false; address(msg.sender).FUN5(VAR20[VAR30].VAR14);\n}\n}",
        "label": false,
        "name": "0x1cf33ead073351b3fc63c1f4f35dc10791fe6c7c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\naddress public VAR3 = 0x17e2c574cF092950eF89FB4939C97DB2086e796f;\nCON2 VAR4 = CON2(VAR3);\naddress VAR5;\nstruct Flight {\nuint256 VAR6;\nuint256 VAR7;\nuint256 VAR8;\nuint256 VAR9;\naddress VAR10;\naddress VAR11;\naddress VAR12;\naddress VAR13;\naddress VAR14;\naddress VAR15;\naddress VAR16;\naddress VAR17;\naddress VAR18;\naddress VAR19;\n}\nmapping(uint256 => Flight) public VAR20;\nstruct FlightFee {\nuint VAR21;\nuint256 VAR22;\n}\nmapping(address => FlightFee) public VAR23;\nconstructor () public {\nVAR5 = address(this);\n}\nfunction FUN3(uint256 VAR24,uint256 VAR25,uint256 VAR26,address VAR27,address VAR28,address VAR29,address VAR30,address VAR31,address VAR32,address VAR33,address VAR34,address VAR35,address VAR36) public FUN1\n{\nrequire(VAR24 != 0);\nrequire(VAR26 != 0);\nrequire(VAR27 != address(0));\nrequire(VAR28 != address(0));\nrequire(VAR29 != address(0));\nrequire(VAR30 != address(0));\nrequire(VAR31 != address(0));\nrequire(VAR32 != address(0));\nrequire(VAR33 != address(0));\nrequire(VAR34 != address(0));\nrequire(VAR35 != address(0));\nrequire(VAR36 != address(0));\nVAR20[VAR24].VAR6 = VAR25;\nVAR20[VAR24].VAR8 = VAR26;\nVAR20[VAR24].VAR10 = VAR27;\nVAR20[VAR24].VAR11 = VAR28;\nVAR20[VAR24].VAR12 = VAR29;\nVAR20[VAR24].VAR13 = VAR30;\nVAR20[VAR24].VAR14 = VAR31;\nVAR20[VAR24].VAR15 = VAR32;\nVAR20[VAR24].VAR16 = VAR33;\nVAR20[VAR24].VAR17 = VAR34;\nVAR20[VAR24].VAR18 = VAR35;\nVAR20[VAR24].VAR19 = VAR36;\n}\nfunction FUN4(uint256 VAR24,uint256 VAR37,uint256 VAR38,uint256 VAR39,uint256 VAR40,uint256 VAR41,uint256 VAR42,uint256 VAR43,uint256 VAR44,uint256 VAR45,uint256 VAR46) public FUN1\n{\nVAR23[VAR20[VAR24].VAR10].VAR22 = VAR37;\nVAR23[VAR20[VAR24].VAR11].VAR22 = VAR38;\nVAR23[VAR20[VAR24].VAR12].VAR22 = VAR39;\nVAR23[VAR20[VAR24].VAR13].VAR22 = VAR40;\nVAR23[VAR20[VAR24].VAR14].VAR22 = VAR41;\nVAR23[VAR20[VAR24].VAR15].VAR22 = VAR42;\nVAR23[VAR20[VAR24].VAR16].VAR22 = VAR43;\nVAR23[VAR20[VAR24].VAR17].VAR22 = VAR44;\nVAR23[VAR20[VAR24].VAR18].VAR22 = VAR45;\nVAR23[VAR20[VAR24].VAR19].VAR22 = VAR46;\n}\nfunction FUN5(uint256 VAR24, uint256 VAR47, uint256 VAR48, uint256 VAR49) public FUN1 {\nrequire(VAR24 != 0);\nVAR20[VAR24].VAR7 = VAR47;\nVAR20[VAR24].VAR9 = VAR48;\nVAR4.transfer(VAR20[VAR24].VAR10, VAR23[VAR20[VAR24].VAR10].VAR22 * VAR49);\nVAR4.transfer(VAR20[VAR24].VAR11, VAR23[VAR20[VAR24].VAR11].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR12, VAR23[VAR20[VAR24].VAR12].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR13, VAR23[VAR20[VAR24].VAR13].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR14, VAR23[VAR20[VAR24].VAR14].VAR22 * VAR49);\nVAR4.transfer(VAR20[VAR24].VAR15, VAR23[VAR20[VAR24].VAR15].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR16, VAR23[VAR20[VAR24].VAR16].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR17, VAR23[VAR20[VAR24].VAR17].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR18, VAR23[VAR20[VAR24].VAR18].VAR22);\nVAR4.transfer(VAR20[VAR24].VAR19, VAR23[VAR20[VAR24].VAR19].VAR22);\n}\nfunction FUN6() public FUN1 {\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0xed29fc02944f509eadb3d5649919930fcf319038.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() public {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) public FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5\n{\nstring public VAR17 = \"DAC\";\nstring public VAR18 = \"DAC\";\nuint public VAR19 = 6;\nuint private constant VAR20 = 10e9 * 1e6;\nfunction CON6() public\n{\nVAR15 = msg.sender;\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\n}",
        "label": false,
        "name": "0xbbdeb234400e04ac508772b8d3f0e22798c0008d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 internal VAR4;\naddress VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping(address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR10) {\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN3(address VAR11, uint VAR9) public returns (bool VAR10) {\nVAR7[msg.sender][VAR11] = VAR9;\nreturn true;\n}\nfunction FUN4(address VAR12, address VAR8, uint VAR9) public returns (bool VAR10) {\nVAR6[VAR12] = VAR6[VAR12].sub(VAR9);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR14) internal {\nrequire(VAR13 != address(0), \"ERC20: mint VAR8 the zero address\");\nVAR4 = VAR4.add(VAR14);\nVAR6[VAR13] = VAR6[VAR13].add(VAR14);\n}\nfunction FUN6(address VAR13, uint256 VAR14) internal {\nrequire(VAR13 != address(0), \"ERC20: burn VAR12 the zero address\");\nVAR4 = VAR4.sub(VAR14);\nVAR6[VAR13] = VAR6[VAR13].sub(VAR14);\n}\nfunction FUN7(address VAR15, uint256 VAR9) public FUN1 returns (bool VAR10) {\nreturn CON1(VAR15).FUN2(VAR5, VAR9);\n}\nfunction FUN8(address VAR15, uint256 VAR9) public FUN1 returns (bool VAR10) {\nreturn this.FUN4(VAR5,VAR15, VAR9);\n}\n}\ncontract CON3 is CON2{\nusing SafeMath for uint256;\nCON4 VAR16;\nstring public constant VAR1 = \"Gtech\";\nstring public constant VAR2 = \"GenTech\";\nuint8 public constant VAR3 = 18;\nuint256 internal VAR17;\naddress VAR5;\nconstructor(address VAR18) public {\nVAR16 = CON4(VAR18);\nVAR17 = 300000000 * 10**uint(VAR3); VAR5 = msg.sender;\nFUN5(VAR5,VAR17);\n}\nfunction FUN9() public payable {}\nfunction FUN10() public payable {\nuint256 VAR19 = msg.VAR14.mul(VAR16.VAR24());\nuint256 VAR20= VAR19.div(1 ether);\nFUN5(msg.sender,VAR20* 10**uint(VAR3));\n}\nfunction FUN11(uint256 VAR21) public returns (uint256 VAR22){\nrequire(VAR21 <= balanceOf(msg.sender));\nVAR22 = (VAR21.mul(1 ether)).div(VAR16.VAR24());\nif(balanceOf(msg.sender) <= VAR22) {\nVAR22 = VAR22.mul(balanceOf(msg.sender));\nVAR22 = VAR22.mul(VAR16.VAR24());\nVAR22 = VAR22.div(1 ether);\nVAR22 = VAR22.mul(totalSupply());\n}\nFUN6(msg.sender,VAR21);\nmsg.sender.FUN2(VAR22);\n}\n}\ninterface CON4 {\n}\ncontract CON5 is CON4 {\nuint256 public VAR23;\naddress VAR5;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor() public {\nVAR5 = msg.sender;\n}\nfunction FUN12(uint256 VAR24) public FUN1 {\nVAR23 = VAR24;\n}\n}",
        "label": false,
        "name": "0xf58ade053207657c1e014f896be86eef306ab430.sol"
    },
    {
        "source": "contract CON1{\nfunction FUN1(address VAR1) {}\nfunction FUN2(uint VAR2) {}\nfunction FUN3() {}\n}\ncontract CON2{\naddress VAR1;\nCON1 VAR3;\nconstructor() public\n{\nVAR1 = msg.sender;\n}\nfunction FUN4(address VAR4) public\n{\nrequire(VAR1==msg.sender);\nVAR3 = CON1(VAR4);\n}\nfunction FUN5() payable public\n{\nrequire(VAR1==msg.sender);\nVAR3.FUN1(address(this));\nVAR3.FUN3();\n}\nfunction FUN6(uint VAR2) public\n{\nrequire(VAR1==msg.sender);\nVAR3.FUN2(VAR2);\nmsg.sender.transfer(VAR2 * (1 ether));\n}\nfunction () payable public\n{}\n}",
        "label": false,
        "name": "0x0531c928d539cbee3aa3bb3dae37ad507c750efc.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire (msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 8;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9, string VAR10, string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5);\nVAR7[msg.sender] = VAR6; VAR3 = VAR10;\nVAR4 = VAR11;\n}\nfunction FUN3(address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR7[VAR12];\n}\nfunction FUN4(address VAR14, address VAR15, uint256 VAR16) internal {\nrequire(VAR15 != 0x0);\nrequire(VAR7[VAR14] >= VAR16);\nrequire(VAR7[VAR15] + VAR16 > VAR7[VAR15]);\nuint VAR17 = VAR7[VAR14] + VAR7[VAR15];\nVAR7[VAR14] -= VAR16;\nVAR7[VAR15] += VAR16;\nassert(VAR7[VAR14] + VAR7[VAR15] == VAR17);\n}\nfunction FUN5(address VAR15, uint256 VAR16) public {\nFUN4(msg.sender, VAR15, VAR16);\n}\nfunction FUN6(address VAR14, address VAR15, uint256 VAR16) public returns (bool VAR18) {\nrequire(VAR16 <= VAR8[VAR14][msg.sender]); VAR8[VAR14][msg.sender] -= VAR16;\nFUN4(VAR14, VAR15, VAR16);\nreturn true;\n}\nfunction FUN7(address VAR19, uint256 VAR16) public returns (bool VAR18) {\nVAR8[msg.sender][VAR19] = VAR16;\nreturn true;\n}\nfunction FUN8(address VAR19, uint256 VAR16, bytes VAR20) public returns (bool VAR18) {\nCON1 VAR21 = CON1(VAR19);\nif (FUN7(VAR19, VAR16)) {\nVAR21.receiveApproval(msg.sender, VAR16, this, VAR20);\nreturn true;\n}\n}\nfunction FUN9(uint256 VAR16) public returns (bool VAR18) {\nrequire(VAR7[msg.sender] >= VAR16); VAR7[msg.sender] -= VAR16;\nVAR6 -= VAR16;\nreturn true;\n}\nfunction FUN10(address VAR14, uint256 VAR16) public returns (bool VAR18) {\nrequire(VAR7[VAR14] >= VAR16);\nrequire(VAR16 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] -= VAR16;\nVAR8[VAR14][msg.sender] -= VAR16;\nVAR6 -= VAR16;\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string VAR10,string VAR11) CON3 (VAR9, VAR10, VAR11) public {}\nfunction FUN4(address VAR14, address VAR15, uint VAR16) internal {\nrequire (VAR15 != 0x0);\nrequire (VAR7[VAR14] > VAR16);\nrequire (VAR7[VAR15] + VAR16 > VAR7[VAR15]);\nrequire(!VAR22[VAR14]);\nrequire(!VAR22[VAR15]);\nVAR7[VAR14] -= VAR16;\nVAR7[VAR15] += VAR16;\n}\nfunction FUN11(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN12(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\n}",
        "label": false,
        "name": "0x00cab00609e70f14e755524bd07e1c639665e796.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 8;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x50583310f056d2da6b910726c927ea1b7a872b15.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\n}\ncontract CON6 is CON1, CON5 {\n}\ncontract CON7 is CON4, CON6 {\nstring public constant VAR11 = \"Mozo Token\";\nstring public constant VAR12 = \"MOZO\";\nuint8 public constant VAR13 = 2;\naddress public VAR14;\nmodifier FUN6() {\nrequire(msg.sender == VAR14);\n_;\n}\nfunction CON7(uint256 VAR15) public {\nVAR14 = msg.sender;\nVAR2 = VAR15;\nVAR1[msg.sender] = VAR2;\n}\n}",
        "label": false,
        "name": "0x44bf22949f9cc84b61b9328a9d885d1b5c806b41.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nusing SafeMath for uint256;\nuint256 constant internal VAR1 = 31561600;\nmodifier FUN1 {\nrequire(msg.sender == VAR10, \"not owner\");\n_;\n}\nmodifier FUN2(address VAR2) {\nrequire(VAR2 != address(0) && VAR2 != address(this) && VAR2 != address(VAR8), \"not valid _recipient\");\n_;\n}\nstruct Grant {\nuint256 VAR3;\nuint256 VAR4;\nuint256 VAR5;\nuint256 VAR6;\nuint256 VAR7;\n}\nCON2 public VAR8;\nmapping (address => Grant) public VAR9;\naddress public VAR10;\nconstructor(CON2 VAR11) public {\nrequire(address(VAR11) != address(0));\nVAR10 = msg.sender;\nVAR8 = VAR11;\n}\nfunction FUN3(address VAR2,uint256 VAR12,uint256 VAR13,uint256 VAR14)\nFUN1\nFUN2(VAR2)\nexternal\n{\nrequire(!grantExist(VAR2), \"grant already exist\");\nrequire(VAR14 <= 25, \"more than 25 years\");\nuint256 VAR15 = VAR13.div(VAR14);\nrequire(VAR15 > 0, \"amountVestedPerYear > 0\");\nrequire(VAR8.transferFrom(msg.sender, address(this), VAR13), \"transfer failed\");\nGrant memory VAR16 = Grant({VAR3: VAR12 == 0 ? currentTime() : VAR12,VAR4: VAR13,VAR5: VAR14,VAR6: 0,VAR7: 0});\nVAR9[VAR2] = VAR16;\n}\nfunction FUN4(address VAR2) external {\nuint256 VAR17;\nuint256 VAR18;\n(VAR17, VAR18) = calculateGrantClaim(VAR2);\nrequire(VAR18 > 0, \"amountVested is 0\");\nGrant storage VAR19 = VAR9[VAR2];\nVAR19.VAR6 = VAR17;\nVAR19.VAR7 = VAR19.VAR7.add(VAR18);\nrequire(VAR8.transfer(VAR2, VAR18), \"no tokens\");\n}\nfunction FUN5(address VAR20)\nexternal\nFUN1\nFUN2(VAR20)\n{\nVAR10 = VAR20;\n}\n}",
        "label": false,
        "name": "0xd698dc82f4cd43097009e5ddc4e0adc1e43875a3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON1 {\nbool public VAR4 = false;\nmodifier FUN3() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4);\n_;\n}\nfunction VAR4() FUN1 FUN3 public {\nVAR4 = true;\n}\nfunction FUN5() FUN1 FUN4 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) VAR6;\nfunction FUN6(address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR7 != address(0));\nuint256 VAR10 = VAR6[VAR9][msg.sender];\nVAR5[VAR9] = VAR5[VAR9].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nVAR6[VAR9][msg.sender] = VAR10.sub(VAR8);\nreturn true;\n}\nfunction FUN8(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\nfunction FUN9(address VAR13, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN10(address VAR11, address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR6[VAR11][VAR13];\n}\nfunction FUN11(uint256 VAR8) FUN1 public returns (bool VAR15) {\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].add(VAR8);\nVAR3 = VAR3.add(VAR8);\nreturn true;\n}\nfunction FUN12(uint256 VAR8) public returns (bool VAR15) {\nrequire(VAR8 > 0);\nrequire(VAR5[msg.sender] >= VAR8);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR16 = \"KLAB Coin\";\nstring public VAR17 = \"KLAB\";\nuint public VAR18 = 18;\nuint public constant VAR19 = 1000000e18;\naddress public constant VAR20 = 0x6a0Dc4629C0a6A655e8E4DC80b017145b1774622;\nfunction CON5() public {\nVAR5[msg.sender] = VAR19;\nVAR3 = VAR19;\nFUN6(VAR20, VAR19);\n}\nfunction() payable public { }\nfunction FUN14() public {\nif (address(this).VAR12 > 0)\nVAR1.send(address(this).VAR12);\n}\nfunction FUN15() public {\nif(FUN8(this) > 0)\nthis.FUN6(VAR20, FUN8(this));\n}\nfunction FUN16() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0x6889799d2a2c709d226202ed76fd41858f2d05e6.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) FUN3 public {\nrequire(VAR8 != address(0));\nVAR7 = VAR8;\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nuint256 VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) public returns (bool) {\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\nfunction FUN8 (address VAR12, uint VAR14)\nreturns (bool VAR15) {\nVAR9[msg.sender][VAR12] = VAR9[msg.sender][VAR12].add(VAR14);\nreturn true;\n}\nfunction FUN9 (address VAR12, uint VAR16) public\nreturns (bool VAR15) {\nuint VAR17 = VAR9[msg.sender][VAR12];\nif (VAR16 > VAR17) {\nVAR9[msg.sender][VAR12] = 0;\n} else {\nVAR9[msg.sender][VAR12] = VAR17.sub(VAR16);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nfunction FUN10(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR2[msg.sender]);\naddress VAR18 = msg.sender;\nVAR2[VAR18] = VAR2[VAR18].sub(VAR4);\nVAR1 = VAR1.sub(VAR4);\n}\n}\ncontract CON7 is CON5, CON4 {\nbool public VAR19 = false;\nmodifier FUN11() {\nrequire(!VAR19);\n_;\n}\nfunction FUN12(address VAR3, uint256 VAR20) FUN3 FUN11 public returns (bool) {\nVAR1 = VAR1.add(VAR20);\nVAR2[VAR3] = VAR2[VAR3].add(VAR20);\nreturn true;\n}\nfunction FUN13() FUN3 public returns (bool) {\nVAR19 = true;\nreturn true;\n}\n}\ncontract CON8 is CON7, CON6 {\nstring public VAR21 = \"www.tigereum.io\";\nstring public VAR22 = \"Tigereum\";\nstring public VAR23 = \"TIG\";\nuint8 public VAR24 = 18;\n}",
        "label": false,
        "name": "0xeee2d00eb7deb8dd6924187f5aa3496b7d06e62a.sol"
    },
    {
        "source": "contract CON1 {\nmapping (uint32 => bytes32) private VAR1;\nfunction FUN1 (uint32 VAR2, bytes32 VAR3) {\nif (msg.sender == 0x46b396728e61741D3AbD6Aa5bfC42610997c32C3) {\nVAR1 [VAR2] = VAR3;\n}\n}\nfunction FUN2 (uint32 VAR2) constant returns (bytes32) {\nreturn VAR1 [VAR2];\n}\n}",
        "label": false,
        "name": "0x361adf7ac4dff1ef44a240050136ba3d2805ef1c.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor() internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\naddress private VAR6;\nconstructor(address VAR7, address VAR8) public {\nrequire(VAR7 != address(0),\"Owner should not be the zero address\");\nrequire(VAR8 != address(0),\"Implementor should not be the zero address\");\nFUN3(VAR7);\nVAR6 = VAR8;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nFUN14\n{\nVAR3[VAR7] = VAR9;\n}\nfunction FUN6(address VAR7, uint256 VAR10)\npublic\nFUN14\n{\nVAR3[VAR7] = VAR3[VAR7].add(VAR10);\n}\nfunction FUN7(address VAR7, uint256 VAR11)\npublic\nFUN14\n{\nVAR3[VAR7] = VAR3[VAR7].sub(VAR11);\n}\nfunction FUN8(address VAR7,address VAR12,uint256 VAR9)\npublic\nFUN14\n{\nVAR4[VAR7][VAR12] = VAR9;\n}\nfunction FUN9(address VAR7,address VAR12,uint256 VAR10)\npublic\nFUN14\n{\nVAR4[VAR7][VAR12] = VAR4[VAR7][VAR12].add(VAR10);\n}\nfunction FUN10(address VAR7,address VAR12,uint256 VAR11)\npublic\nFUN14\n{\nVAR4[VAR7][VAR12] = VAR4[VAR7][VAR12].sub(VAR11);\n}\nfunction FUN11(uint256 VAR9)\npublic\nFUN14\n{\nVAR5 = VAR9;\n}\nfunction FUN12(address VAR13)\npublic\nFUN15(VAR13)\nFUN13\n{\nrequire(VAR13 != VAR6,\"Cannot transfer to same VAR8 as existing\");\naddress VAR14 = VAR6;\nVAR6 = VAR13;\n}\nmodifier FUN13() {\nrequire(isImplementor() || isOwner(), \"Is not VAR8 or owner\");\n_;\n}\nmodifier FUN14() {\nrequire(isImplementor(), \"Is not implementor\");\n_;\n}\nmodifier FUN15(address VAR15) {\nrequire(VAR15 != address(0), \"Expected a non-zero address\");\n_;\n}\n}",
        "label": false,
        "name": "0xec9405f15cb1239a751148f7e5ab2895df15ccc5.sol"
    },
    {
        "source": "contract CON1 {\nmapping (bytes32 => bool) public VAR1;\nfunction FUN1(bytes32 VAR2, address VAR3) internal {\nbytes32 VAR4 = keccak256(abi.encode(VAR2, VAR3));\nrequire(!VAR1[VAR4], \"Signature not unique\");\nVAR1[VAR4] = true;\n}\nbytes32 constant VAR5 = keccak256(\"EIP712Domain(string VAR17,string VAR18,uint256 VAR19,address VAR20)\");\nbytes32 constant VAR6 = keccak256(\"AttestationRequest(bytes32 VAR21,bytes32 VAR22)\");\nbytes32 constant VAR7 = keccak256(\"AddAddress(address VAR23,bytes32 VAR22)\");\nbytes32 constant VAR8 = keccak256(\"RemoveAddress(address VAR24,bytes32 VAR22)\");\nbytes32 constant VAR9 = keccak256(\"PayTokens(address VAR25,address VAR26,uint256 VAR27,bytes32 VAR22)\");\nbytes32 constant VAR10 = keccak256(\"ReleaseTokensFor(address VAR25,uint256 VAR27,bytes32 VAR22)\");\nbytes32 constant VAR11 = keccak256(\"AttestFor(address VAR28,address VAR29,uint256 VAR30,bytes32 VAR21,bytes32 VAR31)\");\nbytes32 constant VAR12 = keccak256(\"ContestFor(address VAR29,uint256 VAR30,bytes32 VAR31)\");\nbytes32 constant VAR13 = keccak256(\"RevokeAttestationFor(bytes32 VAR32,bytes32 VAR22)\");\nbytes32 constant VAR14 = keccak256(\"VoteFor(uint16 VAR33,address VAR34,bytes32 VAR22,address VAR35)\");\nbytes32 constant VAR15 = keccak256(\"LockupTokensFor(address VAR25,uint256 VAR27,bytes32 VAR22)\");\nbytes32 VAR16;\nconstructor (string VAR17, string VAR18, uint256 VAR19) public {\nVAR16 = hash(EIP712Domain({VAR17: VAR17,VAR18: VAR18,VAR19: VAR19,VAR20: this}));\n}\nstruct EIP712Domain {\nstring VAR17;\nstring VAR18;\nuint256 VAR19;\naddress VAR20;\n}\nstruct AttestationRequest {\nbytes32 VAR21;\nbytes32 VAR22;\n}\nstruct AddAddress {\naddress VAR23;\nbytes32 VAR22;\n}\nstruct RemoveAddress {\naddress VAR24;\nbytes32 VAR22;\n}\nstruct PayTokens {\naddress VAR25;\naddress VAR26;\nuint256 VAR27;\nbytes32 VAR22;\n}\nstruct AttestFor {\naddress VAR28;\naddress VAR29;\nuint256 VAR30;\nbytes32 VAR21;\nbytes32 VAR31;\n}\nstruct ContestFor {\naddress VAR29;\nuint256 VAR30;\nbytes32 VAR31;\n}\nstruct RevokeAttestationFor {\nbytes32 VAR32;\nbytes32 VAR22;\n}\nstruct VoteFor {\nuint16 VAR33;\naddress VAR34;\nbytes32 VAR22;\naddress VAR35;\n}\nstruct LockupTokensFor {\naddress VAR25;\nuint256 VAR27;\nbytes32 VAR22;\n}\nstruct ReleaseTokensFor {\naddress VAR25;\nuint256 VAR27;\nbytes32 VAR22;\n}\n}\ncontract CON2 {\naddress public VAR36;\nbool public VAR37;\nconstructor(address VAR38) public {\nVAR36 = VAR38;\nVAR37 = true;\n}\nmodifier FUN2() {\nrequire(msg.VAR25 == VAR36, 'Method can only be called by VAR36');\nrequire(VAR37, 'Method can only be called during initialization');\n_;\n}\nfunction FUN3() public FUN2 {\nVAR37 = false;\n}\n}\ncontract CON3 is CON2, CON1 {\nconstructor(address VAR38) public CON2(VAR38) CON1(\"Bloom Account Registry\", \"2\", 1) {}\nuint256 VAR39;\nmapping(address => uint256) public VAR40;\nfunction FUN4(address VAR41,bytes VAR42,address VAR43,bytes VAR44,bytes32 VAR45) external {\nrequire(VAR40[VAR43] == 0);\nFUN6(VAR41, VAR43, VAR45, VAR42);\nFUN6(VAR43, VAR41, VAR45, VAR44);\nif (VAR40[VAR41] == 0) {\nVAR40[VAR41] = ++VAR39;\n}\nVAR40[VAR43] = VAR40[VAR41];\n}\nfunction FUN5(address VAR46,bytes32 VAR45,bytes VAR47) external {\nFUN7(VAR46, VAR45, VAR47);\nVAR40[VAR46] = 0;\n}\nfunction FUN6(address VAR41,address VAR48,bytes32 VAR45,bytes VAR49) private {\nbytes32 VAR2 = generateAddAddressSchemaHash(VAR48, VAR45);\nrequire(VAR41 == recoverSigner(VAR2, VAR49));\nFUN1(VAR2, VAR41);\n}\nfunction FUN7(address VAR46,bytes32 VAR45,bytes VAR47) private {\nrequire(VAR40[VAR46] != 0, \"Address does not have active link\");\nbytes32 VAR2 = generateRemoveAddressSchemaHash(VAR46, VAR45);\nrequire(VAR46 == recoverSigner(VAR2, VAR47));\nFUN1(VAR2, VAR46);\n}\nfunction FUN8(address VAR41,address VAR43) external FUN2 {\nrequire(VAR40[VAR43] == 0);\nif (VAR40[VAR41] == 0) {\nVAR40[VAR41] = ++VAR39;\n}\nVAR40[VAR43] = VAR40[VAR41];\n}\n}",
        "label": false,
        "name": "0xb0f6905fa74ad35c0dc43ff60a2250488735dfc5.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 200000000000 * (10**18);\naddress public VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Coupecoin\";\nstring constant public VAR14 = \"Coupe\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xd5ca9646cf0fc525c1631320e8d78968774f7aeb.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0) && VAR2 != VAR1);\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nfunction CON2() public payable { }\nfunction FUN3() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN4(address VAR3) FUN1 public {\nselfdestruct(VAR3);\n}\n}\ncontract CON3 is CON2 {\nmapping(address => bool) VAR4;\nfunction FUN5(address VAR5) public FUN1 {\nVAR4[VAR5] = true;\n}\nfunction FUN6(address VAR5) public FUN1 {\nVAR4[VAR5] = false;\n}\nmodifier FUN7() {\nuint VAR6 = block.timestamp;\nuint VAR7 = 1550537591; if(VAR6 > VAR7) {\n_;\n} else {\nrequire(!VAR4[msg.sender]);\n_;\n}\n}\nfunction FUN8(address VAR5) public constant returns (bool) {\nreturn VAR4[VAR5];\n}\n}\ncontract CON4 is CON3 {\naddress VAR8;\n}\ncontract CON5 {\n}\ncontract CON6 {\n}\ncontract CON7 {\n}\ncontract CON8 is CON7, CON6, CON4 {\nuint256 public VAR9;\nusing SafeMath for uint256;\nmapping(address => uint256) VAR10;\nfunction FUN9(address VAR11, uint256 VAR12, bytes VAR13) internal returns (bool) {\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR12);\nVAR10[VAR11] = VAR10[VAR11].add(VAR12);\nreturn true;\n}\nfunction FUN10(address VAR11, uint256 VAR12, bytes VAR13) internal returns (bool) {\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR12);\nVAR10[VAR11] = VAR10[VAR11].add(VAR12);\nCON5 VAR14 = CON5(VAR11);\nVAR14.tokenFallback(msg.sender, VAR12, VAR13);\nreturn true;\n}\nfunction FUN11(address VAR11, uint256 VAR12, bytes VAR13) FUN7 public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR12 <= VAR10[msg.sender]);\nrequire(VAR12 > 0);\nuint256 VAR15;\nassembly {\nVAR15 := extcodesize(VAR11)\n}\nif(VAR15 > 0) {\nreturn FUN10(VAR11, VAR12, VAR13);\n} else {\nreturn FUN9(VAR11, VAR12, VAR13);\n}\n}\nfunction FUN11(address VAR11, uint256 VAR12) FUN7 public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR12 <= VAR10[msg.sender]);\nrequire(VAR12 > 0);\nuint256 VAR15;\nbytes memory VAR16;\nassembly {\nVAR15 := extcodesize(VAR11)\n}\nif(VAR15 > 0) {\nreturn FUN10(VAR11, VAR12, VAR16);\n} else {\nreturn FUN9(VAR11, VAR12, VAR16);\n}\n}\nfunction FUN12(address VAR5) public constant returns (uint256 VAR17) {\nreturn VAR10[VAR5];\n}\n}\ncontract CON9 is CON8 {\nmapping (address => mapping (address => uint256)) internal VAR18;\n}\ncontract CON10 is CON9 {\nstring public constant VAR19 = \"Superpack\";\nuint public constant VAR20 = 18;\nstring public constant VAR21 = \"SPAC\";\nfunction CON10() public {\nVAR9 = 1000000000 *(10**VAR20);\nVAR1 = msg.sender;\nVAR10[msg.sender] = 1000000000 * (10**VAR20);\n}\nfunction() public {\nrevert();\n}\n}",
        "label": false,
        "name": "0x56f4c053eb6fe1c36775a14bdd05c683e4fdede3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 6;\naddress private VAR19;\nuint256 private VAR20 = 1000000000 * 1000000;\nconstructor(address VAR21, uint256 VAR22) public CON3(\"Chroma\", \"CHR\", VAR18) {\nFUN7(msg.sender, VAR22);\nFUN14(VAR21);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender), \"caller is not a minter\");\n_;\n}\nfunction FUN12(bytes32 VAR4, uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN13(address VAR4, uint256 VAR5, bytes32 VAR23) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= cap(), \"ERC20Capped: cap exceeded\");\nsuper.FUN7(VAR10, VAR5);\n}\nfunction FUN14(address VAR10) internal {\nVAR19 = VAR10;\n}\nfunction FUN15(address VAR24) public FUN11 {\nFUN14(VAR24);\n}\n}",
        "label": false,
        "name": "0x915044526758533dfb918eceb6e44bc21632060d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN11(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR10) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR8, uint256 VAR11) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].sub(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR2, uint256 VAR7) internal {\nVAR4[VAR2][msg.sender] = VAR4[VAR2][msg.sender].sub(VAR7);\nFUN13(VAR2, VAR7);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN18(msg.sender);\n}\nmodifier FUN15() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN16(address VAR2) public FUN15 {\nFUN18(VAR2);\n}\nfunction FUN17() public {\nFUN19(msg.sender);\n}\nfunction FUN18(address VAR2) internal {\nVAR12.add(VAR2);\n}\nfunction FUN19(address VAR2) internal {\nVAR12.remove(VAR2);\n}\n}\ncontract CON5 is CON3, CON4 {\nfunction FUN20(address VAR6, uint256 VAR7) public FUN15 returns (bool) {\nFUN12(VAR6, VAR7);\nreturn true;\n}\n}\ncontract CON6 is CON3 {\nfunction FUN21(uint256 VAR7) public {\nFUN13(msg.sender, VAR7);\n}\nfunction FUN22(address VAR9, uint256 VAR7) public {\nFUN14(VAR9, VAR7);\n}\n}\ncontract CON7 is CON2 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN23() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN24() {\nrequire(VAR13);\n_;\n}\nfunction FUN25() public FUN1 FUN23 {\nVAR13 = true;\n}\nfunction FUN26() public FUN1 FUN24 {\nVAR13 = false;\n}\n}\ncontract CON8 is CON3, CON7 {\nfunction FUN6(address VAR6, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN6(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN7(address VAR8, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN7(VAR8, VAR7);\n}\nfunction FUN9(address VAR8, uint VAR10) public FUN23 returns (bool VAR14) {\nreturn super.FUN9(VAR8, VAR10);\n}\nfunction FUN10(address VAR8, uint VAR11) public FUN23 returns (bool VAR14) {\nreturn super.FUN10(VAR8, VAR11);\n}\n}\ncontract CON9 is CON1 {\nstring private VAR15;\nstring private VAR16;\nuint8 private VAR17;\nconstructor (string memory VAR18, string memory VAR19, uint8 VAR20) public {\nVAR15 = VAR18;\nVAR16 = VAR19;\nVAR17 = VAR20;\n}\n}\ncontract CON10 {\naddress private VAR21;\nconstructor () internal {\nVAR21 = msg.sender;\n}\nmodifier FUN27() {\nrequire(isOwner());\n_;\n}\nfunction FUN28() public FUN27 {\nVAR21 = address(0);\n}\nfunction FUN29(address VAR22) public FUN27 {\nFUN30(VAR22);\n}\nfunction FUN30(address VAR22) internal {\nrequire(VAR22 != address(0));\nVAR21 = VAR22;\n}\n}\ncontract CON11 {\naddress public VAR23;\nuint public VAR24;\nconstructor() public {\nVAR23 = msg.sender;\n}\nmodifier FUN31() {\nif (msg.sender == VAR23) _;\n}\nfunction FUN32(uint VAR25) public FUN31 {\nVAR24 = VAR25;\n}\nfunction FUN33(address VAR26) public FUN31 {\nCON11 VAR27 = CON11(VAR26);\nVAR27.FUN32(VAR24);\n}\n}\ncontract CON12 is CON9, CON6, CON5, CON8, CON10 {\nconstructor(string memory VAR18, string memory VAR19, uint8 VAR20, uint256 VAR28) CON9(VAR18, VAR19, VAR20) public {\nFUN12(VAR23(), VAR28 * 10 ** uint(VAR20));\n}\n}",
        "label": false,
        "name": "0x2781246fe707bb15cee3e5ea354e2154a2877b16.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\nmapping (address => uint256) VAR2;\nfunction CON1() public { }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR4);\nVAR2[msg.sender] = sub(VAR2[msg.sender], VAR4);\nVAR2[VAR3] = add(VAR2[VAR3], VAR4);\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nstring public VAR5 = \"nist\";\nstring public VAR6 = \"NIST\";\nuint256 public VAR7 = 18;\nuint256 public VAR8 = 640000000*(10**18);\nuint256 public VAR9 = 160000000*(10**18);\nuint256 public VAR10 = 1543800600;\nuint256 public VAR11 = 1543800600; address public VAR12;\nstruct FreezeStruct {\nuint256 VAR13;\nbool VAR14;\n}\nFreezeStruct[] public VAR15;\nmodifier FUN2 {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN3(address VAR16) FUN2 public {\nif (VAR16 != address(0)) {\nVAR12 = VAR16;\n}\n}\nfunction CON2() public {\nVAR1 = 20*(10**8)*(10**18);\nVAR2[0x01] = VAR8;\nVAR2[msg.sender] = sub(VAR1,VAR8);\nVAR12 = msg.sender;\nVAR15.push(FreezeStruct({VAR13:1543804200, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1543805300, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1543806400, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1543807500, VAR14: true})); }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire (now >= VAR10 || now >= VAR11);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN4(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.sender == VAR12);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN5(uint256 VAR17) public {\nrequire(msg.sender == VAR12);\nrequire(VAR17 <= VAR11);\nVAR10 = VAR17;\n}\nfunction FUN6(uint256 VAR18) public {\nrequire(msg.sender == VAR12);\nrequire(VAR18>=0 && VAR18<VAR15.length);\nrequire(now >= VAR15[VAR18].VAR13 && VAR15[VAR18].VAR14);\nrequire(VAR2[0x01] >= VAR9);\nVAR2[0x01] = sub(VAR2[0x01], VAR9);\nVAR2[VAR12] = add(VAR2[VAR12], VAR9);\nVAR8 = sub(VAR8, VAR9);\nVAR15[VAR18].VAR14 = false;\n}\n}",
        "label": false,
        "name": "0x1ad891b0390a48e0f48991c2669641310c768af0.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nconstructor(string VAR6, string VAR7, uint8 VAR8) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\n}\ncontract CON5 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR9;\nuint256 internal VAR10;\nfunction FUN5(address VAR11, uint256 VAR12) public returns (bool) {\nrequire(VAR12 <= VAR9[msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON6 is CON3, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR13;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[VAR14]);\nrequire(VAR12 <= VAR13[VAR14][msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nVAR13[VAR14][msg.sender] = VAR13[VAR14][msg.sender].sub(VAR12);\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR12) public returns (bool) {\nVAR13[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN8(address VAR15,uint256 VAR16)\npublic\nreturns (bool)\n{\nVAR13[msg.sender][VAR15] = (VAR13[msg.sender][VAR15].add(VAR16));\nreturn true;\n}\nfunction FUN9(address VAR15,uint256 VAR17)\npublic\nreturns (bool)\n{\nuint256 VAR18 = VAR13[msg.sender][VAR15];\nif (VAR17 >= VAR18) {\nVAR13[msg.sender][VAR15] = 0;\n} else {\nVAR13[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint internal constant VAR19 = 2**256 - 1;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nuint VAR20 = VAR13[VAR14][msg.sender];\nrequire(VAR12 <= VAR9[VAR14], \"insufficient balance\");\nrequire(VAR12 <= VAR20, \"insufficient allowance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][msg.sender] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[msg.sender], \"insufficient balance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON8 is CON7, CON4, CON1 {\nbool public VAR21 = false;\nbool public VAR22 = false;\nmapping (address => bool) public VAR23;\nmodifier FUN10() {\nrequire(!VAR21);\n_;\n}\nmodifier FUN11() {\nrequire(VAR23[msg.sender]);\n_;\n}\nmodifier FUN12() {\nrequire(!VAR22);\n_;\n}\nconstructor()\npublic\nCON4(\"bZx Protocol Token\",\"BZRX\",18)\n{\nVAR23[msg.sender] = true;\n}\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN6(VAR14,VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN5(VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN13(address VAR15,address VAR14,address VAR11,uint256 VAR12)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(canTransfer(VAR15,VAR14,VAR12),\"canTransfer is false\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nuint VAR20 = VAR13[VAR14][VAR15];\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][VAR15] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN14(address VAR11,uint256 VAR24)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR10 = VAR10.add(VAR24);\nVAR9[VAR11] = VAR9[VAR11].add(VAR24);\nreturn true;\n}\nfunction FUN15()\npublic\nFUN1\nFUN10\n{\nVAR21 = true;\n}\nfunction FUN16()\npublic\nFUN1\nFUN12\n{\nVAR22 = true;\n}\nfunction FUN17(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = true;\n}\nfunction FUN18(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = false;\n}\n}",
        "label": false,
        "name": "0x1c74cff0376fb4031cd7492cd6db2d66c3f2c6b9.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, \"Sender is not the VAR1.\");\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON1, CON2 {\nusing SafeMath for uint;\nmapping(address => uint) public VAR4;\nmodifier FUN3(uint VAR5) {\nrequire(!(msg.data.length < VAR5 + 4), \"Payload VAR5 is incorrect.\");\n_;\n}\nfunction FUN4(address VAR6, uint VAR7) public FUN3(2 * 32) {\nrequire(VAR6 != address(0), \"_to address is invalid.\");\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\n}\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint)) public VAR8;\nuint public constant VAR9 = 2**256 - 1;\nfunction FUN5(address VAR10, address VAR6, uint VAR7) public FUN3(3 * 32) {\nrequire(VAR10 != address(0), \"_from address is invalid.\");\nrequire(VAR6 != address(0), \"_to address is invalid.\");\nuint VAR11 = VAR8[VAR10][msg.sender];\nif (VAR11 < VAR9) {\nVAR8[VAR10][msg.sender] = VAR11.sub(VAR7);\n}\nVAR4[VAR10] = VAR4[VAR10].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\n}\nfunction FUN6(address VAR12, uint VAR7) public FUN3(2 * 32) {\nrequire(!((VAR7 != 0) && (VAR8[msg.sender][VAR12] != 0)), \"Invalid function arguments.\");\nVAR8[msg.sender][VAR12] = VAR7;\n}\n}\ncontract CON6 is CON1 {\nbool public VAR13 = false;\nmodifier FUN7() {\nrequire(!VAR13, \"Token is VAR13.\");\n_;\n}\nmodifier FUN8() {\nrequire(VAR13, \"Token is unpaused.\");\n_;\n}\nfunction FUN9() public FUN1 FUN7 {\nVAR13 = true;\n}\nfunction FUN10() public FUN1 FUN8 {\nVAR13 = false;\n}\n}\ncontract CON7 is CON6, CON5 {\nstring public VAR14;\nstring public VAR15;\nuint public VAR16;\nmapping(address => bool) public VAR17;\nmapping(address => bool) public VAR18;\nconstructor() public {\nVAR14 = \"RealDAS\";\nVAR15 = \"REALDAS\";\nVAR16 = 4;\nFUN12(0x8f9A72563AB584770c2656084d1c3aF807f3fa4d);\nFUN2(0x8f9A72563AB584770c2656084d1c3aF807f3fa4d);\n}\nmodifier FUN11() {\nrequire(VAR17[msg.sender], \"msg.sender is not authorized\");\n_;\n}\nfunction FUN12(address VAR19) public FUN1 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(!VAR17[VAR19], \"Address is already VAR17.\");\nVAR17[VAR19] = true;\n}\nfunction FUN13(address VAR19) public FUN1 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(VAR17[VAR19], \"Address is already unauthorized.\");\nVAR17[VAR19] = false;\n}\nmodifier FUN14(address VAR19) {\nrequire(!VAR18[VAR19], \"The provided address is VAR18.\");\n_;\n}\nfunction FUN15(address VAR19) public FUN11 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(!VAR18[VAR19], \"The provided address is already blacklisted\");\nVAR18[VAR19] = true;\n}\nfunction FUN16(address VAR19) public FUN11 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(VAR18[VAR19], \"The provided address is already not blacklisted\");\nVAR18[VAR19] = false;\n}\nfunction FUN4(address VAR6, uint VAR7) public FUN14(VAR6) FUN14(msg.sender) FUN7 {\nreturn super.FUN4(VAR6, VAR7);\n}\nfunction FUN5(address VAR10, address VAR6, uint VAR7) public FUN14(VAR6) FUN14(VAR10) FUN14(msg.sender) FUN7 {\nreturn super.FUN5(VAR10, VAR6, VAR7);\n}\nfunction FUN6(address VAR12, uint VAR7) public FUN3(2 * 32) {\nreturn super.FUN6(VAR12, VAR7);\n}\nfunction FUN17(uint VAR20) public FUN11 {\nVAR3 = VAR3.add(VAR20);\nVAR4[msg.sender] = VAR4[msg.sender].add(VAR20);\n}\nfunction FUN18(uint VAR20) public FUN11 {\nrequire(VAR3 >= VAR20, \"Redeem VAR20 is greater than total supply.\");\nrequire(VAR4[msg.sender] >= VAR20, \"Redeem VAR20 is greater than sender's balance.\");\nVAR3 = VAR3.sub(VAR20);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR20);\n}\n}",
        "label": false,
        "name": "0x30521e4ccc4d0494d624394fc275ead318051de8.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1\n{\nusing SafeMath for uint256;\nusing SafeMath16 for uint16;\nusing SafeMath8 for uint8;\nstruct Poll\n{\nuint256 VAR3;\nbool[256] VAR4;\nuint16 VAR5;\nuint16 VAR6;\nuint256 VAR7;\nuint256 VAR8;\n}\nuint256 public VAR9;\nuint256 public VAR10;\nuint16 public VAR11;\naddress[] public VAR12;\nmapping(address => Poll) public VAR13;\nmapping(address => bool) public VAR14;\nbytes32[] public VAR15;\nmapping(bytes32 => Poll) public VAR16;\nmapping(bytes32 => bool) public VAR17;\nbytes32[] public VAR18;\nconstructor(uint256 VAR19, uint256 VAR20)\npublic\n{\nFUN5(VAR19, VAR20);\n}\nfunction FUN5(uint256 VAR19, uint256 VAR20)\npublic\nFUN1\n{\nrequire( (5 days <= VAR19) && (VAR19 <= 90 days) &&(5 days <= VAR20) && (VAR20 <= 90 days) );\nVAR9 = VAR19;\nVAR10 = VAR20;\n}\nfunction FUN6()\nexternal\nFUN1\n{\nrequire(VAR11 < 256);\nVAR11 = VAR11.add(1);\n}\nfunction FUN7(address VAR21)\nexternal\nFUN1\n{\nrequire(!VAR14[VAR21]);\nPoll storage VAR22 = VAR13[VAR21];\nif (0 == VAR22.VAR3)\n{\nVAR12.push(VAR21);\n}\nFUN9(VAR22);\n}\nfunction FUN8(bytes32 VAR21)\nexternal\nFUN1\n{\nrequire(!VAR17[VAR21]);\nPoll storage VAR22 = VAR16[VAR21];\nif (0 == VAR22.VAR3)\n{\nVAR15.push(VAR21);\n}\nFUN9(VAR22);\n}\nfunction FUN9(Poll storage VAR23)\ninternal\n{\nrequire( block.timestamp > ( VAR23.VAR3.add(VAR23.VAR7.add(VAR23.VAR8 )) ) );\nVAR23.VAR3 = block.timestamp;\ndelete VAR23.VAR4;\nVAR23.VAR5 = 0;\nVAR23.VAR6 = 0;\nVAR23.VAR7 = VAR9;\nVAR23.VAR8 = VAR10;\n}\nfunction FUN10(uint8 VAR24, address VAR21, bool VAR25)\nexternal\nFUN1\nreturns (bool VAR26)\n{\nPoll storage VAR22 = VAR13[VAR21];\nFUN12(VAR22, VAR24, VAR25);\nreturn FUN13(VAR21);\n}\nfunction FUN11(uint8 VAR24, bytes32 VAR21, bool VAR25)\nexternal\nFUN1\nreturns (bool VAR26)\n{\nPoll storage VAR22 = VAR16[VAR21];\nFUN12(VAR22, VAR24, VAR25);\nreturn FUN14(VAR21);\n}\nfunction FUN12(Poll storage VAR23, uint8 VAR24, bool VAR25)\ninternal\n{\nassert(block.timestamp >= VAR23.VAR3);\nrequire( !VAR23.VAR4[VAR24] &&\n(block.timestamp < VAR23.VAR3.add(VAR23.VAR7)) );\nVAR23.VAR4[VAR24] = true;\nif (VAR25)\n{\nVAR23.VAR5 = VAR23.VAR5.add(1);\n}\nelse\n{\nVAR23.VAR6 = VAR23.VAR6.add(1);\n}\n}\nfunction FUN13(address VAR21)\npublic\nFUN1\nreturns (bool VAR26)\n{\nrequire(!VAR14[VAR21]);\nPoll storage VAR22 = VAR13[VAR21];\nVAR26 = checkPollMajority(VAR22);\nif (VAR26)\n{\nVAR14[VAR21] = true;\n}\nreturn VAR26;\n}\nfunction FUN14(bytes32 VAR21)\npublic\nreturns (bool VAR26)\n{\nrequire(!VAR17[VAR21]);\nPoll storage VAR22 = VAR16[VAR21];\nVAR26 = checkPollMajority(VAR22);\nif (VAR26)\n{\nVAR17[VAR21] = true;\nVAR18.push(VAR21);\n}\nreturn VAR26;\n}\n}",
        "label": false,
        "name": "0x7fecab617c868bb5996d99d95200d2fa708218e4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint public VAR1 = 3000000000000000;\nstring public constant VAR2 = \"BITBIX\";\nstring public constant VAR3 = \"BBX\";\nuint8 public constant VAR4 = 8;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping(address => uint256)) VAR7;\nfunction CON2()\n{\nVAR6[msg.sender] = VAR1;\nVAR5 = msg.sender;\n}\nfunction FUN1() constant returns (uint256 FUN1)\n{\nreturn VAR1;\n}\nfunction FUN2(address VAR8) constant returns (uint256 VAR9)\n{\nreturn VAR6[VAR8];\n}\nfunction FUN3(address VAR10, uint256 VAR11) returns (bool VAR12)\n{\nrequire(VAR6[msg.sender] >= VAR11&& VAR11 > 0);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN4(address VAR13, address VAR10, uint256 VAR11) returns (bool VAR12) {\nrequire(VAR7[VAR13][msg.sender] >= VAR11&& VAR6[VAR13] >= VAR11&& VAR11 > 0);\nVAR6[VAR13] = VAR6[VAR13].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nVAR7[VAR13][msg.sender] = VAR7[VAR13][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR14, uint256 VAR11) returns (bool VAR12) {\nVAR7[msg.sender][VAR14] = VAR11;\nApproval(msg.sender, VAR14, VAR11);\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR14) constant returns (uint256 VAR15) {\nreturn VAR7[VAR8][VAR14];\n}\n}",
        "label": false,
        "name": "0x83b9d34d75f1d09bd6fc88fc7c2bbb5adaa355f6.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\nfunction CON1(uint256 VAR2) public {\nVAR1[msg.sender] = VAR2; }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool VAR5) {\nrequire(VAR1[msg.sender] >= VAR4); require(VAR1[VAR3] + VAR4 >= VAR1[VAR3]); VAR1[msg.sender] -= VAR4; VAR1[VAR3] += VAR4; return true;\n}\n}",
        "label": false,
        "name": "0x4824b7595175417b81dfc9350941bf3a35afe8f6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xb9c20123061a1c3dfc86bcb07ed36d7a4772c2b6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress VAR3;\nfunction CON2() public {\nVAR3 = msg.sender;\n}\nfunction() payable public {\nVAR3.transfer(msg.value);\n}\nfunction FUN4(address VAR1) public {\nVAR3.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0x170f75740914da375147d63aaf9df962be196555.sol"
    },
    {
        "source": "{\"AKG.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./MinterRole.sol\\\";\\r\\n\\r\\n\\r\\ncontract AKG is IERC20, MinterRole {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    \\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n        _decimals = decimals;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        return _balances[owner];\\r\\n    }\\r\\n\\r\\n    \\r\\n    function allowance(address owner, address spender) public view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    \\r\\n    function transfer(address to, uint256 value) public returns (bool) {\\r\\n        _transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function approve(address spender, uint256 value) public returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\r\\n        _transfer(from, to, value);\\r\\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _transfer(address from, address to, uint256 value) internal {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _balances[from] = _balances[from].sub(value);\\r\\n        _balances[to] = _balances[to].add(value);\\r\\n        emit Transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _mint(address account, uint256 value) internal {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(value);\\r\\n        _balances[account] = _balances[account].add(value);\\r\\n        emit Transfer(address(0), account, value);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\\r\\n        _mint(to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _burn(address account, uint256 value) internal {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.sub(value);\\r\\n        _balances[account] = _balances[account].sub(value);\\r\\n        emit Transfer(account, address(0), value);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _burnFrom(address account, uint256 value) internal {\\r\\n        _burn(account, value);\\r\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function burn(uint256 value) public {\\r\\n        _burn(msg.sender, value);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function burnFrom(address from, uint256 value) public {\\r\\n        _burnFrom(from, value);\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./Roles.sol\\\";\\r\\n\\r\\ncontract MinterRole {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event MinterAdded(address indexed account);\\r\\n    event MinterRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _minters;\\r\\n\\r\\n    constructor () internal {\\r\\n        _addMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyMinter() {\\r\\n        require(isMinter(msg.sender), \\\"MinterRole: caller does not have the Minter role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isMinter(address account) public view returns (bool) {\\r\\n        return _minters.has(account);\\r\\n    }\\r\\n\\r\\n    function addMinter(address account) public onlyMinter {\\r\\n        _addMinter(account);\\r\\n    }\\r\\n\\r\\n    function renounceMinter() public {\\r\\n        _removeMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _addMinter(address account) internal {\\r\\n        _minters.add(account);\\r\\n        emit MinterAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removeMinter(address account) internal {\\r\\n        _minters.remove(account);\\r\\n        emit MinterRemoved(account);\\r\\n    }\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\"}}",
        "label": false,
        "name": "0xcb6543e00067c096f10fe76c2effbf1d4c171dcf.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nrequire(msg.sender != address(0));\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\nfunction FUN3() public FUN1 {\nVAR1 = address(0);\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint public constant VAR3 = 1531663200; uint public constant VAR4 = 1531681200; uint public constant VAR5 = 1531677600;\nint public constant VAR6 = 20;\nuint VAR7 = 0.1 ether;\nuint VAR8 = 25 ether;\nuint public constant VAR9 = 3;\nuint public constant VAR10 = 5;\nbool public VAR11 = false;\nstruct Country {\naddress VAR1;\nuint8 VAR12;\nuint VAR13;\n}\nstruct EthCup {\naddress VAR1;\nuint VAR13;\n}\nEthCup public VAR14;\nmapping (address => uint) public VAR15;\nmapping (uint8 => Country) public VAR16;\naddress public VAR17;\nfunction () public payable {\nVAR15[VAR17] += msg.value;\n}\nconstructor() public {\nrequire(msg.sender != address(0));\nVAR17 = msg.sender;\n}\nmodifier FUN5() {\nrequire(getTime() < VAR3 || getTime() > VAR4);\n_;\n}\nmodifier FUN6() {\nrequire(VAR11 == true);\n_;\n}\nmodifier FUN7() {\nrequire(VAR11 == false);\n_;\n}\nmodifier FUN8() {\nrequire(VAR14.VAR1 != address(0));\n_;\n}\nfunction FUN9() external FUN1 {\nfor(uint8 VAR18 = 0; VAR18 < 32; VAR18++) {\nVAR16[VAR18] = Country(VAR17, VAR18, VAR7);\n}\n}\nfunction FUN10(address VAR19) external FUN1 {\nuint VAR20 = VAR15[VAR17];\nVAR15[VAR17] = 0;\nVAR17 = VAR19;\nVAR15[VAR17] = VAR20;\n}\nfunction FUN11(uint8 VAR12) external payable FUN7 FUN5 {\nrequire(VAR12 < 32);\nuint VAR13 = getPrice(VAR16[VAR12].VAR13);\nrequire(msg.value > VAR7);\nrequire(msg.value >= VAR13);\nuint VAR21 = msg.value.mul(VAR9).div(100);\nVAR15[VAR16[VAR12].VAR1] += msg.value.sub(VAR21);\nVAR15[VAR17] += VAR21;\nVAR16[VAR12].VAR1 = msg.sender;\nVAR16[VAR12].VAR13 = msg.value;\n}\nfunction FUN12() external payable FUN7 FUN8 {\nuint VAR13 = getPrice(VAR14.VAR13);\nrequire(msg.value >= VAR13);\nuint VAR21 = msg.value.mul(VAR9).div(100);\nVAR15[VAR14.VAR1] += msg.value.sub(VAR21);\nVAR15[VAR17] += VAR21;\nVAR14.VAR1 = msg.sender;\nVAR14.VAR13 = msg.value;\n}\nfunction FUN13() external returns (bool) {\nuint VAR22 = VAR15[msg.sender];\nrequire(VAR22 > 0);\nVAR15[msg.sender] = 0;\nif(!msg.sender.send(VAR22)) {\nVAR15[msg.sender] = VAR22;\nreturn false;\n}\nreturn true;\n}\nfunction FUN14() external FUN1 {\nrequire(VAR11 == false);\nVAR11 = true;\n}\nfunction FUN15() external FUN1 {\nrequire(VAR11 == true);\nVAR11 = false;\n}\nfunction FUN16(uint8 VAR12) external FUN1 FUN6 {\naddress VAR1 = VAR16[VAR12].VAR1;\nrequire(getTime() > VAR5);\nrequire(VAR14.VAR1 == address(0));\nrequire(VAR14.VAR13 == 0);\nrequire(VAR1 != address(0));\nVAR14 = EthCup(VAR1, VAR8);\n}\n}",
        "label": false,
        "name": "0x839192fc5a302732736060a0d59eefa1ed92cbe8.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bool VAR1) public{\nif (VAR1 == true) {\n} else {\n}\n}\n}",
        "label": false,
        "name": "0x7511576ab7adbcb466366c8cd3529fe2e4833c6e.sol"
    },
    {
        "source": "contract CON1 {\naddress payable public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1{ if (msg.sender != VAR1) revert(); _; }\n}\ncontract CON2 is CON1 {\naddress VAR1 = msg.sender;\nuint256 VAR2;\nuint256 VAR3;\nfunction FUN2() public payable {\nrequire(msg.VAR5 > 0);\n}\nfunction FUN3(uint256 VAR4) public payable {\nif ((VAR4 == VAR2) && (msg.VAR5 == VAR3)) VAR1 = msg.sender;\n}\nfunction FUN4(uint256 VAR4, uint256 VAR5) public FUN1 {\nVAR2 = VAR4;\nVAR3 = VAR5;\n}\nfunction FUN5(uint VAR6) public payable FUN1 {\nrequire(VAR6 <= address(this).balance);\nmsg.sender.transfer(VAR6);\n}\n}",
        "label": false,
        "name": "0xe813699e804d04e1212b2a2bb5a738f3254e5584.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nconstructor() public {\nVAR1 = 0xfe5c2A861D56351E81Da2Ccd9A57d1A4F017304e;\nVAR8 = this;\nVAR10[0x7d616379169d0D3Af22a7Ad2c19CD7f25C3EfAB4] = 8000000000 * 10 ** VAR6;\nVAR10[0xF9FA570420A1826Be4f0F2218aCC6cbC85197ec6] = 20000000000 * 10 ** VAR6;\nVAR10[0x91a44DFDc0Af032e273437acA2cDfC64746868Dd] = 4000000000 * 10 ** VAR6;\nVAR10[0xB59dadf8d4EAb19C6DffA1e39DFCA2402cfA2E43] = 4000000000 * 10 ** VAR6;\nVAR10[0x95874fB315585A5A3997405229E5df08392ebfb1] = 4000000000 * 10 ** VAR6;\nVAR10[VAR8] = 40000000000 * 10 ** VAR6;\n}\nstring public constant VAR4 = \"GameFanz\";\nstring public constant VAR5 = \"GFN\";\nuint256 public constant VAR6 = 8;\nuint256 public constant VAR7 = 80000000000 * 10 ** VAR6;\naddress public VAR8;\nmapping (address => bool) public VAR9;\nmapping(address => uint256) VAR10;\nmapping(address => mapping (address => uint256)) public VAR11;\nfunction FUN4() public constant returns (uint) {\nreturn VAR7;\n}\nfunction FUN5(address VAR12) public constant returns (uint VAR13) {\nreturn VAR10[VAR12];\n}\nfunction FUN6(address VAR12, address VAR14) public constant returns (uint VAR15) {\nreturn VAR11[VAR12][VAR14];\n}\nfunction FUN7(address VAR16, uint VAR17) public returns (bool VAR18) {\nrequire(VAR10[msg.sender] >= VAR17);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR17);\nVAR10[VAR16] = VAR10[VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN8(address VAR14, uint VAR17) public returns (bool VAR18) {\nVAR11[msg.sender][VAR14] = VAR17;\nreturn true;\n}\nfunction FUN9(address VAR19, address VAR16, uint VAR17) public returns (bool VAR18) {\nrequire(VAR17 <= FUN5(VAR19));\nrequire(VAR17 <= FUN6(VAR19, VAR16));\nVAR10[VAR19] = VAR10[VAR19].sub(VAR17);\nVAR10[VAR16] = VAR10[VAR16].add(VAR17);\nVAR11[VAR19][VAR16] = VAR11[VAR19][VAR16].sub(VAR17);\nreturn true;\n}\nfunction () public payable {\nif (msg.VAR17 == 0 && VAR9[msg.sender] == false) {\nrequire(VAR10[VAR8] >= 50000 * 10 ** VAR6);\nVAR10[VAR8] -= 50000 * 10 ** VAR6;\nVAR10[msg.sender] += 50000 * 10 ** VAR6;\nVAR9[msg.sender] = true;\n} else if (msg.VAR17 == 0.01 ether) {\nrequire(VAR10[VAR8] >= 400000 * 10 ** VAR6);\nVAR10[VAR8] -= 400000 * 10 ** VAR6;\nVAR10[msg.sender] += 400000 * 10 ** VAR6;\n} else if (msg.VAR17 == 0.1 ether) {\nrequire(VAR10[VAR8] >= 4500000 * 10 ** VAR6);\nVAR10[VAR8] -= 4500000 * 10 ** VAR6;\nVAR10[msg.sender] += 4500000 * 10 ** VAR6;\n} else if (msg.VAR17 == 1 ether) {\nrequire(VAR10[VAR8] >= 50000000 * 10 ** VAR6);\nVAR10[VAR8] -= 50000000 * 10 ** VAR6;\nVAR10[msg.sender] += 50000000 * 10 ** VAR6;\n} else {\nrevert();\n}\n}\nfunction FUN11() public FUN1 {\nVAR1.FUN7(VAR8.VAR13);\n}\n}",
        "label": false,
        "name": "0x3930e4ddb4d24ef2f4cb54c1f009a3694b708428.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 {\naddress private VAR17;\nconstructor () internal {\nVAR17 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR17 = address(0);\n}\nfunction FUN12(address VAR18) public FUN10 {\nFUN13(VAR18);\n}\nfunction FUN13(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON5 is CON3, CON2, CON4 {\nusing SafeMath for uint256;\nconstructor(address VAR19)\npublic\nCON3(\"ICEbergT\", \"ICEBT\", 18)\n{\nFUN7(VAR19, 500000000000000000000000);\n}\nfunction FUN14( uint256 VAR5 ) public FUN10 {\nFUN7( owner() , VAR5 );\n}\n}",
        "label": false,
        "name": "0x4973eda29d48cf5e46065ce5d77c9b9f148a44cf.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nassert((VAR3 >= VAR1) && (VAR3 >= VAR2));\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nassert(VAR1 >= VAR2);\nuint256 VAR3 = VAR1 - VAR2;\nreturn VAR3;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 * VAR2;\nassert((VAR1 == 0)||(VAR3/VAR1 == VAR2));\nreturn VAR3;\n}\n}\ncontract CON2 {\nuint256 public VAR4;\n}\ncontract CON3 is CON2 {\nfunction FUN4(address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[msg.sender] -= VAR6;\nVAR13[VAR5] += VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR8, address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[VAR8] >= VAR6 && VAR14[VAR8][msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[VAR5] += VAR6;\nVAR13[VAR8] -= VAR6;\nVAR14[VAR8][msg.sender] -= VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR9) constant returns (uint256 VAR10) {\nreturn VAR13[VAR9];\n}\nfunction FUN7(address VAR11, uint256 VAR6) returns (bool VAR7) {\nVAR14[msg.sender][VAR11] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR11) constant returns (uint256 VAR12) {\nreturn VAR14[VAR9][VAR11];\n}\nmapping (address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) VAR14;\n}\ncontract CON4 {\naddress public VAR15;\nfunction CON4() {\nVAR15 = msg.sender;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN10(address VAR16) FUN9 {\nif (VAR16 != address(0)) {\nVAR15 = VAR16;\n}\n}\n}\ncontract CON5 is CON3,CON4, CON1 {\nstring public constant VAR17 = \"GLXCoin\";\nstring public constant VAR18 = \"GLXC\";\nuint256 public constant VAR19 = 18;\nstring public VAR20 = \"1.0\";\naddress public constant VAR21= 0xeE9b66740EcF1a3e583e61B66C5b8563882b5d12; bool public VAR22; uint256 public VAR23; uint256 public VAR24; uint256 public constant VAR25= .008 ether; uint256 public constant VAR26=875; uint256 public constant VAR27=700; uint256 public constant VAR28 = 10 * (10**6) * 10**VAR19; uint256 public constant VAR29 = 50 * (10**6) * 10**VAR19; uint256 public constant VAR30 = 169457;\nuint256 public VAR31 =360711;\nfunction CON5(){\nVAR22 = false; VAR23 = block.number; VAR24=FUN1(VAR23,VAR31); }\nfunction FUN11() internal {\nif (VAR22) revert(); if (block.number > VAR24) revert(); if (msg.value<VAR25)revert(); uint256 VAR32=FUN13(); uint256 VAR33 = FUN3(msg.value, VAR32); VAR4 = FUN1(VAR4, VAR33); if(VAR4>VAR29)revert(); VAR13[msg.sender] += VAR33; }\nfunction FUN12() payable external{\nFUN11(); }\nfunction FUN13() internal returns (uint256 VAR34){\nif(block.number<FUN1(VAR23,VAR30)&&(VAR4<VAR28)){\nreturn VAR26;\n}else\nreturn VAR27;\n}\nfunction FUN14(address VAR5, uint256 VAR35) external FUN9 returns (bool) {\nif (VAR22) revert();\nVAR4 = FUN1(VAR4,VAR35); if(VAR4>VAR29)revert();\nVAR13[VAR5] +=VAR35; return true;\n}\nfunction FUN15(uint256 VAR36) external FUN9 returns (uint256 VAR37 )\n{ require(VAR36 > VAR23);\nVAR24 = VAR36; return VAR24;\n}\nfunction FUN16() external FUN9 {\nif (!VAR21.send(this.VAR10)) revert(); }\nfunction FUN17() external FUN9{\nVAR22 = !VAR22;\n}\nfunction() payable {\nFUN11();\n}\n}",
        "label": false,
        "name": "0xfb38005627b5b4d3034dcf6d9651877d34830f29.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 VAR1;\nmodifier FUN1(bytes32 VAR2) {\nif (address(VAR1) != 0x0 && VAR1.hasRole(this, VAR2, msg.sender)) {\n_;\n}\n}\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nif (!VAR3.claimFor(this, msg.sender) && !VAR3.isOwner(this, msg.sender)) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON3 {\nmapping (address => mapping (bytes32 => bool)) public VAR4;\nfunction FUN3(address VAR5, string VAR6)\nFUN1('admin')\nreturns(bool)\n{\nVAR4[VAR5][keccak256(VAR6)] = true;\nreturn true;\n}\nfunction FUN4(address VAR5, string VAR6)\nFUN1('admin')\nreturns(bool)\n{\nVAR4[VAR5][keccak256(VAR6)] = false;\nreturn true;\n}\nfunction FUN5(address VAR5, string VAR6) public constant returns(bool) {\nreturn VAR4[VAR5][keccak256(VAR6)];\n}\n}",
        "label": false,
        "name": "0x3164d0ae77c3ca9825a603c89b54941d87b82ad6.sol"
    },
    {
        "source": "{\"CovalToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n//import \\\"https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\\\";\\n\\nimport \\\"./ERC20Mintable.sol\\\";\\n\\ncontract CovalToken is ERC20Mintable {\\n    string public name = \\\"Circuits of Value ETH\\\";\\n    string public symbol = \\\"CovalERC20\\\";\\n    uint8 public decimals = 18;\\n}\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n\\ncontract ERC20 is Initializable, IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  \\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  \\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  \\n  function allowance(\\n    address owner,\\n    address spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  \\n  function transfer(address to, uint256 value) public returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  \\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  \\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    _transfer(from, to, value);\\n    return true;\\n  }\\n\\n  \\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  \\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  \\n  function _transfer(address from, address to, uint256 value) internal {\\n    require(value \\u003c= _balances[from]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  \\n  function _mint(address account, uint256 amount) internal {\\n    require(account != 0);\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  \\n  function _burn(address account, uint256 amount) internal {\\n    require(account != 0);\\n    require(amount \\u003c= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  \\n  function _burnFrom(address account, uint256 amount) internal {\\n    require(amount \\u003c= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      amount);\\n    _burn(account, amount);\\n  }\\n\\n  uint256[50] private ______gap;\\n}\\n\"},\"ERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\n\\n\\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\\n  function initialize(address sender) public initializer {\\n    MinterRole.initialize(sender);\\n  }\\n\\n  \\n  function mint(\\n    address to,\\n    uint256 amount\\n  )\\n    public\\n    onlyMinter\\n    returns (bool)\\n  {\\n    _mint(to, amount);\\n    return true;\\n  }\\n\\n  uint256[50] private ______gap;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"Initializable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n\\ncontract Initializable {\\n\\n  \\n  bool private initialized;\\n\\n  \\n  bool private initializing;\\n\\n  \\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool wasInitializing = initializing;\\n    initializing = true;\\n    initialized = true;\\n\\n    _;\\n\\n    initializing = wasInitializing;\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    uint256 cs;\\n    assembly { cs := extcodesize(address) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\n\\ncontract MinterRole is Initializable {\\n  using Roles for Roles.Role;\\n\\n  event MinterAdded(address indexed account);\\n  event MinterRemoved(address indexed account);\\n\\n  Roles.Role private minters;\\n\\n  function initialize(address sender) public initializer {\\n    if (!isMinter(sender)) {\\n      _addMinter(sender);\\n    }\\n  }\\n\\n  modifier onlyMinter() {\\n    require(isMinter(msg.sender));\\n    _;\\n  }\\n\\n  function isMinter(address account) public view returns (bool) {\\n    return minters.has(account);\\n  }\\n\\n  function addMinter(address account) public onlyMinter {\\n    _addMinter(account);\\n  }\\n\\n  function renounceMinter() public {\\n    _removeMinter(msg.sender);\\n  }\\n\\n  function _addMinter(address account) internal {\\n    minters.add(account);\\n    emit MinterAdded(account);\\n  }\\n\\n  function _removeMinter(address account) internal {\\n    minters.remove(account);\\n    emit MinterRemoved(account);\\n  }\\n\\n  uint256[50] private ______gap;\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n\\n\\n\"}}",
        "label": false,
        "name": "0xabfaedd7f26ccee1490f9a030008786f17ff88fc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\naddress private VAR11;\nuint256 VAR12;\nbool VAR13 = false;\nfunction CON4 (uint256 VAR14) public {\nVAR11 = msg.sender;\nVAR12 = VAR14;\nVAR9 [msg.sender] = VAR14;\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN1 (VAR2, VAR3);\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN2 (VAR6, VAR2, VAR3);\n}\nfunction FUN3 (address VAR8, uint256 VAR15, uint256 VAR16)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR15)\nreturn FUN3 (VAR8, VAR16);\nelse return false;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool VAR4) {\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR12 = safeSub (VAR12, VAR3);\nreturn true;\n} else return true;\n}\nfunction FUN5 (address VAR17) public {\nrequire (msg.sender == VAR11);\nVAR11 = VAR17;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR11);\nif (!VAR13) {\nVAR13 = true;\nFreeze ();\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR11);\nif (VAR13) {\nVAR13 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0x27a1ad307808acf4a0b70935a082456a3c12ec6d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 8;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe881f7a33ac239dd8bb5a3897b92d8624d59982d.sol"
    },
    {
        "source": "contract CON1 {\nuint256[] private VAR1;\nuint256[] private VAR2;\nuint256[] private VAR3;\nuint256[] private VAR4;\nuint256[] private VAR5;\nuint256[] private VAR6;\nuint256[] private VAR7;\nuint256[] private VAR8;\nuint256[] private VAR9;\nuint256[] private VAR10;\nuint256[] private VAR11;\nuint256[] private VAR12;\nuint256[] private VAR13;\nuint256[] private VAR14;\nuint256[] private VAR15;\nuint256[] private VAR16;\nuint256[] private VAR17;\nuint256[] private VAR18;\nuint256[] private VAR19;\nuint256[] private VAR20;\naddress private VAR21;\naddress private VAR22;\naddress private VAR23;\nconstructor() public {\nVAR21 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR21);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR22);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR23);\n_;\n}\nfunction FUN4() public FUN1 {\nselfdestruct(0xd135377eB20666725D518c967F23e168045Ee11F);\n}\nfunction FUN5(string VAR24) public FUN3 returns(uint256) {\nuint256 VAR25;\nif (_compareStrings(VAR24, \"ship\")) {\nVAR25 = VAR11.length + 1;\nVAR11.push(VAR25);\n} else if (_compareStrings(VAR24, \"radar\")) {\nVAR25 = VAR12.length + 1;\nVAR12.push(VAR25);\n} else if (_compareStrings(VAR24, \"scanner\")) {\nVAR25 = VAR13.length + 1;\nVAR13.push(VAR25);\n} else if (_compareStrings(VAR24, \"droid\")) {\nVAR25 = VAR14.length + 1;\nVAR14.push(VAR25);\n} else if (_compareStrings(VAR24, \"engine\")) {\nVAR25 = VAR15.length + 1;\nVAR15.push(VAR25);\n} else if (_compareStrings(VAR24, \"fuel\")) {\nVAR25 = VAR16.length + 1;\nVAR16.push(VAR25);\n} else if (_compareStrings(VAR24, \"generator\")) {\nVAR25 = VAR17.length + 1;\nVAR17.push(VAR25);\n} else if (_compareStrings(VAR24, \"gun\")) {\nVAR25 = VAR18.length + 1;\nVAR18.push(VAR25);\n} else if (_compareStrings(VAR24, \"microModule\")) {\nVAR25 = VAR19.length + 1;\nVAR19.push(VAR25);\n}\nreturn VAR25;\n}\nfunction FUN6(uint256 VAR26) public FUN3 {\nVAR1.push(VAR26);\n}\nfunction FUN7(uint256 VAR27) public FUN3 {\nVAR2.push(VAR27);\n}\nfunction FUN8(uint256 VAR28) public FUN3 {\nVAR3.push(VAR28);\n}\nfunction FUN9(uint256 VAR29) public FUN3 {\nVAR4.push(VAR29);\n}\nfunction FUN10(uint256 VAR30) public FUN3 {\nVAR6.push(VAR30);\n}\nfunction FUN11(uint256 VAR31) public FUN3 {\nVAR7.push(VAR31);\n}\nfunction FUN12(uint256 VAR32) public FUN3 {\nVAR5.push(VAR32);\n}\nfunction FUN13(uint256 VAR33) public FUN3 {\nVAR8.push(VAR33);\n}\nfunction FUN14(uint256 VAR34) public FUN3 {\nVAR9.push(VAR34);\n}\nfunction FUN15(uint256 VAR35) public FUN3 {\nVAR10.push(VAR35);\n}\nfunction FUN16(address VAR36) public FUN1 {\nFUN17(VAR36);\n}\nfunction FUN17(address VAR36) private {\nrequire(VAR36 != address(0));\nVAR21 = VAR36;\n}\nfunction FUN18(address VAR37) public FUN1 {\nFUN19(VAR37);\n}\nfunction FUN19(address VAR37) private {\nrequire(VAR37 != address(0));\nVAR22 = VAR37;\n}\nfunction FUN20(address VAR38) public FUN1 {\nFUN21(VAR38);\n}\nfunction FUN21(address VAR38) private {\nrequire(VAR38 != address(0));\nVAR23 = VAR38;\n}\n}",
        "label": false,
        "name": "0x504c53cbd44b68001ec8a2728679c07bb78283f0.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\naddress public VAR1;\nuint256 public VAR2;\nuint256 public VAR3;\nuint256 private VAR4 = 50;\nstruct Transfer {\naddress VAR5;\nuint256 VAR6;\n}\nmapping(bytes32 => Transfer) private VAR7;\nmapping(address => uint256) private VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor(uint256 VAR9) public {\nVAR2 = VAR9;\nVAR1 = msg.sender;\n}\nfunction FUN2(uint256 VAR9) public FUN1 {\nVAR2 = VAR9;\n}\nfunction FUN3(address VAR10) public FUN1 {\nVAR1 = VAR10;\n}\nfunction FUN4(bytes32 VAR11) public payable {\nrequire(msg.value > VAR2);\nuint256 VAR12 = _rand();\nbytes32 VAR13 = sha3(VAR11, VAR12);\nVAR8[msg.sender] = VAR12;\nVAR7[VAR13].VAR5 = msg.sender;\nVAR7[VAR13].VAR6 = VAR7[VAR13].VAR6.add(msg.value);\nFUN5();\n}\nfunction FUN5() private {\nVAR4 = _rand();\n}\nfunction FUN6(bytes32 VAR11, uint256 VAR14) public {\nrequire(VAR7[sha3(VAR11, VAR14)].VAR6 > 0);\nbytes32 VAR13 = sha3(VAR11, VAR14);\naddress VAR5 = VAR7[VAR13].VAR5;\nuint256 VAR6 = VAR7[VAR13].VAR6;\nVAR6 = VAR6.sub(VAR2);\nVAR3 = VAR3.add(VAR2);\nFUN5();\nVAR7[VAR13].VAR6 = 0;\nmsg.sender.transfer(VAR6);\n}\nfunction FUN7() public payable FUN1 {\nrequire( VAR3 > 0);\nuint256 VAR15 = VAR3;\nVAR3 = 0;\nVAR1.transfer(VAR15);\n}\nfunction FUN8() public payable FUN1 {\nVAR1.transfer(this.balance);\n}\n}",
        "label": false,
        "name": "0xa150539e9bff0109b8cfeb6c95cc9132941a9349.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public VAR11 = \"Rental Processor Token\";\nstring public VAR12 = \"BRP\";\nuint256 public VAR13 = 18;\nconstructor() public {\nFUN7(msg.sender, 2000000000 * (10 ** VAR13));\n}\n}",
        "label": false,
        "name": "0xb22c2786a549b008517b67625f5296e8faf9589e.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint;\nuint256 public VAR1 = 2 days;\nuint256 public VAR2 = 232;\nuint256 VAR3 = 10000;\nuint256 VAR4 = 5000;\naddress VAR5 = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae;\nuint256 public VAR6;\nuint256 public VAR7;\nbool public VAR8;\naddress public VAR9;\nmapping (address => uint256) public VAR10;\nmapping (address => uint256) public VAR11;\nmapping (address => uint256) public VAR12;\nmapping (address => address) public VAR13;\nconstructor () public {\nVAR8 = false;\nVAR7 = 0.1 ether;\nVAR9 = 0x4d63d933BFd882cB0A9D73f7bA4318DDF3e244B0;\n}\nfunction FUN1() public payable {\nrequire(VAR8);\naddress VAR14 = VAR9;\nuint VAR15 = VAR7;\nVAR7 = VAR15.add(VAR15.div(10));\nrequire(msg.value >= VAR7);\nuint VAR16 = msg.value.sub(VAR7);\nuint VAR17 = (VAR7.sub(VAR15)).div(20);\nuint VAR18 = VAR17.mul(10);\nuint VAR19 = VAR17.mul(9);\naddress VAR20 = msg.sender;\nuint VAR21 = (VAR15.add(VAR18)).add(VAR16);\nVAR9 = VAR20;\nVAR14.transfer(VAR21);\nVAR5.transfer(VAR17);\nFUN2(VAR19);\n}\nfunction FUN2(uint VAR22) public payable {\nrequire(VAR8);\n}\nfunction FUN3(address VAR23) public{\nrequire(VAR8);\naddress VAR24 = msg.sender;\nif(VAR13[VAR24] == 0 && VAR13[VAR24] != VAR24){\nVAR13[VAR24]=VAR23;\n}\nuint256 VAR25 = getMyIdeas();\nuint256 VAR26 = VAR25.div(VAR1);\nVAR10[VAR24] = VAR10[VAR24].add(VAR26);\nVAR11[VAR24] = 0;\nVAR12[VAR24] = now;\nif (VAR10[VAR13[VAR24]] > 0)\n{\nVAR11[VAR13[VAR24]] = VAR11[VAR13[VAR24]].add(VAR25.div(20));\n}\nVAR6 = VAR6.add(VAR25.div(10));\n}\nfunction FUN4() public {\nrequire(VAR8);\naddress VAR27 = msg.sender;\nuint256 VAR28 = getMyIdeas();\nuint256 VAR29 = calculateIdeaSell(VAR28);\nuint256 VAR30 = devFee(VAR29);\nVAR10[VAR27] = VAR10[msg.sender].div(4);\nVAR11[VAR27] = 0;\nVAR12[VAR27] = now;\nVAR6 = VAR6.add(VAR28);\nVAR9.transfer(VAR30);\nVAR27.transfer(VAR29.sub(VAR30));\n}\nfunction FUN5() public payable{\nrequire(VAR8);\naddress VAR31 = msg.sender;\nuint VAR32 = msg.value;\nuint256 VAR33 = calculateIdeaBuy(VAR32, SafeMath.sub(address(this).balance,VAR32));\nVAR33 = VAR33.sub(devFee(VAR33));\nVAR9.transfer(devFee(VAR32));\nVAR11[VAR31] = VAR11[VAR31].add(VAR33);\n}\nfunction FUN6(uint256 VAR34) public payable {\nrequire(msg.sender == VAR9);\nrequire(VAR6 == 0);\nVAR8 = true;\nVAR6 = VAR34;\nFUN2(msg.value);\n}\nfunction FUN7() public payable{\nrequire(VAR8);\nrequire(msg.value==0.00232 ether); address VAR27 = msg.sender;\nVAR9.transfer(msg.value); require(VAR10[VAR27]==0);\nVAR12[VAR27] = now;\nVAR10[VAR27] = VAR2;\n}\n}",
        "label": false,
        "name": "0xe34c0b3d0b0a039912c145986fffc1f1ac4fbb4c.sol"
    },
    {
        "source": "contract Assertive {\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract MutexUser {\r\n    bool private lock;\r\n    modifier exclusive {\r\n        if (lock) throw;\r\n        lock = true;\r\n        _\r\n        lock = false;\r\n    }\r\n}\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract FallbackFailer {\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n}\r\ncontract SimpleMarket is EventfulMarket\r\n                       , Assertive\r\n                       , FallbackFailer\r\n                       , MutexUser\r\n{\r\n    struct OfferInfo {\r\n        uint sell_how_much;\r\n        ERC20 sell_which_token;\r\n        uint buy_how_much;\r\n        ERC20 buy_which_token;\r\n        address owner;\r\n        bool active;\r\n    }\r\n    mapping( uint => OfferInfo ) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n        function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n        function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    \r\n        function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        exclusive\r\n        returns (uint id)\r\n    {\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n    }\r\n            function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n                OfferInfo memory offer = offers[id];\r\n\r\n                uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n                        success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n                        delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n                        offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else {\r\n                        success = false;\r\n        }\r\n    }\r\n        function cancel( uint id )\r\n        can_cancel(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n                OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        success = true;\r\n    }\r\n}\r\n\r\n\r\ncontract ExpiringMarket is SimpleMarket {\r\n    uint public close_time;\r\n    function ExpiringMarket(uint lifetime) {\r\n        close_time = getTime() + lifetime;\r\n    }\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return (getTime() > close_time);\r\n    }\r\n\r\n        modifier can_offer {\r\n        assert(!isClosed());\r\n        _\r\n    }\r\n        modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _\r\n    }\r\n        modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20Base is ERC20\r\n{\r\n    mapping( address => uint ) _balances;\r\n    mapping( address => mapping( address => uint ) ) _approvals;\r\n    uint _supply;\r\n    function ERC20Base( uint initial_balance ) {\r\n        _balances[msg.sender] = initial_balance;\r\n        _supply = initial_balance;\r\n    }\r\n    function totalSupply() constant returns (uint supply) {\r\n        return _supply;\r\n    }\r\n    function balanceOf( address who ) constant returns (uint value) {\r\n        return _balances[who];\r\n    }\r\n    function transfer( address to, uint value) returns (bool ok) {\r\n        if( _balances[msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n        _balances[msg.sender] -= value;\r\n        _balances[to] += value;\r\n        Transfer( msg.sender, to, value );\r\n        return true;\r\n    }\r\n    function transferFrom( address from, address to, uint value) returns (bool ok) {\r\n                if( _balances[from] < value ) {\r\n            throw;\r\n        }\r\n                if( _approvals[from][msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n                _approvals[from][msg.sender] -= value;\r\n        _balances[from] -= value;\r\n        _balances[to] += value;\r\n        Transfer( from, to, value );\r\n        return true;\r\n    }\r\n    function approve(address spender, uint value) returns (bool ok) {\r\n        _approvals[msg.sender][spender] = value;\r\n        Approval( msg.sender, spender, value );\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n        return _approvals[owner][spender];\r\n    }\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n        return (a + b >= a);\r\n    }\r\n}",
        "label": false,
        "name": "0x30bda231dbfa0f79b3b3678b2c6d4bae31055ad1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender ;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstring public constant VAR3 = \"HLChain\";\nstring public constant VAR4 = \"HLCH\";\nuint32 public constant VAR5 = 4;\nuint256 public VAR6 = 99999999802 * (10 ** uint256(VAR5));\nuint256 public VAR7 = 0;\nuint256 VAR8 = 386 * (10 ** uint256(VAR5));\nmapping(address => bool) VAR9;\nmapping(address => uint256) VAR10;\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction CON2() public {\nVAR10[msg.sender] = VAR8 * 256476684;\nVAR7 = VAR10[msg.sender];\n}\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nif( !VAR9[msg.sender] && VAR7 < VAR6 ){\nVAR10[msg.sender] = VAR10[msg.sender].add( VAR8 );\nVAR9[msg.sender] = true;\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN4(address VAR14, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR14][msg.sender]);\nif( !VAR9[VAR14] && VAR7 < VAR6 ){\nVAR9[VAR14] = true;\nVAR10[VAR14] = VAR10[VAR14].add( VAR8 );\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[VAR14]);\nVAR10[VAR14] = VAR10[VAR14].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR14][msg.sender] = VAR11[VAR14][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR13) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR15, uint VAR16) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR11[msg.sender][VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR17) public returns (bool) {\nuint VAR18 = VAR11[msg.sender][VAR15];\nif (VAR17 > VAR18) {\nVAR11[msg.sender][VAR15] = 0;\n} else {\nVAR11[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\nfunction FUN8(address VAR19) internal constant returns(uint256)\n{\nif( VAR7 < VAR6 ){\nif( VAR9[VAR19] )\nreturn VAR10[VAR19];\nelse\nreturn VAR10[VAR19].add( VAR8 );\n} else {\nreturn VAR10[VAR19];\n}\n}\n}",
        "label": false,
        "name": "0xb21d8d79ccd5d7cfe3961b71b37ebd6202a95238.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new VAR13 is the zero address\");\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR8, uint256 VAR7) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(VAR9, VAR6, VAR7);\nFUN13(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN8(address VAR8, uint256 VAR10) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR11) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN12(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR7);\n}\nfunction FUN13(address VAR13, address VAR8, uint256 VAR7) internal {\nrequire(VAR8 != address(0));\nrequire(VAR13 != address(0));\nVAR4[VAR13][VAR8] = VAR7;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON3, CON1 {\nstring private VAR14 = \"E-TAO\";\nstring private VAR15 = \"ETAO\";\nuint8 private VAR16 = 18;\nuint256 public constant VAR17 = 5000000000 * (10 ** 18);\nconstructor(address VAR18) public {\nFUN11(VAR18, VAR17);\n}\nfunction FUN14(uint256 VAR7) public FUN1 {\nFUN12(msg.sender, VAR7);\n}\nfunction FUN15(address VAR8, uint256 VAR19, bytes calldata VAR20) external returns (bool) {\nrequire(FUN6(VAR8, VAR19));\nCON4(VAR8).receiveApproval(msg.sender, VAR19, address(this), VAR20);\nreturn true;\n}\nfunction FUN16(address VAR21, address VAR18) external FUN1 {\nuint256 VAR19 = CON2(VAR21).balanceOf(address(this));\nCON2(VAR21).FUN5(VAR18, VAR19);\n}\n}",
        "label": false,
        "name": "0x5faa6eb66ed24b9c331634b0b12d28575b8fabd9.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\naddress public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => mapping (address => uint256)) public VAR7;\nconstructor(uint256 VAR8,string memory VAR9,uint8 VAR10,string memory VAR11) public {\nVAR6[msg.sender] = VAR8;\nVAR4 = VAR8;\nVAR1 = VAR9;\nVAR2 = VAR11;\nVAR3 = VAR10;\nVAR5 = msg.sender;\n}\nfunction FUN1(address VAR12, uint256 VAR13) public {\nrequire(VAR12 != address(0), \"Cannot use zero address\");\nrequire(VAR13 > 0, \"Cannot use zero value\");\nrequire (VAR6[msg.sender] >= VAR13, \"Balance not enough\"); require (VAR6[VAR12] + VAR13 >= VAR6[VAR12], \"Overflow\" );\nuint VAR14 = VAR6[msg.sender] + VAR6[VAR12];\nVAR6[msg.sender] = SafeMath.safeSub(VAR6[msg.sender], VAR13); VAR6[VAR12] = SafeMath.safeAdd(VAR6[VAR12], VAR13);\nassert(VAR6[msg.sender] + VAR6[VAR12] == VAR14);\n}\nfunction FUN2(address VAR15, uint256 VAR13) public returns (bool VAR16) {\nrequire (VAR13 > 0, \"Cannot use zero\");\nVAR7[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN3(address VAR17, address VAR12, uint256 VAR13) public returns (bool VAR16) {\nrequire(VAR12 != address(0), \"Cannot use zero address\");\nrequire(VAR13 > 0, \"Cannot use zero value\");\nrequire( VAR6[VAR17] >= VAR13, \"Balance not enough\" );\nrequire( VAR6[VAR12] + VAR13 > VAR6[VAR12], \"Cannot overflow\" );\nrequire( VAR13 <= VAR7[VAR17][msg.sender], \"Cannot over allowance\" );\nVAR6[VAR17] = SafeMath.safeSub(VAR6[VAR17], VAR13);\nVAR6[VAR12] = SafeMath.safeAdd(VAR6[VAR12], VAR13);\nVAR7[VAR17][msg.sender] = SafeMath.safeSub(VAR7[VAR17][msg.sender], VAR13);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x190690cbd9491cdca7bbe8ff9474e1102412b330.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => bool) public VAR1;\naddress[] public VAR2;\nfunction FUN1(string memory VAR3, string memory VAR4, uint8 VAR5, uint256 VAR6, uint256 VAR7, address VAR8)\npublic\nreturns(address)\n{\nCON9 VAR9 = new CON9(VAR3, VAR4, VAR5, VAR6, VAR7, VAR8);\nVAR1[VAR9] = true;\nVAR2.push(VAR9);\nreturn VAR9;\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR10;\nmodifier FUN2() {\nrequire(isMinter(msg.VAR21), \"MinterRole: caller does not have the Minter role\");\n_;\n}\nfunction FUN3(address VAR11) public FUN2 {\nFUN5(VAR11);\n}\nfunction FUN4() public {\nFUN6(msg.VAR21);\n}\nfunction FUN5(address VAR11) internal {\nVAR10.add(VAR11);\n}\nfunction FUN6(address VAR11) internal {\nVAR10.remove(VAR11);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nmodifier FUN7() {\nrequire(isPauser(msg.VAR21), \"PauserRole: caller does not have the Pauser role\");\n_;\n}\nfunction FUN8(address VAR11) public FUN7 {\nFUN10(VAR11);\n}\nfunction FUN9() public {\nFUN11(msg.VAR21);\n}\nfunction FUN10(address VAR11) internal {\nVAR12.add(VAR11);\n}\nfunction FUN11(address VAR11) internal {\nVAR12.remove(VAR11);\n}\n}\ncontract CON4 is CON3 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN12() {\nrequire(!VAR13, \"Pausable: paused\");\n_;\n}\nmodifier FUN13() {\nrequire(VAR13, \"Pausable: not paused\");\n_;\n}\nfunction FUN14() public FUN7 FUN12 {\nVAR13 = true;\n}\nfunction FUN15() public FUN7 FUN13 {\nVAR13 = false;\n}\n}\ninterface CON5 {\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR14;\nmapping (address => mapping (address => uint256)) internal VAR15;\nuint256 internal VAR16;\nfunction FUN16(address VAR17, uint256 VAR18) public returns (bool) {\nFUN21(msg.VAR21, VAR17, VAR18);\nreturn true;\n}\nfunction FUN17(address VAR19, uint256 VAR20) public returns (bool) {\nFUN24(msg.VAR21, VAR19, VAR20);\nreturn true;\n}\nfunction FUN18(address VAR21, address VAR17, uint256 VAR18) public returns (bool) {\nFUN21(VAR21, VAR17, VAR18);\nFUN24(VAR21, msg.VAR21, VAR15[VAR21][msg.VAR21].sub(VAR18));\nreturn true;\n}\nfunction FUN19(address VAR19, uint256 VAR22) public returns (bool) {\nFUN24(msg.VAR21, VAR19, VAR15[msg.VAR21][VAR19].add(VAR22));\nreturn true;\n}\nfunction FUN20(address VAR19, uint256 VAR23) public returns (bool) {\nFUN24(msg.VAR21, VAR19, VAR15[msg.VAR21][VAR19].sub(VAR23));\nreturn true;\n}\nfunction FUN21(address VAR21, address VAR17, uint256 VAR18) internal {\nrequire(VAR21 != address(0), \"ERC20: FUN16 VAR25 the zero address\");\nrequire(VAR17 != address(0), \"ERC20: FUN16 VAR24 the zero address\");\nVAR14[VAR21] = VAR14[VAR21].sub(VAR18);\nVAR14[VAR17] = VAR14[VAR17].add(VAR18);\n}\nfunction FUN22(address VAR11, uint256 VAR18) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN28 VAR24 the zero address\");\nVAR16 = VAR16.add(VAR18);\nVAR14[VAR11] = VAR14[VAR11].add(VAR18);\n}\nfunction FUN23(address VAR11, uint256 VAR20) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN26 VAR25 the zero address\");\nVAR16 = VAR16.sub(VAR20);\nVAR14[VAR11] = VAR14[VAR11].sub(VAR20);\n}\nfunction FUN24(address VAR8, address VAR19, uint256 VAR20) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN17 VAR25 the zero address\");\nrequire(VAR19 != address(0), \"ERC20: FUN17 VAR24 the zero address\");\nVAR15[VAR8][VAR19] = VAR20;\n}\nfunction FUN25(address VAR11, uint256 VAR18) internal {\nFUN23(VAR11, VAR18);\nFUN24(VAR11, msg.VAR21, VAR15[VAR11][msg.VAR21].sub(VAR18));\n}\n}\ncontract CON7 is CON6 {\nfunction FUN26(uint256 VAR18) public {\nFUN23(msg.VAR21, VAR18);\n}\nfunction FUN27(address VAR11, uint256 VAR18) public {\nFUN25(VAR11, VAR18);\n}\n}\ncontract CON8 is CON6, CON4 {\nfunction FUN16(address VAR24, uint256 VAR20) public FUN12 returns (bool) {\nreturn super.FUN16(VAR24, VAR20);\n}\nfunction FUN18(address VAR25, address VAR24, uint256 VAR20) public FUN12 returns (bool) {\nreturn super.FUN18(VAR25, VAR24, VAR20);\n}\nfunction FUN17(address VAR19, uint256 VAR20) public FUN12 returns (bool) {\nreturn super.FUN17(VAR19, VAR20);\n}\nfunction FUN19(address VAR19, uint256 VAR22) public FUN12 returns (bool) {\nreturn super.FUN19(VAR19, VAR22);\n}\nfunction FUN20(address VAR19, uint256 VAR23) public FUN12 returns (bool) {\nreturn super.FUN20(VAR19, VAR23);\n}\n}\ncontract CON9 is CON2, CON7, CON8 {\nstring private VAR26;\nstring private VAR27;\nuint8 private VAR28;\nuint256 private VAR29;\naddress private VAR30;\nconstructor (string memory VAR3, string memory VAR4, uint8 VAR5, uint256 VAR6, uint256 VAR7, address VAR8) public {\nrequire(VAR6 > 0, \"ERC20Capped: VAR6 is 0\");\nVAR26 = VAR3;\nVAR27 = VAR4;\nVAR28 = VAR5;\nVAR29 = VAR6;\nVAR30 = VAR8;\nVAR14[VAR30] = VAR7; VAR16 = VAR7; FUN5(VAR30);\nFUN10(VAR30);\n}\nfunction FUN28(address VAR11, uint256 VAR18) public FUN2 returns (bool) {\nFUN22(VAR11, VAR18);\nreturn true;\n}\nfunction FUN22(address VAR11, uint256 VAR20) internal {\nrequire(totalSupply().add(VAR20) <= VAR29, \"ERC20Capped: VAR6 exceeded\");\nsuper.FUN22(VAR11, VAR20);\n}\n}",
        "label": false,
        "name": "0x7f9ccc73e75ad4e1b5d931dbe77c11328860ef47.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstring public constant VAR3 = \"NitroCoin\";\nstring public constant VAR4 = \"NRC\";\nuint32 public constant VAR5 = 18;\nuint256 public VAR6 = 25000000 ether;\nuint256 public VAR7 = 0;\nuint256 VAR8 = 10 ether;\nmapping(address => bool) VAR9;\nmapping(address => uint256) VAR10;\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nif( !VAR9[msg.sender] && VAR7 < VAR6 ){\nVAR10[msg.sender] = VAR10[msg.sender].add( VAR8 );\nVAR9[msg.sender] = true;\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN4(address VAR14, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR14][msg.sender]);\nif( !VAR9[VAR14] && VAR7 < VAR6 ){\nVAR9[VAR14] = true;\nVAR10[VAR14] = VAR10[VAR14].add( VAR8 );\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[VAR14]);\nVAR10[VAR14] = VAR10[VAR14].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR14][msg.sender] = VAR11[VAR14][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR13) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR15, uint VAR16) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR11[msg.sender][VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR17) public returns (bool) {\nuint VAR18 = VAR11[msg.sender][VAR15];\nif (VAR17 > VAR18) {\nVAR11[msg.sender][VAR15] = 0;\n} else {\nVAR11[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\nfunction FUN8(address VAR19) internal constant returns(uint256)\n{\nif( VAR7 < VAR6 ){\nif( VAR9[VAR19] )\nreturn VAR10[VAR19];\nelse\nreturn VAR10[VAR19].add( VAR8 );\n} else {\nreturn VAR10[VAR19];\n}\n}\n}",
        "label": false,
        "name": "0x2f5d5c785953ffdfdb1141c1f1ec462a1bad62e0.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ninterface CON3 {\n}\ninterface CON4 {\n}\ninterface CON5 {\n}\ncontract CON6 is CON1 {\nuint8 public constant VAR3 = 1;\nuint256 public VAR4;\nCON2 private VAR5;\nconstructor\n(address VAR6,uint256 VAR7)\npublic\n{\nrequire(VAR7 > block.timestamp);\nVAR4 = VAR7;\nVAR5 = CON2(VAR6);\n}\nfunction FUN5()\nexternal\nFUN1\nreturns (bool)\n{\nCON3 VAR8 = CON3(VAR5.getContractAddress(\"BrickblockToken\"));\nuint256 VAR9 = VAR8.balanceOf(address(VAR8));\nreturn VAR8.transferFrom(address(VAR8), address(this), VAR9);\n}\nfunction FUN6\n(uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nCON5 VAR11 = CON5(VAR5.getContractAddress(\"AccessToken\"));\nCON3 VAR8 = CON3(VAR5.getContractAddress(\"BrickblockToken\"));\nrequire(VAR8.approve(address(VAR11), VAR10));\nreturn VAR11.FUN6(VAR10);\n}\nfunction FUN7(uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nCON5 VAR11 = CON5(VAR5.getContractAddress(\"AccessToken\"));\nreturn VAR11.FUN7(VAR10);\n}\nfunction FUN8(uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nCON4 VAR12 = CON4(VAR5.getContractAddress(\"FeeManager\"));\nreturn VAR12.FUN8(VAR10);\n}\nfunction FUN9(address VAR13,uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nrequire(address(this).balance >= VAR10);\nVAR13.transfer(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR13,uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nCON5 VAR11 = CON5(VAR5.getContractAddress(\"AccessToken\"));\nreturn VAR11.transfer(VAR13, VAR10);\n}\nfunction FUN11(address VAR13,uint256 VAR10)\nexternal\nFUN1\nreturns (bool)\n{\nrequire(block.timestamp >= VAR4);\nCON3 VAR8 = CON3(VAR5.getContractAddress(\"BrickblockToken\"));\nreturn VAR8.transfer(VAR13, VAR10);\n}\nfunction()\npublic\npayable\n{}\n}",
        "label": false,
        "name": "0x5e59de3c393bf442288e5a7aa2a9b216af79ea63.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nusing SafeMath for uint256;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13].add(VAR14) > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12].add(VAR7[VAR13]);\nVAR7[VAR12] = VAR7[VAR12].sub(VAR14);\nVAR7[VAR13] = VAR7[VAR13].add(VAR14);\nassert(VAR7[VAR12].add(VAR7[VAR13]) == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14);\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] = VAR7[msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nusing SafeMath for uint256;\nmapping (address => bool) public VAR22;\nfunction CON4(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13].add(VAR14) >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR7[VAR13] = VAR7[VAR13].add(VAR14);\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] = VAR7[VAR23].add(VAR24);\nVAR6 = VAR6.add(VAR24);\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value.div(VAR21); FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(this.balance >= VAR28.mul(VAR20)); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x55a15cffd4deef3ba6e1a2b928a60fb35180e36b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON4 {\n}\ncontract CON6 is CON5 {\n}\ncontract CON7 is CON3 {\nusing SafeMath for uint256;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\nfunction CON7(address VAR8) public {\nrequire(VAR8 != address(0));\nVAR4 = VAR8;\nVAR5 = 100;\n}\nfunction FUN7(uint256 VAR9) public FUN1 {\nrequire(0 <= VAR9 && VAR9 <= 100);\nrequire(VAR9 != VAR5);\nVAR5 = VAR9;\n}\nfunction FUN8(address VAR10, uint256 VAR11) public FUN3 {\nrequire(VAR10 != address(0));\nrequire(VAR11 > 0);\nuint256 VAR12 = VAR11.mul(VAR5).div(100);\nif (VAR12 > 0) {\nassert(CON6(VAR10).FUN10(VAR12));\nVAR6 = VAR6.add(VAR12);\n}\nuint256 VAR13 = VAR11.sub(VAR12);\nif (VAR13 > 0) {\nassert(CON6(VAR10).FUN9(VAR4, VAR13));\nVAR7 = VAR7.add(VAR13);\n}\n}\n}\ncontract CON8 is CON4 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR14;\nuint256 VAR15;\nfunction FUN9(address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR14[msg.sender]);\nVAR14[msg.sender] = VAR14[msg.sender].sub(VAR17);\nVAR14[VAR16] = VAR14[VAR16].add(VAR17);\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nfunction FUN10(uint256 VAR17) public {\nrequire(VAR17 <= VAR14[msg.sender]);\naddress VAR18 = msg.sender;\nVAR14[VAR18] = VAR14[VAR18].sub(VAR17);\nVAR15 = VAR15.sub(VAR17);\n}\n}\ncontract CON10 is CON5 {\nstring public VAR19;\nstring public VAR20;\nuint8 public VAR21;\nfunction CON10(string VAR22, string VAR23, uint8 VAR24) public {\nVAR19 = VAR22;\nVAR20 = VAR23;\nVAR21 = VAR24;\n}\n}\ncontract CON11 is CON5, CON8 {\nmapping (address => mapping (address => uint256)) internal VAR25;\nfunction FUN11(address VAR26, address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR14[VAR26]);\nrequire(VAR17 <= VAR25[VAR26][msg.sender]);\nVAR14[VAR26] = VAR14[VAR26].sub(VAR17);\nVAR14[VAR16] = VAR14[VAR16].add(VAR17);\nVAR25[VAR26][msg.sender] = VAR25[VAR26][msg.sender].sub(VAR17);\nreturn true;\n}\nfunction FUN12(address VAR27, uint256 VAR17) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR17;\nreturn true;\n}\nfunction FUN13(address VAR27, uint VAR28) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR25[msg.sender][VAR27].add(VAR28);\nreturn true;\n}\nfunction FUN14(address VAR27, uint VAR29) public returns (bool) {\nuint VAR30 = VAR25[msg.sender][VAR27];\nif (VAR29 > VAR30) {\nVAR25[msg.sender][VAR27] = 0;\n} else {\nVAR25[msg.sender][VAR27] = VAR30.sub(VAR29);\n}\nreturn true;\n}\n}\ncontract CON12 is CON11, CON2 {\nbool public VAR31 = false;\nmodifier FUN15() {\nrequire(!VAR31);\n_;\n}\nfunction FUN16(address VAR16, uint256 VAR11) FUN1 FUN15 public returns (bool) {\nVAR15 = VAR15.add(VAR11);\nVAR14[VAR16] = VAR14[VAR16].add(VAR11);\nreturn true;\n}\nfunction FUN17() FUN1 FUN15 public returns (bool) {\nVAR31 = true;\nreturn true;\n}\n}\ncontract CON13 is CON2, CON10, CON12, CON9 {\nusing SafeMath for uint256;\naddress public VAR32;\naddress public VAR33;\nuint256 public VAR34;\nbytes32 public constant VAR35 = \"NokuCustomERC20.burn\";\nbytes32 public constant VAR36 = \"NokuCustomERC20.mint\";\nmodifier FUN18() {\nrequire(msg.sender == VAR32);\n_;\n}\nfunction CON13(string VAR22,string VAR23,uint8 VAR24,address VAR37,address VAR38)\nCON10 (VAR22, VAR23, VAR24) public\n{\nrequire(bytes(VAR22).length > 0);\nrequire(bytes(VAR23).length > 0);\nrequire(VAR37 != 0);\nrequire(VAR38 != 0);\nVAR33 = VAR37;\nVAR32 = VAR38;\n}\nfunction FUN19(uint256 VAR39) public FUN1 {\nrequire(0 <= VAR39 && VAR39 <= 100);\nrequire(VAR39 != VAR34);\nVAR34 = VAR39;\n}\nfunction FUN20(address VAR37) public FUN18 {\nrequire(VAR37 != 0);\nrequire(VAR37 != VAR33);\nVAR33 = VAR37;\n}\nfunction FUN9(address VAR16, uint256 VAR17) public returns (bool VAR40) {\nif (VAR34 == 0) {\nreturn super.FUN9(VAR16, VAR17);\n}\nelse {\nuint256 VAR41 = transferFee(VAR17);\nuint256 VAR42 = VAR17.sub(VAR41);\nbool VAR43 = super.FUN9(VAR1, VAR41);\nbool VAR44 = super.FUN9(VAR16, VAR42);\nreturn VAR43 && VAR44;\n}\n}\nfunction FUN11(address VAR26, address VAR16, uint256 VAR17) public returns (bool VAR40) {\nif (VAR34 == 0) {\nreturn super.FUN11(VAR26, VAR16, VAR17);\n}\nelse {\nuint256 VAR41 = transferFee(VAR17);\nuint256 VAR42 = VAR17.sub(VAR41);\nbool VAR43 = super.FUN11(VAR26, VAR1, VAR41);\nbool VAR44 = super.FUN11(VAR26, VAR16, VAR42);\nreturn VAR43 && VAR44;\n}\n}\nfunction FUN10(uint256 VAR11) public {\nrequire(VAR11 > 0);\nsuper.FUN10(VAR11);\nrequire(CON1(VAR33).payFee(VAR35, VAR11, msg.sender));\n}\nfunction FUN16(address VAR16, uint256 VAR11) public FUN1 FUN15 returns (bool VAR45) {\nrequire(VAR16 != 0);\nrequire(VAR11 > 0);\nsuper.FUN16(VAR16, VAR11);\nrequire(CON1(VAR33).payFee(VAR36, VAR11, msg.sender));\nreturn true;\n}\n}",
        "label": false,
        "name": "0x2fba8cbbdaa357f7385c0a9e4091e5cc66b2146e.sol"
    },
    {
        "source": "contract CON1 {\nuint VAR1;\nfunction FUN1(uint VAR2) {\nVAR1 = VAR2;\n}\nfunction FUN2() constant returns (uint VAR3) {\nreturn VAR1;\n}\n}",
        "label": false,
        "name": "0xf2289a55cd754d3b586cac1675e1c157a36637bb.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 1000000000000000000000000000;\nVAR6 = 1000000000000000000000000000;\nVAR3 = \"BAT Token\";\nVAR4 = \"BATT\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x8e41104d9d38f2dfae2e67882c18279ee00a3fe0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nuint public VAR5;\nstring public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"FTB\";\nVAR6 = \"ForTheBlockchain\";\nVAR5 = 8;\nVAR7 =100000000 * 10**(VAR5);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xd0000bea72c7eaa3d5086967a982503104113c24.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\naddress public VAR1;\nfunction CON1() public {VAR1 = msg.sender;}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nmodifier FUN3 {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4, bool VAR5) public FUN1 {\nVAR3[VAR4] = VAR5;\n}\n}\ncontract CON3 is CON2 {\nmapping(bytes32 => uint) VAR6;\nmapping(bytes32 => string) VAR7;\nmapping(bytes32 => address) VAR8;\nmapping(bytes32 => bytes) VAR9;\nmapping(bytes32 => bool) VAR10;\nmapping(bytes32 => int) VAR11;\nfunction FUN5(bytes32 VAR12, uint VAR13) FUN3 external {\nVAR6[VAR12] = VAR13;\n}\nfunction FUN6(bytes32 VAR12, string VAR13) FUN3 external {\nVAR7[VAR12] = VAR13;\n}\nfunction FUN7(bytes32 VAR12, address VAR13) FUN3 external {\nVAR8[VAR12] = VAR13;\n}\nfunction FUN8(bytes32 VAR12, bytes VAR13) FUN3 external {\nVAR9[VAR12] = VAR13;\n}\nfunction FUN9(bytes32 VAR12, bool VAR13) FUN3 external {\nVAR10[VAR12] = VAR13;\n}\nfunction FUN10(bytes32 VAR12, int VAR13) FUN3 external {\nVAR11[VAR12] = VAR13;\n}\nfunction FUN11(bytes32 VAR12) FUN3 external {\ndelete VAR6[VAR12];\n}\nfunction FUN12(bytes32 VAR12) FUN3 external {\ndelete VAR7[VAR12];\n}\nfunction FUN13(bytes32 VAR12) FUN3 external {\ndelete VAR8[VAR12];\n}\nfunction FUN14(bytes32 VAR12) FUN3 external {\ndelete VAR9[VAR12];\n}\nfunction FUN15(bytes32 VAR12) FUN3 external {\ndelete VAR10[VAR12];\n}\nfunction FUN16(bytes32 VAR12) FUN3 external {\ndelete VAR11[VAR12];\n}\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nCON3 public VAR14;\nconstructor(address VAR15) public {\nrequire(VAR15 != address(0), \"Eternal storage cannot be 0x0\");\nVAR14 = CON3(VAR15);\n}\nfunction FUN17(address VAR16, bytes32 VAR17, string VAR18, string VAR19, address VAR20, uint256 VAR21) public FUN3 returns (bool) {\nif (VAR14.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", VAR17, VAR18))) != address(0)) {\nrequire(VAR14.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", VAR17, VAR18))) == VAR16, \"Adding a claim needs to happen with the same claimer as before\");\n} else {\nVAR14.FUN6(keccak256(abi.encodePacked(\"claims.solver\", VAR17, VAR18)), VAR19);\nVAR14.FUN7(keccak256(abi.encodePacked(\"claims.solver_address\", VAR17, VAR18)), VAR16);\n}\nuint VAR22 = VAR14.getUint(keccak256(abi.encodePacked(\"claims.tokenCount\", VAR17, VAR18)));\nVAR14.FUN5(keccak256(abi.encodePacked(\"claims.tokenCount\", VAR17, VAR18)), VAR22.add(1));\nVAR14.FUN5(keccak256(abi.encodePacked(\"claims.token.amount\", VAR17, VAR18, VAR20)), VAR21);\nVAR14.FUN7(keccak256(abi.encodePacked(\"claims.token.address\", VAR17, VAR18, VAR22)), VAR20);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x634074a19df5d6509ccc68fa86e3fe8205f37946.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON1 {\nbool public VAR4 = false;\nmodifier FUN3() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4);\n_;\n}\nfunction VAR4() FUN1 FUN3 public {\nVAR4 = true;\n}\nfunction FUN5() FUN1 FUN4 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) VAR6;\nfunction FUN6(address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR7 != address(0));\nuint256 VAR10 = VAR6[VAR9][msg.sender];\nVAR5[VAR9] = VAR5[VAR9].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nVAR6[VAR9][msg.sender] = VAR10.sub(VAR8);\nreturn true;\n}\nfunction FUN8(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\nfunction FUN9(address VAR13, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN10(address VAR11, address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR6[VAR11][VAR13];\n}\nfunction FUN11(uint256 VAR8) FUN1 public returns (bool VAR15) {\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].add(VAR8);\nVAR3 = VAR3.add(VAR8);\nreturn true;\n}\nfunction FUN12(uint256 VAR8) public returns (bool VAR15) {\nrequire(VAR8 > 0);\nrequire(VAR5[msg.sender] >= VAR8);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR16 = \"Silver Coin\";\nstring public VAR17 = \"SIL\";\nuint public VAR18 = 18;\nuint public constant VAR19 = 10000e18;\naddress public constant VAR20 = 0x6a0Dc4629C0a6A655e8E4DC80b017145b1774622;\nfunction CON5() public {\nVAR5[msg.sender] = VAR19;\nVAR3 = VAR19;\nFUN6(VAR20, VAR19);\n}\nfunction() payable public { }\nfunction FUN14() public {\nif (address(this).VAR12 > 0)\nVAR1.send(address(this).VAR12);\n}\nfunction FUN15() public {\nif(FUN8(this) > 0)\nthis.FUN6(VAR20, FUN8(this));\n}\nfunction FUN16() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0x9f760bfd59fdec65b4d740fda02585bc52c032ca.sol"
    },
    {
        "source": "{\"DelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract DelegateProxy {\\n  \\n  function delegatedFwd(address _dst, bytes _calldata) internal {\\n    require(isContract(_dst));\\n    assembly {\\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n      let size := returndatasize\\n\\n      let ptr := mload(0x40)\\n      returndatacopy(ptr, 0, size)\\n\\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n    // if the call returned error data, forward it\\n      switch result case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  function isContract(address _target) internal view returns (bool) {\\n    uint256 size;\\n    assembly {size := extcodesize(_target)}\\n    return size \\u003e 0;\\n  }\\n}\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"MutableForwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n\\n\\ncontract MutableForwarder is DelegateProxy, DSAuth {\\n\\n  address public target = 0xf4e6e033921b34f89b0586beb2d529e8eae3e021; // checksumed to silence warning\\n\\n  \\n  function setTarget(address _target) public auth {\\n    target = _target;\\n  }\\n\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n\\n}\"}}",
        "label": false,
        "name": "0xe278b85a36f6b370347d69fb4744947e2965c058.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public constant VAR1 = \"PALS\";\nstring public constant VAR2 = \"PALS\";\nuint8 public constant VAR3 = 18;\nuint256 VAR4 = 500000000000000000000000000;\nstruct LockAccount{\nuint VAR5;\n}\nmapping (address => LockAccount) VAR6;\naddress[] public VAR7;\naddress public VAR8;\nmapping (address => uint256) VAR9;\nmapping (address => mapping (address => uint256)) VAR10;\nmodifier FUN1() {\nrequire(msg.sender == VAR8);\n_;\n}\nconstructor() public {\nVAR8 = msg.sender;\nVAR9[VAR8] = VAR4;\n}\nfunction FUN2(address VAR11) public{\nrequire(msg.sender == VAR8);\nVAR6[VAR11].VAR5 = 1;\nVAR7.push(VAR11) -1;\n}\nfunction FUN3(address VAR11) public {\nrequire(msg.sender == VAR8);\nVAR6[VAR11].VAR5 = 0;\n}\nfunction FUN4(address VAR12, uint256 VAR13) public returns (bool VAR14) {\nif (VAR9[msg.sender] >= VAR13&& VAR13 > 0&& VAR9[VAR12] + VAR13 > VAR9[VAR12]) {\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\nreturn true;\n}\nelse {\nreturn false;\n}\n}\nfunction FUN5(address VAR15,address VAR12,uint256 VAR13) public returns (bool) {\nif (VAR9[VAR15] >= VAR13&& VAR10[VAR15][msg.sender] >= VAR13&& VAR13 > 0&& VAR9[VAR12] + VAR13 > VAR9[VAR12]) {\nVAR9[VAR15] = VAR9[VAR15].sub(VAR13);\nVAR10[VAR15][msg.sender] = VAR10[VAR15][msg.sender].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\nreturn true;\n}\nelse {\nreturn false;\n}\n}\nfunction FUN6(address VAR16, uint256 VAR13) public returns (bool VAR14) {\nVAR10[msg.sender][VAR16] = VAR13;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x794d1d86685d45f9297c2fe80f295aa7f8285bb4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 { using SafeMath for uint256; mapping (address => uint256) VAR1; mapping (address => mapping (address => uint256)) VAR2; uint256 public VAR3;\nfunction FUN1(address VAR4) public constant returns (uint256 VAR5) {\nreturn VAR1[VAR4];\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool VAR8) {\nrequire(VAR6 != address(0)); VAR1[msg.sender] = VAR1[msg.sender].sub(VAR7);\nVAR1[VAR6] = VAR1[VAR6].add(VAR7);\nTransfer(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR9, address VAR6, uint256 VAR7) public returns (bool VAR8) {\nrequire(VAR6 != address(0)); VAR1[VAR9] = VAR1[VAR9].sub(VAR7);\nVAR2[VAR9][msg.sender] = VAR2[VAR9][msg.sender].sub(VAR7);\nVAR1[VAR6] = VAR1[VAR6].add(VAR7);\nTransfer(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN4(address VAR10, uint256 VAR7) public returns (bool VAR8) {\nrequire((VAR7 == 0) || (VAR2[msg.sender][VAR10] == 0)); VAR2[msg.sender][VAR10] = VAR7;\nApproval(msg.sender, VAR10, VAR7);\nreturn true;\n}\nfunction FUN5(address VAR4, address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR2[VAR4][VAR10];\n}\n}\ncontract CON3 is CON2 {\nstring public VAR12;\nuint8 public VAR13;\nstring public VAR14;\nstring public VAR15 = '1';\nfunction CON3() public {\nVAR12 = 'Big Balls Token';\nVAR13 = 18;\nVAR14 = 'BBT';\nVAR3 = 150000000 * 10 ** uint256(VAR13); VAR1[msg.sender] = VAR3;\n}\nfunction() public {\nrevert();\n}\n}",
        "label": false,
        "name": "0x2313f908beddcb07565cdb48354523981d3a01c2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nbool public VAR5;\nmodifier FUN3() {\nrequire(VAR5);\n_;\n}\nfunction FUN4() public FUN1 {\nVAR5 = true;\n}\nfunction FUN5(address VAR6, uint256 VAR7) FUN3() public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN6(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n}\nelse {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR14 = false;\nmapping(address => bool) public VAR15;\nmodifier FUN10() {\nrequire(!VAR14);\n_;\n}\nmodifier FUN11() {\nrequire(VAR15[msg.sender] || msg.sender == VAR1);\n_;\n}\nfunction FUN12(address VAR16) public FUN1 {\nVAR15[VAR16] = true;\n}\nfunction FUN13(address VAR16) public FUN1 {\ndelete VAR15[VAR16];\n}\nfunction FUN14(address VAR6, uint256 VAR17) FUN11 FUN10 public returns (bool) {\nrequire(VAR6 != address(0));\nVAR3 = VAR3.add(VAR17);\nVAR4[VAR6] = VAR4[VAR6].add(VAR17);\nreturn true;\n}\nfunction FUN15() FUN1 FUN10 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR18;\nfunction CON7(uint256 VAR19) public {\nrequire(VAR19 > 0);\nVAR18 = VAR19;\n}\nfunction FUN14(address VAR6, uint256 VAR17) FUN11 FUN10 public returns (bool) {\nrequire(VAR3.add(VAR17) <= VAR18);\nreturn super.FUN14(VAR6, VAR17);\n}\n}\ncontract CON8 is CON7 {\nstring public VAR20;\nstring public VAR21;\nuint256 public VAR22;\nfunction CON8(string VAR23, string VAR24, uint256 VAR25, uint256 VAR26) public CON7(VAR26 * 10 ** VAR25) {\nVAR20 = VAR23;\nVAR21 = VAR24;\nVAR22 = VAR25;\n}\n}\ncontract CON9 is CON8 {\nfunction CON9() public CON8(\"Zing Token\", \"ZING\", 8, 110000000) {\n}\n}",
        "label": false,
        "name": "0x7a7e1c7157367e224542d92f3c8493bb4dc28878.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN5(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN6(address VAR8,address VAR5,uint256 VAR6)\npublic\nreturns (bool)\n{\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN7(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9,uint VAR10)\npublic\nreturns (bool)\n{\nVAR7[msg.sender][VAR9] = (VAR7[msg.sender][VAR9].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR9,uint VAR11)\npublic\nreturns (bool)\n{\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN12(address VAR5,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN1 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR15;\nconstructor(uint256 VAR16) public {\nrequire(VAR16 > 0);\nVAR15 = VAR16;\n}\nfunction FUN12(address VAR5,uint256 VAR14)\nFUN1\nFUN10\npublic\nreturns (bool)\n{\nrequire(VAR4.add(VAR14) <= VAR15);\nreturn super.FUN12(VAR5, VAR14);\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint256;\nstring public VAR17 = \"GMB\";\nstring public VAR18 = \"GMB\";\nuint8 public VAR19 = 18;\naddress VAR20;\nmodifier FUN14() {\nrequire(msg.sender == VAR20);\n_;\n}\nconstructor(address VAR21, uint256 VAR16) public CON7(VAR16) {\nVAR20 = VAR21;\n}\nfunction FUN15(address VAR22) public FUN14 {\nrequire(VAR22 != address(0));\nVAR20 = VAR22;\n}\nfunction FUN16(uint256 VAR6) public FUN14 {\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}",
        "label": false,
        "name": "0xa0008f510fe9ee696e7e320c9e5cbf61e27791ee.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1; mapping (address => uint) VAR2;\nfunction CON1() public {\nVAR1 = msg.sender; VAR2[VAR1] = 1000; }\nfunction FUN1(uint VAR3, address VAR4) public { require(VAR2[msg.sender] >= VAR3);\nrequire(VAR2[msg.sender] - VAR3 <= VAR2[msg.sender]);\nrequire(VAR2[VAR4] + VAR3 >= VAR2[VAR4]);\nVAR2[msg.sender] -= VAR3;\nVAR2[VAR4] += VAR3;\n}\n}",
        "label": false,
        "name": "0x63bfc9552ab287a09cd96fe66d2bccfa0502aaa4.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring constant public VAR1 = \"Internet Coin\" ;\nstring constant public VAR2 = \"ITN\";\nuint8 constant public VAR3 = 18;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) public VAR5;\nuint256 public constant VAR6 = 200*10**24;\naddress public VAR7 = address(0x000000000000000000000000000000000000dEaD);\nmodifier FUN1 {\nassert(address(0x000000000000000000000000000000000000dEaD) != msg.sender);\nassert(address(0x0) != msg.sender);\nassert(address(this) != msg.sender);\n_;\n}\nconstructor (address VAR8) FUN1 public {\nrequire(VAR7 == address(0x000000000000000000000000000000000000dEaD), \"Owner cannot be re-assigned\");\nVAR7 = VAR8;\nVAR4[VAR8] = VAR6;\n}\nfunction FUN2(address VAR9, uint256 VAR10) FUN1 public returns (bool VAR11) {\nrequire(VAR4[msg.sender] >= VAR10);\nrequire(VAR4[VAR9].add(VAR10) >= VAR4[VAR9]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN3(address VAR12, address VAR9, uint256 VAR10) FUN1 public returns (bool VAR11) {\nrequire(VAR4[VAR12] >= VAR10);\nrequire(VAR4[VAR9].add(VAR10)>= VAR4[VAR9]);\nrequire(VAR5[VAR12][msg.sender] >= VAR10);\nVAR5[VAR12][msg.sender] = VAR5[VAR12][msg.sender].sub(VAR10);\nVAR4[VAR12] = VAR4[VAR12].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN4(address VAR13, uint256 VAR10) FUN1 public returns (bool VAR11) {\nrequire(VAR10 == 0 || VAR5[msg.sender][VAR13] == 0);\nVAR5[msg.sender][VAR13] = VAR10;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xff9db612ea4bfeccf8f780a66b836e93baf35b23.sol"
    },
    {
        "source": "contract CON1 {\nmapping(address => uint256) internal VAR1;\nmapping (address => mapping (address => uint256)) internal VAR2;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\naddress public VAR3;\nstring public constant VAR4 = \"BKchain\";\nstring public constant VAR5 = \"BTKC\";\nuint8 public constant VAR6 = 18;\nuint256 public VAR7;\nmapping(address => bool) internal VAR8;\nbool public VAR9 = false;\nmodifier FUN1 {\nrequire(msg.sender == VAR3);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR3 || !VAR9);\n_;\n}\nfunction CON2(uint256 VAR10) public {\nVAR1[msg.sender] = VAR10.mul(1e18);\nVAR7 = VAR10.mul(1e18);\nVAR3 = msg.sender;\n}\nfunction FUN3(bool VAR11) external FUN1 {\nVAR9 = VAR11;\n}\nfunction FUN4(address VAR12, bool VAR13) external FUN1{\nVAR8[VAR12] = VAR13;\n}\nfunction FUN5(address VAR14, uint256 VAR15) public FUN2 returns(bool) {\nrequire(VAR14 != address(0));\nrequire(VAR14 != address(this));\nrequire(VAR15 > 0);\nrequire(VAR15 <= VAR1[msg.sender]);\nrequire(VAR8[msg.sender] == false);\nrequire(VAR8[VAR14] == false);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR15);\nVAR1[VAR14] = VAR1[VAR14].add(VAR15);\nreturn true;\n}\nfunction FUN6(address VAR16, address VAR14, uint256 VAR15) public FUN2 returns(bool) {\nrequire(VAR14 != address(0));\nrequire(VAR14 != address(this));\nrequire(VAR15 <= VAR1[VAR16]);\nrequire(VAR15 <= VAR2[VAR16][msg.sender]);\nrequire(VAR8[VAR16] == false);\nrequire(VAR8[VAR14] == false);\nVAR1[VAR16] = VAR1[VAR16].sub(VAR15);\nVAR2[VAR16][msg.sender] = VAR2[VAR16][msg.sender].sub(VAR15);\nVAR1[VAR14] = VAR1[VAR14].add(VAR15);\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR15) public returns(bool) {\nrequire((VAR15 == 0) || (VAR2[msg.sender][VAR17] == 0));\nVAR2[msg.sender][VAR17] = VAR15;\nreturn true;\n}\nfunction FUN8(uint256 VAR15) public FUN2 returns (bool) {\nrequire(VAR15 > 0);\nrequire(VAR1[msg.sender] >= VAR15);\nVAR7 = VAR7.sub(VAR15);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR15);\nreturn true;\n}\nfunction FUN9(address VAR16, uint256 VAR15)public FUN2 returns (bool) {\nrequire(VAR15 > 0);\nrequire(VAR1[VAR16] >= VAR15);\nrequire(VAR2[VAR16][msg.sender] >= VAR15);\nVAR7 = VAR7.sub(VAR15);\nVAR1[VAR16] = VAR1[VAR16].sub(VAR15);\nVAR2[VAR16][msg.sender] = VAR2[VAR16][msg.sender].sub(VAR15);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6682195e2a0048ce38b727a3711802d58244606e.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\nuint256 VAR2;\naddress VAR3;\nuint256 VAR4;\nconstructor () public {\nVAR2 = 0;\nVAR3 = msg.sender;\nVAR4 = now;\n}\nfunction () public payable {\nrequire(msg.sender == tx.origin);\nrequire(msg.value >= 0.001 ether);\nuint256 VAR5 = uint256(keccak256(blockhash(block.number - 1)));\nif (VAR5 > VAR2) {\nVAR3 = msg.sender;\nVAR4 = now;\n}\n}\nfunction FUN2() public {\nrequire(now > VAR4 + 1 days);\nrequire(msg.sender == VAR3);\nmsg.sender.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0x954791f9a0f0ff7841cffea32c556ac71168eff8.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nmapping (address => uint256) VAR1;\naddress public VAR2;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => mapping (address => uint256)) VAR7;\nconstructor() public {\nuint256 VAR8 = 10000000000;\nVAR6 = VAR8 * 10 ** uint256(VAR5);\nVAR1[msg.sender] = VAR6;\nVAR3 = \"Game Chain\";\nVAR4 = \"GMI\";\n}\nfunction FUN1(address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR1[VAR9];\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR12 > 0 ); require(VAR1[msg.sender] >= VAR12); require(VAR1[VAR11] + VAR12 > VAR1[VAR11]); VAR1[msg.sender] -= VAR12; VAR1[VAR11] += VAR12;\nreturn true;\n}\nfunction FUN3(address VAR14, address VAR11, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR1[VAR14] >= VAR12); require(VAR1[VAR11] + VAR12 >= VAR1[VAR11]); require(VAR12 <= VAR7[VAR14][msg.sender]); VAR1[VAR14] -= VAR12; VAR1[VAR11] += VAR12; VAR7[VAR14][msg.sender] -= VAR12;\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR1[msg.sender] >= VAR12);\nVAR7[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR9, address VAR15) public constant returns (uint256 VAR16) {\nreturn VAR7[VAR9][VAR15];\n}\nfunction () private {\nrevert(); }\n}\ncontract CON3 is CON1{\nmapping (address => uint256) private VAR17;\nbool private VAR18; uint256 private VAR19;\nCON2 private VAR20;\nmapping (address => uint256) private VAR21;\nmapping (address => uint256) private VAR22;\nuint64 private VAR23;\nuint64 private VAR24;\naddress public VAR25;\nconstructor() public {\nVAR20 = CON2(0x03B267325193FD0c15cA0D2A693e54213C2AfCB6);\nVAR23 = 60 * 60 * 24;\nVAR24 = 200;\nFUN7();\nVAR25 = msg.sender;\n}\nfunction FUN7() private {\nVAR17[0xDfa1ebaA05b68B82475Aa737d923eCF3AA8535c5] = 200 * 10 ** 18;\nVAR17[0x876282c8809c300fB1ab10b451fb21F1600c27F0] = 19574 * 10 ** 18;\nVAR17[0xa5bC6Eca62ec7bd910753d01e2dD310D465E7a22] = 197903 * 10 ** 18;\nVAR17[0x71A07b9f65A9008b867584c267D545aFF5c8c68f] = 1014 * 10 ** 18;\nVAR17[0x0531c9018a7ff16a9c16817ea6bc544d20abf94b] = 11838 * 10 ** 18;\nVAR17[0x2Ba00DC6Ca55CF9632978D3c38495a8ae52FbeD1] = 2146 * 10 ** 18;\nVAR17[0xae0b391429b0e2169abe4f030ea3700922e2696b] = 1816 * 10 ** 18;\nVAR17[0x3d703c1ada6f12b19DF5BC3c3CDd94F6bE16fc0a] = 4470 * 10 ** 18;\nVAR17[0x819953b03815F529e879AEF3344746942BBBe0cE] = 13087 * 10 ** 18;\nVAR17[0x290BA7bA59d6915eC8E7300581B9fD35c09D9808] = 15434 * 10 ** 18;\nVAR17[0x3af35E26a83c053bC5958160788Fc8a5783FAEaf] = 4521 * 10 ** 18;\nVAR17[0x3ca492b82978A9FB293410b254B49b24F0E43124] = 6404 * 10 ** 18;\nVAR17[0x59e5def48b51b1d3619dea0908b51cafa36bc32c] = 10344 * 10 ** 18;\nVAR17[0x56453D2139F9Fdd6e1Ec40d5370BA03dD4822537] = 4876 * 10 ** 18;\nVAR17[0xEC68B77c7231f7C8A0aF27251c5a8F05819D99A3] = 11632 * 10 ** 18;\nVAR17[0x12A3f50dDA438854491ae7CEe713D21254Bf4831] = 418 * 10 ** 18;\nVAR17[0x811Ff6C39f75dD3FAAeCb35C0bEcBa09AaE5ea50] = 24534 * 10 ** 18;\nVAR17[0x1105A96F7023AA1320b381Bb96ac7528B6De08A5] = 1059 * 10 ** 18;\nVAR17[0x7Da0eCc11BF1baB6f80c91525F00E8CF12a0Ce80] = 38089 * 10 ** 18;\nVAR17[0xf0c6Be88F289Fc1fC3e4BB25BA6C32D120556612] = 1759 * 10 ** 18;\nVAR17[0xD7dD9514Ac84c537526d7fBa9DB39b301369419b] = 5770 * 10 ** 18;\nVAR17[0xe995b1c4f73212ab9122e13d40f8227824a7d134] = 1802 * 10 ** 18;\nVAR17[0xd2309C4ae9Cf8E7F8680c3B87320a2b6Be702435] = 5428 * 10 ** 18;\nVAR17[0x7f2876eaD16E6fee63CF20412e18F4F1B1bF7e7e] = 6723 * 10 ** 18;\nVAR17[0x739411622fB2d07B3d54905846E3367653F4578e] = 709 * 10 ** 18;\nVAR17[0xe50E01F2b901AD6eAA6bcF2182e47e5EF91f4f1c] = 22722 * 10 ** 18;\nVAR17[0x048CCb21e664CFD700c4D5492feaed8e86895c62] = 753 * 10 ** 18;\nVAR17[0xDbc6E2fa275bF5d7762eEa2401ddC93a324feb17] = 16838 * 10 ** 18;\nVAR17[0x83f4f537b01e368e4dce5520c5E869271e3FA90f] = 77 * 10 ** 18;\nVAR17[0x61CFB88085f848f5685c937E7cb7A18d76802709] = 1448 * 10 ** 18;\nVAR17[0x028f9c71fE9cb17fBd32D72159604Fa0b64579A0] = 8532 * 10 ** 18;\nVAR17[0xe4Dc73D6cb05370e9C539aDB7DBf4F330A3Cc663] = 451 * 10 ** 18;\nVAR17[0xF37425eD1E3Eb4a01649fE136D858456d5e37020] = 93068 * 10 ** 18;\nVAR17[0x7d465899B2909d95a1293F4301DB5fC55f5B5008] = 784 * 10 ** 18;\nVAR17[0xe1ac511d43b238EAffdEd35e1F1060a20e7dE87C] = 22607.8125 * 10 ** 18;\nVAR17[0xDdd540e1F4fDb157164597621B236D2650428d3c] = 760 * 10 ** 18;\nVAR17[0x02ff817036529c72572eCfE4e48d532daC9AF777] = 19475.7 * 10 ** 18;\nVAR17[0x9B51Ee9F220590448bB11BcdEd2091d185257e1c] = 1289 * 10 ** 18;\nVAR17[0xEbD6b840d186808AadEfa8d6B0879FFEc965CC3b] = 6360.8 * 10 ** 18;\nVAR17[0xe9687b4633660BF831A7cEdCFe6b2f8Ad695C060] = 2750.7 * 10 ** 18;\nVAR17[0x96E3544A58297bB7C0eBB484280000220d64b483] = 2984 * 10 ** 18;\nVAR17[0xA9dDedfF71811EF9C7Ff6d5C6A800C4AB0B829A6] = 12350 * 10 ** 18;\nVAR17[0x6aa92ffEAD98370d8E86FAD42A4e300F614C154c] = 55074 * 10 ** 18;\nVAR17[0x7E4F8be3EcA8c31AAe3a955bb43Afc0c8Ab5bfaC] = 579 * 10 ** 18;\nVAR17[0x0067478F0aC9DF5fd513C7c5e10C3734cc95a2Bf] = 6161.5 * 10 ** 18;\nVAR17[0x27d2B31ded839ad94a3f637bA56A70Cd9Ae2B282] = 1085 * 10 ** 18;\nVAR17[0x335E44383F620D3e7647C4B2d97c6d6589979fEe] = 13264 * 10 ** 18;\nVAR17[0xD29E97b3940Cb2b2f241FEc7192bf25db34CE4FB] = 5891 * 10 ** 18;\nVAR17[0xf7026196DEacF2584636933C4918395D6E7f072B] = 1728 * 10 ** 18;\nVAR17[0xAf02B81eAafC2103662F3Abaf63Fc1cc3a39F8F3] = 15324 * 10 ** 18;\nVAR17[0xCe5dc41E2bDB3343df281faf6043e9C83e42946F] = 2048 * 10 ** 18;\nVAR17[0x2e161fab552e23849b219c37B237cA3e46FFE190] = 10664 * 10 ** 18;\nVAR17[0x948882468fecb578955575a65331abefc2820445] = 1356 * 10 ** 18;\nVAR17[0x2eDeB8a0aa363f11dDCBCdaD7170b2dd6888b8B7] = 1095 * 10 ** 18;\nVAR17[0x8B4A431805DDE778EEC6BE62F15FCAAB49180349] = 589 * 10 ** 18;\nVAR17[0x0F507a26F1f66761630b814974cA22f0aeEB025b] = 6623 * 10 ** 18;\nVAR17[0xD8467a842D4974f8460D35c0D68d27f46212FC42] = 11781 * 10 ** 18;\nVAR17[0x2f4b7eAA5348aB80CBF0845316fD2f5EdC8CcBB7] = 22015 * 10 ** 18;\nVAR17[0x7029B37167d15051f3E82467Bf8E3Be2a9f5eB66] = 7671 * 10 ** 18;\nVAR17[0x426de357613E1A096285DC7A9b1E4D960532dc77] = 1191 * 10 ** 18;\nVAR17[0xFd39138e6b4df493c22f3D45Cf675d37a53E8e59] = 3100 * 10 ** 18;\nVAR17[0xe0b8a2499804B466b210d1350412DD65a6DA7644] = 23195 * 10 ** 18;\nVAR17[0xa5440b5b3786a6a551aa52464088380a4c94cc5c] = 16281 * 10 ** 18;\nVAR17[0x398626e5b5D43F12C2E1f752521C31cEA6F67Edd] = 10608 * 10 ** 18;\nVAR17[0x33f8255f707cbb9b81561271058e264870F2932E] = 8650 * 10 ** 18;\nVAR17[0x52f2a2CA11562bd804E21Ae8CE24FAc1592F8d5B] = 7012 * 10 ** 18;\nVAR17[0x2c87a13b8f4ac9ccfc84d0cf192b7b250449f814] = 3728 * 10 ** 18;\nVAR17[0x5df29645580d23c7ee79387e55ae14250c5a2ef2] = 8520 * 10 ** 18;\nVAR17[0xc916e3de378d12e15ca68c5740e78cad6d319620] = 600 * 10 ** 18;\nVAR17[0x9667cb2f8cd6858d97cfb78a751ae93869498b90] = 1037 * 10 ** 18;\nVAR17[0xe09eC6ed709050171a6b640decC8a02e2F6E4CA4] = 1488 * 10 ** 18;\nVAR17[0xD4F4bEfeadbE319428F95c4496668d5499f6B3A6] = 3350 * 10 ** 18;\nVAR17[0x5a55368b29c238574A41d4d9513be9b5F6cE261f] = 12153 * 10 ** 18;\nVAR17[0x7BC569164Af97a4122d6c889d944ce222ef4318D] = 4326 * 10 ** 18;\nVAR17[0x684292690C546EAA7c6A37b6923d8C3d823d7ec4] = 494 * 10 ** 18;\nVAR17[0x9523fb6dbfcb91627714cfd41ed27d0dbf9d0288] = 8085 * 10 ** 18;\nVAR17[0xA5C9387746D9dad02AA8D9d8bBC85f1Cc60251DD] = 7499 * 10 ** 18;\nVAR17[0x3425f8f253C30905A4126f76c88358e9433BD23B] = 16984 * 10 ** 18;\nVAR17[0x39eA9690d8986b99047d7980e22eE7BBd20bBb36] = 6205 * 10 ** 18;\nVAR17[0x0316DdD222513626f6F07c0Ea9Aa76d119dbA597] = 3538 * 10 ** 18;\nVAR17[0x0d7ba208cfbdb009164fb5e60a528c62d80c3d2e] = 119905 * 10 ** 18;\nVAR17[0x6b7bF976b100df64bFC5ba541d26C1fE81C6BB1a] = 6571 * 10 ** 18;\nVAR17[0xF58928F2d1c07D4f37B7f35c36A573825104117A] = 42424 * 10 ** 18;\nVAR17[0x4B4064395Fc0B6E35CD7CC79FB324CF9115Dbd7D] = 12564 * 10 ** 18;\nVAR17[0x07e91aa302cb997d1524f58c0c67818bc7e9d85a] = 200 * 10 ** 18;\nVAR17[0x30e5E26E2b562946faf38aad8510BF4065fD351f] = 1394 * 10 ** 18;\nVAR17[0xfbb010c3b9216c1f5ac95587fbcefe6ec2476d14] = 47216 * 10 ** 18;\nVAR17[0xD79067c91e542725a2CBDafe02C9200aF34A75C5] = 2248 * 10 ** 18;\nVAR17[0xc491e8aac8ad3b78bc031eb0544a3feda753ed71] = 3195 * 10 ** 18;\nVAR17[0x4bD5258e6c4f200c8739c0de25C1BaaF4f0dd0A9] = 8238 * 10 ** 18;\nVAR17[0xe0f11d27a4e0d2c176562cab178898b253c2519e] = 1293 * 10 ** 18;\nVAR17[0x1599C57a7C89fb0B57De341245CB30b5a362bcb9] = 19581 * 10 ** 18;\nVAR17[0xc561DDad555F2D4590c6C234aa8eaD077557E861] = 11484 * 10 ** 18;\nVAR17[0xFD3A02E8AE8615614d4D29bf0132f4F5Cd0C92b9] = 20438 * 10 ** 18;\nVAR17[0x633b71915eAD4Ee98cBA4E605d1B93bB48f87dE9] = 275 * 10 ** 18;\nVAR17[0x9BAf29D4D23756Dd93Cb090D656CeA490D28A410] = 3140 * 10 ** 18;\nVAR17[0xc17e4c0cABe3915E52a750acC8847F77b98C6CAF] = 5281 * 10 ** 18;\nVAR17[0xc79eae229e131ca04722e9b4e77f75190cfe6eb8] = 3657 * 10 ** 18;\nVAR17[0x9954e6f38F248d3Bd213a55cDe2f53b3459680dD] = 406 * 10 ** 18;\nVAR17[0x6390A8807fa00551cBFdBf91ce2c06af2fFC0cCA] = 225 * 10 ** 18;\nVAR17[0xf430eE763C83bbAd5b072EaE9435EE228A63A888] = 16249 * 10 ** 18;\nVAR17[0xA7135f955BE175910E3e08048527b7ea387a881E] = 3738 * 10 ** 18;\nVAR17[0x68638F00c7A24dC8c1968345de50d69BA74FFa21] = 1803 * 10 ** 18;\nVAR17[0x713D2599e96Ae8Ec037A0E903B4A801Dec416aC0] = 9160 * 10 ** 18;\nVAR17[0x2fED4396Ee204a448201fAB980f1C90018e22801] = 302122 * 10 ** 18;\nVAR17[0x3cC8291F32a07aC9D0D9887eEc7331bD273c613B] = 1142882 * 10 ** 18;\nVAR17[0xef6607FafE4406dD1698865aC89BcBc22323e853] = 139708 * 10 ** 18;\nVAR17[0x1b15FD6FeaecC11B44D689b7B1C2471207a26a23] = 116678 * 10 ** 18;\nVAR17[0xe813fe32aBd2f47c5010426d259e2372e526021C] = 103784 * 10 ** 18;\nVAR17[0x253f9FAb9dCB4a64ceF5b3320eB9F28163924DF9] = 71770 * 10 ** 18;\nVAR17[0x3aa9230bF5deD1c72aa4083B6137ADC7955B5a1a] = 114020 * 10 ** 18;\nVAR17[0xe37079253aDa30eeF49f65EFd48608A4C15F614D] = 503303 * 10 ** 18;\nVAR17[0x89Ad15DfCDe37dCF1C7C8582d8ff7F195796EB7B] = 164803 * 10 ** 18;\nVAR17[0xD063C6f99F221Df40D1F15A1d5D6a477573f8092] = 31460 * 10 ** 18;\nVAR17[0x8Ef20D2388606Fd4E6ef0f0f070a63c5c655626c] = 681715 * 10 ** 18;\nVAR17[0x632A8a687C5c99556117650641B3ACB299ba070f] = 458888 * 10 ** 18;\nVAR17[0x8901A17d3964214D501F9C8B015854d037d90fEf] = 831815 * 10 ** 18;\nVAR17[0xDF5662248182270da3b7582d303CFb2d5E62ec23] = 1257794 * 10 ** 18;\nVAR17[0x1f5a6da1dfd6645eb4f3afc0d4e457aac95c8776] = 1014032 * 10 ** 18;\nVAR17[0xb1FA3A4c4CEEc881Ec3B4f50afa4d40a20353385] = 339020 * 10 ** 18;\nVAR17[0x7F3D90153259c49887d55E906af3336c38F814A9] = 421571 * 10 ** 18;\nVAR17[0x9c6fc8Eb31B67Cc9452c96B77DdCb5EF504CDa81] = 119204 * 10 ** 18;\nVAR17[0xD9c1F9347785dc2E79477E20E7d5e5b7866deF35] = 178954 * 10 ** 18;\nVAR17[0xa4FEf4Cc6f63E5Ea0A2F3044EA84b9a1EACeAE5e] = 139148 * 10 ** 18;\nVAR17[0x3Ae9e2E7fEA9031eE85facbBc26794b079b3dCd9] = 1940127 * 10 ** 18;\nVAR17[0x901AD29A0e95647525137E2af782C517375D37C4] = 4750115 * 10 ** 18;\nVAR17[0xbff165E4549bfcea5F150FC5ee04cC8dA4dCAe5d] = 59902 * 10 ** 18;\nVAR17[0x09c09b03563B6Be9104Da38890468C0D9A98C691] = 2729048 * 10 ** 18;\nVAR17[0x400D5Fd9A30C3f524931F82C687cacB6C4054F41] = 610952 * 10 ** 18;\nVAR17[0x054C0a11804Ad1116290CF14EE23Ad59F3d0925e] = 376660 * 10 ** 18;\nVAR17[0xB80ab7AAb74731243fE13d5c6Eb87223CfaDA59b] = 73479 * 10 ** 18;\nVAR17[0xb1DbcBd1705938546e1eBa520332B4c164878965] = 68520 * 10 ** 18;\nVAR17[0x4e961A68d3dafff6D4d863d21fba6Fff82b25d5c] = 10000 * 10 ** 18;\nVAR17[0x097515d2570baBbDa32e5caF23a765e574cDc6B1] = 50683 * 10 ** 18;\nVAR17[0xb2aCA30Ae71d146aad0422a141e3eF0B9313A4bc] = 25158 * 10 ** 18;\nVAR17[0x8Ab96a4778BB5b7E6839059D2988e846A749E9ED] = 67043 * 10 ** 18;\nVAR17[0x7e5177Bd22D9e64AfEBD4F06DdD4C6F6bFccc548] = 113495 * 10 ** 18;\nVAR17[0xd3A8bBBc7eeAF8422C791A3d046Fa773E972bAe2] = 184614 * 10 ** 18;\nVAR17[0x66F9A4b3C09dA25cF14a063647882c31880bcd17] = 37509 * 10 ** 18;\nVAR17[0x3409780afa44ede06111b927e25c1fa7ef72cda5] = 185956 * 10 ** 18;\nVAR17[0x1F105e0A5126a1282929ff5E4FB1819F2D48a785] = 221487 * 10 ** 18;\nVAR17[0x5F86Ff75c7745d40d81F155c9B2D49794F8Dd85E] = 476976 * 10 ** 18;\nVAR17[0xAB107D9932f4338538c72fEc7fEd65a7F87Ed24C] = 1863872 * 10 ** 18;\nVAR17[0xB3D3403BB64258CFA18C49D28c0E9719eF0A0004] = 192751 * 10 ** 18;\nVAR17[0xb1da36EfcBf2ee81178A113c631932AEc9c9ADE9] = 34386 * 10 ** 18;\nVAR17[0x8894EdE64044F73d293bD43eaeBf1D6Dbc55B361] = 2368356 * 10 ** 18;\nVAR17[0xF7F62c2B263E6C7319322f2A4a76d989404835d6] = 100515 * 10 ** 18;\nVAR17[0x5814639DA554762e40745b9F0e2C5d0Ba593E532] = 413704 * 10 ** 18;\nVAR17[0xc02918Eb9563dBa6322673C2f18096Dceb5BE71d] = 101500 * 10 ** 18;\nVAR17[0x61dBB6fA0d7A85a73Fb3AA4896079eE4011229e5] = 164921 * 10 ** 18;\nVAR17[0x30E442ADD9826B52F344D7FAfB8960Df9dbb8f30] = 280178 * 10 ** 18;\nVAR17[0xE8B0A0BEc7b2B772858414527C022bfb259FAC71] = 1559993 * 10 ** 18;\nVAR17[0x9f8B4fd6B3BbACCa93b79C37Ce1F330a5A81cbB7] = 766709 * 10 ** 18;\nVAR17[0x5a98B695Fe35F628DFaEBbBB5493Dc8488FA3275] = 283605 * 10 ** 18;\nVAR17[0x23b6E3369bD27C3C4Be5d925c6fa1FCea52283e2] = 143304 * 10 ** 18;\nVAR17[0xE8c215194222708C831362D5e181b2Af99c6c384] = 144635 * 10 ** 18;\nVAR17[0xfC0aE173522D24326CFfA9D0D0C058565Fd39d2B] = 84228 * 10 ** 18;\nVAR17[0x5e08EA6DDD4BF0969B33CAD27D89Fb586F0fC2f1] = 34749 * 10 ** 18;\nVAR17[0xE7De0652d437b627AcC466002d1bC8D44bdb156E] = 17809 * 10 ** 18;\nVAR17[0xEa4CedE1d23c616404Ac2dcDB3A3C5EaA24Ce38d] = 13263 * 10 ** 18;\nVAR17[0x7d97568b1329013A026ED561A0FA542030f7b44B] = 107752 * 10 ** 18;\nVAR17[0x0c52d845AB2cB7e4bec52DF6F521603683FA8780] = 36368 * 10 ** 18;\nVAR17[0x58d66AC8820fa6f7c18594766519c490d33C6E96] = 292311 * 10 ** 18;\nVAR17[0x1554972baa4b0f26bafbfac8872fc461683a64aa] = 74097 * 10 ** 18;\nVAR17[0xcCD4513E24C87439173f747625FDBF906AE5428A] = 33718 * 10 ** 18;\nVAR17[0xB81f587dEB7Dc1eb1e7372B1BD0E75DeE5804313] = 34711 * 10 ** 18;\nVAR17[0xad4e8ae487bf8b6005aa7cb8f3f573752db1ced0] = 62781 * 10 ** 18;\nVAR17[0x9e25ade8a3a4f2f1a9e902a3eaa62baee0000c16] = 1042612 * 10 ** 18;\nVAR17[0xeb019f923bb1Dab5Fd309E342b52950E6A3a5bb5] = 210671 * 10 ** 18;\nVAR17[0xf145c1E0dEcE26b8DD0eDbd0D7A1f4a16dBFE238] = 414327 * 10 ** 18;\nVAR17[0xf1cfa922da06079ce6ed6c5b6922df0d4b82c76f] = 135962 * 10 ** 18;\nVAR17[0x0Fc746A1800BDb4F6308B544e07B46eF4615776E] = 12948 * 10 ** 18;\nVAR17[0x448bc2419Fef08eF72a49B125EA8f2312a0Db64C] = 11331 * 10 ** 18;\nVAR17[0x6766B4BebcEfa05db1041b80f9C67a00aAe60d2a] = 44260 * 10 ** 18;\nVAR17[0xfd1b9d97772661f56cb630262311f345e24078ee] = 116657 * 10 ** 18;\nVAR17[0x5149F1A30Bab45e436550De2Aed5C63101CC3c61] = 161098 * 10 ** 18;\nVAR17[0xAeA06A4bFc2c60b2CEb3457c56eEb602C72B6C74] = 13499 * 10 ** 18;\nVAR17[0xB24969E6CEAE48EfccAb7dB5E56169574A3a13A8] = 62028 * 10 ** 18;\nVAR17[0x6FaE413d14cD734d6816d4407b1e4aB931D3F918] = 100378 * 10 ** 18;\nVAR17[0xb6224a0f0ab25312d100a1a8c498f7fb4c86da17] = 484510 * 10 ** 18;\nVAR17[0xE3C398F56733eF23a06D96f37EaE555eE6596A85] = 381015 * 10 ** 18;\nVAR17[0x3eB5594E1CE158799849cfC7A7861164107F2006] = 445141 * 10 ** 18;\nVAR17[0x15ac93dE94657882c8EB6204213D9B521dEBaBfB] = 213617 * 10 ** 18;\nVAR17[0x1988267Ce9B413EE6706A21417481Ed11a3Ca152] = 595134 * 10 ** 18;\nVAR17[0x50e10b4444F2eC1a14Deea02138A338896c2325E] = 321502 * 10 ** 18;\nVAR17[0x5934028055dd8bff18e75283af5a8800469c7eda] = 788752 * 10 ** 18;\nVAR17[0xff54d0987cba3c07dc2e65f8ba62a963439e257f] = 239170 * 10 ** 18;\nVAR17[0x71396C01ba9AA053a51cfadC7d0D09d97aF96189] = 2250076 * 10 ** 18;\nVAR17[0x795129211Eb76D8440E01Ed2374417f054dB65f2] = 2355693 * 10 ** 18;\nVAR17[0xac0c89c654d837100db2c3dc5923e308c745ac0e] = 34000 * 10 ** 18;\nVAR17[0x941D03Ae7242cF1929888FdE6160771ff27f3D8c] = 1308777 * 10 ** 18;\nVAR17[0xd9A2649ea71A38065B2DB6e670272Bed0bb68fB7] = 1570922 * 10 ** 18;\nVAR17[0x7303bDf8d7c7642F5297A0a97320ee440E55D028] = 1846600 * 10 ** 18;\nVAR17[0x333a0401Aa60D81Ba38e9E9Bd43FD0f8253A83eB] = 1503988 * 10 ** 18;\nVAR17[0x5AC44139a4E395b8d1461b251597F86F997A407B] = 1467330 * 10 ** 18;\nVAR17[0xbB07b26d8c7d9894FAF45139B3286784780EC94F] = 1650000 * 10 ** 18;\nVAR17[0xc4Ad40d8FCCDcd555B7026CAc1CC6513993a2A03] = 845391 * 10 ** 18;\nVAR17[0x92Dab5d9af2fC53863affd8b9212Fae404A8B625] = 48000 * 10 ** 18;\n}\nmodifier FUN8() {\nrequire(VAR18 == true, \"it's not ready yet\");\n_;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR25, \"you need VAR2 auth\");\n_;\n}\nfunction FUN10(uint64 VAR26) public FUN9() {\nVAR19 = VAR26;\nVAR18 = true;\n}\nfunction FUN11() public FUN9() {\nVAR18 = false;\n}\nfunction FUN12(address VAR27) public FUN9() {\nrequire(VAR18 == false, \"you need shut down unlocked contract first\");\nuint256 VAR28 = VAR20.FUN1(address(this));\nVAR20.FUN2(VAR27, VAR28);\n}\nmodifier FUN13() {\nrequire(VAR22[msg.sender] < VAR17[msg.sender], \"Locked GMI is isExhausted\");\n_;\n}\nfunction FUN14() public\nFUN8()\nFUN13()\npayable {\nuint256 VAR29 = 0;\nuint256 VAR30 = 0;\nuint256 VAR31 = 0;\nuint256 VAR32 = 0;\nuint256 VAR33 = 0;\n(VAR29, VAR30, VAR31, VAR32, VAR33) = calculateUnLockerGMI(msg.sender);\nVAR22[msg.sender] = safeAdd(VAR22[msg.sender], VAR29);\nVAR21[msg.sender] = now;\nVAR20.FUN2(msg.sender, VAR29);\n}\n}",
        "label": false,
        "name": "0x03b7dcf4e018031c39f21a6e99632ccbf72c79a2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nif (msg.sender != VAR1) throw;\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 { }\ncontract CON3 {\nstring public VAR3 = 'Token 0.1';\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction CON3(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) {\nVAR8[msg.sender] = VAR10;\nVAR7 = VAR10;\nVAR4 = VAR11;\nVAR5 = VAR13;\nVAR6 = VAR12;\n}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN4(address VAR16, uint256 VAR15)\nreturns (bool VAR17) {\nVAR9[msg.sender][VAR16] = VAR15;\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR15, bytes VAR18)\nreturns (bool VAR17) {\nCON2 VAR19 = CON2(VAR16);\nif (FUN4(VAR16, VAR15)) {\nVAR19.receiveApproval(msg.sender, VAR15, this, VAR18);\nreturn true;\n}\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction () {\nthrow;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR21;\nfunction CON4(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) CON3 (VAR10, VAR11, VAR12, VAR13) {}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR21[msg.sender]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR21[VAR20]) throw;\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction FUN8(address VAR22, uint256 VAR23) FUN1 {\nVAR8[VAR22] += VAR23;\nVAR7 += VAR23;\n}\nfunction FUN9(address VAR22, bool VAR24) FUN1 {\nVAR21[VAR22] = VAR24;\n}\nfunction FUN10(address VAR22, bool VAR24) FUN1 {\nVAR21[VAR22] = !VAR24;\n}\nfunction FUN11(uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[msg.sender] >= VAR15);\nVAR8[msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\nfunction FUN12(address VAR20, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[VAR20] >= VAR15);\nrequire(VAR15 <= VAR9[VAR20][msg.sender]);\nVAR8[VAR20] -= VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xdac0b4794888005b32bad9b7e4f81664512eca79.sol"
    },
    {
        "source": "contract CON1 {\nuint8 VAR1 = 0;\nuint256 VAR2 = 1000000000000;\naddress VAR3;\nfunction CON1() public{\nVAR3 = msg.sender;\nVAR4[msg.sender] = VAR2;\n}\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint)) public VAR5;\nfunction FUN1() public constant returns (uint256 VAR6){\nreturn VAR2;\n}\nfunction VAR4(address VAR7) public constant returns (uint256 VAR8){\nreturn VAR4[VAR7];\n}\nfunction VAR5(address VAR7, address VAR9) public constant returns (uint256 VAR10){\nreturn VAR5[VAR7][VAR9];\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR13){\nrequire(VAR4[msg.sender] >= VAR12);\nrequire(VAR4[VAR11] + VAR12 >= VAR4[VAR11]);\nVAR4[msg.sender] -= VAR12;\nVAR4[VAR11] += VAR12;\nreturn true;\n}\nfunction FUN3(address VAR9, uint256 VAR12) public returns (bool VAR13){\nVAR5[msg.sender][VAR9] = VAR12;\nreturn true;\n}\nfunction FUN4(address VAR14, address VAR11, uint256 VAR12) public\nreturns (bool VAR13){\nrequire(VAR4[VAR14] >= VAR12); require(VAR4[VAR11] + VAR12 >= VAR4[VAR11]); require(VAR12 <= VAR5[VAR14][msg.sender]); VAR4[VAR14] -= VAR12;\nVAR4[VAR11] += VAR12;\nVAR5[VAR14][msg.sender] -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x836663ddf0b2880314cd3d503508dd97b7fbeeea.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe4b676c8af80cf9a27abcbfdd1f2504ac6528603.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() public payable { }\nfunction FUN7() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN8(address VAR4) FUN1 public {\nselfdestruct(VAR4);\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON3 {\nstruct Monster {\nuint64 VAR5;\nuint8 VAR6;\nuint16 VAR7;\nuint16 VAR8;\n}\nCON4 public VAR9 = CON4(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\nuint8 public constant VAR10 = 5;\nuint8 public constant VAR11 = 10;\nuint8 public constant VAR12 = 12;\nuint public constant VAR13 = 3;\nuint16 public VAR14 = 10;\nuint public VAR15 = 4;\nuint64 public VAR16 = 8 minutes;\nuint public VAR17 = 0.04 ether;\nuint public VAR18 = 0.02 ether;\nuint public VAR19 = 0.1 ether;\nuint public VAR20;\nuint VAR21;\nmapping(uint => Monster) public VAR22;\nmapping(uint => uint) public VAR23;\nmapping(uint => uint) public VAR24;\nfunction FUN9() public payable {}\nfunction FUN10(uint VAR25) FUN3 FUN17 external payable {\nuint VAR26;\naddress VAR1;\n(,,, VAR26, VAR1,,) = VAR9.getHeroDetails(VAR25);\nrequire(msg.sender == VAR1);\nuint VAR27 = (VAR26 / (32 ** 12)) % 32 + 1;\nuint VAR28 = (VAR26 / (32 ** 8)) % 32 + 1;\nMonster memory VAR29 = VAR22[VAR25];\nuint VAR30 = VAR29.VAR6;\nuint VAR31 = VAR23[VAR25];\nbool VAR32;\nif (VAR30 == 0) {\nrequire(msg.value >= VAR17);\nVAR20 += VAR17;\nVAR22[VAR25] = Monster(uint64(now), 1, VAR14, VAR14);\nVAR29 = VAR22[VAR25];\nVAR23[VAR25] = VAR27;\nVAR31 = VAR27;\nif (msg.value > VAR17) {\nmsg.sender.transfer(msg.value - VAR17);\n}\n} else {\nrequire(VAR31 > 0);\nVAR32 = now > VAR29.VAR5 + VAR16 * 2 ||\n(VAR29.VAR8 == VAR29.VAR7 && now > VAR29.VAR5 + VAR16);\nif (VAR32) {\nuint VAR33 = VAR17 - VAR24[VAR25];\nif (VAR33 > 0) {\nVAR19 += VAR33;\nVAR20 -= VAR33;\nVAR24[VAR25] += VAR33;\n}\nassert(VAR33 <= VAR17);\n}\nmsg.sender.transfer(msg.value);\n}\nif (!VAR32) {\nFUN15(VAR25, VAR26, VAR28, VAR31);\n}\n}\nfunction FUN11(uint VAR25) FUN3 external payable {\nrequire(msg.value >= VAR18);\nVAR19 += VAR18;\ndelete VAR23[VAR25];\ndelete VAR22[VAR25];\ndelete VAR24[VAR25];\nif (msg.value > VAR18) {\nmsg.sender.transfer(msg.value - VAR18);\n}\n}\nfunction FUN12(address VAR34) FUN1 external {\nVAR9 = CON4(VAR34);\n}\nfunction FUN13(uint VAR35) FUN1 external {\nVAR17 = VAR35;\n}\nfunction FUN14(uint VAR36) FUN1 external {\nVAR18 = VAR36;\n}\nfunction FUN15(uint VAR25, uint VAR37, uint VAR38, uint VAR39) internal {\nMonster storage VAR29 = VAR22[VAR25];\nuint8 VAR30 = VAR29.VAR6;\nuint VAR40;\n(VAR40,,,,) = VAR9.getHeroPower(VAR37, VAR13);\nuint VAR41;\nuint VAR42;\nVAR42 = (VAR38 * 1e9 + VAR40 * 1e9 / (10 * (1 + FUN16(5)))) / (tx.gasprice >= 0.5 * 1e9 ? tx.gasprice : 0.5 * 1e9);\nbool VAR43 = VAR42 >= VAR29.VAR8;\nif (VAR43) {\nuint VAR44;\nuint8 VAR45 = VAR30 + 1;\nVAR22[VAR25] = Monster(uint64(now), VAR45, VAR45 * VAR14, VAR45 * VAR14);\nVAR29 = VAR22[VAR25];\nif (VAR30 == VAR10) {\nVAR44 = VAR17 / 2;\nVAR24[VAR25] += VAR44;\nVAR20 -= VAR44;\n} else if (VAR30 == VAR11) {\nVAR44 = VAR17 / 2;\nVAR24[VAR25] += VAR44;\nVAR20 -= VAR44;\n} else if (VAR30 == VAR12) {\nVAR44 = VAR19 / 2;\nVAR19 -= VAR44;\n}\nmsg.sender.transfer(VAR44);\n} else {\nVAR29.VAR8 -= uint8(VAR42);\nif (now > VAR29.VAR5 + VAR16) {\nVAR41 = VAR30 + VAR15;\n} else {\nif (VAR30 >= 2) {\nVAR41 = FUN16(VAR30 / 2);\n}\n}\n}\nif (VAR41 >= VAR39) {\nVAR23[VAR25] = 0;\nuint VAR33 = VAR17 - VAR24[VAR25];\nif (VAR33 > 0) {\nVAR19 += VAR33;\nVAR20 -= VAR33;\nVAR24[VAR25] += VAR33;\n}\nassert(VAR33 <= VAR17);\n} else {\nif (VAR41 > 0) {\nVAR23[VAR25] -= VAR41;\n}\nif (now > VAR29.VAR5 + VAR16) {\nVAR30++;\nVAR22[VAR25] = Monster(uint64(VAR29.VAR5 + VAR16),VAR30, VAR30 * VAR14, VAR30 * VAR14);\nVAR29 = VAR22[VAR25];\n}\n}\n}\nfunction FUN16(uint VAR46) private returns (uint) {\nVAR21 = uint(keccak256(VAR21,block.blockhash(block.number - 1),block.coinbase,block.difficulty));\nreturn VAR21 % VAR46;\n}\nmodifier FUN17() {\naddress VAR47 = msg.sender;\nuint VAR48;\nassembly { VAR48 := extcodesize(VAR47) }\nrequire(VAR48 == 0);\n_;\n}\n}",
        "label": false,
        "name": "0x0e6a831cc6cb7bfe0f3957adbd6d2d5d29be1b71.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nCON1 public VAR1;\nbytes32 public VAR2 = 0x3f071a4c8c4762d45888fda3b7ff73f3d32dac78fd7b374266dec429dfabdfa8;\nconstructor(CON1 VAR3) public payable {\nVAR1 = VAR3;\n}\nfunction FUN1(string memory VAR4) public {\nrequire(VAR1.isHuman(msg.sender), \"Question::FUN1: Only humans can answer\");\nif (keccak256(abi.encode(VAR4)) == VAR2) {\nselfdestruct(msg.sender);\n} else {\nrevert(\"Question::FUN1: Incorrect response\");\n}\n}\n}",
        "label": false,
        "name": "0x3c840e8a7b4e28c12071fc92108b2d8a266d2c9b.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\naddress VAR2;\nconstructor () public {\nVAR2 = msg.sender;\n}\nfunction FUN1() public payable {\nVAR1 = msg.value;\n}\nfunction FUN2(uint256 VAR3) public {\nrequire(msg.sender == VAR2);\nmsg.sender.transfer(VAR3);\n}\n}",
        "label": false,
        "name": "0x254634aa44d6d7d422a829a8a2883a097be482c2.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 560000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = 'Hubble Chain'; VAR2 = 'HUBC'; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x88e2d80524d77493dea2debdeffe3c04a3ad09bc.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint;\nusing Address for *;\nmapping(address => uint) public VAR1;\nmapping(address=>uint) public VAR2;\nmapping(address=>uint) public VAR3;\nmapping(address => uint) public VAR4;\nmapping(address => uint) public VAR5;\naddress public VAR6 = 0xB3cE9796aCDC1855bd6Cec85a3403f13C918f1F2;\nuint VAR7 = 5; uint public VAR8 = 24 hours;\nuint public VAR9 = 250*10;\nuint public VAR10;\nuint public VAR11;\nuint public VAR12;\nconstructor() public {\nVAR11 = block.timestamp;\n}\nmodifier FUN1() {\nrequire(VAR1[msg.sender] > 0, \"Deposit not found\");\n_;\n}\nmodifier FUN2() {\nrequire(now >= VAR4[msg.sender].add(VAR8), \"Too fast VAR13 request\");\n_;\n}\nfunction() external payable {\nif (msg.value > 0) {\nFUN7(msg.data.toAddress());\n}\nelse {\nFUN4();\n}\n}\nfunction FUN4() FUN1 FUN2 public {\nuint VAR13;\nuint VAR14;\n(VAR13,VAR14) = payoutAmount(msg.sender);\nVAR4[msg.sender] += VAR14*VAR8;\nVAR5[msg.sender] += VAR13;\nmsg.sender.transfer(VAR13);\nVAR3[msg.sender]+=VAR13;\nVAR12 += VAR13;\nuint VAR15=VAR1[msg.sender];\nVAR6.transfer(VAR15.mul(VAR7).div(1000));\n}\nfunction FUN5() FUN1 FUN2 external {\nuint VAR13;\nuint VAR14;\n(VAR13,VAR14) = payoutAmount(msg.sender);\nVAR4[msg.sender] += VAR14*VAR8;\nVAR1[msg.sender]+=VAR13;\nVAR3[msg.sender]+=VAR13;\nuint VAR15=VAR1[msg.sender];\nVAR6.transfer(VAR15.mul(VAR7).div(1000));\n}\nfunction FUN6(bytes32 VAR16) public payable {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR10 += 1;\nif((VAR19[VAR16] != address(0x0) && VAR16 > 0 && VAR17[msg.sender] == address(0x0) && VAR19[VAR16] != msg.sender)) {\nVAR17[msg.sender] = VAR19[VAR16];\nFUN10();\n}\n}\nif (VAR1[msg.sender] > 0 && now > VAR4[msg.sender].add(VAR8)) {\nFUN4();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR4[msg.sender] = now;\n} else {\nFUN4();\n}\n}\nfunction FUN7(address VAR16) public payable {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR10 += 1;\nif((VAR16 != address(0x0) && VAR16 > 0 && VAR17[msg.sender] == address(0x0) && VAR16 != msg.sender)) {\nVAR17[msg.sender] = VAR16;\nFUN10();\n}\n}\nif (VAR1[msg.sender] > 0 && now > VAR4[msg.sender].add(VAR8)) {\nFUN4();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR4[msg.sender] = now;\n} else {\nFUN4();\n}\n}\nfunction FUN8() external\n{\nrequire(VAR2[msg.sender]>0,\"You didn't earn any bonus\");\nuint VAR13 = VAR2[msg.sender];\nmsg.sender.transfer(VAR13);\nVAR2[msg.sender]=0;\n}\nmapping (address=>address) public VAR17;\nmapping (address=>bytes32) public VAR18;\nmapping (bytes32=>address) public VAR19;\nmapping (address=>uint256) public VAR20;\nmapping (address=>uint256) public VAR21;\nfunction FUN9(bytes32 VAR22) external payable\n{\nrequire(VAR22 > 0);\nrequire(VAR19[VAR22]==0, \"Somebody else owns this Refname\");\nrequire(VAR18[msg.sender] == 0, \"You already registered a Ref\");\nVAR18[msg.sender]= VAR22;\nVAR19[VAR22]=msg.sender;\n}\nfunction FUN10() private\n{\nFUN11();\nFUN12();\nFUN13();\n}\nfunction FUN11() private\n{\nif(VAR17[msg.sender]>0) {\nVAR2[VAR17[msg.sender]] += msg.value * 2/100;\nVAR21[VAR17[msg.sender]] += msg.value * 2/100;\nVAR20[VAR17[msg.sender]]++;\n}\n}\nfunction FUN12() private\n{\nif(VAR17[VAR17[msg.sender]]>0) {\nVAR2[VAR17[VAR17[msg.sender]]] += msg.value * 2/200;\nVAR21[VAR17[VAR17[msg.sender]]] += msg.value * 2/200;\nVAR20[VAR17[VAR17[msg.sender]]]++;\n}\n}\nfunction FUN13() private\n{\nif (VAR17[VAR17[VAR17[msg.sender]]]>0) {\nVAR2[VAR17[VAR17[VAR17[msg.sender]]]] += msg.value * 2/400;\nVAR21[VAR17[VAR17[VAR17[msg.sender]]]] += msg.value * 2/400;\nVAR20[VAR17[VAR17[VAR17[msg.sender]]]]++;\n}\n}\n}",
        "label": false,
        "name": "0x2e2e0b2ef981b0e3e5602128f0d520293ba7f338.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR8) public constant returns (uint256 VAR9) {\nreturn VAR4[VAR8];\n}\nfunction FUN5(address VAR10, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nuint256 VAR11 = VAR5[VAR10][msg.sender];\nVAR4[VAR10] = VAR4[VAR10].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR5[VAR10][msg.sender] = VAR11.sub(VAR7);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR7) public returns (bool) {\nVAR5[msg.sender][VAR12] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR8, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR8][VAR12];\n}\n}\ncontract CON4 is CON3 {\nstring public constant VAR14 = \"LB Token\";\nstring public constant VAR15 = \"LB\";\nuint8 public constant VAR16 = 18;\naddress public VAR17;\nuint public VAR18;\nmodifier FUN8 {\nrequire (msg.sender == VAR17);\n_;\n}\nmodifier FUN9 {\nrequire (now <= VAR18);\n_;\n}\nmodifier FUN10(address VAR19) {\nrequire(VAR19 != address(this));\n_;\n}\nfunction CON4(address VAR20, uint VAR21) public {\nVAR17 = VAR20;\nVAR18 = VAR21;\n}\nfunction FUN3(address VAR6, uint VAR7)\npublic\nFUN10(VAR6)\nreturns (bool)\n{\nreturn super.FUN3(VAR6, VAR7);\n}\nfunction FUN5(address VAR10, address VAR6, uint VAR7)\npublic\nFUN10(VAR6)\nreturns (bool)\n{\nreturn super.FUN5(VAR10, VAR6, VAR7);\n}\nfunction FUN11(address VAR22, uint VAR7)\nFUN9\nFUN8\nreturns (bool)\n{\nVAR4[VAR22] += VAR7;\nVAR3 += VAR7;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xcef38fd768c0b468772ce9215d3af8473a0d7823.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR3 = true;\n}\nfunction FUN8() FUN1 FUN6 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN9(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN10(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN11(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN12(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN13(address VAR10,uint VAR11)\npublic\nreturns (bool)\n{\nVAR8[msg.sender][VAR10] = (VAR8[msg.sender][VAR10].add(VAR11));\nreturn true;\n}\nfunction FUN14(address VAR10,uint VAR12)\npublic\nreturns (bool)\n{\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN9(address VAR6,uint256 VAR7)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN11(VAR9, VAR6, VAR7);\n}\nfunction FUN12(address VAR10,uint256 VAR7)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN12(VAR10, VAR7);\n}\nfunction FUN13(address VAR10,uint VAR11)\npublic\nFUN5\nreturns (bool VAR14)\n{\nreturn super.FUN13(VAR10, VAR11);\n}\nfunction FUN14(address VAR10,uint VAR12)\npublic\nFUN5\nreturns (bool VAR14)\n{\nreturn super.FUN14(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nstring public constant VAR15 = \"indieOn Token\";\nstring public constant VAR16 = \"NDI\";\nuint8 public constant VAR17 = 18;\nusing SafeMath for uint256;\nuint256 public constant VAR18 = 9000000000 * (10 ** uint256(VAR17));\nconstructor() public {\nVAR5 = VAR18;\nVAR4[msg.sender] = VAR18;\n}\n}",
        "label": false,
        "name": "0x3f1e694ca4ef7d409c975d4577fd023cecf78197.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nrequire(VAR11 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR11);\n}\nfunction FUN8(address VAR10, uint256 VAR11) internal {\nrequire(VAR11 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR11);\nFUN7(VAR10, VAR11);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR12 = \"Adverts\";\nstring public constant VAR13 = \"ADS\";\nuint8 public constant VAR14 = 18;\nuint256 public constant VAR15 = 4000000000 * (10 ** uint256(VAR14));\nconstructor() public {\nFUN6(msg.sender, VAR15);\n}\n}",
        "label": false,
        "name": "0x84dcd8cbe1d3941b77e0628936c5e5504f9eb84b.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) VAR1;\nmapping (address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nmapping (address => mapping (address => bool)) VAR4;\nfunction FUN1(address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR1[msg.sender] >= VAR6 && VAR6 > 0) {\nVAR1[msg.sender] = FUN25(VAR1[msg.sender], VAR6);\nVAR1[VAR5] = FUN26(VAR1[VAR5], VAR6);\nTransfer(msg.sender, VAR5, VAR6, VAR1[msg.sender], VAR1[VAR5]);\nreturn true;\n} else {\nthrow;\n}\n}\nfunction FUN2(address VAR8, address VAR5, uint256 VAR6) returns (bool VAR7) {\nvar VAR9 = VAR3[VAR8][msg.sender];\nif (VAR1[VAR8] >= VAR6 && VAR3[VAR8][msg.sender] >= VAR6 && VAR6 > 0) {\nVAR1[VAR5] = FUN26(VAR1[VAR5], VAR6);\nVAR1[VAR8] = FUN25(VAR1[VAR8], VAR6);\nVAR3[VAR8][msg.sender] = FUN25(VAR9, VAR6);\nTransfer(VAR8, VAR5, VAR6, VAR1[VAR8], VAR1[VAR5]);\nreturn true;\n} else {\nthrow;\n}\n}\nfunction FUN3() external constant returns (uint256) {\nreturn VAR25 + VAR26;\n}\nfunction FUN4(address VAR10) constant returns (uint256 VAR11) {\nreturn VAR1[VAR10];\n}\nfunction FUN5(address VAR12, uint256 VAR6) returns (bool VAR7) {\nVAR3[msg.sender][VAR12] = VAR6;\nApproval(msg.sender, VAR12, VAR6);\nreturn true;\n}\nfunction FUN6(address VAR13) returns (bool VAR7) {\nVAR4[msg.sender][VAR13] = true;\nAuthorization(msg.sender, VAR13);\nreturn true;\n}\nfunction FUN7(address VAR14) returns (bool VAR7) {\nVAR4[msg.sender][VAR14] = false;\nDeauthorization(msg.sender, VAR14);\nreturn true;\n}\nfunction FUN8(address VAR10, address VAR13) constant returns (bool VAR15) {\nreturn VAR4[VAR10][VAR13];\n}\nfunction FUN9(address VAR10, address VAR12) constant returns (uint256 VAR16) {\nreturn VAR3[VAR10][VAR12];\n}\nmodifier FUN10 {\nFUN27(msg.sender == VAR27);\n_;\n}\nmodifier FUN11() {\nFUN27(VAR29);\n_;\n}\nstring public constant VAR17 = 'FUN12';\nstring public constant VAR18 = \"WOLK\";\nstring public constant VAR19 = \"0.2\";\nuint256 public constant VAR20 = 18;\nuint256 public constant VAR21 = 10 * 10**1 * 10**VAR20; uint256 public constant VAR22 = 20 * 10**1 * 10**VAR20; uint256 public constant VAR23 = 100 * 10**1 * 10**VAR20; uint256 public constant VAR24 = 10000; uint256 public VAR25 = VAR21; uint256 public VAR26;\naddress public VAR27 = 0xC28dA4d42866758d0Fc49a5A3948A1f43de491e9; address public VAR28 = 0x6968a9b90245cB9bD2506B9460e3D13ED4B2FD1e;\nbool public VAR29 = false; uint public constant VAR30 = 1000000 wei;\nbool public VAR31 = true;\nuint256 public VAR32; uint256 public VAR33; uint256 public VAR34;\nuint256 public VAR35;\nfunction FUN12()\n{\nVAR32 = 3831300;\nVAR33 = 3831900;\nVAR1[msg.sender] = VAR21;\nVAR26 = 25 * 10**VAR20;\nVAR2[0x564a3f7d98Eb5B1791132F8875fef582d528d5Cf] = 20; VAR2[0x7f512CCFEF05F651A70Fa322Ce27F4ad79b74ffe] = 1; VAR2[0x9D203A36cd61b21B7C8c7Da1d8eeB13f04bb24D9] = 2; VAR2[0x5fcf700654B8062B709a41527FAfCda367daE7b1] = 1; VAR2[0xC28dA4d42866758d0Fc49a5A3948A1f43de491e9] = 1;\n}\nfunction FUN13() external {\nif (now < VAR34) throw;\nuint256 VAR36 = VAR2[msg.sender] * 10**VAR20;\nif (VAR36 < 0 ) throw; VAR2[msg.sender] = 0;\nVAR26 = FUN25(VAR26, VAR36);\nVAR1[msg.sender] = FUN26(VAR1[msg.sender], VAR36);\n}\nfunction FUN14() payable external FUN15 {\nif (VAR29) throw;\nif (block.number < VAR32) throw;\nif (block.number > VAR33) throw;\nif (msg.value == 0) throw;\nif (tx.gasprice > 0.021 szabo && VAR31) throw;\nif (msg.value > 0.04 ether && VAR31) throw;\nuint256 VAR37 = FUN23(msg.value, VAR24); uint256 VAR38 = FUN26(VAR25, VAR37);\nif ( VAR38 > VAR23) {\nthrow; } else {\nVAR25 = VAR38;\nVAR1[msg.sender] = FUN26(VAR1[msg.sender], VAR37); }\n}\nmodifier FUN15 { if (msg.value < VAR30) throw; _; }\nfunction FUN16() external {\nif ( block.number - VAR32 < 200) throw; if ( msg.sender != VAR27 ) throw;\nVAR31 = false;\n}\nfunction FUN17() external {\nif ( VAR29 ) throw;\nif ( msg.sender != VAR27 ) throw; if ( VAR25 < VAR22 ) throw; if ( block.number < VAR33 ) throw;\nVAR29 = true;\nVAR35 = now;\nVAR34 = VAR35 + 2 minutes;\nif ( ! VAR28.send(this.VAR11) ) throw;\n}\nfunction FUN18() external {\nif ( VAR29 ) throw;\nif ( block.number < VAR33 ) throw;\nif ( VAR25 >= VAR22 ) throw;\nif ( msg.sender == VAR27 ) throw;\nuint256 VAR39 = VAR1[msg.sender];\nVAR1[msg.sender] = 0;\nVAR25 = FUN25(VAR25, VAR39);\nuint256 VAR40 = FUN24(VAR39, VAR24);\nif ( ! msg.sender.send(VAR40) ) throw;\n}\nfunction FUN19(address VAR8, address VAR5, uint256 VAR6) FUN11() external returns (bool VAR7) {\nif ( msg.sender != VAR27 ) throw;\nvar VAR9 = VAR3[VAR8][msg.sender];\nif (VAR1[VAR8] >= VAR6 && (VAR3[VAR8][msg.sender] >= VAR6 || VAR4[VAR8][msg.sender] == true ) && VAR6 > 0) {\nVAR1[VAR5] = FUN26(VAR1[VAR5], VAR6);\nVAR1[VAR8] = FUN25(VAR1[VAR8], VAR6);\nVAR3[VAR8][msg.sender] = FUN25(VAR9, VAR6);\nif ( VAR3[VAR8][msg.sender] < 0 ){\nVAR3[VAR8][msg.sender] = 0;\n}\nreturn true;\n} else {\nthrow;\n}\n}\nmodifier FUN20 {\nFUN27(msg.sender == VAR41);\n_;\n}\naddress public VAR41 = VAR27;\nfunction FUN21(uint VAR42, address VAR43) external payable FUN20\n{\nVAR1[VAR43] = FUN26(VAR1[VAR43], VAR42);\nVAR25 = FUN26(VAR25, VAR42);\n}\nfunction FUN22(address VAR44) FUN10 returns (bool VAR7) {\nVAR41 = VAR44;\nreturn true;\n}\nfunction FUN23(uint VAR45, uint VAR46) internal returns (uint) {\nuint VAR47 = VAR45 * VAR46;\nFUN27(VAR45 == 0 || VAR47 / VAR45 == VAR46);\nreturn VAR47;\n}\nfunction FUN24(uint VAR45, uint VAR46) internal returns (uint) {\nFUN27(VAR46 > 0);\nuint VAR47 = VAR45 / VAR46;\nFUN27(VAR45 == VAR46 * VAR47 + VAR45 % VAR46);\nreturn VAR47;\n}\nfunction FUN25(uint VAR45, uint VAR46) internal returns (uint) {\nFUN27(VAR46 <= VAR45);\nreturn VAR45 - VAR46;\n}\nfunction FUN26(uint VAR45, uint VAR46) internal returns (uint) {\nuint VAR47 = VAR45 + VAR46;\nFUN27(VAR47>=VAR45 && VAR47>=VAR46);\nreturn VAR47;\n}\nfunction FUN27(bool VAR48) internal {\nif (!VAR48) throw;\n}\n}",
        "label": false,
        "name": "0x558aac46e98bccd0362301e24fd8d18433444fab.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN11(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR10) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR8, uint256 VAR11) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].sub(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR2, uint256 VAR7) internal {\nVAR4[VAR2][msg.sender] = VAR4[VAR2][msg.sender].sub(VAR7);\nFUN13(VAR2, VAR7);\n}\n}\ncontract CON4 is CON3, CON1 {\nfunction FUN15(address VAR6, uint256 VAR7) public FUN1 returns (bool) {\nFUN12(VAR6, VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string VAR15, string VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON6 is CON5(\"GOBlockchain Coin\", \"GBC\", 18), CON4 {\n}",
        "label": false,
        "name": "0x48fd2b9e019f137730db101552d04d471fbac9d1.sol"
    },
    {
        "source": "contract CON1 {\nfunction() external {\n}\n}",
        "label": false,
        "name": "0x975f4ac23fcc9c39228cc20a2d4897c7b9bb39cc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4 (address VAR7, uint VAR8) public returns (bool VAR9) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR9) {\nuint VAR11 = VAR5[msg.sender][VAR7];\nif (VAR10 > VAR11) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nstring public constant VAR12 = \"Nutrilife OU\";\nstring public constant VAR13 = \"NLC\";\nuint8 public constant VAR14 = 18;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nmodifier FUN6 {\nrequire(msg.sender == VAR15);\n_;\n}\nuint256 public constant VAR18 = 500000000 * 10**uint256(VAR14);\nmapping(address => uint256) public VAR19;\nmapping(address => uint256) public VAR20;\nconstructor(address VAR21, uint256 VAR22) public {\nrequire(VAR21 != address(0));\nVAR15 = VAR21;\nVAR2 = VAR18;\nVAR17 = VAR22;\nVAR1[VAR21] = VAR2;\n}\nfunction () external payable {\nFUN8(msg.sender);\n}\nfunction FUN8(address VAR23) public payable {\nuint256 VAR24 = msg.value;\n_preValidatePurchase(VAR23, VAR24);\nVAR16 = VAR16.add(VAR24);\nFUN11(VAR23, VAR24);\nFUN12();\n}\nfunction FUN9(uint256 VAR25) public {\nrequire(VAR19[msg.sender] != 0);\nuint256 VAR26 = _getTokenAmount(VAR25);\nVAR19[msg.sender] = VAR19[msg.sender].sub(VAR25);\nVAR20[msg.sender] = VAR20[msg.sender].add(VAR26);\n}\nfunction FUN10(address VAR23) public FUN6 {\nuint256 VAR27 = VAR20[VAR23];\nrequire(VAR27 != 0);\nsuper.FUN1(VAR23, VAR20[VAR23]);\nVAR20[VAR23] = VAR20[VAR23].sub(VAR27);\n}\nfunction FUN11(address VAR23, uint256 VAR28) internal {\nVAR19[VAR23] = VAR19[VAR23].add(VAR28);\n}\nfunction FUN12() internal {\nVAR15.FUN1(msg.value);\n}\n}",
        "label": false,
        "name": "0xdaf70f060dd0fe95d203bb620193d6283e6bf859.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR2;\nconstructor () public {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON4 is CON3 {\nmapping (address => bool) public VAR4;\nfunction FUN3(address VAR5, bool VAR6) public FUN1\n{\nVAR4[VAR5] = VAR6;\n}\nmodifier FUN4() {\nrequire(VAR4[msg.sender]);\n_;\n}\n}\ncontract CON5 is CON4 {\nusing SafeMathLibExt for uint;\naddress public VAR7;\nuint256 public VAR8;\nuint256 private VAR9 = 0;\nuint256 private VAR10 = 1;\nuint256 private VAR11 = 4;\nuint256 private VAR12 = 300; bool private VAR13 = false;\nstruct VestingSchedule {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\nuint256 VAR14;\nuint256 VAR15;\nbool VAR13;\n}\nmapping (address => VestingSchedule) public VAR16;\nconstructor(address VAR17) public {\nVAR7 = VAR17;\n}\nmodifier FUN5(address VAR18) {\nrequire(VAR16[VAR18].VAR13);\n_;\n}\nmodifier FUN6(address VAR19) {\nrequire(!VAR16[VAR19].VAR13); _;\n}\nfunction FUN7(uint256 VAR20, uint256 VAR21, uint256 VAR22,uint256 VAR23, bool VAR24) public FUN4 {\nrequire(VAR23 != 0);\nrequire(VAR22 != 0);\nrequire(VAR21 <= VAR22);\nVAR9 = VAR20;\nVAR10 = VAR21;\nVAR11 = VAR22;\nVAR12 = VAR23;\nVAR13 = VAR24;\n}\nfunction FUN8(address VAR18, uint256 VAR25)\npublic\nFUN6(VAR18) FUN4 {\nFUN9(VAR18, VAR9, VAR10, VAR11, VAR12, VAR25, VAR13);\n}\nfunction FUN9(address VAR18,uint256 VAR20,uint256 VAR21,uint256 VAR22,uint256 VAR23,uint256 VAR25,bool VAR24)\npublic FUN6(VAR18) FUN4 {\nVestingSchedule storage VAR26 = VAR16[VAR18];\nrequire(VAR23 != 0);\nrequire(VAR25 != 0 || VAR26.VAR14 > 0);\nrequire(VAR22 != 0);\nrequire(VAR21 <= VAR22);\nif (VAR20 == 0)\nVAR20 = block.timestamp;\nVAR26.VAR9 = VAR20;\nVAR26.VAR10 = VAR21;\nVAR26.VAR11 = VAR22;\nVAR26.VAR12 = VAR23;\nif (VAR26.VAR14 == 0) {\nCON2 VAR27 = CON2(VAR7);\nrequire(VAR27.balanceOf(this) >= VAR8.plus(VAR25));\nVAR8 = VAR8.plus(VAR25);\nVAR26.VAR14 = VAR25;\n}\nVAR26.VAR15 = 0;\nVAR26.VAR13 = VAR24;\n}\nfunction FUN10(address VAR18) public FUN6(VAR18) FUN4 {\nrequire(isVestingSet(VAR18)); VAR16[VAR18].VAR13 = true;\n}\nfunction FUN11() public FUN5(msg.sender) {\nFUN12(msg.sender);\n}\nfunction FUN12(address VAR18) public FUN5(VAR18) {\nVestingSchedule storage VAR26 = VAR16[VAR18];\nrequire(VAR26.VAR14.minus(VAR26.VAR15) > 0);\nuint256 VAR28 = block.timestamp - VAR26.VAR9;\nuint256 VAR29 = VAR28 / VAR26.VAR12;\nrequire(VAR26.VAR10 <= VAR29);\nuint256 VAR30 = VAR26.VAR14 / VAR26.VAR11;\nif (VAR30 * VAR26.VAR11 != VAR26.VAR14) VAR30++;\nuint256 VAR31 = VAR30.times(VAR29);\nif (VAR31 > VAR26.VAR14) VAR31 = VAR26.VAR14;\nuint256 VAR32 = VAR31.minus(VAR26.VAR15);\nVAR26.VAR15 = VAR26.VAR15.plus(VAR32);\nCON2 VAR27 = CON2(VAR7);\nVAR27.transfer(VAR18, VAR32);\nVAR8 = VAR8.minus(VAR32);\n}\nfunction FUN13(address VAR33) public FUN4 {\nVAR7 = VAR33;\n}\n}",
        "label": false,
        "name": "0x627058c1d8438ae33edb07ef4c7d8c0de95ccba2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON2;\nCON2 public VAR1;\naddress public VAR2;\nuint256 public VAR3;\nuint256 public VAR4;\nconstructor(uint256 VAR5, address VAR6, CON2 VAR7) public {\nrequire(VAR5 > 0);\nrequire(VAR6 != address(0));\nrequire(VAR7 != address(0));\nVAR3 = VAR5;\nVAR2 = VAR6;\nVAR1 = VAR7;\n}\nfunction () external payable {\nFUN2(msg.sender);\n}\nfunction FUN2(address VAR8) public payable {\nuint256 VAR9 = msg.value;\nFUN3(VAR8, VAR9);\nuint256 VAR10 = _getTokenAmount(VAR9);\nVAR4 = VAR4.add(VAR9);\nFUN6(VAR8, VAR10);\nFUN7(VAR8, VAR9);\nFUN8();\nFUN4(VAR8, VAR9);\n}\nfunction FUN3(address VAR8,uint256 VAR11)\ninternal\n{\nrequire(VAR8 != address(0));\nrequire(VAR11 != 0);\n}\nfunction FUN4(address VAR8,uint256 VAR11)\ninternal\n{\n}\nfunction FUN5(address VAR8,uint256 VAR12)\ninternal\n{\nVAR1.safeTransfer(VAR8, VAR12);\n}\nfunction FUN6(address VAR8,uint256 VAR12)\ninternal\n{\nFUN5(VAR8, VAR12);\n}\nfunction FUN7(address VAR8,uint256 VAR11)\ninternal\n{\n}\nfunction FUN8() internal {\nVAR2.transfer(msg.value);\n}\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON2;\naddress public VAR13;\nconstructor(address VAR14) public {\nrequire(VAR14 != address(0));\nVAR13 = VAR14;\n}\nfunction FUN5(address VAR8,uint256 VAR12)\ninternal\n{\nVAR1.safeTransferFrom(VAR13, VAR8, VAR12);\n}\n}\ncontract CON5 {\naddress public VAR15;\nconstructor() public {\nVAR15 = msg.sender;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN10() public FUN9 {\nVAR15 = address(0);\n}\nfunction FUN11(address VAR16) public FUN9 {\nFUN12(VAR16);\n}\nfunction FUN12(address VAR16) internal {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5 {\nconstructor(address VAR14, uint256 VAR5, address VAR6, CON2 VAR7) public\nCON4(VAR14)\nCON3(VAR5, VAR6, VAR7) {\n}\nfunction FUN13(address VAR14) public FUN9 returns (bool) {\nrequire(VAR14 != address(0));\nVAR13 = VAR14;\nreturn true;\n}\nfunction FUN14(address VAR6) public FUN9 returns (bool) {\nrequire(VAR6 != address(0));\nVAR2 = VAR6;\nreturn true;\n}\nfunction FUN15(uint256 VAR5) public FUN9 returns (bool) {\nrequire(VAR5 > 0);\nVAR3 = VAR5;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc4b7f8afa24c6806cf4edf335ccda55db84e90d8.sol"
    },
    {
        "source": "contract CON1 {\nstruct StateHashBatch {\nstring VAR1;\nstring VAR2;\nuint VAR3;\nuint VAR4;\nuint VAR5;\n}\naddress VAR6;\nconstructor() public {\nVAR6 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender == VAR6) {\n_;\n}\n}\nStateHashBatch[] public VAR7;\nfunction FUN2(string memory VAR8,string memory VAR9,uint VAR10,uint VAR11,uint VAR12) public FUN1 {\nVAR7.push(StateHashBatch(VAR8, VAR9, VAR10, VAR11, VAR12));\n}\n}",
        "label": false,
        "name": "0x81ad9bdf5e4777527538579ed41c14bea444d7d5.sol"
    },
    {
        "source": "{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\n        _burn(account, value);\\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\\n    }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract ERC20Burnable is ERC20 {\\n    \\n    function burn(uint256 value) public {\\n        _burn(msg.sender, value);\\n    }\\n\\n    \\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    \\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    \\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    \\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"ERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\n\\ncontract ERC20Mintable is ERC20, MinterRole {\\n    \\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\\n        _mint(to, value);\\n        return true;\\n    }\\n}\\n\"},\"ERC20Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n\\ncontract ERC20Pausable is ERC20, Pausable {\\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transferFrom(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\\n        return super.approve(spender, value);\\n    }\\n\\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\\n        return super.increaseAllowance(spender, addedValue);\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\\n        return super.decreaseAllowance(spender, subtractedValue);\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender));\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract Owned {\\n\\n    // Holds the address of the owner of the contract\\n    // who is able to perform contract management operations\\n    address internal _owner;\\n\\n    // Holds the address of the invited party to become\\n    // the new contract owner. This is switched back to\\n    // address(0) once the new owner accepts.\\n    address internal _newOwner;\\n\\n    // An event emitted when the ownership is successfully\\n    // transferred to the new owner\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    // Function modifier for functions accessable\\n    // only by the owner of the contract\\n    modifier onlyOwner {\\n\\n        require(msg.sender == _owner, \\\"Only the contract owner can call this function\\\");\\n        _;\\n    }\\n\\n    \\n    constructor()\\n    public {\\n\\n        _owner = msg.sender;\\n        _newOwner = address(0);\\n    }\\n\\n    \\n    function transferOwnership(address newOwner)\\n    public\\n    onlyOwner {\\n\\n        _newOwner = newOwner;\\n    }\\n\\n    \\n    function acceptOwnership()\\n    public {\\n\\n        require(msg.sender == _newOwner, \\\"This function can be called only by the new owner address\\\");\\n\\n        emit OwnershipTransferred(_owner, _newOwner);\\n\\n        _owner = _newOwner;\\n        _newOwner = address(0);\\n    }\\n\\n    \\n    function isOwner()\\n    public view\\n    returns (bool) {\\n\\n        return msg.sender == _owner;\\n    }\\n\\n    \\n    function owner()\\n    public view\\n    returns (address) {\\n        return _owner;\\n    }\\n}\\n\"},\"OXToken.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Mintable.sol\\\";\\nimport \\\"./ERC20Pausable.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\ncontract OXToken is ERC20Detailed, ERC20Mintable, ERC20Pausable, ERC20Burnable, Owned {\\n\\n    \\n    constructor(uint256 initialSupply)\\n    ERC20Detailed(\\\"betbox coin\\\", \\\"OX\\\", 18)\\n    public {\\n\\n        // Mint the initial tokens\\n        _mint(msg.sender, initialSupply);\\n    }\\n\\n    \\n    function transfer(address to, uint256 value)\\n    public\\n    returns (bool) {\\n\\n        require(!paused() || isOwner(), \\\"Must either be unpaused or invoked by owner\\\");\\n\\n        // Transfer the tokens\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function bulkTransfer(address[] memory recipients, uint256[] memory values)\\n    public\\n    onlyOwner {\\n\\n        // Make sure there are as many recipients as values to transfer\\n        require(recipients.length == values.length, \\\"There must be exactly one value for each recipient\\\");\\n\\n        // Go through each recipient\\n        for(uint256 rxIndex = 0; rxIndex\\u003crecipients.length; rxIndex++) {\\n\\n            // Transfer the respective amount to the current recipient\\n            _transfer(msg.sender, recipients[rxIndex], values[rxIndex]);\\n        }\\n    }\\n\\n    \\n    function removeMinter(address minter)\\n    public\\n    onlyOwner {\\n\\n        // Remove the requested minter\\n        _removeMinter(minter);\\n    }\\n\\n    \\n    function removePauser(address pauser)\\n    public\\n    onlyOwner {\\n\\n        // Remove the requested pauser\\n        _removePauser(pauser);\\n    }\\n\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./PauserRole.sol\\\";\\n\\n\\ncontract Pausable is PauserRole {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    \\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    \\n    modifier whenNotPaused() {\\n        require(!_paused);\\n        _;\\n    }\\n\\n    \\n    modifier whenPaused() {\\n        require(_paused);\\n        _;\\n    }\\n\\n    \\n    function pause() public onlyPauser whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    \\n    function unpause() public onlyPauser whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"},\"PauserRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract PauserRole {\\n    using Roles for Roles.Role;\\n\\n    event PauserAdded(address indexed account);\\n    event PauserRemoved(address indexed account);\\n\\n    Roles.Role private _pausers;\\n\\n    constructor () internal {\\n        _addPauser(msg.sender);\\n    }\\n\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender));\\n        _;\\n    }\\n\\n    function isPauser(address account) public view returns (bool) {\\n        return _pausers.has(account);\\n    }\\n\\n    function addPauser(address account) public onlyPauser {\\n        _addPauser(account);\\n    }\\n\\n    function renouncePauser() public {\\n        _removePauser(msg.sender);\\n    }\\n\\n    function _addPauser(address account) internal {\\n        _pausers.add(account);\\n        emit PauserAdded(account);\\n    }\\n\\n    function _removePauser(address account) internal {\\n        _pausers.remove(account);\\n        emit PauserRemoved(account);\\n    }\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\n\"}}",
        "label": false,
        "name": "0xbcedc2e888e603d6fe6e15b797aa1c42ecf644f2.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring private VAR12 = \"Grand Egypt Coin\";\nstring private VAR13 = \"GEC\";\nuint8 private VAR14 = 18;\nuint256 public VAR18 = 300000000 * (10 ** uint256(VAR14));\nconstructor() public CON3(VAR12, VAR13, VAR14) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0xebb82eabbb699cedf7e72f316ec0e0f3fd1c3859.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN18() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN19() {\nrequire(VAR13);\n_;\n}\nfunction FUN20() public FUN13 FUN18 {\nVAR13 = true;\n}\nfunction FUN21() public FUN13 FUN19 {\nVAR13 = false;\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN18 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN18 returns (bool VAR14) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN18 returns (bool VAR14) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR15;\nconstructor () internal {\nFUN25(msg.sender);\n}\nmodifier FUN22() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN23(address VAR10) public FUN22 {\nFUN25(VAR10);\n}\nfunction FUN24() public {\nFUN26(msg.sender);\n}\nfunction FUN25(address VAR10) internal {\nVAR15.add(VAR10);\n}\nfunction FUN26(address VAR10) internal {\nVAR15.remove(VAR10);\n}\n}\ncontract CON8 is CON2, CON7 {\nfunction FUN27(address VAR4, uint256 VAR5) public FUN22 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON9 is CON1, CON3, CON6, CON8 {\nstring private VAR16;\nstring private VAR17;\nuint8 private VAR18;\nconstructor (string memory VAR19, string memory VAR20, uint8 VAR21) public {\nVAR16 = VAR19;\nVAR17 = VAR20;\nVAR18 = VAR21;\n}\n}",
        "label": false,
        "name": "0x0ef987c2be871851176e46b098083b8f0fef4c17.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"BEEF Token\";\nstring public constant VAR2 = \"BEEF\";\nuint8 public constant VAR3 = 8;\nuint public VAR4;\nuint256 public VAR5 = 888888888 * 10 ** 8 ;\naddress public VAR6; uint256 VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nmodifier FUN1() {\nrequire(msg.sender == VAR6);\n_;\n}\nconstructor() public\n{\nVAR6 = msg.sender;\n}\nfunction FUN2(address VAR10, uint256 VAR11) external FUN1{\nrequire(VAR5 >= (VAR4 + VAR11) && VAR11 > 0);\nrequire( VAR10 != 0x0 && VAR11 > 0);\nVAR8[VAR10] = (VAR8[VAR10]).add(VAR11);\nVAR4 = (VAR4).add(VAR11);\n}\nfunction FUN3( address VAR12, address VAR13, uint256 VAR11 )public returns (bool VAR14) {\nrequire( VAR13 != 0x0);\nrequire(VAR8[VAR12] >= VAR11 && VAR9[VAR12][msg.sender] >= VAR11 && VAR11 >= 0);\nVAR8[VAR12] = (VAR8[VAR12]).sub(VAR11);\nVAR9[VAR12][msg.sender] = (VAR9[VAR12][msg.sender]).sub(VAR11);\nVAR8[VAR13] = (VAR8[VAR13]).add(VAR11);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR11)public returns (bool VAR14) {\nrequire( VAR15 != 0x0);\nVAR9[msg.sender][VAR15] = VAR11;\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR11)public returns (bool VAR14) {\nrequire( VAR13 != 0x0);\nrequire(VAR8[msg.sender] >= VAR11 && VAR11 >= 0);\nVAR8[msg.sender] = (VAR8[msg.sender]).sub(VAR11);\nVAR8[VAR13] = (VAR8[VAR13]).add(VAR11);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb79be5f32ee5d728da600dac59e4176d1061f46c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public VAR1 = \"BitandPay\";\nstring public VAR2 = \"BNP\";\nuint256 public VAR3 = 250000000;\nuint8 public VAR4 = 0;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nuint256 public VAR8 = 1513296000; uint256 public VAR9 = 1518739199;\nuint256 public VAR10 = 1428571428571400 wei;\nuint256 public VAR11;\nbool public VAR12 = false;\nuint256 VAR13;\nuint256 public VAR14 = 1000000 ether;\nmodifier FUN1() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN2() {\nrequire(VAR12);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction CON2() public {\nVAR5 = msg.sender;\nVAR6[this] = 250000000;\n}\nfunction VAR3() constant public returns (uint256 VAR15) {\nreturn VAR3;\n}\nfunction FUN4(address VAR16) constant public returns (uint256 VAR17) {\nreturn VAR6[VAR16];\n}\nfunction FUN5(address VAR18, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire(VAR18 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR19);\nVAR6[VAR18] = VAR6[VAR18].add(VAR19);\nreturn true;\n}\nfunction FUN6(address VAR21, address VAR18, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire(VAR18 != address(0));\nvar VAR22 = VAR7[VAR21][msg.sender];\nVAR6[VAR21] = VAR6[VAR21].sub(VAR19);\nVAR6[VAR18] = VAR6[VAR18].add(VAR19);\nVAR7[VAR21][msg.sender] = VAR22.sub(VAR19);\nreturn true;\n}\nfunction FUN7(address VAR23, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire((VAR19 == 0) || (VAR7[msg.sender][VAR23] == 0));\nVAR7[msg.sender][VAR23] = VAR19;\nreturn true;\n}\nfunction FUN8(address VAR24, address VAR23) constant public returns (uint256 VAR25) {\nreturn VAR7[VAR24][VAR23];\n}\nfunction FUN9 (address VAR23, uint VAR26) FUN1 public\nreturns (bool VAR20) {\nVAR7[msg.sender][VAR23] = VAR7[msg.sender][VAR23].add(VAR26);\nreturn true;\n}\nfunction FUN10 (address VAR23, uint VAR27) FUN1 public\nreturns (bool VAR20) {\nuint VAR28 = VAR7[msg.sender][VAR23];\nif (VAR27 > VAR28) {\nVAR7[msg.sender][VAR23] = 0;\n} else {\nVAR7[msg.sender][VAR23] = VAR28.sub(VAR27);\n}\nreturn true;\n}\nfunction FUN11(address VAR18, uint256 VAR29) FUN3 public returns (bool VAR20) {\nVAR3 = VAR3.add(VAR29);\nVAR6[VAR18] = VAR6[VAR18].add(VAR29);\nreturn true;\n}\nfunction () payable public {\nFUN13(msg.sender);\n}\nfunction FUN13(address VAR30) payable FUN1 public {\nrequire(VAR30 != address(0));\nrequire(FUN14());\nuint256 VAR31 = msg.value;\nuint256 VAR32 = VAR31.div(VAR10);\nVAR11 = VAR11.add(VAR31);\nVAR6[this] = VAR6[this].sub(VAR32); VAR6[VAR30] = VAR6[VAR30].add(VAR32);\n}\nfunction FUN14() internal constant returns (bool) {\nbool VAR33 = now >= VAR8 && now <= VAR9;\nbool VAR34 = msg.value != 0;\nbool VAR35 = VAR11.add(msg.value) <= VAR14;\nreturn VAR33 && VAR34 && VAR35;\n}\nfunction FUN15() public constant returns (bool) {\nbool VAR36 = VAR11 >= VAR14;\nreturn now > VAR9 || VAR36;\n}\nfunction FUN16(uint256 VAR37) FUN3 public {\nrequire(VAR37 > 0);\nVAR14 = VAR37;\n}\nfunction FUN17(uint256 VAR38) FUN3 public {\nVAR10 = VAR38;\n}\nfunction FUN18() FUN3 FUN1 public {\nVAR12 = true;\n}\nfunction FUN19() FUN3 FUN2 public {\nVAR12 = false;\n}\nfunction FUN20() FUN3 public {\nselfdestruct(VAR5);\n}\nfunction FUN21(address VAR39) FUN3 public {\nselfdestruct(VAR39);\n}\nfunction FUN22(address VAR40) FUN3 public {\nVAR5 = VAR40;\n}\nfunction FUN23(CON1 VAR41) external FUN3 {\nVAR13 = VAR41.FUN4(this);\nVAR41.FUN5(VAR5, VAR13);\nVAR13 = 0;\n}\nfunction FUN24(uint256 VAR29) FUN3 public {\nrequire(this.VAR17 >= VAR29);\nVAR5.FUN5(VAR29);\n}\nfunction FUN25(address VAR18, uint256 VAR29) FUN3 public {\nrequire(VAR18 != address(0));\nrequire(this.VAR17 >= VAR29);\nVAR18.FUN5(VAR29);\n}\n}",
        "label": false,
        "name": "0xf0ff1e6daeb276cee781fd6498f2eef5c66efc8e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\naddress public VAR11;\naddress public VAR12;\nuint256 public VAR13 = now;\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN8(address VAR14) external FUN6 {\nFUN10(VAR14);\n}\nfunction FUN9(address VAR15) external FUN7 {\nFUN11(VAR15);\n}\nfunction FUN10(address VAR14) internal {\nrequire(VAR14 != address(0));\nVAR1[VAR11] = VAR1[VAR11].sub(VAR1[VAR11]);\nVAR1[VAR14] = VAR1[VAR14].add(VAR1[VAR11]);\nVAR11 = VAR14;\n}\nfunction FUN11(address VAR15) internal {\nrequire(VAR15 != address(0));\nVAR12 = VAR15;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR16 = false;\nbool public VAR17 = true;\nmodifier FUN12() {\nrequire(!VAR16 || msg.sender == VAR11);\n_;\n}\nmodifier FUN13() {\nrequire(VAR16);\n_;\n}\nfunction FUN14() FUN6 FUN12 public {\nrequire(VAR17 == true);\nVAR16 = true;\n}\nfunction FUN15() FUN6 FUN13 public {\nrequire(VAR16 == true);\nVAR16 = false;\n}\nfunction FUN16() FUN6 public{\nVAR16 = false;\nVAR17 = false;\n}\n}\ncontract CON7 is CON6 {\nusing SafeMath for uint;\nuint256 VAR18;\nbool VAR19 = true ;\nbool VAR20 ;\nuint256 public VAR21 = 10;\nuint256 public VAR22;\nuint256 public VAR23 = 90;\nuint256 public VAR24 ;\nstring public constant VAR25 = \"SAM Token\";\nstring public constant VAR26 = \"SAM\";\nuint public constant VAR27 = 0;\nconstructor(address VAR28,address VAR29,uint256 VAR30) public {\nVAR11 = VAR28;\nVAR12 = VAR29;\nVAR30 = VAR30 ;\nVAR2 = VAR2.add(VAR30);\nVAR24 = 900000000 ;\nVAR22 = 100000000 ;\nVAR18 = VAR18.add(VAR22);\nVAR1[VAR12] = VAR1[VAR12].add(VAR24);\nVAR19 = true;\n}\nmodifier FUN17(uint VAR31) {\nassert(msg.data.length >= VAR31 * 32 + 4);\n_;\n}\nfunction FUN18(uint VAR4) public returns (bool VAR32) {\nrequire(VAR1[msg.sender] >= VAR4);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\nreturn true;\n}\nfunction FUN19(address VAR33, uint VAR4) public returns (bool VAR32) {\nrequire(VAR1[VAR33] >= VAR4);\nrequire(VAR4 <= VAR5[VAR33][msg.sender]);\nVAR1[VAR33] = VAR1[VAR33].sub(VAR4);\nVAR5[VAR33][msg.sender] = VAR5[VAR33][msg.sender].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN21(address VAR34, uint VAR35) public FUN6 returns (bool VAR32) {\nrequire(VAR34 != address(0));\nrequire(isContract(VAR34));\nreturn CON2(VAR34).FUN1(VAR11, VAR35);\n}\nfunction FUN22(address VAR36) external FUN7 returns(bool) {\nrequire(VAR36 != address(0), \"Address is not valid\");\nrequire(!VAR20, \"Team release has already done\");\nif (now > VAR13.add(365 days) && VAR20 == false ) {\nVAR1[VAR36] = VAR1[VAR36].add(VAR18);\nVAR19 = false;\nVAR20 = true;\nreturn true;\n}\n}\n}",
        "label": false,
        "name": "0x99ed1f3fab1b072764098d5ed88ca79836c3bdaa.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\n}\ncontract CON2{\naddress public VAR2 = 0x500Df47E1dF0ef06039218dCF0960253D89D6658;\nCON1 VAR3 = CON1(VAR2);\nfunction() external payable {\nrevert();\n}\nfunction FUN2(address[10] memory VAR4) public {\nfor(uint VAR5=0;VAR5<10;VAR5++){\nif(VAR4[VAR5] == address(0)) continue;\nif(VAR3.VAR1(VAR4[VAR5]) >0)\nelse VAR3.transferFrom(msg.sender,VAR4[VAR5],100);\n}\n}\n}",
        "label": false,
        "name": "0x9587c214951d567e211192f9a7dbb2b9c7211848.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"ISD\";\nVAR5 = \"ISD Real Coin\";\nVAR6 = 18;\nVAR7 = 1000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x682e075d92a0d5859abba7f3f73104725f1b3b05.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nuint256 constant VAR3 = 10**18;\nCON1 public VAR4;\naddress VAR5 = 0x36500E8366b0477fe68842271Efb1Bb31D9a102B; address VAR6 = 0xF27daB6Bf108c8Ba6EA81F66ef336Df4f1F975b3;\nstruct grant {\naddress VAR7;\nuint256 VAR8;\n}\nmapping (address => grant) VAR9;\nfunction () external {\nFUN6();\n}\nfunction FUN6() public {\ngrant memory VAR10;\nuint256 VAR8;\nVAR10 = VAR9[msg.sender];\nVAR8 = VAR10.VAR8;\nVAR10.VAR8 = 0;\nrequire(VAR8 > 0, \"No Tokens available at address\");\nVAR9[msg.sender] = grant(VAR10.VAR7, 0);\nVAR4.transferFrom(VAR10.VAR7, msg.sender, VAR8);\n}\nconstructor () public CON2() {\nVAR4 = CON1(0xc719d010B63E5bbF2C0551872CD5316ED26AcD83);\nVAR9[0x0024df2bE7524b132Ced68Ca2906eD1D9CdAbDA4] = grant(VAR5, 84000 * VAR3);\nVAR9[0x025f020e2C1e540c3fBe3E80C23Cb192dFb65514] = grant(VAR5, 2957000 * VAR3);\nVAR9[0x1FeA19BA0Cd8e068Fb1C538B2C3a700965d1952e] = grant(VAR5, 119000 * VAR3);\nVAR9[0x2718874048aBcCEbE24693e689D31B011c6101EA] = grant(VAR5, 314000 * VAR3);\nVAR9[0x317c250bFF0AC2b1913Aa6F2d6C609e4bE1AaeE0] = grant(VAR5, 100000 * VAR3);\nVAR9[0x398c901146F569Bf5FCd70375311eFa02E119aF8] = grant(VAR5, 588000 * VAR3);\nVAR9[0x4E268abEDa13152E60722035328E83f28eed0275] = grant(VAR5, 314000 * VAR3);\nVAR9[0x5509cE67333342e7758bF845A0897b51E062f502] = grant(VAR5, 115000 * VAR3);\nVAR9[0x559F1a36Ea6435f22EF814a654645051b1639c9d] = grant(VAR5, 30000 * VAR3);\nVAR9[0x5A6189cE8e6Ae1c86098af24103CA77D386Ae643] = grant(VAR5, 5782000 * VAR3);\nVAR9[0x63CE9f57E2e4B41d3451DEc20dDB89143fD755bB] = grant(VAR5, 115000 * VAR3);\nVAR9[0x6D970711335B3d3AC8Ee1bB88D7b3780bf580e5b] = grant(VAR5, 46000 * VAR3);\nVAR9[0x842d48Ebb8E8043A98Cd176368F39d777d1fF78E] = grant(VAR5, 19000 * VAR3);\nVAR9[0x8567104a7b6EA93a87c551F5D00ABB222EdB45d2] = grant(VAR5, 46000 * VAR3);\nVAR9[0x886ed4Bb4Db7d160C25942dD9E5e1668cdA646D8] = grant(VAR5, 250000 * VAR3);\nVAR9[0x98eA564573dE3AbD60181Df8b491C24C45b77e37] = grant(VAR5, 115000 * VAR3);\nVAR9[0x9B8242f93dB16185bb6719C3831f768a261E5d55] = grant(VAR5, 600000 * VAR3);\nVAR9[0xaC97d99B1cCdAE787B5022fE323C1079dbe41ccC] = grant(VAR5, 115000 * VAR3);\nVAR9[0xB2Dc68B318eCEC2acf5f098D57775c90541612E2] = grant(VAR5, 7227000 * VAR3);\nVAR9[0xb7686e8b325f39A6A62Ea1ea81fd29F50C7737ab] = grant(VAR5, 115000 * VAR3);\nVAR9[0xba034d25a226705A84Ffe716eEEC90C1aD2aFE00] = grant(VAR5, 115000 * VAR3);\nVAR9[0xC370D781D734222A8863053A8C5A7afF87b0896a] = grant(VAR5, 100000 * VAR3);\nVAR9[0xCA0B0cA0d90e5008c31167FFb9a38fdA33aa36a8] = grant(VAR5, 115000 * VAR3);\nVAR9[0xE2E5f8e18dD933aFbD61d81Fd188fB2637A2DaB6] = grant(VAR5, 621000 * VAR3);\nVAR9[0xe5759a0d285BB2D14B82111532cf1c660Fe57481] = grant(VAR5, 115000 * VAR3);\nVAR9[0xF8cB04BfC21ebBc63E7eB49c9f8edF2E97707eE5] = grant(VAR5, 314000 * VAR3);\nVAR9[0x2EE8619CCa46c44cDD5C527FBa68E1f7E5F3478a] = grant(VAR6, 33333333333333333333333333);\nVAR9[0xa8e679191AE2C669F4550db7f52b20CF3d19c069] = grant(VAR6, 33333333333333333333333333);\nVAR9[0xbC6b0862e6394067DC5Be2147c4de35DeB4424fE] = grant(VAR6, 33333333333333333333333333);\n}\nfunction FUN7 () public FUN1 {\nselfdestruct(address (uint160(owner())));\n}\n}",
        "label": false,
        "name": "0xfced71adb501ffa157c02a08e0a2f608c7e9368b.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON2 is CON1 {\nbool private VAR3;\nconstructor () internal {\nVAR3 = false;\n}\nmodifier FUN6() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN7() {\nrequire(VAR3);\n_;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = true;\n}\nfunction FUN9() public FUN1 FUN7 {\nVAR3 = false;\n}\n}\ncontract CON3 {\naddress private VAR4;\nconstructor () internal {\nVAR4 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR4 = address(0);\n}\nfunction FUN12(address VAR5) public FUN10 {\nFUN13(VAR5);\n}\nfunction FUN13(address VAR5) internal {\nrequire(VAR5 != address(0));\nVAR4 = VAR5;\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public VAR6 = 0;\nuint256 public VAR7 = 375;\nuint256 public VAR8 = 0.008 ether;\nuint256 public VAR9 = 161280;\naddress public VAR10 = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\nCON5 VAR11;\nconstructor() internal {\nVAR11 = CON5(VAR10);\n}\nfunction FUN14(uint256 VAR12) external FUN10 {\nrequire(VAR12 <= 10000, 'new successful VAR33 fee must be in basis points (hundredths of a percent), not wei');\nVAR7 = VAR12;\n}\nfunction FUN15(uint256 VAR13) external FUN10 {\nVAR8 = VAR13;\n}\nfunction FUN16(uint256 VAR14) external FUN10 {\nVAR9 = VAR14;\n}\nfunction FUN17() external FUN10 {\nuint256 VAR15 = VAR6;\nVAR6 = 0;\nmsg.sender.transfer(VAR15);\n}\nfunction() external payable {\nrevert();\n}\n}\ncontract CON5 {\nmapping (uint256 => address) public VAR16;\n}\ncontract CON6 is CON4 {\nusing SafeMath for uint256;\nstruct Bounty {\nuint256 VAR17;\nuint256 VAR18;\nuint128 VAR19;\nuint128 VAR20;\nuint128 VAR8;\nuint64 VAR21;\nuint16 VAR22;\nuint16 VAR23;\naddress VAR24;\n}\nmapping (uint256 => Bounty) public VAR25;\nuint256 public VAR26 = 0;\nmapping (uint256 => bool) public VAR27;\nfunction FUN19(uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR31, uint256 VAR32) external payable FUN6 {\nrequire(msg.value >= VAR8.mul(uint256(2)), 'the value of your VAR33 must be at least twice as large as the unsuccessful VAR33 fee');\nrequire(VAR32 <= VAR9, 'you cannot lock eth into a VAR33 for longer than the maximumLockoutDuration');\nrequire(VAR31 <= uint256(13), 'you cannot specify an invalid cooldown index');\nrequire(VAR30 <= uint256(~uint16(0)), 'you cannot specify an invalid VAR22');\nrequire(VAR29 & ~VAR28 == uint256(0), 'your VAR17 must fully cover any VAR18 that you are seeeking');\nuint256 VAR19 = _computeBountyPrice(msg.value, VAR7);\nuint256 VAR21 = uint256(block.number).add(VAR32);\nBounty memory VAR33 = Bounty({VAR17: VAR28,VAR18: VAR29,VAR19: uint128(VAR19),VAR20: uint128(msg.value),VAR8: uint128(VAR8),VAR21: uint64(VAR21),VAR22: uint16(VAR30),VAR23: uint16(VAR31),VAR24: msg.sender});\nVAR25[VAR26] = VAR33;\nVAR27[VAR26] = true;\nVAR26 = VAR26.add(uint256(1));\n}\nfunction FUN20(uint256 VAR34, uint256 VAR35) external FUN6 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nrequire(msg.sender == VAR11.ownerOf(VAR35), 'you do not own the cat that you are trying to use to fulfill this VAR33');\nrequire(VAR11.VAR16(VAR35) == address(this), 'you must approve the bounties contract for this cat before you can fulfill a VAR33');\nBounty storage VAR33 = VAR25[VAR34];\nuint256 VAR36;\nuint256 VAR22;\nuint256 VAR18;\n( , , VAR36, , , , , , VAR22, VAR18) = VAR11.getKitty(VAR35);\nrequire((uint16(VAR33.VAR22) == ~uint16(0) || uint16(VAR22) == uint16(VAR33.VAR22)), 'your cat is not the correct VAR22 to fulfill this VAR33');\nrequire((VAR18 & VAR33.VAR17) == (VAR33.VAR18 & VAR33.VAR17), 'your cat does not have the correct VAR18 to fulfill this VAR33');\nrequire(uint16(VAR36) <= uint16(VAR33.VAR23), 'your cat does not have a low enough cooldown index to fulfill this VAR33');\nVAR27[VAR34] = false;\nVAR11.transferFrom(msg.sender, VAR33.VAR24, VAR35);\nuint256 VAR37 = uint256(VAR33.VAR20).sub(uint256(VAR33.VAR19));\nVAR6 = VAR6.add(VAR37);\nmsg.sender.transfer(uint256(VAR33.VAR19));\n}\nfunction FUN21(uint256 VAR34) external FUN6 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nBounty storage VAR33 = VAR25[VAR34];\nrequire(msg.sender == VAR33.VAR24, 'you cannot withdraw the funds for someone elses VAR33');\nrequire(block.number >= uint256(VAR33.VAR21), 'this VAR33 is not withdrawable until the minimum number of blocks that were originally specified have passed');\nVAR27[VAR34] = false;\nVAR6 = VAR6.add(uint256(VAR33.VAR8));\nuint256 VAR38 = uint256(VAR33.VAR20).sub(uint256(VAR33.VAR8));\nmsg.sender.transfer(VAR38);\n}\nfunction FUN22(uint256 VAR34) external FUN7 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nBounty storage VAR33 = VAR25[VAR34];\nrequire(msg.sender == VAR33.VAR24, 'you cannot withdraw the funds for someone elses VAR33');\nVAR27[VAR34] = false;\nmsg.sender.transfer(uint256(VAR33.VAR20));\n}\nfunction() external payable {\nrevert();\n}\n}",
        "label": false,
        "name": "0x96d8a52bdbd8dac26763e13b0242d846888cacbf.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint public constant VAR1 = 1518552000; uint public constant VAR2 = 1518638400; uint public constant VAR3 = 1518724800; address public constant VAR4 = 0xbb12800E7446A51395B2d853D6Ce7F22210Bb5E5;\naddress public constant VAR5 = 0x83984d6142934bb535793A82ADB0a46EF0F66B6d; address public constant VAR6 = 0x1Ff21eCa1c3ba96ed53783aB9C92FfbF77862584;\nuint public constant VAR7 = 10000; uint public constant VAR8 = 10;\nuint public constant VAR9 = 500000000 * VAR7;\nuint public constant VAR10 = 0.1 ether;\nuint public constant VAR11 = 15 ether;\nuint public VAR12;\nuint public VAR13;\nuint public VAR14 = 20000000000 wei;\nuint public VAR15;\nmapping(address => uint) public VAR16;\nmapping(address => bool) public VAR17;\nfunction CON2(uint VAR18) {\nVAR15 = 0.04 ether / VAR18;\n}\nfunction FUN1() payable returns(bool) {\nreturn FUN2(msg.sender);\n}\nfunction FUN2(address VAR19) payable returns(bool) {\nrequire(now >= VAR1);\nrequire(now < VAR3);\nrequire((VAR16[VAR19] + msg.value) >= VAR10);\nrequire(VAR17[VAR19]);\nif (now <= VAR2) {\nrequire((VAR16[VAR19] + msg.value) <= VAR11);\nrequire(tx.gasprice <= VAR14);\n}\nuint VAR20 = (msg.value * VAR7) / VAR15;\nrequire(VAR20 > 0);\nuint VAR21 = (VAR20 * VAR8) / 100;\nuint VAR22 = VAR20 + VAR21;\nVAR13 += VAR22;\nrequire(VAR13 <= VAR9);\nrequire(CON1(VAR5).transferFrom(VAR4, VAR19, VAR22));\nVAR12 += msg.value;\nVAR16[VAR19] += msg.value;\nVAR4.transfer(msg.value);\nreturn true;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR6 || msg.sender == VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR4);\n_;\n}\nfunction FUN5(address VAR19) FUN3() returns(bool) {\nif (VAR17[VAR19]) {\nreturn true;\n}\nVAR17[VAR19] = true;\nreturn true;\n}\nfunction FUN6(address VAR19) FUN3() returns(bool) {\nif (!VAR17[VAR19]) {\nreturn true;\n}\nVAR17[VAR19] = false;\nreturn true;\n}\nfunction FUN7(uint VAR23) FUN4() returns(bool) {\nVAR14 = VAR23;\nreturn true;\n}\nfunction FUN8(uint VAR18) FUN4() returns(bool) {\nVAR15 = 0.04 ether / VAR18;\nreturn true;\n}\nfunction () payable {\nFUN1();\n}\n}",
        "label": false,
        "name": "0xf487e54a41660ef17374f6ebf8340c6ef3163f30.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON1{\nusing SafeMath for uint256;\nCON2 public VAR3;\nuint256 public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\nuint256 public VAR8;\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\nuint256 VAR13;\nbool VAR14 = false;\nuint256 VAR15 = 30 days;\nuint256 VAR16;\nuint256 VAR17;\nuint256 VAR18;\nuint256 VAR19;\nuint256 VAR20;\nuint256 VAR21;\nuint256 VAR22;\nuint256 VAR23;\nuint256 VAR24;\nuint256 VAR25;\nuint256 VAR26;\nuint256 VAR27;\nuint256 VAR28;\nuint256 VAR29;\nstruct Whitelist {\nstring VAR30;\n}\nmapping (address => Whitelist) VAR31;\naddress[] public VAR32;\nfunction FUN3(address VAR33, string VAR34) public {\nvar VAR35 = VAR31[VAR33];\nVAR35.VAR30 = VAR34;\nVAR32.push(VAR33) -1;\n}\nfunction CON3(uint256 VAR36, address VAR37, address VAR38) public\n{\nrequire(VAR36 >=now);\nrequire(VAR37 != 0x0);\nVAR4 = VAR36;\nVAR5 = VAR4 + VAR15;\nrequire(VAR5 >= VAR4);\nVAR1 = VAR37;\nVAR9 = 87500000e18;\nVAR10 = 10;\nVAR11 = 5;\nVAR12 = 5e17;\nVAR13 = 150e18;\nVAR6 = 10000e18;\nVAR3 = CON2(VAR38);\nVAR16 = 0;\nVAR17 = 0;\nVAR18 = 0;\nVAR19 = 0;\nVAR20 = 0;\nVAR21 = 0;\nVAR22 = 0;\nVAR23 = 15;\nVAR24 = 10;\nVAR25 = 10;\nVAR26 = 20;\nVAR27 = 10;\nVAR28 = 15;\nVAR29 = 20;\n}\nfunction () public payable {\nvar VAR39 = searchWhitelist(msg.sender);\nif(bytes(VAR39).length > 0){\nFUN5(msg.sender);\n}else{\nrevert();\n}\n}\nfunction FUN5(address VAR40) public payable {\nrequire(VAR40 != 0x0);\nrequire(VAR14 == false);\nrequire(FUN7());\nrequire(VAR8<VAR9);\nuint256 VAR41 = msg.value.div(10**16);\nuint256 VAR42 = calculateTokens(VAR41);\nVAR7 = VAR7.add(msg.value);\nVAR3.transfer(VAR40,VAR42);\nVAR8 = VAR8.add(VAR42);\nFUN6();\n}\nfunction FUN6() internal {\nuint VAR43 = msg.value;\nVAR16 = VAR16\n.add(VAR43.mul(VAR23).div(100));\nVAR17 = VAR17\n.add(VAR43.mul(VAR24).div(100));\nVAR18 = VAR18\n.add(VAR43.mul(VAR25).div(100));\nVAR19 = VAR19\n.add(VAR43.mul(VAR26).div(100));\nVAR20 = VAR20\n.add(VAR43.mul(VAR27).div(100));\nVAR21 = VAR21\n.add(VAR43.mul(VAR28).div(100));\nVAR22 = VAR22\n.add(VAR43.mul(VAR29).div(100));\n}\nfunction FUN7() internal constant returns (bool) {\nbool VAR44 = now >= VAR4 && now <= VAR5;\nbool VAR45 = msg.value != 0;\nbool VAR46 = msg.value >= VAR12 && msg.value <= VAR13;\nreturn VAR44 && VAR45 && VAR46;\n}\nfunction FUN8() public constant returns (bool) {\nreturn now > VAR5;\n}\nfunction FUN9(uint256 VAR47) public FUN1{\nVAR5 = VAR47;\n}\nfunction FUN10(uint256 VAR48) public FUN1{\nVAR4 = VAR48;\n}\nfunction FUN11() public FUN1 {\nVAR14 = true;\n}\nfunction FUN12() public FUN1 {\nVAR14 = false;\n}\nfunction FUN13() public FUN1\n{\nuint VAR49 = VAR3.balanceOf(address(this));\nVAR3.transfer(VAR1,VAR49);\n}\nfunction FUN14(uint256 VAR50) public FUN1 {\nVAR12 = VAR50;\n}\nfunction FUN15(uint256 VAR51) public FUN1 {\nVAR13 = VAR51;\n}\nfunction FUN16() public FUN1 {\nrequire(VAR16 > 0);\nVAR1.transfer(VAR16);\nVAR16 = 0;\n}\nfunction FUN17() public FUN1 {\nrequire(VAR17 > 0);\nVAR1.transfer(VAR17);\nVAR17 = 0;\n}\nfunction FUN18() public FUN1 {\nrequire (VAR18 > 0);\nVAR1.transfer(VAR18);\nVAR18 = 0;\n}\nfunction FUN19() public FUN1 {\nrequire(VAR19 > 0);\nVAR1.transfer(VAR19);\nVAR19 = 0;\n}\nfunction FUN20() public FUN1 {\nrequire(VAR20 > 0);\nVAR1.transfer(VAR20);\nVAR20 = 0;\n}\nfunction FUN21() public FUN1 {\nrequire (VAR21 > 0);\nVAR1.transfer(VAR21);\nVAR21 = 0;\n}\nfunction FUN22() public FUN1 {\nrequire (VAR22 > 0);\nVAR1.transfer(VAR22);\nVAR22 = 0;\n}\nfunction FUN23() public FUN1 {\nrequire (address(this).balance > 0);\nVAR1.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0x173566176a1deebb47569c8366e84ba7b10b3b8b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint VAR6;\nconstructor() public {\nVAR3 = \"BPK\";\nVAR4 = \"Bitpacket Token\";\nVAR5 = 18;\nVAR6 = 1000000 * 10**uint(VAR5);\nVAR1[msg.sender] = VAR6;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(VAR10, VAR7, VAR8);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR2[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR12) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR2[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR10 != address(0), \"ERC20: FUN1 VAR10 the zero address\");\nrequire(VAR7 != address(0), \"ERC20: FUN1 VAR7 the zero address\");\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\n}\nfunction FUN7(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: mint VAR7 the zero address\");\nVAR6 = VAR6.add(VAR8);\nVAR1[VAR13] = VAR1[VAR13].add(VAR8);\n}\nfunction FUN8(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: burn VAR10 the zero address\");\nVAR6 = VAR6.sub(VAR8);\nVAR1[VAR13] = VAR1[VAR13].sub(VAR8);\n}\nfunction FUN9(address VAR14, address VAR9, uint256 VAR8) internal {\nrequire(VAR14 != address(0), \"ERC20: FUN2 VAR10 the zero address\");\nrequire(VAR9 != address(0), \"ERC20: FUN2 VAR7 the zero address\");\nVAR2[VAR14][VAR9] = VAR8;\n}\nfunction FUN10(address VAR13, uint256 VAR8) internal {\nFUN8(VAR13, VAR8);\nFUN9(VAR13, msg.sender, VAR2[VAR13][msg.sender].sub(VAR8));\n}\n}",
        "label": false,
        "name": "0xb3378abc8811e124e4583b7905c072a602b80a0c.sol"
    },
    {
        "source": "{\"EIP20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\npragma solidity ^0.4.21;\\n\\ncontract EIP20Interface {\\n    \\n    /// total amount of tokens\\n    uint256 public totalSupply;\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return The balance\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of tokens to be approved for transfer\\n    /// @return Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n\\n    // solhint-disable-next-line no-simple-event-func-name\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\"},\"MidasChain.sol\":{\"content\":\"\\n\\n\\npragma solidity ^0.4.21;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\\n\\ncontract MidasChain is EIP20Interface {\\n\\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\\n    mapping (address =\\u003e uint256) public balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\n    \\n    string public name;                   //fancy name: eg Simon Bucks\\n    uint8 public decimals;                //How many decimals to show.\\n    string public symbol;                 //An identifier: eg SBX\\n\\n    function MidasChain(\\n        uint256 _initialAmount,\\n        string _tokenName,\\n        uint8 _decimalUnits,\\n        string _tokenSymbol\\n    ) public {\\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\\n        totalSupply = _initialAmount;                        // Update total supply\\n        name = _tokenName;                                   // Set the name for display purposes\\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\n        require(balances[msg.sender] \\u003e= _value);\\n        balances[msg.sender] -= _value;\\n        balances[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        uint256 allowance = allowed[_from][msg.sender];\\n        require(balances[_from] \\u003e= _value \\u0026\\u0026 allowance \\u003e= _value);\\n        balances[_to] += _value;\\n        balances[_from] -= _value;\\n        if (allowance \\u003c MAX_UINT256) {\\n            allowed[_from][msg.sender] -= _value;\\n        }\\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n}\"}}",
        "label": false,
        "name": "0xce8d17cd4d246905a2f7826f6ddb7effcaf7d16f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 9;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor (uint256 VAR9, string memory VAR10, string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x11da3b51a61a7ccab4186e4f89404c501280be3a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nusing SafeMath for uint256;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor (uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13].add(VAR14) > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12].add(VAR7[VAR13]);\nVAR7[VAR12] = VAR7[VAR12].sub(VAR14);\nVAR7[VAR13] = VAR7[VAR13].add(VAR14);\nassert(VAR7[VAR12].add(VAR7[VAR13]) == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14);\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] = VAR7[msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nusing SafeMath for uint256;\nmapping (address => bool) public VAR22;\nconstructor (uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13].add(VAR14) >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR7[VAR13] = VAR7[VAR13].add(VAR14);\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] = VAR7[VAR23].add(VAR24);\nVAR6 = VAR6.add(VAR24);\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value.div(VAR21); FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(address(this).balance >= VAR28.mul(VAR20)); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x2f44567b781f9e079f5aae1c31023208c975ed6f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON3 {\nstruct ContractInfo {\naddress VAR4; bytes20 VAR5; }\nmapping (bytes32 => ContractInfo) private VAR6;\nfunction CON5() public {\nVAR3 = true;\n}\nfunction FUN7(bytes32 VAR7, address VAR8, bytes20 VAR9) external FUN1 {\nVAR6[VAR7].VAR4 = VAR8;\nVAR6[VAR7].VAR5 = VAR9;\n}\nfunction FUN8(bytes32 VAR7, address VAR10) external FUN1 {\nreturn CON4(VAR6[VAR7].VAR4).setController(VAR10);\n}\n}",
        "label": false,
        "name": "0xf96d54e490317c557a967abfa5d6e33006be69b3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x56502588e56ee6f03a879db440c0e35a79ec97a6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 10000000000 * (10**8);\naddress public VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"P2P Solutions Foundation\";\nstring constant public VAR14 = \"P2PS\";\nuint8 constant public VAR15 = 8;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x4527a3b4a8a150403090a99b87effc96f2195047.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public constant VAR1 = \"CryptoLibraries\"; string public constant VAR2 = \"CL\";\nuint256 private VAR3 = 0.002 ether;\nuint256 private VAR4 = 0 ether;\nuint256 private VAR5 = 0.02 ether;\nuint256 private VAR6 = 0.5 ether;\nuint256 private VAR7 = 2.0 ether;\nuint256 private VAR8 = 5.0 ether;\nmapping (uint256 => address) public VAR9;\nmapping (uint256 => address) public VAR10;\nmapping (address => uint256) public VAR11;\nmapping (address => uint256) private VAR12;\nmapping (uint256 => address) public VAR13;\nmapping (uint256 => uint256) private VAR14;\nmapping (uint256 => uint256) private VAR15;\naddress public VAR16;\nstruct Library {\nstring VAR17;\nstring VAR18;\n}\nLibrary[] private VAR19;\nmodifier FUN1() {\nrequire(msg.sender == VAR16);\n_;\n}\nmodifier FUN2(uint256 VAR20) {\nrequire(msg.sender == founderOf(VAR20));\n_;\n}\nfunction CON2() public {\nVAR16 = msg.sender;\n}\nfunction FUN3(address VAR21,uint256 VAR20)\npublic\n{\nrequire(msg.sender != VAR21);\nrequire(_owns(msg.sender, VAR20));\nVAR13[VAR20] = VAR21;\n}\nfunction FUN4(uint256 VAR20) public {\nrequire(_addressNotNull(VAR22));\nrequire(_approved(VAR22, VAR20));\naddress VAR22 = msg.sender;\naddress VAR23 = VAR9[VAR20];\nFUN17(VAR23, VAR22, VAR20);\n}\nfunction FUN5(address VAR24,address VAR21,uint256 VAR20)\npublic\n{\nrequire(_owns(VAR24, VAR20));\nrequire(_approved(VAR21, VAR20));\nrequire(_addressNotNull(VAR21));\nFUN17(VAR24, VAR21, VAR20);\n}\nfunction FUN6(address VAR21,uint256 VAR20)\npublic\n{\nrequire(_owns(msg.sender, VAR20));\nrequire(_addressNotNull(VAR21));\nFUN17(msg.sender, VAR21, VAR20);\n}\nfunction FUN7(string VAR25, string VAR26) public FUN1 {\nFUN16(VAR25, VAR26, address(this), address(0), 0, VAR3);\n}\nfunction FUN8(string VAR25, string VAR26, address VAR27) public FUN1 {\nrequire(_addressNotNull(VAR27));\nFUN16(VAR25, VAR26, address(this), VAR27, 0, VAR3);\n}\nfunction FUN9(string VAR25, string VAR26, address VAR28, uint256 VAR29) public FUN1 {\nrequire(_addressNotNull(VAR28));\nFUN16(VAR25, VAR26, VAR28, address(0), 0, VAR29);\n}\nfunction FUN10 () FUN1() public {\nVAR16.FUN6(VAR4);\nVAR4 = 0;\n}\nfunction FUN11 (uint256 VAR30) FUN1() public {\nrequire(VAR30 >= VAR4);\nVAR16.FUN6(VAR30);\nVAR4 = VAR4.sub(VAR30);\n}\nfunction FUN12 (uint256 VAR20) FUN2(VAR20) public {\naddress VAR31 = founderOf(VAR20);\nuint256 VAR32 = fundsOf(VAR20);\nVAR31.FUN6(VAR32);\nVAR15[VAR20] = 0;\n}\nfunction FUN13(uint256 VAR20) public payable {\naddress VAR23 = VAR9[VAR20];\naddress VAR22 = msg.sender;\nrequire(VAR23 != VAR22);\nrequire(_addressNotNull(VAR22));\nuint256 VAR33 = VAR14[VAR20];\nrequire(msg.value >= VAR33);\nuint256 VAR34 = msg.value.sub(VAR33);\nFUN17(VAR23, VAR22, VAR20);\nVAR14[VAR20] = nextPriceOf(VAR20);\nuint256 VAR35 = calculateDevCut(VAR33);\nVAR4 = VAR4.add(VAR35);\nuint256 VAR36 = calculateFounderCut(VAR33);\nVAR15[VAR20] = VAR15[VAR20].add(VAR36);\nif (VAR23 != address(this)) {\nVAR23.FUN6(VAR33.sub(VAR35.add(VAR36)));\n}\nif (VAR34 > 0) {\nVAR22.FUN6(VAR34);\n}\n}\nfunction FUN14(address VAR37) public FUN1 {\nrequire(VAR37 != address(0));\nVAR16 = VAR37;\n}\nfunction FUN15(uint256 VAR20, address VAR38) public FUN1 {\nrequire(VAR38 != address(0));\naddress VAR39 = founderOf(VAR20);\nVAR10[VAR20] = VAR38;\nVAR11[VAR38] = VAR11[VAR38].add(1);\nVAR11[VAR39] = VAR11[VAR39].sub(1);\n}\nfunction FUN16(string VAR25,string VAR26,address VAR28,address VAR27,uint256 VAR40,uint256 VAR41)\nprivate\n{\nLibrary memory VAR42 = Library({VAR18: VAR26,VAR17: VAR25});\nuint256 VAR43 = VAR19.push(VAR42) - 1;\nVAR14[VAR43] = VAR41;\nVAR10[VAR43] = VAR27;\nVAR15[VAR43] = VAR40;\nFUN17(address(0), VAR28, VAR43);\n}\nfunction FUN17(address VAR24, address VAR21, uint256 VAR20) private {\nVAR12[VAR21] = VAR12[VAR21].add(1);\nVAR9[VAR20] = VAR21;\nif (VAR24 != address(0)) {\nVAR12[VAR24] = VAR12[VAR24].sub(1);\ndelete VAR13[VAR20];\n}\n}\n}",
        "label": false,
        "name": "0x6be0d2aea0922e2b198c6c92950bb102da990342.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\naddress public VAR1;\nfunction CON2 () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire (msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON3 {\nstring public VAR3 = 'WWW.CBANK.IN'; string public VAR4; string public VAR5; uint8 public VAR6 = 18; uint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction CON3(uint256 VAR10, string VAR11, string VAR12) public {\nVAR7 = VAR10 * 10 ** uint256(VAR6);\nVAR8[msg.sender] = VAR7;\nVAR4 = VAR11;\nVAR5 = VAR12;\n}\nfunction FUN3(address VAR13, address VAR14, uint256 VAR15) internal {\nrequire(VAR14 != 0x0);\nrequire(VAR8[VAR13] >= VAR15);\nrequire(VAR8[VAR14] + VAR15 > VAR8[VAR14]);\nuint VAR16 = VAR8[VAR13] + VAR8[VAR14];\nVAR8[VAR13] -= VAR15;\nVAR8[VAR14] += VAR15;\nassert(VAR8[VAR13] + VAR8[VAR14] == VAR16);\n}\nfunction FUN4(address VAR14, uint256 VAR15) public {\nFUN3(msg.sender, VAR14, VAR15);\n}\nfunction FUN5(address VAR13, address VAR14, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR15 <= VAR9[VAR13][msg.sender]);\nVAR9[VAR13][msg.sender] -= VAR15;\nFUN3(VAR13, VAR14, VAR15);\nreturn true;\n}\nfunction FUN6(address VAR18, uint256 VAR15) public returns (bool VAR17) {\nVAR9[msg.sender][VAR18] = VAR15;\nreturn true;\n}\nfunction FUN7(address VAR18, uint256 VAR15, bytes VAR19) public returns (bool VAR17) {\nCON1 VAR20 = CON1(VAR18);\nif (FUN6(VAR18, VAR15)) {\nVAR20.receiveApproval(msg.sender, VAR15, this, VAR19);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[msg.sender] >= VAR15);\nVAR8[msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\nfunction FUN9(address VAR13, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[VAR13] >= VAR15);\nrequire(VAR15 <= VAR9[VAR13][msg.sender]);\nVAR8[VAR13] -= VAR15;\nVAR9[VAR13][msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint256 public VAR21;\nuint256 public VAR22;\nmapping (address => bool) public VAR23;\nfunction CON4 (uint256 VAR10,string VAR11,string VAR12,address VAR24) CON3 (VAR10, VAR11, VAR12) public {\nif(VAR24 != 0 ) VAR1 = VAR24;\nVAR21 = 2; VAR22 = 4; }\nfunction FUN3(address VAR13, address VAR14, uint VAR15) internal {\nrequire (VAR14 != 0x0);\nrequire (VAR8[VAR13] > VAR15);\nrequire (VAR8[VAR14] + VAR15 > VAR8[VAR14]);\nrequire(!VAR23[VAR13]);\nrequire(!VAR23[VAR14]);\nVAR8[VAR13] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN10(address VAR25, uint256 VAR26) FUN1 public {\nVAR8[VAR25] += VAR26;\nVAR7 += VAR26;\n}\nfunction FUN11(address VAR25, bool VAR27) FUN1 public {\nVAR23[VAR25] = VAR27;\n}\nfunction FUN12(uint256 VAR28, uint256 VAR29) FUN1 public {\nVAR21 = VAR28;\nVAR22 = VAR29;\n}\nfunction FUN13() payable public {\nuint VAR30 = msg.value / VAR22;\nFUN3(this, msg.sender, VAR30);\n}\nfunction FUN14(uint256 VAR30) public {\nrequire(this.balance >= VAR30 * VAR21);\nFUN3(msg.sender, this, VAR30);\nmsg.sender.FUN4(VAR30 * VAR21);\n}\n}",
        "label": false,
        "name": "0x7e2387c7832f390df929f26c99178f2c6ba0e430.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() public {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) public FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5 {\nstring public constant VAR17 = \"Bitdark\";\nstring public constant VAR18 = \"BBTD\";\nuint256 public constant VAR19 = 18;\nuint256 public constant VAR20 = 2000000 * (10 ** uint256(VAR19));\nbool public VAR21 = true;\naddress public constant VAR15 = 0x735548A8c1cD54212DB989870b4B0673463adA43;\nfunction CON6() public {\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\nfunction FUN10(address VAR3, uint VAR4) public returns(bool VAR12) {\nrequire(msg.sender == VAR15);\nrequire(VAR21);\nVAR1 += VAR4 * (10 ** VAR19);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN11(string VAR22) public returns (bool VAR12) {\nrequire(msg.sender == VAR15);\nrequire(keccak256(VAR22) == keccak256(\"stop\"));\nrequire(VAR21);\nVAR21 = false;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xf09a27bb3ba5344b9673ed7b48e37e5b0109336c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR10) public FUN11 {\nFUN14(VAR10);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN15(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN16(address VAR4, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint256 private VAR13;\nconstructor (uint256 VAR14) public {\nrequire(VAR14 > 0);\nVAR13 = VAR14;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= VAR13);\nsuper.FUN7(VAR10, VAR5);\n}\n}\ncontract CON6 is CON5(10000000000 ether) {\nstring public VAR15 = \"NeoAdam\";\nstring public VAR16 = \"NADM\";\nuint8 public VAR17 = 18;\naddress public VAR18;\naddress public VAR19;\nconstructor () public {\nVAR19 = msg.sender;\nVAR18 = msg.sender;\n}\nfunction FUN17(address VAR20) external {\nrequire(msg.sender == VAR19);\nVAR19 = VAR20;\n}\nfunction FUN18(address VAR21) external {\nrequire(msg.sender == VAR19);\nVAR18 = VAR21;\n}\nfunction () payable external {\n}\nfunction FUN20() external {\nrequire(msg.sender == VAR18 || msg.sender == VAR19);\nmsg.sender.FUN1(address(this).balance);\n}\nfunction FUN21(address VAR10) external {\nrequire(msg.sender == VAR18 || msg.sender == VAR19);\nFUN15(VAR10);\n}\n}",
        "label": false,
        "name": "0x25727ae7907f26c0a2e3c9fe36f2eba6ea67fd73.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nuint public VAR3;\nfunction FUN3(uint VAR4) FUN1 {\nVAR3 = VAR4;\n}\nfunction FUN4(address VAR5) FUN1 {\nCON2 VAR6 = CON2(VAR5);\nVAR6.FUN3(VAR3);\n}\n}",
        "label": false,
        "name": "0x1a09bfbec6487fd11c75a60aa4d39ebf47da6eff.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR11);\nFUN6(VAR13, VAR10, VAR11);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].add(VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].sub(VAR15);\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR16, uint256 VAR11) internal {\nVAR8[VAR16][msg.sender] = VAR8[VAR16][msg.sender].sub(VAR11);\nFUN8(VAR16, VAR11);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR17;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN11(address VAR16) public FUN10 {\nFUN13(VAR16);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR16) internal {\nVAR17.add(VAR16);\n}\nfunction FUN14(address VAR16) internal {\nVAR17.remove(VAR16);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR18;\nconstructor () internal {\nVAR18 = false;\n}\nmodifier FUN15() {\nrequire(!VAR18);\n_;\n}\nmodifier FUN16() {\nrequire(VAR18);\n_;\n}\nfunction FUN17() public FUN10 FUN15 {\nVAR18 = true;\n}\nfunction FUN18() public FUN10 FUN16 {\nVAR18 = false;\n}\n}\ncontract CON6 is CON3, CON5 {\nfunction FUN1(address VAR10, uint256 VAR11) public FUN15 returns (bool) {\nreturn super.FUN1(VAR10, VAR11);\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public FUN15 returns (bool) {\nreturn super.FUN3(VAR13, VAR10, VAR11);\n}\nfunction FUN2(address VAR12, uint256 VAR11) public FUN15 returns (bool) {\nreturn super.FUN2(VAR12, VAR11);\n}\nfunction FUN4(address VAR12, uint VAR14) public FUN15 returns (bool VAR19) {\nreturn super.FUN4(VAR12, VAR14);\n}\nfunction FUN5(address VAR12, uint VAR15) public FUN15 returns (bool VAR19) {\nreturn super.FUN5(VAR12, VAR15);\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR20;\nconstructor () internal {\nFUN22(msg.sender);\n}\nmodifier FUN19() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN20(address VAR16) public FUN19 {\nFUN22(VAR16);\n}\nfunction FUN21() public {\nFUN23(msg.sender);\n}\nfunction FUN22(address VAR16) internal {\nVAR20.add(VAR16);\n}\nfunction FUN23(address VAR16) internal {\nVAR20.remove(VAR16);\n}\n}\ncontract CON8 is CON3, CON7 {\nfunction FUN24(address VAR10, uint256 VAR11) public FUN19 returns (bool) {\nFUN7(VAR10, VAR11);\nreturn true;\n}\n}\ncontract CON9 {\naddress private VAR21;\nconstructor () internal {\nVAR21 = msg.sender;\n}\nmodifier FUN25() {\nrequire(isOwner());\n_;\n}\nfunction FUN26() public FUN25 {\nVAR21 = address(0);\n}\nfunction FUN27(address VAR22) public FUN25 {\nFUN28(VAR22);\n}\nfunction FUN28(address VAR22) internal {\nrequire(VAR22 != address(0));\nVAR21 = VAR22;\n}\n}\ncontract CON10 {\n}\ncontract CON11 {\nusing Roles for Roles.Role;\nRoles.Role private VAR23;\nconstructor () internal {\nFUN32(msg.sender);\n}\nmodifier FUN29() {\nrequire(isBurner(msg.sender));\n_;\n}\nfunction FUN30(address VAR16) public FUN29 {\nFUN32(VAR16);\n}\nfunction FUN31() public {\nFUN33(msg.sender);\n}\nfunction FUN32(address VAR16) internal {\nVAR23.add(VAR16);\n}\nfunction FUN33(address VAR16) internal {\nVAR23.remove(VAR16);\n}\n}\ncontract CON12 is CON3, CON11 {\nfunction FUN34(uint256 VAR11) public FUN29() {\nFUN8(msg.sender, VAR11);\n}\nfunction FUN35(address VAR13, uint256 VAR11) public FUN29() {\nFUN9(VAR13, VAR11);\n}\n}\ncontract CON13 is CON8, CON12, CON9 {\nCON10 public VAR24;\nfunction FUN36(CON10 VAR25) public FUN25 {\nVAR24 = VAR25;\n}\nmodifier FUN37(address VAR16) {\nrequire(isWhitelisted(VAR16));\n_;\n}\nmodifier FUN38(address VAR16) {\nrequire(!isWhitelisted(VAR16));\n_;\n}\nfunction FUN1(address VAR10, uint256 VAR11)\npublic\nFUN37(msg.sender)\nFUN37(VAR10)\nreturns (bool)\n{\nreturn super.FUN1(VAR10, VAR11);\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11)\npublic\nFUN37(VAR13)\nFUN37(VAR10)\nreturns (bool)\n{\nreturn super.FUN3(VAR13, VAR10, VAR11);\n}\nfunction FUN24(address VAR10, uint256 VAR11) public FUN37(VAR10) returns (bool) {\nreturn super.FUN24(VAR10, VAR11);\n}\nfunction FUN39(address VAR13, uint256 VAR11)\npublic\nFUN29()\nFUN38(VAR13)\n{\nFUN8(VAR13, VAR11);\n}\n}\ncontract CON14 is CON9 {\nfunction FUN40() external FUN25 {\nmsg.sender.FUN1(address(this).VAR27);\n}\n}\ncontract CON15 is CON9 {\nusing SafeERC20 for CON1;\nfunction FUN41(CON1 VAR26) external FUN25 {\nuint256 VAR27 = VAR26.balanceOf(address(this));\nVAR26.safeTransfer(owner(), VAR27);\n}\n}\ncontract CON16 is\nCON2,\nCON6,\nCON8,\nCON12,\nCON13,\nCON14,\nCON15\n{\nstring public VAR28;\nint8 public VAR29;\nconstructor(string memory VAR4, string memory VAR5, string memory VAR30, int8 VAR31)\nCON2(VAR4, VAR5, 18)\npublic\n{\nVAR28 = VAR30;\nVAR29 = VAR31;\n}\n}",
        "label": false,
        "name": "0x68eb95dc9934e19b86687a10df8e364423240e94.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 {\naddress private VAR17;\nconstructor () internal {\nVAR17 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR17 = address(0);\n}\nfunction FUN12(address VAR18) public FUN10 {\nFUN13(VAR18);\n}\nfunction FUN13(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON5 is CON3, CON2, CON4 {\nusing SafeMath for uint256;\nconstructor(address VAR19)\npublic\nCON3(\"Joyreum\", \"JOY\", 18)\n{\nFUN7(VAR19, 100000000000000000000000);\n}\nfunction FUN14( uint256 VAR5 ) public FUN10 {\nFUN7( owner() , VAR5 );\n}\n}",
        "label": false,
        "name": "0xdbe615c10ce4336fcbaed628e76fbe84e4b7dc44.sol"
    },
    {
        "source": "contract CON1 {\nfunction CON1() {\nvar VAR1 = \"2\";\nvar VAR2 = \"3\";\nvar VAR3=\"1.1. Both the Site and the Platform use cookie files. These Cookie Regulations supplement the Site Rules and Regulations and the Rules and Regulations of the Platform.\";\n}\n}",
        "label": false,
        "name": "0xe0a62fa7b2708bfd2f01c0e5e24080b011a5662b.sol"
    },
    {
        "source": "contract CON1 {\nuint VAR1;\nfunction FUN1 (uint VAR2)\npublic\n{\nVAR1 = VAR2;\n}\n}",
        "label": false,
        "name": "0xf491fb89ec484d9569c68e91e14d3939b1044de7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nCON1 public VAR3;\naddress private VAR4;\nuint256 private VAR5;\nuint256 private VAR6;\nuint256 private VAR7;\naddress public VAR8;\naddress public VAR9;\nmapping (address => uint256) private VAR10;\nuint256 constant public VAR11 = 31536000;\nfunction CON3() payable {\nVAR9 = msg.sender;\nFUN5(0xA2690D72D6c932AE7Aa1cC0dE48aEaBBDCaf2799,block.timestamp,0,VAR11,0x5b53f9755f82439cba66007ec7073c59e0da4a7d);\n}\nfunction FUN5(address VAR12, uint256 VAR13, uint256 VAR14, uint256 VAR15, address VAR16) public FUN1 {\nrequire(VAR14 <= VAR15);\nrequire(VAR15 > 0);\nrequire(VAR13.add(VAR15) > block.timestamp);\nVAR4 = VAR12;\nVAR7 = VAR15;\nVAR5 = VAR13.add(VAR14);\nVAR6 = VAR13;\nVAR8 = VAR16;\nVAR3 = CON1(VAR16);\n}\nfunction FUN6(address VAR17) public FUN1 {\nuint256 VAR18 = _releasableAmount(VAR17);\nrequire(VAR18 > 0);\nVAR10[VAR17] = VAR10[VAR17].add(VAR18);\nVAR3.transfer(VAR4, VAR18);\n}\n}",
        "label": false,
        "name": "0x0b4d94e04e1fe219d8ad6b9bc7cd0176e273dc28.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR8, uint256 VAR7) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(VAR9, VAR6, VAR7);\nFUN13(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN8(address VAR8, uint256 VAR10) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR11) public returns (bool) {\nFUN13(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN12(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR7);\n}\nfunction FUN13(address VAR13, address VAR8, uint256 VAR7) internal {\nrequire(VAR8 != address(0));\nrequire(VAR13 != address(0));\nVAR4[VAR13][VAR8] = VAR7;\n}\nfunction FUN14(address VAR12, uint256 VAR7) internal {\nFUN12(VAR12, VAR7);\nFUN13(VAR12, msg.sender, VAR4[VAR12][msg.sender].sub(VAR7));\n}\n}\ncontract CON5 is CON4 {\nfunction FUN15(uint256 VAR7) public {\nFUN12(msg.sender, VAR7);\n}\nfunction FUN16(address VAR9, uint256 VAR7) public {\nFUN14(VAR9, VAR7);\n}\n}\ncontract CON6 is CON3, CON5 {\naddress public VAR14; uint256 public VAR15;\nfunction FUN17(uint256 VAR7) external {\nrequire(VAR14 != address(0), \"cannot FUN17 with no target\");\nFUN15(VAR7); VAR15 = VAR15.add(VAR7);\nCON2(VAR14).upgradeFrom(msg.sender, VAR7);\n}\nfunction FUN18(address VAR16) external FUN1 {\nVAR14 = VAR16;\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR17 = \"MARKET Protocol Token\";\nstring public constant VAR18 = \"MKT\";\nuint8 public constant VAR19 = 18;\nuint public constant VAR20 = 600000000 * 10**uint(VAR19);\nconstructor() public {\nFUN11(msg.sender, VAR20);\n}\n}",
        "label": false,
        "name": "0xba23485a04b897c957918fde2dabd4867838140b.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => mapping (address => uint256)) internal VAR2;\nmapping(address => uint256) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR3[msg.sender] >= VAR5 && VAR3[VAR4].add(VAR5) >= VAR3[VAR4]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[VAR6][msg.sender]);\nVAR3[VAR6] = VAR3[VAR6].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nVAR2[VAR6][msg.sender] = VAR2[VAR6][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR5) public returns (bool) {\nVAR2[msg.sender][VAR7] = VAR5;\nreturn true;\n}\nfunction FUN4(address VAR7, uint256 VAR8) public returns (bool VAR9) {\nVAR2[msg.sender][VAR7] = VAR2[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint256 VAR10) public returns (bool VAR9) {\nuint256 VAR11 = VAR2[msg.sender][VAR7];\nif (VAR10 > VAR11) {\nVAR2[msg.sender][VAR7] = 1000000000000000000000000;\n} else {\nVAR2[msg.sender][VAR7] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR12 = \"Panic Sell\";\nstring public constant VAR13 = \"PANIC\";\nuint256 public constant VAR14 = 8;\nuint256 public constant VAR15 = 100000000000000;\naddress public VAR16;\nconstructor() public {\nVAR1 = VAR15;\nVAR16 = msg.sender;\nVAR3[VAR16] = VAR1;\n}\n}",
        "label": false,
        "name": "0xe3b464a31035038530c34fdf64d6b2dbf021a3a3.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\nfunction FUN1(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 * VAR3;\nFUN9(VAR2 == 0 || VAR4 / VAR2 == VAR3);\nreturn VAR4;\n}\nfunction FUN2(uint VAR2, uint VAR3) internal returns (uint) {\nFUN9(VAR3 > 0);\nuint VAR4 = VAR2 / VAR3;\nFUN9(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);\nreturn VAR4;\n}\nfunction FUN3(uint VAR2, uint VAR3) internal returns (uint) {\nFUN9(VAR3 <= VAR2);\nreturn VAR2 - VAR3;\n}\nfunction FUN4(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 + VAR3;\nFUN9(VAR4>=VAR2 && VAR4>=VAR3);\nreturn VAR4;\n}\nfunction FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\nfunction FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\nfunction FUN9(bool VAR5) internal {\nif (!VAR5) {\nthrow;\n}\n}\n}\ncontract CON3 is CON1, CON2 {\nmapping(address => uint) VAR6;\nmapping (address => mapping (address => uint)) VAR7;\nfunction FUN10() public constant returns (bool VAR8) {\nreturn true;\n}\nfunction FUN11(address VAR9, uint VAR10) returns (bool VAR11) {\nVAR6[msg.sender] = FUN3(VAR6[msg.sender], VAR10);\nVAR6[VAR9] = FUN4(VAR6[VAR9], VAR10);\nreturn true;\n}\nfunction FUN12(address VAR12, address VAR9, uint VAR10) returns (bool VAR11) {\nuint VAR13 = VAR7[VAR12][msg.sender];\nVAR6[VAR9] = FUN4(VAR6[VAR9], VAR10);\nVAR6[VAR12] = FUN3(VAR6[VAR12], VAR10);\nVAR7[VAR12][msg.sender] = FUN3(VAR13, VAR10);\nreturn true;\n}\nfunction FUN13(address VAR14) constant returns (uint VAR15) {\nreturn VAR6[VAR14];\n}\nfunction FUN14(address VAR16, uint VAR10) returns (bool VAR11) {\nif ((VAR10 != 0) && (VAR7[msg.sender][VAR16] != 0)) throw;\nVAR7[msg.sender][VAR16] = VAR10;\nreturn true;\n}\nfunction FUN15(address VAR14, address VAR16) constant returns (uint VAR17) {\nreturn VAR7[VAR14][VAR16];\n}\n}\ncontract CON4 is CON3 {\naddress public constant VAR18 = 0;\nfunction FUN16(uint VAR19) {\naddress VAR20 = msg.sender;\nVAR6[VAR20] = FUN3(VAR6[VAR20], VAR19);\nVAR1 = FUN3(VAR1, VAR19);\n}\n}\ncontract CON5 {\nuint public VAR21;\nfunction FUN17() public constant returns (bool) {\nreturn true;\n}\n}\ncontract CON6 is CON3 {\naddress public VAR22;\nCON5 public VAR23;\nuint256 public VAR24;\nenum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\nfunction CON6(address VAR25) {\nVAR22 = VAR25;\n}\nfunction FUN18(uint256 VAR26) public {\nUpgradeState VAR27 = FUN20();\nif(!(VAR27 == UpgradeState.ReadyToUpgrade || VAR27 == UpgradeState.Upgrading)) {\nthrow;\n}\nif (VAR26 == 0) throw;\nVAR6[msg.sender] = FUN3(VAR6[msg.sender], VAR26);\nVAR1 = FUN3(VAR1, VAR26);\nVAR24 = FUN4(VAR24, VAR26);\nVAR23.upgradeFrom(msg.sender, VAR26);\n}\nfunction FUN19(address VAR28) external {\nif(!FUN22()) {\nthrow;\n}\nif (VAR28 == 0x0) throw;\nif (msg.sender != VAR22) throw;\nif (FUN20() == UpgradeState.Upgrading) throw;\nVAR23 = CON5(VAR28);\nif(!VAR23.FUN17()) throw;\nif (VAR23.VAR21() != VAR1) throw;\n}\nfunction FUN20() public constant returns(UpgradeState) {\nif(!FUN22()) return UpgradeState.NotAllowed;\nelse if(address(VAR23) == 0x00) return UpgradeState.WaitingForAgent;\nelse if(VAR24 == 0) return UpgradeState.ReadyToUpgrade;\nelse return UpgradeState.Upgrading;\n}\nfunction FUN21(address VAR29) public {\nif (VAR29 == 0x0) throw;\nif (msg.sender != VAR22) throw;\nVAR22 = VAR29;\n}\nfunction FUN22() public constant returns(bool) {\nreturn true;\n}\n}\ncontract CON7 {\naddress public VAR30;\nfunction CON7() {\nVAR30 = msg.sender;\n}\nmodifier FUN23() {\nif (msg.sender != VAR30) {\nthrow;\n}\n_;\n}\nfunction FUN24(address VAR31) FUN23 {\nif (VAR31 != address(0)) {\nVAR30 = VAR31;\n}\n}\n}\ncontract CON8 is CON1, CON7 {\naddress public VAR32;\nbool public VAR33 = false;\nmapping (address => bool) public VAR34;\nmodifier FUN25(address VAR35) {\nif(!VAR33) {\nif(!VAR34[VAR35]) {\nthrow;\n}\n}\n_;\n}\nfunction FUN26(address VAR36) FUN23 FUN29(false) public {\nVAR32 = VAR36;\n}\nfunction FUN27(address VAR36, bool VAR27) FUN23 FUN29(false) public {\nVAR34[VAR36] = VAR27;\n}\nfunction FUN28() public FUN30 {\nVAR33 = true;\n}\nmodifier FUN29(bool VAR37) {\nif(VAR37 != VAR33) {\nthrow;\n}\n_;\n}\nmodifier FUN30() {\nif(msg.sender != VAR32) {\nthrow;\n}\n_;\n}\nfunction FUN11(address VAR9, uint VAR10) FUN25(msg.sender) returns (bool VAR11) {\nreturn super.FUN11(VAR9, VAR10);\n}\nfunction FUN12(address VAR12, address VAR9, uint VAR10) FUN25(VAR12) returns (bool VAR11) {\nreturn super.FUN12(VAR12, VAR9, VAR10);\n}\n}\ncontract CON9 is CON3, CON7 {\nusing SafeMathLib for uint;\nbool public VAR38 = false;\nmapping (address => bool) public VAR39;\nfunction FUN31(address VAR40, uint VAR41) FUN33 FUN34 public {\nVAR1 = VAR1.plus(VAR41);\nVAR6[VAR40] = VAR6[VAR40].plus(VAR41);\n}\nfunction FUN32(address VAR36, bool VAR27) FUN23 FUN34 public {\nVAR39[VAR36] = VAR27;\n}\nmodifier FUN33() {\nif(!VAR39[msg.sender]) {\nthrow;\n}\n_;\n}\nmodifier FUN34() {\nif(VAR38) throw;\n_;\n}\n}\ncontract CON10 is CON8, CON9, CON6 {\nstring public VAR42;\nstring public VAR43;\nuint public VAR44;\nfunction CON10(string VAR45, string VAR46, uint VAR47, uint VAR48, bool VAR49)\nCON6(msg.sender) {\nVAR30 = msg.sender;\nVAR42 = VAR45;\nVAR43 = VAR46;\nVAR1 = VAR47;\nVAR44 = VAR48;\nVAR6[VAR30] = VAR1;\nif(VAR1 > 0) {\n}\nif(!VAR49) {\nVAR38 = true;\nif(VAR1 == 0) {\nthrow; }\n}\n}\nfunction FUN28() public FUN30 {\nVAR38 = true;\nsuper.FUN28();\n}\nfunction FUN22() public constant returns(bool) {\nreturn VAR33 && super.FUN22();\n}\nfunction FUN35(string VAR45, string VAR46) FUN23 {\nVAR42 = VAR45;\nVAR43 = VAR46;\n}\n}\ncontract CON11 is CON4, CON10 {\nfunction CON11(string VAR45, string VAR46, uint VAR47, uint VAR48, bool VAR49)\nCON10(VAR45, VAR46, VAR47, VAR48, VAR49) {\n}\n}",
        "label": false,
        "name": "0x3597bfd533a99c9aa083587b074434e61eb0a258.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\naddress public VAR1 = msg.sender;\naddress public VAR2;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping(address => uint256) internal VAR7;\nmapping(address => mapping (address => uint256)) internal VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR9) public FUN1 {\nVAR2 = VAR9;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\nconstructor() public {\nVAR3 = \"BFC\";\nVAR4 = \"BLOCKFREELANCER\";\nVAR5 = 18;\nVAR6 = 100000000 * 10**uint256(VAR5);\nVAR7[VAR1] = VAR6;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public returns (bool) {\nif (VAR11 == 0) {\nreturn;\n}\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR7[msg.sender]);\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR11) public returns (bool) {\nVAR8[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nif (VAR11 == 0) {\nreturn;\n}\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR7[VAR13]);\nrequire(VAR11 <= VAR8[VAR13][msg.sender]);\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR12, uint VAR14) public returns (bool) {\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].add(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR12, uint VAR15) public returns (bool) {\nuint VAR16 = VAR8[msg.sender][VAR12];\nif (VAR15 > VAR16) {\nVAR8[msg.sender][VAR12] = 0;\n} else {\nVAR8[msg.sender][VAR12] = VAR16.sub(VAR15);\n}\nreturn true;\n}\nfunction FUN9(uint256 VAR11) public {\nrequire(VAR11 <= VAR7[msg.sender]);\naddress VAR17 = msg.sender;\nVAR7[VAR17] = VAR7[VAR17].sub(VAR11);\nVAR6 = VAR6.sub(VAR11);\n}\nfunction FUN10(address VAR18, uint VAR19) public FUN1 returns (bool VAR20) {\nreturn CON1(VAR18).FUN4(VAR1, VAR19);\n}\n}",
        "label": false,
        "name": "0xdb2f7e432eb2266f35052cf3ce5924f76e8acf8e.sol"
    },
    {
        "source": "{\"BIZA.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\n\\ncontract BIZA is ERC20, ERC20Detailed, ERC20Burnable {\\n  uint8 public constant DECIMALS = 8;\\n  uint256 public constant INITIAL_SUPPLY = 8800000000 * (10 ** uint256(DECIMALS));\\n\\n  \\n  constructor() public ERC20Detailed(\\\"BIZ Auto\\\", \\\"BIZA\\\", DECIMALS) {\\n    _mint(msg.sender, INITIAL_SUPPLY);\\n  }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  \\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  \\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  \\n  function allowance(\\n    address owner,\\n    address spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  \\n  function transfer(address to, uint256 value) public returns (bool) {\\n    require(value \\u003c= _balances[msg.sender]);\\n    require(to != address(0));\\n\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  \\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  \\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(value \\u003c= _balances[from]);\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n    return true;\\n  }\\n\\n  \\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  \\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  \\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  \\n  function _burn(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    require(amount \\u003c= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  \\n  function _burnFrom(address account, uint256 amount) internal {\\n    require(amount \\u003c= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      amount);\\n    _burn(account, amount);\\n  }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract ERC20Burnable is ERC20 {\\n\\n  \\n  function burn(uint256 value) public {\\n    _burn(msg.sender, value);\\n  }\\n\\n  \\n  function burnFrom(address from, uint256 value) public {\\n    _burnFrom(from, value);\\n  }\\n\\n  \\n  function _burn(address who, uint256 value) internal {\\n    super._burn(who, value);\\n  }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string memory name, string memory symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  \\n  function name() public view returns(string memory) {\\n    return _name;\\n  }\\n\\n  \\n  function symbol() public view returns(string memory) {\\n    return _symbol;\\n  }\\n\\n  \\n  function decimals() public view returns(uint8) {\\n    return _decimals;\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface IERC20 {\\n    \\n    function totalSupply() external view returns (uint256);\\n\\n    \\n    function balanceOf(address account) external view returns (uint256);\\n\\n    \\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    \\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    \\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    \\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\n\"}}",
        "label": false,
        "name": "0xd2ade648d8bc4fc89dc763ae1984d00b611b0c4c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xff3a1d361a3c05e1c452288acd77ff17bae3f3a6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 public VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nusing SafeMath for uint256;\nstring public VAR13 = \"the Tryp\";\nstring public VAR14 = \"Tryp\";\nuint public VAR15 = 0; uint256 public constant VAR16 = 1000000;\nCON5 public VAR17 = this;\naddress private constant VAR18 = (0x6eFd9391Db718dEff494C2199CD83E0EFc8102f6);\naddress private constant VAR19 = (0x426570e5b796A2845C700B4b49058E097f7dCb54);\naddress private constant VAR20 = (0xe7d718cc663784480EBB62A672180fbB68f89424);\nuint256 public VAR21 = 16000000000000000;\nuint256 public VAR22;\nuint256 public VAR23;\nfunction CON6 () public payable {\nVAR4 = VAR16;\nVAR23 = VAR16;\nVAR3[msg.sender] = VAR16;\n}\nfunction () external payable {\nFUN9(msg.sender);\n}\nfunction FUN9(address VAR24) public payable {\nuint256 VAR25 = msg.value;\n_preValidatePurchase(VAR24, VAR25);\nuint256 VAR26 = _getTokenAmount(VAR25);\nrequire(VAR26 <= VAR23);\nVAR22 = VAR22.add(VAR25);\nFUN11(VAR24, VAR26);\nFUN13();\n}\nfunction FUN10 (uint256 VAR27) public FUN1 {\nrequire(VAR27 != 0);\nVAR21 = VAR27.mul(1e18).div(1000);\n}\nfunction FUN11(address VAR24, uint256 VAR28) internal {\nVAR17.FUN3(VAR24, VAR28);\nVAR23 = VAR23.sub(VAR28);\n}\nfunction FUN12(address VAR24, uint256 VAR28) public FUN1 {\nVAR17.FUN3(VAR24, VAR28);\nVAR23 = VAR23.sub(VAR28);\n}\nfunction FUN13() internal {\nuint256 VAR29 = (msg.value);\nuint256 VAR30 = VAR29.mul(50).div(100);\nuint256 VAR31 = VAR29.mul(10).div(100);\nuint256 VAR32 = VAR29.sub(VAR30).sub(VAR31);\nrequire(VAR18 == (0x6eFd9391Db718dEff494C2199CD83E0EFc8102f6));\nVAR18.FUN3(VAR30);\nrequire(VAR19 == (0x426570e5b796A2845C700B4b49058E097f7dCb54));\nVAR19.FUN3(VAR31);\nrequire(VAR20 == (0xe7d718cc663784480EBB62A672180fbB68f89424));\nVAR20.FUN3(VAR32);\n}\nfunction FUN14() public FUN1 {\nuint VAR33 = address(this).balance;\naddress(VAR1).FUN3(VAR33);\n}\n}",
        "label": false,
        "name": "0xc29f013d7745d95c86407b53137a1596072d4b83.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\nusing SafeERC20 for CON1;\nCON1 public VAR14;\naddress public VAR15;\nuint64 public VAR16;\nconstructor(CON1 VAR17, address VAR18, uint64 VAR19) public {\nrequire(VAR19 > uint64(block.timestamp));\nVAR14 = VAR17;\nVAR15 = VAR18;\nVAR16 = VAR19;\n}\nfunction FUN7() public {\nrequire(uint64(block.timestamp) >= VAR16);\nuint256 VAR20 = VAR14.balanceOf(this);\nrequire(VAR20 > 0);\nVAR14.safeTransfer(VAR15, VAR20);\n}\n}\ncontract CON6 {\naddress public VAR21;\nconstructor() public {\nVAR21 = msg.sender;\n}\nmodifier FUN8 {\nrequire(msg.sender == VAR21);\n_;\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR14;\nconstructor(CON3 VAR17) public {\nVAR14 = VAR17;\n}\nfunction FUN9() public {\nuint256 VAR20 = VAR14.balanceOf(this);\nrequire(VAR20 > 0);\nVAR14.FUN3(VAR14, VAR20);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN10(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR22 = msg.sender;\nVAR1[VAR22] = VAR1[VAR22].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON6 {\nstring public constant VAR23 = \"IdealCoin\";\nstring public constant VAR24 = \"IDC\";\nuint8 public constant VAR25 = 18;\nuint256 public constant VAR26 = 2200000000 * 10**uint256(VAR25);\naddress public VAR27;\naddress public VAR28;\naddress public VAR29;\naddress public VAR30;\nuint64 public VAR31 = 1548979200;\nCON7 public VAR32;\nmapping(address => address) public VAR33;\nbool public VAR34 = false;\nmodifier FUN11 {\nrequire(!VAR34);\n_;\n}\nconstructor(address VAR35, address VAR36,address VAR37, address VAR38) public {\nrequire(VAR35 != address(0));\nrequire(VAR36 != address(0));\nrequire(VAR37 != address(0));\nrequire(VAR38 != address(0));\nVAR27 = VAR35;\nVAR28 = VAR36;\nVAR29 = VAR37;\nVAR30 = VAR38;\nuint256 VAR39 = 73050000;\nFUN14(VAR39, VAR29);\nuint256 VAR40 = 7950000;\nFUN14(VAR40, VAR30);\nuint256 VAR41 = 12000000;\nFUN14(VAR41, VAR27);\nuint256 VAR42 = 2080000000;\nFUN14(VAR42, VAR28);\nrequire(VAR2 <= VAR26);\n}\nfunction FUN12() external FUN8 FUN11 {\nuint256 VAR43 = 27000000;\nVAR32 = FUN13(VAR43);\nrequire(VAR2 <= VAR26);\n}\nfunction FUN13(uint256 VAR44) internal FUN8 returns (CON7) {\nCON7 VAR45 = new CON7(CON3(this));\nFUN14(VAR44, VAR45);\nVAR45.FUN9();\nreturn VAR45;\n}\nfunction FUN14(uint256 VAR46, address VAR47) internal FUN8 {\nuint256 VAR44 = VAR46 * 10**uint256(VAR25);\nVAR2 = VAR2.add(VAR44);\nVAR1[VAR47] = VAR44;\nrequire(VAR2 <= VAR26);\n}\nfunction FUN15(address VAR18, uint256 VAR48) external FUN8 {\nrequire(VAR33[VAR18] == 0x0);\nrequire(VAR18 != address(0));\nCON5 VAR49 = new CON5(CON3(this), VAR18, VAR31);\nVAR33[VAR18] = address(VAR49);\nrequire(this.FUN2(VAR32, VAR49, VAR48));\n}\nfunction FUN16() external {\nFUN17(msg.sender);\n}\nfunction FUN17(address VAR8) public {\nCON5(VAR33[VAR8]).FUN7();\n}\nfunction FUN18() external FUN8 FUN11 {\nuint256 VAR50 = VAR1[VAR29];\nVAR1[VAR28] = VAR1[VAR28].add(VAR50);\nVAR1[VAR29] = 0;\nuint256 VAR51 = VAR1[VAR30];\nVAR1[VAR28] = VAR1[VAR28].add(VAR51);\nVAR1[VAR30] = 0;\nVAR34 = true;\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR34 || msg.sender == address(this) || msg.sender == VAR21) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nreturn false;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR34 || msg.sender == VAR29 || msg.sender == VAR30) {\nreturn super.FUN1(VAR3, VAR4);\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0x3ca51bd89078145a8a16f09fc254677550bdb566.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bool VAR1) public {\nrequire(!VAR1, \"Shit it reverted!\");\n}\nfunction FUN2(bool VAR1) public returns (uint256) {\nrequire(!VAR1, \"Shit it reverted!\");\nreturn 42;\n}\n}",
        "label": false,
        "name": "0x376c128eb3d734912de09f6ad9a8609e3f87e13f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10, uint VAR11) public FUN3 returns (bool VAR14) {\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10, uint VAR12) public FUN3 returns (bool VAR14) {\nreturn super.FUN11(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nuint8 public constant VAR15 = 18;\nbool public VAR16 = false;\nmodifier FUN12() {\nrequire(!VAR16);\n_;\n}\nmodifier FUN13() {\nrequire(VAR16);\n_;\n}\nfunction FUN14(address VAR6, uint256 VAR17)\nexternal\nFUN1\nFUN12\nFUN3\nreturns (bool)\n{\nVAR5 = VAR5.add(VAR17);\nVAR4[VAR6] = VAR4[VAR6].add(VAR17);\nreturn true;\n}\nfunction FUN15() external FUN1 FUN12 returns (bool) {\nVAR16 = true;\nreturn true;\n}\nfunction FUN16() external FUN1 FUN13 returns (bool) {\nVAR16 = false;\nreturn true;\n}\n}\ncontract CON9 {\nuint public VAR18;\nfunction FUN17(address VAR9, uint256 VAR7) public {}\n}\ncontract CON10 is CON8 {\naddress public VAR19;\nbool private VAR20;\nCON9 public VAR21;\nuint public VAR22;\nenum UpgradeState { NotAllowed, Waiting, ReadyToUpgrade, Upgrading }\nmodifier FUN18 {\nrequire(msg.sender == VAR19);\n_;\n}\nmodifier FUN19 {\nrequire(getUpgradeState() != UpgradeState.Upgrading);\n_;\n}\nfunction CON10(address VAR23) public {\nVAR19 = VAR23;\n}\nfunction FUN20(address VAR24)\nexternal\nFUN18\nFUN19\n{\nrequire(canUpgrade());\nrequire(VAR24 != address(0));\nVAR21 = CON9(VAR24);\nrequire(VAR21.isTokenUpgrader());\nrequire(VAR21.VAR18() == VAR5);\n}\nfunction FUN21(uint VAR7) external {\nUpgradeState VAR25 = getUpgradeState();\nrequire(VAR25 == UpgradeState.ReadyToUpgrade || VAR25 == UpgradeState.Upgrading);\nrequire(VAR7 != 0);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR5 = VAR5.sub(VAR7);\nVAR22 = VAR22.add(VAR7);\nVAR21.FUN17(msg.sender, VAR7);\n}\nfunction FUN22(address VAR26) external FUN18 {\nrequire(VAR26 != address(0));\nVAR19 = VAR26;\n}\nfunction FUN23() external FUN18 () {\nVAR20 = true;\n}\nfunction FUN24() external FUN18 () {\nrequire(!(VAR22 > 0));\nVAR20 = false;\n}\n}\ncontract CON11 is CON10 {\nstring public VAR27 = \"Ydentity\";\nstring public VAR28 = \"YDY\";\nuint8 public constant VAR15 = 18;\nuint256 public VAR29;\nfunction CON11(address VAR30, address VAR23, uint256 VAR31)\npublic\nCON10(VAR23)\n{\nVAR29 = VAR31 * (10 ** uint256(VAR15));\nVAR5 = VAR29;\nVAR4[VAR30] = VAR29;\n}\nfunction FUN25(string VAR32, string VAR33) external FUN1 {\nVAR27 = VAR32;\nVAR28 = VAR33;\n}\n}",
        "label": false,
        "name": "0xf0f9f4d63b7dd586e6b07806b0f39cc9cd7e9490.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bytes32 VAR1) public {\n}\nfunction FUN2() public {\n}\n}",
        "label": false,
        "name": "0x8ac16c08105de55a02e2b7462b1eec6085fa4d86.sol"
    },
    {
        "source": "{\"EthexJackpot.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\ncontract EthexJackpot {\\n    mapping(uint256 =\\u003e address payable) tickets;\\n    uint256 public numberEnd;\\n    uint256 public dailyAmount;\\n    uint256 public weeklyAmount;\\n    uint256 public monthlyAmount;\\n    uint256 public seasonalAmount;\\n    bool private dailyProcessed;\\n    bool private weeklyProcessed;\\n    bool private monthlyProcessed;\\n    bool private seasonalProcessed;\\n    uint256 private dailyNumberStartPrev;\\n    uint256 private weeklyNumberStartPrev;\\n    uint256 private monthlyNumberStartPrev;\\n    uint256 private seasonalNumberStartPrev;\\n    uint256 private dailyStart;\\n    uint256 private weeklyStart;\\n    uint256 private monthlyStart;\\n    uint256 private seasonalStart;\\n    uint256 private dailyEnd;\\n    uint256 private weeklyEnd;\\n    uint256 private monthlyEnd;\\n    uint256 private seasonalEnd;\\n    uint256 private dailyNumberStart;\\n    uint256 private weeklyNumberStart;\\n    uint256 private monthlyNumberStart;\\n    uint256 private seasonalNumberStart;\\n    uint256 private dailyNumberEndPrev;\\n    uint256 private weeklyNumberEndPrev;\\n    uint256 private monthlyNumberEndPrev;\\n    uint256 private seasonalNumberEndPrev;\\n    address public lotoAddress;\\n    address payable private owner;\\n    \\n    event Jackpot (\\n        uint256 number,\\n        uint256 count,\\n        uint256 amount,\\n        byte jackpotType\\n    );\\n    \\n    event Ticket (\\n        bytes16 indexed id,\\n        uint256 number\\n    );\\n    \\n    uint256 constant DAILY = 5000;\\n    uint256 constant WEEKLY = 35000;\\n    uint256 constant MONTHLY = 140000;\\n    uint256 constant SEASONAL = 420000;\\n    \\n    constructor() public payable {\\n        owner = msg.sender;\\n        dailyStart = block.number / DAILY * DAILY;\\n        dailyEnd = dailyStart + DAILY;\\n        dailyProcessed = true;\\n        weeklyStart = block.number / WEEKLY * WEEKLY;\\n        weeklyEnd = weeklyStart + WEEKLY;\\n        weeklyProcessed = true;\\n        monthlyStart = block.number / MONTHLY * MONTHLY;\\n        monthlyEnd = monthlyStart + MONTHLY;\\n        monthlyProcessed = true;\\n        seasonalStart = block.number / SEASONAL * SEASONAL;\\n        seasonalEnd = seasonalStart + SEASONAL;\\n        seasonalProcessed = true;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n    \\n    modifier onlyLoto {\\n        require(msg.sender == lotoAddress, \\\"Loto only\\\");\\n        _;\\n    }\\n    \\n    function migrate(address payable newContract) external onlyOwner {\\n        newContract.transfer(address(this).balance);\\n    }\\n\\n    function registerTicket(bytes16 id, address payable gamer) external onlyLoto {\\n        uint256 number = numberEnd + 1;\\n        if (block.number \\u003e= dailyEnd) {\\n            setDaily();\\n            dailyNumberStart = number;\\n        }\\n        if (block.number \\u003e= weeklyEnd) {\\n            setWeekly();\\n            weeklyNumberStart = number;\\n        }\\n        if (block.number \\u003e= monthlyEnd) {\\n            setMonthly();\\n            monthlyNumberStart = number;\\n        }\\n        if (block.number \\u003e= seasonalEnd) {\\n            setSeasonal();\\n            seasonalNumberStart = number;\\n        }\\n        numberEnd = number;\\n        tickets[number] = gamer;\\n        emit Ticket(id, number);\\n    }\\n    \\n    function setLoto(address loto) external onlyOwner {\\n        lotoAddress = loto;\\n    }\\n    \\n    function payIn() external payable {\\n        uint256 amount = msg.value / 4;\\n        dailyAmount += amount;\\n        weeklyAmount += amount;\\n        monthlyAmount += amount;\\n        seasonalAmount += amount;\\n    }\\n    \\n    function settleJackpot() external {\\n        if (block.number \\u003e= dailyEnd) {\\n            setDaily();\\n        }\\n        if (block.number \\u003e= weeklyEnd) {\\n            setWeekly();\\n        }\\n        if (block.number \\u003e= monthlyEnd) {\\n            setMonthly();\\n        }\\n        if (block.number \\u003e= seasonalEnd) {\\n            setSeasonal();\\n        }\\n        \\n        if (block.number == dailyStart)\\n            return;\\n        \\n        uint48 modulo = uint48(bytes6(blockhash(dailyStart) \\u003c\\u003c 29));\\n        \\n        uint256 dailyPayAmount;\\n        uint256 weeklyPayAmount;\\n        uint256 monthlyPayAmount;\\n        uint256 seasonalPayAmount;\\n        uint256 dailyWin;\\n        uint256 weeklyWin;\\n        uint256 monthlyWin;\\n        uint256 seasonalWin;\\n        if (dailyProcessed == false) {\\n            dailyPayAmount = dailyAmount; \\n            dailyAmount = 0;\\n            dailyProcessed = true;\\n            dailyWin = getNumber(dailyNumberStartPrev, dailyNumberEndPrev, modulo);\\n            emit Jackpot(dailyWin, dailyNumberEndPrev - dailyNumberStartPrev + 1, dailyPayAmount, 0x01);\\n        }\\n        if (weeklyProcessed == false) {\\n            weeklyPayAmount = weeklyAmount;\\n            weeklyAmount = 0;\\n            weeklyProcessed = true;\\n            weeklyWin = getNumber(weeklyNumberStartPrev, weeklyNumberEndPrev, modulo);\\n            emit Jackpot(weeklyWin, weeklyNumberEndPrev - weeklyNumberStartPrev + 1, weeklyPayAmount, 0x02);\\n        }\\n        if (monthlyProcessed == false) {\\n            monthlyPayAmount = monthlyAmount;\\n            monthlyAmount = 0;\\n            monthlyProcessed = true;\\n            monthlyWin = getNumber(monthlyNumberStartPrev, monthlyNumberEndPrev, modulo);\\n            emit Jackpot(monthlyWin, monthlyNumberEndPrev - monthlyNumberStartPrev + 1, monthlyPayAmount, 0x04);\\n        }\\n        if (seasonalProcessed == false) {\\n            seasonalPayAmount = seasonalAmount;\\n            seasonalAmount = 0;\\n            seasonalProcessed = true;\\n            seasonalWin = getNumber(seasonalNumberStartPrev, seasonalNumberEndPrev, modulo);\\n            emit Jackpot(seasonalWin, seasonalNumberEndPrev - seasonalNumberStartPrev + 1, seasonalPayAmount, 0x08);\\n        }\\n        if (dailyPayAmount \\u003e 0)\\n            tickets[dailyWin].transfer(dailyPayAmount);\\n        if (weeklyPayAmount \\u003e 0)\\n            tickets[weeklyWin].transfer(weeklyPayAmount);\\n        if (monthlyPayAmount \\u003e 0)\\n            tickets[monthlyWin].transfer(monthlyPayAmount);\\n        if (seasonalPayAmount \\u003e 0)\\n            tickets[seasonalWin].transfer(seasonalPayAmount);\\n    }\\n    \\n    function setDaily() private {\\n        dailyProcessed = dailyNumberEndPrev == numberEnd;\\n        dailyStart = dailyEnd;\\n        dailyEnd = dailyStart + DAILY;\\n        dailyNumberStartPrev = dailyNumberStart;\\n        dailyNumberEndPrev = numberEnd;\\n    }\\n    \\n    function setWeekly() private {\\n        weeklyProcessed = weeklyNumberEndPrev == numberEnd;\\n        weeklyStart = weeklyEnd;\\n        weeklyEnd = weeklyStart + WEEKLY;\\n        weeklyNumberStartPrev = weeklyNumberStart;\\n        weeklyNumberEndPrev = numberEnd;\\n    }\\n    \\n    function setMonthly() private {\\n        monthlyProcessed = monthlyNumberEndPrev == numberEnd;\\n        monthlyStart = monthlyEnd;\\n        monthlyEnd = monthlyStart + MONTHLY;\\n        monthlyNumberStartPrev = monthlyNumberStart;\\n        monthlyNumberEndPrev = numberEnd;\\n    }\\n    \\n    function setSeasonal() private {\\n        seasonalProcessed = seasonalNumberEndPrev == numberEnd;\\n        seasonalStart = seasonalEnd;\\n        seasonalEnd = seasonalStart + SEASONAL;\\n        seasonalNumberStartPrev = seasonalNumberStart;\\n        seasonalNumberEndPrev = numberEnd;\\n    }\\n    \\n    function getNumber(uint256 startNumber, uint256 endNumber, uint48 modulo) pure private returns (uint256) {\\n        return startNumber + modulo % (endNumber - startNumber + 1);\\n    }\\n}\\n\"},\"EthexLoto.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./EthexJackpot.sol\\\";\\n\\ncontract EthexLoto {\\n    struct Bet {\\n        uint256 blockNumber;\\n        uint256 amount;\\n        bytes16 id;\\n        bytes6 bet;\\n        address payable gamer;\\n    }\\n    \\n    struct Payout {\\n        uint256 amount;\\n        bytes32 blockHash;\\n        bytes16 id;\\n        address payable gamer;\\n    }\\n    \\n    Bet[] betArray;\\n    \\n    address payable public jackpotAddress;\\n    address payable private owner;\\n\\n    event Result (\\n        uint256 amount,\\n        bytes32 blockHash,\\n        bytes16 indexed id,\\n        address indexed gamer\\n    );\\n    \\n    uint8 constant N = 16;\\n    uint256 constant MIN_BET = 0.01 ether;\\n    uint256 constant MAX_BET = 100 ether;\\n    uint256 constant PRECISION = 1 ether;\\n    uint256 constant JACKPOT_PERCENT = 10;\\n    \\n    constructor(address payable jackpot) public payable {\\n        owner = msg.sender;\\n        jackpotAddress = jackpot;\\n    }\\n    \\n    function() external payable { }\\n    \\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n    \\n    function placeBet(bytes22 params) external payable {\\n        require(msg.value \\u003e= MIN_BET, \\\"Bet amount should be greater or equal than minimal amount\\\");\\n        require(msg.value \\u003c= MAX_BET, \\\"Bet amount should be lesser or equal than maximal amount\\\");\\n        require(bytes16(params) != 0, \\\"Id should not be 0\\\");\\n        \\n        bytes16 id = bytes16(params);\\n        bytes6 bet = bytes6(params \\u003c\\u003c 128);\\n        \\n        uint256 jackpotFee = msg.value * JACKPOT_PERCENT * PRECISION / 100 / PRECISION;\\n        betArray.push(Bet(block.number, msg.value - jackpotFee, id, bet, msg.sender));\\n        \\n        uint8 markedCount;\\n        for (uint i = 0; i \\u003c bet.length; i++) {\\n            if (bet[i] \\u003e 0x13)\\n                continue;\\n            markedCount++;\\n        }\\n        if (markedCount \\u003e 1)\\n            EthexJackpot(jackpotAddress).registerTicket(id, msg.sender);\\n        \\n        EthexJackpot(jackpotAddress).payIn.value(jackpotFee)();\\n    }\\n    \\n    function settleBets() external {\\n        if (betArray.length == 0)\\n            return;\\n\\n        Payout[] memory payouts = new Payout[](betArray.length);\\n        Bet[] memory missedBets = new Bet[](betArray.length);\\n        uint256 totalPayout;\\n        uint i = betArray.length;\\n        do {\\n            i--;\\n            if(betArray[i].blockNumber \\u003e= block.number)\\n                missedBets[i] = betArray[i];\\n            else {\\n                bytes32 blockHash = blockhash(betArray[i].blockNumber);\\n                uint256 coefficient = PRECISION;\\n                uint8 markedCount;\\n                uint8 matchesCount;\\n                uint256 divider = 1;\\n                for (uint8 j = 0; j \\u003c betArray[i].bet.length; j++) {\\n                    if (betArray[i].bet[j] \\u003e 0x13)\\n                        continue;\\n                    markedCount++;\\n                    byte field;\\n                    if (j % 2 == 0)\\n                        field = blockHash[29 + j / 2] \\u003e\\u003e 4;\\n                    else\\n                        field = blockHash[29 + j / 2] \\u0026 0x0F;\\n                    if (betArray[i].bet[j] \\u003c 0x10) {\\n                        if (field == betArray[i].bet[j])\\n                            matchesCount++;\\n                        else\\n                            divider *= 15 + N;\\n                        continue;\\n                    }\\n                    if (betArray[i].bet[j] == 0x10) {\\n                        if (field \\u003e 0x09 \\u0026\\u0026 field \\u003c 0x10) {\\n                            matchesCount++;\\n                            divider *= 6;\\n                        } else\\n                            divider *= 10 + N;\\n                        continue;\\n                    }\\n                    if (betArray[i].bet[j] == 0x11) {\\n                        if (field \\u003c 0x0A) {\\n                            matchesCount++;\\n                            divider *= 10;\\n                        } else\\n                            divider *= 6 + N;\\n                        continue;\\n                    }\\n                    if (betArray[i].bet[j] == 0x12) {\\n                        if (field \\u003c 0x0A \\u0026\\u0026 field \\u0026 0x01 == 0x01) {\\n                            matchesCount++;\\n                            divider *= 5;\\n                        } else\\n                            divider *= 11 + N;\\n                        continue;\\n                    }\\n                    if (betArray[i].bet[j] == 0x13) {\\n                        if (field \\u003c 0x0A \\u0026\\u0026 field \\u0026 0x01 == 0x0) {\\n                            matchesCount++;\\n                            divider *= 5;\\n                        } else\\n                            divider *= 11 + N;\\n                        continue;\\n                    }\\n                }\\n            \\n                if (matchesCount == 0)\\n                    coefficient = 0;\\n                else {\\n                    uint256 missedCount = markedCount - matchesCount;\\n                    divider *= missedCount ** missedCount;\\n                    coefficient = coefficient * 16**uint256(markedCount) / divider;\\n                }\\n                \\n                uint payoutAmount = betArray[i].amount * coefficient / PRECISION;\\n                if (payoutAmount == 0 \\u0026\\u0026 matchesCount \\u003e 0)\\n                    payoutAmount = matchesCount;\\n                payouts[i] = Payout(payoutAmount, blockHash, betArray[i].id, betArray[i].gamer);\\n                totalPayout += payoutAmount;\\n            }\\n            betArray.pop();\\n        } while (i \\u003e 0);\\n        \\n        i = missedBets.length;\\n        do {\\n            i--;\\n            if (missedBets[i].id != 0)\\n                betArray.push(missedBets[i]);\\n        } while (i \\u003e 0);\\n        \\n        uint balance = address(this).balance;\\n        for (i = 0; i \\u003c payouts.length; i++) {\\n            if (payouts[i].id \\u003e 0) {\\n                if (totalPayout \\u003e balance)\\n                    emit Result(balance * payouts[i].amount * PRECISION / totalPayout / PRECISION, payouts[i].blockHash, payouts[i].id, payouts[i].gamer);\\n                else\\n                    emit Result(payouts[i].amount, payouts[i].blockHash, payouts[i].id, payouts[i].gamer);\\n            }\\n        }\\n        for (i = 0; i \\u003c payouts.length; i++) {\\n            if (payouts[i].amount \\u003e 0) {\\n                if (totalPayout \\u003e balance)\\n                    payouts[i].gamer.transfer(balance * payouts[i].amount * PRECISION / totalPayout / PRECISION);\\n                else\\n                    payouts[i].gamer.transfer(payouts[i].amount);\\n            }\\n        }\\n    }\\n    \\n    function migrate(address payable newContract) external onlyOwner {\\n        newContract.transfer(address(this).balance);\\n    }\\n}\"}}",
        "label": false,
        "name": "0xd8811b4d7e19f98cb476d80f1231f9708acb5b08.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public VAR1 = \"CrypotaPay Token\";\nstring public VAR2 = \"CTT\";\nuint256 public VAR3 = 1000000;\nuint8 public VAR4 = 0;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nuint256 public VAR8;\nmapping(address => uint256) public VAR9;\nbool public VAR10 = false;\nuint256 VAR11;\nmodifier FUN1() {\nrequire(!VAR10);\n_;\n}\nmodifier FUN2() {\nrequire(VAR10);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction CON2() {\nVAR5 = msg.sender;\nVAR6[VAR5] = 1000000;\n}\nfunction VAR3() constant returns (uint256 VAR12) {\nreturn VAR3;\n}\nfunction FUN4(address VAR13) constant returns (uint256 VAR14) {\nreturn VAR6[VAR13];\n}\nfunction FUN5(address VAR15, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire(VAR15 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR16);\nVAR6[VAR15] = VAR6[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN6(address VAR18, address VAR15, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire(VAR15 != address(0));\nvar VAR19 = VAR7[VAR18][msg.sender];\nVAR6[VAR18] = VAR6[VAR18].sub(VAR16);\nVAR6[VAR15] = VAR6[VAR15].add(VAR16);\nVAR7[VAR18][msg.sender] = VAR19.sub(VAR16);\nreturn true;\n}\nfunction FUN7(address VAR20, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire((VAR16 == 0) || (VAR7[msg.sender][VAR20] == 0));\nVAR7[msg.sender][VAR20] = VAR16;\nreturn true;\n}\nfunction FUN8(address VAR21, address VAR20) constant returns (uint256 VAR22) {\nreturn VAR7[VAR21][VAR20];\n}\nfunction FUN9 (address VAR20, uint VAR23) FUN1 returns (bool VAR17) {\nVAR7[msg.sender][VAR20] = VAR7[msg.sender][VAR20].add(VAR23);\nreturn true;\n}\nfunction FUN10 (address VAR20, uint VAR24) FUN1 returns (bool VAR17) {\nuint VAR25 = VAR7[msg.sender][VAR20];\nif (VAR24 > VAR25) {\nVAR7[msg.sender][VAR20] = 0;\n} else {\nVAR7[msg.sender][VAR20] = VAR25.sub(VAR24);\n}\nreturn true;\n}\nfunction FUN11(uint VAR16) returns (bool VAR17)\n{\nrequire(VAR16 > 0);\naddress VAR26 = msg.sender;\nVAR6[VAR26] = VAR6[VAR26].sub(VAR16);\nVAR3 = VAR3.sub(VAR16);\nreturn true;\n}\nfunction FUN12(address VAR15, uint256 VAR27) FUN3 returns (bool VAR17) {\nVAR3 = VAR3.add(VAR27);\nVAR6[VAR15] = VAR6[VAR15].add(VAR27);\nreturn true;\n}\nfunction () payable {\n}\nfunction FUN14() FUN3 FUN1 {\nVAR10 = true;\n}\nfunction FUN15() FUN3 FUN2 {\nVAR10 = false;\n}\nfunction FUN16() FUN3 {\nselfdestruct(VAR5);\n}\nfunction FUN17(address VAR28) FUN3 {\nrequire(VAR28 != address(0));\nVAR5 = VAR28;\n}\nfunction FUN18(CON1 VAR29) external FUN3 {\nVAR11 = VAR29.FUN4(this);\nVAR29.FUN5(VAR5, VAR11);\nVAR11 = 0;\n}\nfunction FUN19(address VAR15, uint256 VAR27) FUN3 {\nVAR9[VAR15] = VAR9[VAR15].add(VAR27);\nVAR8 = VAR8.add(VAR27);\n}\nfunction FUN20() {\naddress VAR30 = msg.sender;\nuint256 VAR31 = VAR9[VAR30];\nrequire(VAR31 != 0);\nrequire(this.VAR14 >= VAR31);\nVAR8 = VAR8.sub(VAR31);\nVAR9[VAR30] = 0;\nVAR30.FUN5(VAR31);\n}\nfunction FUN21(address VAR15, uint256 VAR27) FUN3 {\nrequire(VAR15 != address(0));\nrequire(this.VAR14 >= VAR27);\nVAR15.FUN5(VAR27);\n}\n}",
        "label": false,
        "name": "0xa1a9733966c709172f7b13a644e69005f9466409.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 100000000000 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = 'BLOCKBUSTER';\nVAR2 = 'BBX';\n}\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6840e9d28a8ede5f238becdd8a6dad2a8671ea4c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nuint256 public VAR1;\nuint256 public VAR2;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\naddress public VAR3;\naddress public VAR4;\nconstructor(address VAR5, address VAR6)\npublic\n{\nVAR2 = 0;\nVAR3 = VAR5;\nVAR4 = VAR6;\n}\nmodifier FUN1()\n{\nrequire(msg.sender == VAR3, \"rateControl key required for this function.\");\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR4, \"tokenAssignmentControl key required for this function.\");\n_;\n}\nfunction FUN3(uint256 VAR7)\npublic\nFUN1\n{\nVAR2 = now;\nrequire(VAR7 > 0, \"Please assign a valid rate.\");\nVAR1 = VAR7;\n}\nfunction FUN4(CON1 VAR8, address VAR9)\npublic\nFUN2\n{\nVAR8.transfer(VAR9, VAR8.balanceOf(address(this)));\n}\nfunction() external\npayable\n{\nrevert(\"The contract cannot receive ETH payments.\");\n}\n}",
        "label": false,
        "name": "0x1863d1351fc3003f1ad361939248e3a3a114958e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nstruct Beneficiary {\nuint256 VAR1;\nuint256 VAR2;\nuint256 VAR3;\nuint256 VAR4;\nuint256 VAR5;\n}\nmapping (address => Beneficiary) public VAR6;\nCON1 public VAR7;\nuint256 public VAR8 = 142816;\nmodifier FUN1 (address VAR9) { require(VAR6[VAR9].VAR1 != 0); _; }\nconstructor (CON1 VAR10) public {\nrequire(VAR10 != CON1(0x0));\nVAR7 = VAR10;\n}\nfunction FUN2 (address VAR9) public FUN1(VAR9) {\nuint256 VAR11 = releasableAmount(VAR9);\nrequire(VAR11 > 0);\nVAR6[VAR9].VAR5 = VAR6[VAR9].VAR5.add(VAR11);\nVAR7.transfer(VAR9, VAR11);\nif (VAR6[VAR9].VAR5 == VAR6[VAR9].VAR4) { delete VAR6[VAR9];\n}\n}\nfunction FUN3 (address VAR9,uint256 VAR1,uint256 VAR2,uint256 VAR3,uint256 VAR12) public {\nrequire(VAR12 != 0 && VAR1 != 0 && VAR9 != address(0x0) && VAR3 < VAR2 && VAR6[VAR9].VAR1 == 0);\nrequire(VAR7.transferFrom(msg.sender, address(this), VAR12));\nVAR6[VAR9] = Beneficiary({VAR1: VAR1,VAR2: VAR2,VAR3: VAR1.add(VAR3),VAR4: VAR12,VAR5: 0});\n}\n}",
        "label": false,
        "name": "0xbe056a72d2924295503117c3022215da9f829f69.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nfunction CON2() public {\nFUN4(msg.sender);\n}\nmodifier FUN3() {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4) public FUN1 {\nrequire(!VAR3[VAR4]);\nVAR3[VAR4] = true;\n}\nfunction FUN5(address VAR4) public FUN1 {\nrequire(VAR3[VAR4]);\nVAR3[VAR4] = false;\n}\n}\ncontract CON3 is CON2 {\nmapping(address => bool) VAR5;\nfunction CON3() public {\nFUN7(msg.sender);\n}\nmodifier FUN6() {\nrequire(isWhitelisted(msg.sender));\n_;\n}\nfunction FUN7(address VAR6) public FUN3 {\nrequire(!VAR5[VAR6]);\nVAR5[VAR6] = true;\n}\nfunction FUN8(address VAR6) public FUN3 {\nrequire(VAR5[VAR6]);\nVAR5[VAR6] = false;\n}\n}",
        "label": false,
        "name": "0xbea81fde2822b74674fac9fc743193358c6bb792.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0), \"ERC20: FUN1 VAR4 the zero address\");\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"ERC20: mint VAR4 the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"ERC20: burn VAR7 the zero address\");\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN2 VAR7 the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 VAR4 the zero address\");\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 7700000000 * (10 ** uint256(VAR18));\nconstructor (address VAR11) public CON3(\"EVEGToken\", \"EVEG\", VAR18) {\nFUN7(VAR11, VAR19);\n}\n}",
        "label": false,
        "name": "0xc893c37e5e7cec4dad1054d69122ec3eea0ffc7b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"SoarUSD\";\nstring public constant VAR2 = \"SoarUSD\";\nuint8 public constant VAR3 = 5;\nuint public VAR4;\naddress public VAR5; address public VAR6;\nuint256 VAR7;\nbool VAR8 = false;\nmapping(address => uint) VAR9;\nmapping(address => mapping(address => uint)) VAR10;\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR6);\n_;\n}\nconstructor() public\n{\nVAR5 = msg.sender;\n}\nfunction FUN3(address VAR11, uint256 VAR12) external FUN1{\nrequire( VAR11 != 0x0 && VAR12 > 0);\nVAR9[VAR11] = (VAR9[VAR11]).add(VAR12);\nVAR4 = (VAR4).add(VAR12);\n}\nfunction FUN4(address VAR13) external FUN1\n{\nrequire(VAR13 != 0x0);\nVAR6 = VAR13;\n}\nfunction FUN5(address VAR11,uint256 VAR12) external FUN1{\nrequire(VAR9[VAR11] >= VAR12);\nrequire( VAR11 != 0x0 && VAR12 > 0);\nVAR9[VAR11] = (VAR9[VAR11]).sub(VAR12);\nVAR4 = VAR4.sub(VAR12);\n}\nfunction FUN6( address VAR14, address VAR15, uint256 VAR12 )public returns (bool VAR16) {\nrequire( VAR15 != 0x0);\nrequire(VAR9[VAR14] >= VAR12 && VAR10[VAR14][msg.sender] >= VAR12 && VAR12 >= 0);\nVAR9[VAR14] = (VAR9[VAR14]).sub(VAR12);\nVAR10[VAR14][msg.sender] = (VAR10[VAR14][msg.sender]).sub(VAR12);\nVAR9[VAR15] = (VAR9[VAR15]).add(VAR12);\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR12)public returns (bool VAR16) {\nrequire( VAR17 != 0x0);\nVAR10[msg.sender][VAR17] = VAR12;\nreturn true;\n}\nfunction FUN8(address VAR15, uint256 VAR12)public returns (bool VAR16) {\nrequire( VAR15 != 0x0);\nrequire(VAR9[msg.sender] >= VAR12 && VAR12 >= 0);\nVAR9[msg.sender] = (VAR9[msg.sender]).sub(VAR12);\nVAR9[VAR15] = (VAR9[VAR15]).add(VAR12);\nreturn true;\n}\nfunction FUN9(address VAR14,address VAR15,uint256 VAR12) external FUN2 returns(bool VAR16) {\nrequire( VAR15 != 0x0 && VAR14 !=0x0);\nrequire (VAR9[VAR14] >= VAR12 && VAR12 > 0);\nVAR9[VAR14] = (VAR9[VAR14]).sub(VAR12);\nVAR9[VAR15] = (VAR9[VAR15]).add(VAR12);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6275f4a535053880d553ba46af281c816776daf5.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nCON2 public VAR3;\nCON3 public VAR4;\nstruct Auction {\nbytes32 VAR5;\naddress VAR6;\nuint256 VAR7;\nuint256 VAR8;\n}\nmapping (uint256 => Auction) public VAR9;\nuint256 public VAR10;\nuint256 public VAR11;\nfunction CON4(address VAR12, address VAR13) public {\nVAR3 = CON2(VAR12);\nVAR4 = CON3(VAR13);\n}\nfunction FUN3(uint256 VAR14) FUN1 public {\nVAR11 = VAR14;\n}\nfunction FUN4(uint8 VAR15) FUN1 public {\nrequire(VAR15 < 100);\nVAR10 = VAR15;\n}\nfunction FUN5(uint256 VAR16, uint256 VAR17, uint256 VAR8) public {\naddress VAR18 = VAR4.ownerOf(VAR16);\nrequire(msg.sender == VAR18);\nrequire(VAR4.isAuthorized(address(this), VAR16));\nrequire(VAR17 > 0);\nrequire(VAR8 > now.add(1 minutes));\nbytes32 VAR19 = keccak256(block.timestamp,VAR18,VAR16,VAR17);\nVAR9[VAR16] = Auction({VAR5: VAR19,VAR6: VAR18,VAR7: VAR17,VAR8: VAR8});\nif (VAR11 > 0) {\nrequire(VAR3.transferFrom(msg.sender,VAR1,VAR11));\n}\n}\nfunction FUN6(uint256 VAR16) public {\nrequire(VAR9[VAR16].VAR6 == msg.sender || msg.sender == VAR1);\nbytes32 VAR19 = VAR9[VAR16].VAR5;\naddress VAR20 = VAR9[VAR16].VAR6;\ndelete VAR9[VAR16];\n}\nfunction FUN7(uint256 VAR16, uint256 VAR7) public {\naddress VAR6 = VAR9[VAR16].VAR6;\nrequire(VAR6 != address(0));\nrequire(VAR6 != msg.sender);\nrequire(VAR9[VAR16].VAR7 == VAR7);\nrequire(now < VAR9[VAR16].VAR8);\nrequire(VAR6 == VAR4.ownerOf(VAR16));\nuint VAR21 = 0;\nif (VAR10 > 0) {\nVAR21 = VAR7.mul(VAR10).div(100);\nVAR3.transferFrom(msg.sender,VAR1,VAR21);\n}\nVAR3.transferFrom(msg.sender,VAR6,VAR7.sub(VAR21));\nVAR4.safeTransferFrom(VAR6,msg.sender,VAR16);\nbytes32 VAR19 = VAR9[VAR16].VAR5;\ndelete VAR9[VAR16];\n}\n}",
        "label": false,
        "name": "0xcd2de7fd530269feaf6075c8bca940526fd7c4de.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 VAR1 = CON1(0x2bd2326c993dfaef84f696526064ff22eba5b362);\nfunction FUN1(bool VAR2, address VAR3) returns(bool) {\nif (VAR1.VAR2() && VAR2 && VAR3.send(msg.value)) {\nreturn true;\n}\nelse\nif (!VAR1.VAR2() && !VAR2 && VAR3.send(msg.value)) {\nreturn true;\n}\nthrow; }\nfunction() {\nthrow;\n}\n}",
        "label": false,
        "name": "0x5dc8108fc79018113a58328f5283b376b83922ef.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, \"Only owner\");\n_;\n}\nfunction FUN2(address VAR2) external FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nuint256 public constant VAR3 = 86400 * 365;\nuint256 public VAR4;\nconstructor() public {\nVAR4 = now;\n}\nmodifier FUN3() {\nrequire(now >= VAR4, \"Wallet locked\");\n_;\n}\nfunction FUN4(uint256 VAR5) external FUN1 {\nrequire(VAR5 > VAR4, \"Can't set VAR4 to past\");\nrequire(VAR5 - VAR4 <= VAR3, \"Max VAR4 jump exceeded\");\nVAR4 = VAR5;\n}\nfunction FUN5(CON1 VAR6, address VAR7, uint256 VAR8) external FUN1 FUN3 returns (bool) {\nreturn VAR6.transfer(VAR7, VAR8);\n}\nfunction FUN6(address payable VAR7, uint256 VAR8, bytes calldata VAR9) external FUN1 FUN3 returns (bool, bytes memory) {\nreturn VAR7.FUN6.value(VAR8)(VAR9);\n}\n}",
        "label": false,
        "name": "0x9828280f1decd9a622f2e6d4bd0915384aaa79ea.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR11 = \"Devcon4Token\";\nstring public constant VAR12 = \"D4T\";\nuint256 public constant VAR13 = 1000000;\nconstructor() public {\nFUN7(msg.sender, VAR13);\n}\n}",
        "label": false,
        "name": "0x69651b7daf9633da8f46f5712cc511b32b2749cd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"CryptoAthletes\"; string public constant VAR2 = \"AthleteToken\";\nuint256 private VAR3 = 0.001 ether;\nuint256 private constant VAR4 = 5000;\nuint256 private VAR5 = 0.053613 ether;\nuint256 private VAR6 = 0.564957 ether;\nmapping (uint256 => address) public VAR7;\nmapping (address => uint256) private VAR8;\nmapping (uint256 => address) public VAR9;\nmapping (uint256 => uint256) private VAR10;\naddress public VAR11;\naddress public VAR12;\nuint256 public VAR13;\nstruct Athlete {\nstring VAR14;\n}\nAthlete[] private VAR15;\nmodifier FUN1() {\nrequire(msg.sender == VAR11);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR12);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR11 ||msg.sender == VAR12);\n_;\n}\nfunction CON2() public {\nVAR11 = msg.sender;\nVAR12 = msg.sender;\n}\nfunction FUN4(address VAR16,uint256 VAR17) public {\nrequire(_owns(msg.sender, VAR17));\nVAR9[VAR17] = VAR16;\n}\nfunction FUN5(address VAR18, string VAR19, uint256 VAR20) public FUN2 {\nrequire(VAR13 < VAR4);\naddress VAR21 = VAR18;\nif (VAR21 == address(0)) {\nVAR21 = VAR12;\n}\nif (VAR20 <= 0) {\nVAR20 = VAR3;\n}\nVAR13++;\nFUN14(VAR19, VAR21, VAR20);\n}\nfunction FUN6(string VAR19) public FUN2 {\nFUN14(VAR19, address(this), VAR3);\n}\nfunction FUN7(address VAR16) public FUN3 {\nFUN15(VAR16);\n}\nfunction FUN8(uint256 VAR17) public payable {\naddress VAR22 = VAR7[VAR17];\naddress VAR23 = msg.sender;\nuint256 VAR24 = VAR10[VAR17];\nrequire(VAR22 != VAR23);\nrequire(_addressNotNull(VAR23));\nrequire(msg.value >= VAR24);\nuint256 VAR25 = uint256(SafeMath.div(SafeMath.mul(VAR24, 93), 100));\nuint256 VAR26 = SafeMath.sub(msg.value, VAR24);\nif (VAR24 < VAR5) {\nVAR10[VAR17] = SafeMath.div(SafeMath.mul(VAR24, 200), 93);\n} else if (VAR24 < VAR6) {\nVAR10[VAR17] = SafeMath.div(SafeMath.mul(VAR24, 120), 93);\n} else {\nVAR10[VAR17] = SafeMath.div(SafeMath.mul(VAR24, 115), 93);\n}\nFUN16(VAR22, VAR23, VAR17);\nif (VAR22 != address(this)) {\nVAR22.FUN12(VAR25); }\nmsg.sender.FUN12(VAR26);\n}\nfunction FUN9(address VAR27) public FUN1 {\nrequire(VAR27 != address(0));\nVAR11 = VAR27;\n}\nfunction FUN10(address VAR28) public FUN1 {\nrequire(VAR28 != address(0));\nVAR12 = VAR28;\n}\nfunction FUN11(uint256 VAR17) public {\naddress VAR23 = msg.sender;\naddress VAR22 = VAR7[VAR17];\nrequire(_addressNotNull(VAR23));\nrequire(_approved(VAR23, VAR17));\nFUN16(VAR22, VAR23, VAR17);\n}\nfunction FUN12(address VAR16,uint256 VAR17) public {\nrequire(_owns(msg.sender, VAR17));\nrequire(_addressNotNull(VAR16));\nFUN16(msg.sender, VAR16, VAR17);\n}\nfunction FUN13(address VAR29,address VAR16,uint256 VAR17) public {\nrequire(_owns(VAR29, VAR17));\nrequire(_approved(VAR16, VAR17));\nrequire(_addressNotNull(VAR16));\nFUN16(VAR29, VAR16, VAR17);\n}\nfunction FUN14(string VAR19, address VAR18, uint256 VAR20) private {\nAthlete memory VAR30 = Athlete({VAR14: VAR19});\nuint256 VAR31 = VAR15.push(VAR30) - 1;\nrequire(VAR31 == uint256(uint32(VAR31)));\nVAR10[VAR31] = VAR20;\nFUN16(address(0), VAR18, VAR31);\n}\nfunction FUN15(address VAR16) private {\nif (VAR16 == address(0)) {\nVAR11.FUN12(this.balance);\n} else {\nVAR16.FUN12(this.balance);\n}\n}\nfunction FUN16(address VAR29, address VAR16, uint256 VAR17) private {\nVAR8[VAR16]++;\nVAR7[VAR17] = VAR16;\nif (VAR29 != address(0)) {\nVAR8[VAR29]--;\ndelete VAR9[VAR17];\n}\n}\n}",
        "label": false,
        "name": "0xf6c9ba140b47d336b0c16c87642a83cacd44857e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 10000000000000000000000000000;\nVAR6 = 10000000000000000000000000000;\nVAR3 = \"Contract Block Chain\";\nVAR4 = \"CBC\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x7e0b908220f49882b97d97bcaf197a4b2ea8c95e.sol"
    },
    {
        "source": "contract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract tokenRecipient { function sendApproval(address _from, uint256 _value, address _token); }\r\n\r\ncontract MyToken is owned { \r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\tuint8 public disableconstruction;\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    function MyTokenLoad(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\r\n\t\tif(disableconstruction != 2){\r\n            if(centralMinter != 0 ) owner = msg.sender;                     balanceOf[msg.sender] = initialSupply;                          name = tokenName;                                               symbol = tokenSymbol;                                           decimals = decimalUnits;                            \t\t}\r\n    }\r\n    function MyToken(){\r\n        MyTokenLoad(10000000000000,'Kraze',8,'KRZ',0);\r\n\t\tdisableconstruction=2;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;                   if (balanceOf[_to] + _value < balanceOf[_to]) throw;         balanceOf[msg.sender] -= _value;                             balanceOf[_to] += _value;                                    Transfer(msg.sender, _to, _value);                       }\r\n\r\n    \r\n    function () {\r\n        throw;         }\r\n}",
        "label": false,
        "name": "0x8a772004af0b8fca5e7093c6f277ba7b0e8fa97a.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\nmapping (address => uint256) VAR2;\nfunction CON1() public { }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR4);\nVAR2[msg.sender] = sub(VAR2[msg.sender], VAR4);\nVAR2[VAR3] = add(VAR2[VAR3], VAR4);\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nstring public VAR5 = \"QQQ\";\nstring public VAR6 = \"QQQ\";\nuint256 public VAR7 = 18;\nuint256 public VAR8 = 700000000*(10**18);\nuint256 public VAR9 = 50000000*(10**18);\nuint256 public VAR10 = 1543593600;\nuint256 public VAR11 = 1543593600; address public VAR12;\nstruct FreezeStruct {\nuint256 VAR13;\nbool VAR14;\n}\nFreezeStruct[] public VAR15;\nfunction CON2() public {\nVAR1 = 10*(10**8)*(10**18);\nVAR2[0x01] = VAR8;\nVAR2[msg.sender] = sub(VAR1,VAR8);\nVAR12 = msg.sender;\nVAR15.push(FreezeStruct({VAR13:1575129600, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1575129610, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1606752000, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1606752010, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1638288000, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1669824000, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1701360000, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1732982400, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1764518400, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1796054400, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1827590400, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1859212800, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1890748800, VAR14: true})); VAR15.push(FreezeStruct({VAR13:1922284800, VAR14: true})); }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire (now >= VAR10 || now >= VAR11);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.sender == VAR12);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN3(uint256 VAR16) public {\nrequire(msg.sender == VAR12);\nrequire(VAR16 <= VAR11);\nVAR10 = VAR16;\n}\nfunction FUN4(uint256 VAR17) public {\nrequire(msg.sender == VAR12);\nrequire(VAR17>=0 && VAR17<VAR15.length);\nrequire(now >= VAR15[VAR17].VAR13 && VAR15[VAR17].VAR14);\nrequire(VAR2[0x01] >= VAR9);\nVAR2[0x01] = sub(VAR2[0x01], VAR9);\nVAR2[VAR12] = add(VAR2[VAR12], VAR9);\nVAR8 = sub(VAR8, VAR9);\nVAR15[VAR17].VAR14 = false;\n}\nmodifier FUN5 {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN6(address VAR18) FUN5 public {\nif (VAR18 != address(0)) {\nVAR12 = VAR18;\n}\n}\n}",
        "label": false,
        "name": "0xa89ee2653044aecbe605f0b3d7a193de5cb4d6f9.sol"
    },
    {
        "source": "contract CON1 {\nfunction CON1() public { }\nfunction FUN1(bytes32 VAR1) public {\n}\n}",
        "label": false,
        "name": "0x0bec4767cd170242895d244d7ff73feaff6c2598.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing SafeERC20 for CON1;\nCON1 private VAR1;\naddress private VAR2;\nuint256 private VAR3;\nconstructor(CON1 VAR4, address VAR5, uint256 VAR6) public {\nrequire(VAR6 > block.timestamp);\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\nfunction FUN1() public {\nrequire(block.timestamp >= VAR3);\nuint256 VAR7 = VAR1.balanceOf(address(this));\nrequire(VAR7 > 0);\nVAR1.safeTransfer(VAR2, VAR7);\n}\n}",
        "label": false,
        "name": "0x01b5420c9beccf458461af5e0b1a6b072879f630.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nconstructor() public {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) public FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5\n{\nstring public VAR17 = \"VIR\";\nstring public VAR18 = \"Virtual Reality Token\";\nuint public VAR19 = 18;\nuint private constant VAR20 = 25e9 * 1e18;\nconstructor() public\n{\nVAR15 = msg.sender;\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\n}",
        "label": false,
        "name": "0x501202610ce02b97fcbd406157431214ca55ec75.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) public VAR3;\nmodifier FUN3() {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4, bool VAR5) FUN1 public {\nVAR3[VAR4] = VAR5;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() payable { }\nfunction FUN5() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN6(address VAR6) FUN1 public {\nselfdestruct(VAR6);\n}\n}\ncontract CON4 is CON1 {\nbool public VAR7 = false;\nmodifier FUN7() {\nrequire(!VAR7);\n_;\n}\nmodifier FUN8() {\nrequire(VAR7);\n_;\n}\nfunction FUN9() FUN1 FUN7 public {\nVAR7 = true;\n}\nfunction FUN10() FUN1 FUN8 public {\nVAR7 = false;\n}\n}\ncontract CON5 is CON1{\nstring public VAR8;\nfunction FUN11(string VAR9) FUN1 public {\nVAR8 = VAR9;\n}\n}\ncontract CON6 is CON4, CON5, CON3, CON2 {\nusing SafeMath for uint256;\nstring constant VAR10 = \"0.3\";\nuint public constant VAR11 = 15;\naddress public VAR12;\naddress public VAR13;\nfunction CON6(address VAR14, address VAR15) public {\nrequire(VAR14 != 0x0);\nVAR12 = VAR14;\nFUN14(VAR15);\n}\nfunction FUN12(address VAR16) external payable FUN3 FUN7 {\nrequire(VAR16 != 0x0);\nuint VAR17 = msg.value.sub(VAR11.mul(msg.value).div(1000));\nuint VAR18 = msg.value.sub(VAR17);\nVAR16.transfer(VAR17);\nVAR12.transfer(VAR18);\n}\nfunction FUN13(address VAR19) external FUN1 FUN7 {\nVAR12 = VAR19;\n}\nfunction FUN4(address VAR4, bool VAR5) public {\nrequire(msg.sender == VAR13 || msg.sender == VAR1);\nVAR3[VAR4] = VAR5;\n}\nfunction FUN14(address VAR15) public FUN1 {\nrequire(VAR15 != 0x0);\nVAR13 = VAR15;\n}\n}",
        "label": false,
        "name": "0x03dc9b46243703fa1c1f95c2693212635f742204.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5 {\nstring public VAR17 = \"Line Social\";\nstring public VAR18 = \"LINESO\";\nuint8 public VAR19 = 18;\nuint256 public constant VAR20 = 1000000000 * (10 ** uint256(VAR19));\nfunction CON6() {\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\n}",
        "label": false,
        "name": "0xb06ac1b07151d0f4aa3f50db058dd27ae64ce3cb.sol"
    },
    {
        "source": "contract Assertive {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract Owned is Assertive {\r\n  address internal owner;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  function Owned () {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  function getOwner() returns (address out) {\r\n    return owner;\r\n  }\r\n}\r\n\r\ncontract StateTransferrable is Owned {\r\n  bool internal locked;\r\n  event Locked(address indexed from);\r\n  event PropertySet(address indexed from);\r\n  modifier onlyIfUnlocked {\r\n    assert(!locked);\r\n    _\r\n  }\r\n  modifier setter {\r\n    _\r\n    PropertySet(msg.sender);\r\n  }\r\n  modifier onlyOwnerUnlocked {\r\n    assert(!locked && msg.sender == owner);\r\n    _\r\n  }\r\n  function lock() onlyOwner onlyIfUnlocked {\r\n    locked = true;\r\n    Locked(msg.sender);\r\n  }\r\n  function isLocked() returns (bool status) {\r\n    return locked;\r\n  }\r\n}\r\n\r\ncontract TrustEvents {\r\n  event AuthInit(address indexed from);\r\n  event AuthComplete(address indexed from, address indexed with);\r\n  event AuthPending(address indexed from);\r\n  event Unauthorized(address indexed from);\r\n  event InitCancel(address indexed from);\r\n  event NothingToCancel(address indexed from);\r\n  event SetMasterKey(address indexed from);\r\n  event AuthCancel(address indexed from, address indexed with);\r\n  event NameRegistered(address indexed from, bytes32 indexed name);\r\n}\r\n\r\ncontract Trust is StateTransferrable, TrustEvents {\r\n  mapping (address => bool) public masterKeys;\r\n  mapping (address => bytes32) public nameRegistry;\r\n  address[] public masterKeyIndex;\r\n  mapping (address => bool) public masterKeyActive;\r\n  mapping (address => bool) public trustedClients;\r\n  mapping (bytes32 => address) public functionCalls;\r\n  mapping (address => bytes32) public functionCalling;\r\n  function activateMasterKey(address addr) internal {\r\n    if (!masterKeyActive[addr]) {\r\n      masterKeyActive[addr] = true;\r\n      masterKeyIndex.push(addr);\r\n    }\r\n  }\r\n  function setTrustedClient(address addr) onlyOwnerUnlocked setter {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function untrustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = false;\r\n  }\r\n  function trustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function setMasterKey(address addr) onlyOwnerUnlocked {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n    SetMasterKey(msg.sender);\r\n  }\r\n  modifier onlyMasterKey {\r\n    assert(masterKeys[msg.sender]);\r\n    _\r\n  }\r\n  function extractMasterKeyIndexLength() returns (uint256 length) {\r\n    return masterKeyIndex.length;\r\n  }\r\n  function resetAction(bytes32 hash) internal {\r\n    address addr = functionCalls[hash];\r\n    functionCalls[hash] = 0x0;\r\n    functionCalling[addr] = bytes32(0);\r\n  }\r\n  function authCancel(address from) external returns (uint8 status) {\r\n    if (!masterKeys[from] || !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    bytes32 call = functionCalling[from];\r\n    if (call == bytes32(0)) {\r\n      NothingToCancel(from);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(from, from);\r\n      functionCalling[from] = bytes32(0);\r\n      functionCalls[call] = 0x0;\r\n      return 2;\r\n    }\r\n  }\r\n  function cancel() returns (uint8 code) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n      return 0;\r\n    }\r\n    bytes32 call = functionCalling[msg.sender];\r\n    if (call == bytes32(0)) {\r\n      NothingToCancel(msg.sender);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(msg.sender, msg.sender);\r\n      bytes32 hash = functionCalling[msg.sender];\r\n      functionCalling[msg.sender] = 0x0;\r\n      functionCalls[hash] = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  function authCall(address from, bytes32 hash) external returns (uint8 code) {\r\n    if (!masterKeys[from] && !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    if (functionCalling[from] == 0) {\r\n      if (functionCalls[hash] == 0x0) {\r\n        functionCalls[hash] = from;\r\n        functionCalling[from] = hash;\r\n        AuthInit(from);\r\n        return 1;\r\n      } else { \r\n        AuthComplete(functionCalls[hash], from);\r\n        resetAction(hash);\r\n        return 2;\r\n      }\r\n    } else {\r\n      AuthPending(from);\r\n      return 3;\r\n    }\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n    } else if (functionCalling[msg.sender] == 0) {\r\n      if (functionCalls[hash] == 0x0) {\r\n        functionCalls[hash] = msg.sender;\r\n        functionCalling[msg.sender] = hash;\r\n        AuthInit(msg.sender);\r\n      } else { \r\n        AuthComplete(functionCalls[hash], msg.sender);\r\n        resetAction(hash);\r\n        _\r\n      }\r\n    } else {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(masterKeys[addr]);\r\n    masterKeys[addr] = false;\r\n  }\r\n  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n  }\r\n  function identify(bytes32 name) onlyMasterKey {\r\n    nameRegistry[msg.sender] = name;\r\n    NameRegistered(msg.sender, name);\r\n  }\r\n  function nameFor(address addr) returns (bytes32 name) {\r\n    return nameRegistry[addr];\r\n  }\r\n}\r\n\r\n\r\ncontract TrustClient is StateTransferrable, TrustEvents {\r\n  address public trustAddress;\r\n  function setTrust(address addr) setter onlyOwnerUnlocked {\r\n    trustAddress = addr;\r\n  }\r\n  function nameFor(address addr) constant returns (bytes32 name) {\r\n    return Trust(trustAddress).nameFor(addr);\r\n  }\r\n  function cancel() returns (uint8 status) {\r\n    assert(trustAddress != address(0x0));\r\n    uint8 code = Trust(trustAddress).authCancel(msg.sender);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) NothingToCancel(msg.sender);\r\n    else if (code == 2) AuthCancel(msg.sender, msg.sender);\r\n    return code;\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    assert(trustAddress != address(0x0));\r\n    address current = Trust(trustAddress).functionCalls(hash);\r\n    uint8 code = Trust(trustAddress).authCall(msg.sender, hash);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) AuthInit(msg.sender);\r\n    else if (code == 2) {\r\n      AuthComplete(current, msg.sender);\r\n      _\r\n    }\r\n    else if (code == 3) {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n}\r\ncontract Relay {\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\r\n}\r\ncontract TokenBase is Owned {\r\n    bytes32 public standard = 'Token 0.1';\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    bool public allowTransactions;\r\n\r\n    event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract Precision {\r\n  uint8 public decimals;\r\n}\r\ncontract Token is TokenBase, Precision {}\r\ncontract Util {\r\n  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a *= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function max(uint256 a, uint256 b) internal returns (uint256 res) {\r\n    if (a >= b) return a;\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\ncontract DVIP is Token, StateTransferrable, TrustClient, Util {\r\n\r\n  uint256 public totalSupply;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n  address public oversightAddress;\r\n  uint256 public expiry;\r\n\r\n  uint256 public treasuryBalance;\r\n\r\n  bool public isActive;\r\n  mapping (address => uint256) public exportFee;\r\n  address[] public exportFeeIndex;\r\n  mapping (address => bool) exportFeeActive;\r\n\r\n  mapping (address => uint256) public importFee;\r\n  address[] public importFeeIndex;\r\n  mapping (address => bool) importFeeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DVIP() {\r\n    isActive = true;\r\n    treasuryBalance = 0;\r\n    totalSupply = 0;\r\n    name = \"DVIP\";\r\n    symbol = \"DVIP\";\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n    expiry = 1514764800;   }\r\n\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n \r\n  \r\n  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(balanceOf[msg.sender] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(msg.sender);\r\n    activateAccount(_to);\r\n    balanceOf[msg.sender] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else balanceOf[_to] += _amount;\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][msg.sender]);\r\n    balanceOf[_from] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(msg.sender);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    spender.receiveApproval(msg.sender, _amount, this, _extraData);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n\r\n  \r\n  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {\r\n    expiry = ts;\r\n  }\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    treasuryBalance += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= destroyAmount);\r\n    treasuryBalance -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n  }\r\n\r\n  \r\n  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    assert(allow != allowTransactions);\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    treasuryBalance += amount;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from] + importFee[to];\r\n    if (fee == 0) return 0;\r\n    uint256 amountHeld;\r\n    bool discounted = true;\r\n    uint256 oneDVIPUnit;\r\n    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[from];\r\n    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[to];\r\n    } else discounted = false;\r\n    if (discounted) {\r\n      oneDVIPUnit = pow10(1, decimals);\r\n      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;\r\n      uint256 remaining = oneDVIPUnit - amountHeld;\r\n      return div10(amount*fee*remaining, decimals*2);\r\n    }\r\n    return div10(amount*fee, decimals);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() constant returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n\r\n  function activateExportFeeChargeRecord(address addr) internal {\r\n    if (!exportFeeActive[addr]) {\r\n      exportFeeActive[addr] = true;\r\n      exportFeeIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateImportFeeChargeRecord(address addr) internal {\r\n    if (!importFeeActive[addr]) {\r\n\r\n\r\n    }\r\n  }\r\n  function extractImportFeeChargeLength() returns (uint256 length) {\r\n    return importFeeIndex.length;\r\n  }\r\n\r\n  function extractExportFeeChargeLength() returns (uint256 length) {\r\n    return exportFeeIndex.length;\r\n  }\r\n}\r\n\r\n\r\ncontract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {\r\n\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name;\r\n  bytes32 public symbol;\r\n\r\n  bool public allowTransactions;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  uint256 public totalSupply;\r\n\r\n  address public hotWalletAddress;\r\n  address public assetAddress;\r\n  address public oversightAddress;\r\n  address public membershipAddress;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n\r\n  bool public isActive;\r\n  uint256 public treasuryBalance;\r\n\r\n  mapping (address => uint256) public feeCharge;\r\n  address[] public feeChargeIndex;\r\n  mapping (address => bool) feeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {\r\n    isActive = true;\r\n    name = tokenName;\r\n    symbol = tokenSymbol;\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n   modifier onlyAsset {\r\n    assert(msg.sender == assetAddress);\r\n    _\r\n   }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n    hotWalletAddress = addr;\r\n  }\r\n\r\n  \r\n  function setAsset(address addr) onlyOwnerUnlocked setter {\r\n    assetAddress = addr;\r\n  }\r\n\r\n  \r\n  function setMembership(address addr) onlyOwnerUnlocked setter {\r\n    membershipAddress = addr;\r\n  }\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(balanceOf[_caller] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(_caller);\r\n    activateAccount(_to);\r\n    balanceOf[_caller] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else {\r\n        uint256 fee = feeFor(_caller, _to, _amount);\r\n        balanceOf[_to] += _amount - fee;\r\n        treasuryBalance += fee;\r\n    }\r\n    Transfer(_caller, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][_caller]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 fee = feeFor(_from, _to, _amount);\r\n    balanceOf[_to] += _amount - fee;\r\n    treasuryBalance += fee;\r\n    allowance[_from][_caller] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(_caller);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[hotWalletAddress] >= destroyAmount);\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    if (allow == allowTransactions) throw;\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    balanceOf[hotWalletAddress] += amount;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {\r\n    if (membershipAddress == address(0x0)) return 0;\r\n    return DVIP(membershipAddress).feeFor(a, b, amount);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {\r\n\r\n   address public backendContract;\r\n\r\n   \r\n   function DCAsset(address _backendContract) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   function standard() constant returns (bytes32 std) {\r\n     return DCAssetBackend(backendContract).standard();\r\n   }\r\n\r\n   function name() constant returns (bytes32 nm) {\r\n     return DCAssetBackend(backendContract).name();\r\n   }\r\n\r\n   function symbol() constant returns (bytes32 sym) {\r\n     return DCAssetBackend(backendContract).symbol();\r\n   }\r\n\r\n   function decimals() constant returns (uint8 precision) {\r\n     return DCAssetBackend(backendContract).decimals();\r\n   }\r\n  \r\n   function allowance(address from, address to) constant returns (uint256 res) {\r\n     return DCAssetBackend(backendContract).allowance(from, to);\r\n   }\r\n\r\n\r\n   \r\n\r\n\r\n   \r\n   function setBackend(address _backendContract) multisig(sha3(msg.data)) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   \r\n\r\n   \r\n   function balanceOf(address _address) constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).balanceOf(_address);\r\n   }\r\n\r\n   \r\n   function totalSupply() constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).totalSupply();\r\n   }\r\n\r\n  \r\n   function transfer(address _to, uint256 _amount) returns (bool success)  {\r\n      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;\r\n      Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approve(address _spender, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;\r\n      Transfer(_from, _to, _amount);\r\n      return true;\r\n  }\r\n\r\n  \r\n  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {\r\n      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);\r\n  }\r\n\r\n  \r\n\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n     assert(msg.sender == backendContract);\r\n     TokenRecipient spender = TokenRecipient(_spender);\r\n     spender.receiveApproval(_caller, _amount, this, _extraData);\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Oversight is StateTransferrable, TrustClient {\r\n\r\n  address public hotWalletAddress;\r\n\r\n  mapping (address => uint256) public approved;               address[] public approvedIndex;                           \r\n  mapping (address => uint256) public expiry;               \r\n  mapping (address => bool) public currencyActive;          \r\n  mapping (address => bool) public oversightAddresses;        address[] public oversightAddressesIndex;                 \r\n  mapping (address => bool) public oversightAddressActive;  \r\n  uint256 public timeWindow;                                \r\n  event TransactionsShutDown(address indexed from);\r\n\r\n  \r\n  function Oversight() {\r\n    timeWindow = 10 minutes;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(oversightAddresses[msg.sender]);\r\n    _\r\n  }\r\n\r\n  \r\n  modifier onlyHotWallet {\r\n    assert(msg.sender == hotWalletAddress);\r\n    _\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n      hotWalletAddress = addr;\r\n  }\r\n\r\n  \r\n  function setupTimeWindow(uint256 secs) onlyOwnerUnlocked setter {\r\n    timeWindow = secs;\r\n  }\r\n\r\n  \r\n  function setApproved(address addr, uint256 amount) onlyOwnerUnlocked setter {\r\n    activateCurrency(addr);\r\n    approved[addr] = amount;\r\n  }\r\n\r\n  \r\n  function setExpiry(address addr, uint256 ts) onlyOwnerUnlocked setter {\r\n    activateCurrency(addr);\r\n    expiry[addr] = ts;\r\n  }\r\n\r\n  \r\n  function setOversightAddress(address addr, bool value) onlyOwnerUnlocked setter {\r\n    activateOversightAddress(addr);\r\n    oversightAddresses[addr] = value;\r\n  }\r\n\r\n\r\n\r\n  \r\n\r\n  \r\n  function setTimeWindow(uint256 secs) external multisig(sha3(msg.data)) {\r\n    timeWindow = secs;\r\n  }\r\n\r\n  \r\n  function addOversight(address addr) external multisig(sha3(msg.data)) {\r\n    activateOversightAddress(addr);\r\n    oversightAddresses[addr] = true;\r\n  }\r\n\r\n  \r\n  function removeOversight(address addr) external multisig(sha3(msg.data)) {\r\n    oversightAddresses[addr] = false;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function approve(address currency, uint256 amount) external multisig(sha3(msg.data)) {\r\n    activateCurrency(currency);\r\n    approved[currency] = amount;\r\n    expiry[currency] = now + timeWindow;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function validate(address currency, uint256 amount) external onlyHotWallet returns (bool) {\r\n    assert(approved[currency] >= amount);\r\n    approved[currency] -= amount;\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions(address currency) onlyOverseer {\r\n    address backend = DCAsset(currency).backendContract();\r\n    DCAssetBackend(backend).shutdownTransactions();\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function extractApprovedIndexLength() returns (uint256) {\r\n    return approvedIndex.length;\r\n  }\r\n\r\n  \r\n  function extractOversightAddressesIndexLength() returns (uint256) {\r\n    return oversightAddressesIndex.length;\r\n  }\r\n\r\n  \r\n\r\n  function activateOversightAddress(address addr) internal {\r\n    if (!oversightAddressActive[addr]) {\r\n      oversightAddressActive[addr] = true;\r\n      oversightAddressesIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateCurrency(address addr) internal {\r\n    if (!currencyActive[addr]) {\r\n      currencyActive[addr] = true;\r\n          approvedIndex.push(addr);\r\n    }\r\n  }\r\n\r\n}",
        "label": false,
        "name": "0xb4921b74c089a8029ecd170e8edb2fc95425c20d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.HKD.HongKongDollar\";\nstring public constant VAR2 = \"Hong Kong Monetary Authority\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0xf70d0c8faa25be716e3160b880fad246bbbbafd2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\nuint256 VAR11;\nfunction CON4 (uint256 VAR12) public {\nVAR11 = VAR12;\nVAR9 [msg.sender] = VAR12;\n}\nfunction FUN3 (address VAR8, uint256 VAR13, uint256 VAR14)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR13)\nreturn FUN3 (VAR8, VAR14);\nelse return false;\n}\n}",
        "label": false,
        "name": "0x22aae864a5b1f8e3d41bba0050e0b0027cd793ce.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN2(uint256 VAR4) public {\nFUN3(msg.sender, VAR4);\n}\nfunction FUN3(address VAR5, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR5]);\nVAR1[VAR5] = VAR1[VAR5].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON4 {\naddress public VAR6;\nfunction CON4() public {\nVAR6 = msg.sender;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR6);\n_;\n}\nfunction FUN5(address VAR7) public FUN4 {\nrequire(VAR7 != address(0));\nVAR6 = VAR7;\n}\n}\ncontract CON5 is CON1 {\n}\ncontract CON6 is CON5, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN6(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR8[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR4) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR4;\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON4 {\nbool public VAR14 = false;\nmodifier FUN10() {\nrequire(!VAR14);\n_;\n}\nfunction FUN11(address VAR3, uint256 VAR15) FUN4 FUN10 public returns (bool) {\nVAR2 = VAR2.add(VAR15);\nVAR1[VAR3] = VAR1[VAR3].add(VAR15);\nreturn true;\n}\nfunction FUN12() FUN4 FUN10 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON8 is CON7 {\nuint256 public VAR16;\nfunction CON8(uint256 VAR17) public {\nrequire(VAR17 > 0);\nVAR16 = VAR17;\n}\nfunction FUN11(address VAR3, uint256 VAR15) FUN4 FUN10 public returns (bool) {\nrequire(VAR2.add(VAR15) <= VAR16);\nreturn super.FUN11(VAR3, VAR15);\n}\n}\ncontract CON9 is CON4 {\nbool public VAR18 = false;\nmodifier FUN13() {\nrequire(!VAR18);\n_;\n}\nmodifier FUN14() {\nrequire(VAR18);\n_;\n}\nfunction FUN15() FUN4 FUN13 public {\nVAR18 = true;\n}\nfunction FUN16() FUN4 FUN14 public {\nVAR18 = false;\n}\n}\ncontract CON10 is CON6, CON9 {\nfunction FUN1(address VAR3, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN6(address VAR9, address VAR3, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN6(VAR9, VAR3, VAR4);\n}\nfunction FUN7(address VAR10, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN7(VAR10, VAR4);\n}\nfunction FUN8(address VAR10, uint VAR11) public FUN13 returns (bool VAR19) {\nreturn super.FUN8(VAR10, VAR11);\n}\nfunction FUN9(address VAR10, uint VAR12) public FUN13 returns (bool VAR19) {\nreturn super.FUN9(VAR10, VAR12);\n}\n}\ncontract CON11 is CON8, CON10, CON3 {\nuint public constant VAR20 = 700000000e18;\nstring public VAR21 = \"VREO Token\";\nstring public VAR22 = \"VREO\";\nuint8 public VAR23 = 18;\nconstructor() public CON8(VAR20) {\nFUN15();\n}\n}",
        "label": false,
        "name": "0x1df4683d1cee4d167ea4a9ab3be162fbe9794f95.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x1c4e6c18f7f5c15bbfff34b05b4523e92e56e3f6.sol"
    },
    {
        "source": "\r\n\r\n\r\ninterface ComptrollerInterface {\r\n    \r\n    function isComptroller() external view returns (bool);\r\n\r\n    \r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    \r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    \r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n}\r\n\r\n\r\n\r\ncontract ComptrollerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        COMPTROLLER_MISMATCH,\r\n        INSUFFICIENT_SHORTFALL,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INVALID_CLOSE_FACTOR,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        INVALID_LIQUIDATION_INCENTIVE,\r\n        MARKET_NOT_ENTERED,\r\n        MARKET_NOT_LISTED,\r\n        MARKET_ALREADY_LISTED,\r\n        MATH_ERROR,\r\n        NONZERO_BORROW_BALANCE,\r\n        PRICE_ERROR,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        TOO_MANY_ASSETS,\r\n        TOO_MUCH_REPAY\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        EXIT_MARKET_BALANCE_OWED,\r\n        EXIT_MARKET_REJECTION,\r\n        SET_CLOSE_FACTOR_OWNER_CHECK,\r\n        SET_CLOSE_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n        SET_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_PRICE_ORACLE_OWNER_CHECK,\r\n        SUPPORT_MARKET_EXISTS,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        ZUNUSED\r\n    }\r\n\r\n    \r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    \r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    \r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        BAD_INPUT,\r\n        COMPTROLLER_REJECTION,\r\n        COMPTROLLER_CALCULATION_ERROR,\r\n        INTEREST_RATE_MODEL_ERROR,\r\n        INVALID_ACCOUNT_PAIR,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        MATH_ERROR,\r\n        MARKET_NOT_FRESH,\r\n        MARKET_NOT_LISTED,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_IN_FAILED,\r\n        TOKEN_TRANSFER_OUT_FAILED\r\n    }\r\n\r\n    \r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_ACCRUE_INTEREST_FAILED,\r\n        BORROW_CASH_NOT_AVAILABLE,\r\n        BORROW_FRESHNESS_CHECK,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_LISTED,\r\n        BORROW_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        LIQUIDATE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        LIQUIDATE_FRESHNESS_CHECK,\r\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_ACCRUE_INTEREST_FAILED,\r\n        MINT_COMPTROLLER_REJECTION,\r\n        MINT_EXCHANGE_CALCULATION_FAILED,\r\n        MINT_EXCHANGE_RATE_READ_FAILED,\r\n        MINT_FRESHNESS_CHECK,\r\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        MINT_TRANSFER_IN_FAILED,\r\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n        REDEEM_ACCRUE_INTEREST_FAILED,\r\n        REDEEM_COMPTROLLER_REJECTION,\r\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n        REDEEM_FRESHNESS_CHECK,\r\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        REDUCE_RESERVES_ADMIN_CHECK,\r\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n        REDUCE_RESERVES_FRESH_CHECK,\r\n        REDUCE_RESERVES_VALIDATION,\r\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_COMPTROLLER_REJECTION,\r\n        REPAY_BORROW_FRESHNESS_CHECK,\r\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_ORACLE_MARKET_NOT_LISTED,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n        SET_RESERVE_FACTOR_FRESH_CHECK,\r\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n        TRANSFER_COMPTROLLER_REJECTION,\r\n        TRANSFER_NOT_ALLOWED,\r\n        TRANSFER_NOT_ENOUGH,\r\n        TRANSFER_TOO_MUCH\r\n    }\r\n\r\n    \r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    \r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    \r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract CarefulMath {\r\n\r\n    \r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    \r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    \r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    \r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    \r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    \r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    \r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    \r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    \r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    \r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    \r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    \r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    \r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    \r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        \r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    \r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    \r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n                                (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n                assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    \r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    \r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    \r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    \r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n                return exp.mantissa / expScale;\r\n    }\r\n\r\n    \r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;     }\r\n\r\n    \r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    \r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface EIP20Interface {\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    \r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\n\r\n\r\ninterface EIP20NonStandardInterface {\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n                    \r\n    \r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n                    \r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\n\r\n\r\ncontract ReentrancyGuard {\r\n        uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n                        _guardCounter = 1;\r\n    }\r\n\r\n    \r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"re-entered\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface InterestRateModel {\r\n    \r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\r\n\r\n    \r\n    function isInterestRateModel() external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\r\n    \r\n    bool public constant isCToken = true;\r\n\r\n    \r\n    string public name;\r\n\r\n    \r\n    string public symbol;\r\n\r\n    \r\n    uint public decimals;\r\n\r\n    \r\n    uint constant borrowRateMaxMantissa = 5e14;\r\n\r\n    \r\n    uint constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    \r\n    address payable public admin;\r\n\r\n    \r\n    address payable public pendingAdmin;\r\n\r\n    \r\n    ComptrollerInterface public comptroller;\r\n\r\n    \r\n    InterestRateModel public interestRateModel;\r\n\r\n    \r\n    uint public initialExchangeRateMantissa;\r\n\r\n    \r\n    uint public reserveFactorMantissa;\r\n\r\n    \r\n    uint public accrualBlockNumber;\r\n\r\n    \r\n    uint public borrowIndex;\r\n\r\n    \r\n    uint public totalBorrows;\r\n\r\n    \r\n    uint public totalReserves;\r\n\r\n    \r\n    uint256 public totalSupply;\r\n\r\n    \r\n    mapping (address => uint256) accountTokens;\r\n\r\n    \r\n    mapping (address => mapping (address => uint256)) transferAllowances;\r\n\r\n    \r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    \r\n    mapping(address => BorrowSnapshot) accountBorrows;\r\n\r\n\r\n    \r\n\r\n    \r\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    \r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    \r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    \r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    \r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    \r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    \r\n\r\n    \r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    \r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    \r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    \r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    \r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    \r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n\r\n    \r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint decimals_) internal {\r\n                admin = msg.sender;\r\n\r\n                initialExchangeRateMantissa = initialExchangeRateMantissa_;\r\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\r\n\r\n                uint err = _setComptroller(comptroller_);\r\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\r\n\r\n                accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n\r\n                err = _setInterestRateModelFresh(interestRateModel_);\r\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n    }\r\n\r\n    \r\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (src == dst) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        \r\n        uint startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n        \r\n        MathError mathErr;\r\n        uint allowanceNew;\r\n        uint srcTokensNew;\r\n        uint dstTokensNew;\r\n\r\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n        }\r\n\r\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n        }\r\n\r\n                        \r\n        accountTokens[src] = srcTokensNew;\r\n        accountTokens[dst] = dstTokensNew;\r\n\r\n        \r\n        if (startingAllowance != uint(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        \r\n        emit Transfer(src, dst, tokens);\r\n\r\n        \r\n        comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    \r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\r\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        require(mErr == MathError.NO_ERROR);\r\n        return balance;\r\n    }\r\n\r\n    \r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        uint cTokenBalance = accountTokens[account];\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n\r\n        MathError mErr;\r\n\r\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\r\n    }\r\n\r\n    \r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    \r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\");         return borrowRateMantissa;\r\n    }\r\n\r\n    \r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        \r\n        uint exchangeRateMantissa = exchangeRateStored();\r\n\r\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); \r\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\r\n        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\r\n\r\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\r\n        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\r\n\r\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\r\n        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\r\n\r\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\r\n        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\r\n\r\n        return supplyRate.mantissa;\r\n    }\r\n\r\n    \r\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return totalBorrows;\r\n    }\r\n\r\n    \r\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return borrowBalanceStored(account);\r\n    }\r\n\r\n    \r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\r\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    \r\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\r\n        \r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        \r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n        \r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        \r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    \r\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    \r\n    function exchangeRateStored() public view returns (uint) {\r\n        (MathError err, uint result) = exchangeRateStoredInternal();\r\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    \r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        if (totalSupply == 0) {\r\n            \r\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\r\n        } else {\r\n            \r\n            uint totalCash = getCashPrior();\r\n            uint cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    \r\n    function getCash() external view returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    struct AccrueInterestLocalVars {\r\n        MathError mathErr;\r\n        uint opaqueErr;\r\n        uint borrowRateMantissa;\r\n        uint currentBlockNumber;\r\n        uint blockDelta;\r\n\r\n        Exp simpleInterestFactor;\r\n\r\n        uint interestAccumulated;\r\n        uint totalBorrowsNew;\r\n        uint totalReservesNew;\r\n        uint borrowIndexNew;\r\n    }\r\n\r\n    \r\n    function accrueInterest() public returns (uint) {\r\n        AccrueInterestLocalVars memory vars;\r\n\r\n        \r\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\r\n        if (vars.opaqueErr != 0) {\r\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\r\n        }\r\n\r\n        \r\n        vars.currentBlockNumber = getBlockNumber();\r\n\r\n        \r\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\r\n        assert(vars.mathErr == MathError.NO_ERROR); \r\n        \r\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n                        \r\n        \r\n        accrualBlockNumber = vars.currentBlockNumber;\r\n        borrowIndex = vars.borrowIndexNew;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n        totalReserves = vars.totalReservesNew;\r\n\r\n        \r\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return mintFresh(msg.sender, mintAmount);\r\n    }\r\n\r\n    struct MintLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint mintTokens;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    \r\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        \r\n        vars.err = checkTransferIn(minter, mintAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n                        \r\n        \r\n        vars.err = doTransferIn(minter, mintAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\r\n        }\r\n\r\n        \r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[minter] = vars.accountTokensNew;\r\n\r\n        \r\n        emit Mint(minter, mintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n        \r\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return redeemFresh(msg.sender, redeemTokens, 0);\r\n    }\r\n\r\n    \r\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return redeemFresh(msg.sender, 0, redeemAmount);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint redeemTokens;\r\n        uint redeemAmount;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    \r\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\r\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\r\n\r\n        RedeemLocalVars memory vars;\r\n\r\n        \r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (redeemTokensIn > 0) {\r\n            \r\n            vars.redeemTokens = redeemTokensIn;\r\n\r\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n        } else {\r\n            \r\n\r\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            vars.redeemAmount = redeemAmountIn;\r\n        }\r\n\r\n        \r\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (getCashPrior() < vars.redeemAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n                        \r\n        \r\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\r\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\r\n\r\n        \r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n        \r\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        \r\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return borrowFresh(msg.sender, borrowAmount);\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    \r\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n                        \r\n        \r\n        vars.err = doTransferOut(borrower, borrowAmount);\r\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\r\n\r\n        \r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        \r\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        \r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint repayAmount;\r\n        uint borrowerIndex;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    \r\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        \r\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        \r\n        vars.err = checkTransferIn(payer, vars.repayAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n                        \r\n        \r\n        vars.err = doTransferIn(payer, vars.repayAmount);\r\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\r\n\r\n        \r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        \r\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        \r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\r\n        }\r\n\r\n        error = cTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\r\n        }\r\n\r\n                return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    \r\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        \r\n        if (repayAmount == 0) {\r\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\r\n        }\r\n\r\n        \r\n        if (repayAmount == uint(-1)) {\r\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\r\n        }\r\n\r\n        \r\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\r\n        if (amountSeizeError != 0) {\r\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\r\n        }\r\n\r\n        \r\n        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\r\n        }\r\n\r\n        \r\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\r\n        }\r\n\r\n        \r\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n        \r\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\r\n\r\n        \r\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\r\n        \r\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        MathError mathErr;\r\n        uint borrowerTokensNew;\r\n        uint liquidatorTokensNew;\r\n\r\n        \r\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n                        \r\n        \r\n        accountTokens[borrower] = borrowerTokensNew;\r\n        accountTokens[liquidator] = liquidatorTokensNew;\r\n\r\n        \r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n\r\n        \r\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n                if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n                address oldPendingAdmin = pendingAdmin;\r\n\r\n                pendingAdmin = newPendingAdmin;\r\n\r\n                emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _acceptAdmin() external returns (uint) {\r\n                if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n                address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n                admin = pendingAdmin;\r\n\r\n                pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n                if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n                require(newComptroller.isComptroller(), \"marker method returned false\");\r\n\r\n                comptroller = newComptroller;\r\n\r\n                emit NewComptroller(oldComptroller, newComptroller);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    \r\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\r\n                if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n        }\r\n\r\n                if (accrualBlockNumber != getBlockNumber()) {\r\n                        return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n        }\r\n\r\n                if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n        }\r\n\r\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\r\n        reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return _reduceReservesFresh(reduceAmount);\r\n    }\r\n\r\n    \r\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\r\n        Error err;\r\n                uint totalReservesNew;\r\n\r\n                if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\r\n        }\r\n\r\n                if (accrualBlockNumber != getBlockNumber()) {\r\n                        return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\r\n        }\r\n\r\n                if (getCashPrior() < reduceAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n                        if (reduceAmount > totalReserves) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\r\n        }\r\n\r\n                        \r\n        totalReservesNew = totalReserves - reduceAmount;\r\n                require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\r\n\r\n                totalReserves = totalReservesNew;\r\n\r\n                err = doTransferOut(admin, reduceAmount);\r\n                require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\r\n\r\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n                        return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\r\n        }\r\n                return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    \r\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\r\n\r\n                InterestRateModel oldInterestRateModel;\r\n\r\n                if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n                if (accrualBlockNumber != getBlockNumber()) {\r\n                        return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n        }\r\n\r\n                oldInterestRateModel = interestRateModel;\r\n\r\n                require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\r\n\r\n                interestRateModel = newInterestRateModel;\r\n\r\n                emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function getCashPrior() internal view returns (uint);\r\n\r\n    \r\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\r\n\r\n    \r\n    function doTransferIn(address from, uint amount) internal returns (Error);\r\n\r\n    \r\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract CErc20 is CToken {\r\n\r\n    \r\n    address public underlying;\r\n\r\n    \r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint decimals_) public\r\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\r\n                underlying = underlying_;\r\n        EIP20Interface(underlying).totalSupply();     }\r\n\r\n    \r\n\r\n    \r\n    function mint(uint mintAmount) external returns (uint) {\r\n        return mintInternal(mintAmount);\r\n    }\r\n\r\n    \r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    \r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    \r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        return repayBorrowInternal(repayAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        return repayBorrowBehalfInternal(borrower, repayAmount);\r\n    }\r\n\r\n    \r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint) {\r\n        return liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function getCashPrior() internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    \r\n    function checkTransferIn(address from, uint amount) internal view returns (Error) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n\r\n        if (token.allowance(from, address(this)) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_ALLOWANCE;\r\n        }\r\n\r\n        if (token.balanceOf(from) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_BALANCE;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    \r\n    function doTransferIn(address from, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        bool result;\r\n\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n                assembly {\r\n            switch returndatasize()\r\n                case 0 {                                          result := not(0)                          }\r\n                case 32 {                                         returndatacopy(0, 0, 32)\r\n                    result := mload(0)                        }\r\n                default {                                         revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_IN_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    \r\n    function doTransferOut(address payable to, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        bool result;\r\n\r\n        token.transfer(to, amount);\r\n\r\n                assembly {\r\n            switch returndatasize()\r\n                case 0 {                                          result := not(0)                          }\r\n                case 32 {                                         returndatacopy(0, 0, 32)\r\n                    result := mload(0)                        }\r\n                default {                                         revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n}\r\n",
        "label": false,
        "name": "0xf5dce57282a584d2746faf1593d3121fcac444dc.sol"
    },
    {
        "source": "contract CON1 {\nmapping(address => bool) public VAR1;\nfunction FUN1(address VAR2) public {\nVAR1[VAR2] = true;\n}\n}",
        "label": false,
        "name": "0x9d3c57cd606096b5553283aba72c6d86c58f5d5a.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR3 = true;\n}\nfunction FUN8() FUN1 FUN6 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 public VAR6;\nfunction FUN9(address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR8) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(VAR10, VAR7, VAR8);\nFUN15(VAR10, msg.sender, VAR5[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN12(address VAR9, uint256 VAR11) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR9, uint256 VAR12) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN14(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\nfunction FUN15(address VAR13, address VAR9, uint256 VAR8) internal {\nrequire(VAR9 != address(0));\nrequire(VAR13 != address(0));\nVAR5[VAR13][VAR9] = VAR8;\n}\n}\ncontract CON5 is CON4, CON2 {\nfunction FUN9(address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN10(address VAR9, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR8);\n}\nfunction FUN12(address VAR9, uint VAR11) public FUN5 returns (bool VAR14) {\nreturn super.FUN12(VAR9, VAR11);\n}\nfunction FUN13(address VAR9, uint VAR12) public FUN5 returns (bool VAR14) {\nreturn super.FUN13(VAR9, VAR12);\n}\n}\ncontract CON6 is CON1 {\nCON7 public VAR15;\nuint256 constant public VAR16 = 18;\nuint256 public VAR6 = 90000000 * (10 ** uint256(VAR16));\nconstructor () public {\nVAR15 = FUN16();\nVAR15.FUN8();\n}\nfunction FUN16() internal returns (CON7) {\nreturn new CON7();\n}\nfunction FUN17() external FUN1 {\nVAR15.FUN8();\n}\nfunction FUN18() external FUN1 {\nVAR15.FUN7();\n}\nfunction FUN9(address VAR7, uint256 VAR8) external FUN1 returns (bool VAR17) {\nuint256 VAR18 = VAR8 * (10 ** uint256(VAR16));\nreturn VAR15.FUN9(VAR7, VAR18);\n}\n}\ncontract CON7 is CON5 {\nstring constant public VAR19 = \"MVit Token\";\nstring constant public VAR20 = \"MVT\";\nuint8 constant public VAR21 = 18;\nuint256 constant VAR22 = 10 ** uint256(VAR21);\nuint256 constant VAR23 = 90000000 * VAR22;\nconstructor () public {\nVAR3 = true;\nVAR6 = VAR23;\nVAR4[msg.sender] = VAR23;\n}\n}",
        "label": false,
        "name": "0x3e86c85b66b5fb710a6fd061dbd9984322afdff9.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN4(uint256 VAR6) public {\nrequire(VAR6 <= VAR3[msg.sender]);\naddress VAR7 = msg.sender;\nVAR3[VAR7] = VAR3[VAR7].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON5 is CON2 {\n}\ncontract CON6 is CON5, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR9]);\nrequire(VAR6 <= VAR8[VAR9][msg.sender]);\nVAR3[VAR9] = VAR3[VAR9].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR6) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON1 {\naddress public VAR14;\nbool VAR15;\nbool public VAR16 = false;\nfunction FUN9(address VAR17) external {\nrequire(VAR17 != address(0));\nrequire(VAR15 == false);\nVAR14 = VAR17;\nVAR15 = true;\n}\nmodifier FUN10() {\nif(msg.sender != VAR14) {\nrequire(!VAR16);\n}\n_;\n}\nmodifier FUN11() {\nrequire(VAR16);\n_;\n}\nfunction FUN12() FUN1 FUN10 public {\nVAR16 = true;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR16 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\nfunction FUN6(address VAR10, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN6(VAR10, VAR6);\n}\nfunction FUN7(address VAR10, uint VAR11) public FUN10 returns (bool VAR18) {\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN8(address VAR10, uint VAR12) public FUN10 returns (bool VAR18) {\nreturn super.FUN8(VAR10, VAR12);\n}\n}\ncontract CON9 is CON6, CON1 {\nmapping (address => bool) public VAR19;\nfunction FUN14(address VAR20) public FUN1 {\nVAR19[VAR20] = true;\n}\nfunction FUN15(address VAR20) public FUN1 {\nVAR19[VAR20] = false;\n}\nmodifier FUN16(address VAR21) {\nrequire(!VAR19[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN16(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN16(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON10 is CON6, CON1 {\nmapping (address => uint) public VAR22;\nfunction FUN17(address VAR20, uint VAR23) public FUN1 {\nuint VAR24;\nVAR24 = now + (VAR23 * 1 days);\nVAR22[VAR20] = VAR24;\n}\nfunction FUN18(address VAR20) public FUN1 {\nVAR22[VAR20] = now;\n}\nmodifier FUN19(address VAR21) {\nrequire(now >= VAR22[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN19(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN19(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON11 is CON10, CON9, CON8, CON4 {\nstring public constant VAR25 = \"Happytcon\";\nstring public constant VAR26 = \"HPTC\";\nuint public constant VAR27 = 18;\nuint public constant VAR28 = 1000000000 * (10 ** VAR27);\nconstructor() public {\nVAR4 = VAR28;\nVAR3[msg.sender] = VAR4;\n}\n}",
        "label": false,
        "name": "0x950cc70dd44fec5194e868973ad83f21c335ab71.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint256 public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN1(uint256 VAR3) {\nVAR2 = VAR3;\n}\n}",
        "label": false,
        "name": "0x42096eef973662c941f435e51a04d3b8497afc72.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.CZK.CzechKoruna\";\nstring public constant VAR2 = \"Ceska Narodni Banka\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x60e58672abad3b676f7ad77477e24019ae16a308.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR2[msg.sender][VAR6];\nif (VAR9 >= VAR10) {\nVAR2[msg.sender][VAR6] = 0;\n} else {\nVAR2[msg.sender][VAR6] = VAR10.sub(VAR9);\n}\nreturn true;\n}\nfunction FUN6(address VAR11, uint256 VAR12) internal {\nrequire(VAR11 != 0);\nVAR3 = VAR3.add(VAR12);\nVAR1[VAR11] = VAR1[VAR11].add(VAR12);\n}\nfunction FUN7(address VAR11, uint256 VAR12) internal {\nrequire(VAR11 != 0);\nrequire(VAR12 <= VAR1[VAR11]);\nVAR3 = VAR3.sub(VAR12);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR12);\n}\nfunction FUN8(address VAR11, uint256 VAR12) internal {\nrequire(VAR12 <= VAR2[VAR11][msg.sender]);\nVAR2[VAR11][msg.sender] = VAR2[VAR11][msg.sender].sub(VAR12);\nFUN7(VAR11, VAR12);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR13 = \"OilToken\";\nstring public constant VAR14 = \"OLT\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 15 * (10 ** uint256(7)) * (10 ** uint256(VAR15));\nconstructor() public {\nFUN6(msg.sender, VAR16);\n}\n}",
        "label": false,
        "name": "0x060ccb9c1e0d3c7967fac46d67b6826a5df3bef3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"CanYaCoin\";\nstring public constant VAR2 = \"CAN\";\nuint256 public constant VAR3 = 6;\nuint256 public constant VAR4 = 100000000 * (10 ** VAR3);\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nfunction CON2() {\nVAR5[msg.sender] = VAR4;\n}\nfunction FUN1() constant returns (uint256) {\nreturn VAR4;\n}\nfunction FUN2(address VAR7, uint256 VAR8) public returns (bool) {\nif (VAR5[msg.sender] >= VAR8) {\nVAR5[msg.sender] -= VAR8;\nVAR5[VAR7] += VAR8;\nreturn true;\n}\nreturn false;\n}\nfunction FUN3(address VAR9, address VAR7, uint256 VAR8) public returns (bool) {\nif (VAR5[VAR9] >= VAR8 && VAR6[VAR9][msg.sender] >= VAR8) {\nVAR5[VAR9] -= VAR8;\nVAR6[VAR9][msg.sender] -= VAR8;\nVAR5[VAR7] += VAR8;\nreturn true;\n}\nreturn false;\n}\nfunction FUN4(address VAR10) constant public returns (uint256) {\nreturn VAR5[VAR10];\n}\nfunction FUN5(address VAR11, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR11] = VAR8;\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR11) constant public returns (uint256 VAR12) {\nreturn VAR6[VAR10][VAR11];\n}\n}\ncontract CON3 {\nusing SafeMath for uint256;\nCON2 public VAR13;\nbool public VAR14 = false;\nuint256 internal VAR15 = 0;\nuint256 public constant VAR16 = 3780 ether;\nuint256 public constant VAR17 = 1 ether;\naddress public VAR18;\naddress public VAR19;\nuint256 public constant VAR20 = 400000000; uint256 public VAR21 = 9450000 * (10**6);\nmodifier FUN7() {\nrequire(!VAR14);\n_;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR18);\n_;\n}\nfunction CON3(address VAR22, address VAR23) {\nrequire (VAR22 != address(0) && VAR23 != address(0));\nVAR18 = msg.sender;\nVAR13 = CON2(VAR22);\nVAR19 = VAR23;\n}\nfunction () FUN7 payable public {\nrequire(msg.value >= VAR17 && msg.value <= VAR16);\nuint256 VAR24 = msg.value.div(VAR20);\nif (VAR24 > VAR21) {\nVAR14 = true;\nVAR15 = (VAR24 - VAR21) * VAR20;\nVAR24 = VAR21;\n}\nVAR21 -= VAR24;\nif (VAR14 && VAR15 > 0) {\nuint256 VAR25 = VAR15;\nVAR15 = 0;\nmsg.sender.FUN2(VAR25);\n}\nVAR13.FUN2(msg.sender, VAR24);\nVAR19.FUN2(msg.value - VAR25);\n}\nfunction FUN10(address VAR7) FUN8 public {\nrequire(VAR7 != address(0));\nif (!VAR14) {\n}\nVAR14 = true;\nVAR13.FUN2(VAR7, VAR21);\n}\n}",
        "label": false,
        "name": "0x17355bf21dcb9676013b945465bc5ebe60bce32f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public{\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public{\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint;\nmapping(address => uint) VAR3;\nmapping (address => mapping (address => uint)) VAR4;\nstring public constant VAR5 = \"Arc Unified Chain\";\nstring public constant VAR6 = \"AUCC\";\nuint public constant VAR7 = 18;\nuint public VAR8 = 6700000000000000000000000;\naddress public VAR9;\nfunction CON2() public {\nVAR3[msg.sender] = VAR8; }\nfunction FUN3(address VAR10, uint VAR11) public{\nuint256 VAR12 = VAR11.mul(1).div(100);\nuint256 VAR13 = VAR11.mul(99).div(100);\nif (VAR10 == VAR9){\nFUN9(VAR11); }else{\nFUN9(VAR12); VAR3[msg.sender] = VAR3[msg.sender].sub(VAR13);\n}\nVAR3[VAR10] = VAR3[VAR10].add(VAR13);\n}\nfunction FUN4(address VAR14) public constant returns (uint VAR15) {\nreturn VAR3[VAR14];\n}\nfunction FUN5(address VAR16, address VAR10, uint VAR11) public {\nuint256 VAR12 = VAR11.mul(1).div(100); uint256 VAR13 = VAR11.mul(99).div(100);\nif (VAR10 == VAR9){\nFUN8(VAR16, VAR11); }else{\nFUN8(VAR16, VAR12); VAR3[VAR16] = VAR3[VAR16].sub(VAR13);\n}\nVAR3[VAR10] = VAR3[VAR10].add(VAR13);\nVAR4[VAR16][msg.sender] = VAR4[VAR16][msg.sender].sub(VAR11);\n}\nfunction FUN6(address VAR17, uint VAR11) public{\nrequire((VAR11 == 0) || (VAR4[msg.sender][VAR17] == 0)) ;\nVAR4[msg.sender][VAR17] = VAR11;\n}\nfunction FUN7(address VAR14, address VAR17) public constant returns (uint VAR18) {\nreturn VAR4[VAR14][VAR17];\n}\nfunction FUN8(address VAR16, uint VAR11) internal returns (bool) {\nVAR3[VAR16] = VAR3[VAR16].sub(VAR11);\nVAR8 = VAR8.sub(VAR11);\nreturn true;\n}\nfunction FUN9(uint VAR11) public returns (bool) {\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR11);\nVAR8 = VAR8.sub(VAR11);\nreturn true;\n}\nfunction FUN10(address VAR19) FUN1 public {\nVAR9 = VAR19;\n}\n}",
        "label": false,
        "name": "0x51864bb857b8d4fef57d098e1364803fb66a023d.sol"
    },
    {
        "source": "\r\n\r\n\r\ncontract FixedAddress {\r\n    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\r\n    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\r\n    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\r\n\r\n    function getRegistry() internal pure returns (RegistryInterface) {\r\n        return RegistryInterface(RegistryAddress);\r\n    }\r\n}\r\n\r\ninterface RegistryInterface {\r\n    function getOwner() external view returns (address);\r\n    function getExchangeContract() external view returns (address);\r\n    function contractApproved(address traderAddr) external view returns (bool);\r\n    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool);\r\n    function acceptNextExchangeContract() external;\r\n}\r\n\r\ncontract AccessModifiers is FixedAddress {\r\n\r\n        modifier onlyRegistryOwner() {\r\n        require (msg.sender == getRegistry().getOwner(), \"onlyRegistryOwner() method called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n            modifier onlyApprovedExchange(address trader) {\r\n        require (msg.sender == ProxyAddress, \"onlyApprovedExchange() called not by exchange proxy.\");\r\n        require (getRegistry().contractApproved(trader), \"onlyApprovedExchange() requires approval of the latest contract code by trader.\");\r\n        _;\r\n    }\r\n\r\n        modifier onlyApprovedExchangeBoth(address trader1, address trader2) {\r\n        require (msg.sender == ProxyAddress, \"onlyApprovedExchange() called not by exchange proxy.\");\r\n        require (getRegistry().contractApprovedBoth(trader1, trader2), \"onlyApprovedExchangeBoth() requires approval of the latest contract code by both traders.\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ninterface TreasuryInterface {\r\n    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external;\r\n    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external;\r\n    function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external;\r\n    function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external;\r\n    function exchangeTokens(uint16 tokenCode1, uint16 tokenCode2, address addr1, address addr2, address addrFee, uint amount1, uint fee1, uint amount2, uint fee2) external;\r\n}\r\n\r\n\r\n\r\n\r\ncontract Treasury is AccessModifiers, TreasuryInterface {\r\n    \r\n    uint constant EMERGENCY_RELEASE_CHALLENGE_PERIOD = 2 days;\r\n\r\n    \r\n            bool active = false;\r\n\r\n                mapping (uint16 => address) public tokenContracts;\r\n\r\n            mapping (uint176 => uint) public tokenAmounts;\r\n\r\n    \r\n    event SetActive(bool active);\r\n    event ChangeTokenInfo(uint16 tokenCode, address tokenContract);\r\n    event StartEmergencyRelease(address account);\r\n    event Deposit(uint16 tokenCode, address account, uint amount);\r\n    event Withdrawal(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount);\r\n    event EmergencyRelease(uint16 tokenCode, address account, uint amount);\r\n\r\n                mapping (address => uint) public emergencyReleaseSince;\r\n\r\n    \r\n    constructor () public {\r\n    }\r\n\r\n    \r\n    modifier onlyActive() {\r\n        require (active, \"Inactive treasury only allows withdrawals.\");\r\n        _;\r\n    }\r\n\r\n    modifier emergencyReleasePossible(address trader) {\r\n        uint deadline = emergencyReleaseSince[trader];\r\n        require (deadline > 0 && block.timestamp > deadline, \"Challenge should be active and deadline expired.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    function setActive(bool _active) external onlyRegistryOwner() {\r\n        active = _active;\r\n\r\n        emit SetActive(active);\r\n    }\r\n\r\n    function changeTokenInfo(uint16 tokenCode, address tokenContract) external onlyRegistryOwner() {\r\n        require (tokenCode != 0,\r\n                 \"Token code of zero is reserved for Ether.\");\r\n\r\n        require (tokenContracts[tokenCode] == address(0),\r\n                 \"Token contract address can be assigned only once.\");\r\n\r\n        tokenContracts[tokenCode] = tokenContract;\r\n\r\n        emit ChangeTokenInfo(tokenCode, tokenContract);\r\n    }\r\n\r\n    \r\n        function startEmergencyRelease() external {\r\n        emergencyReleaseSince[msg.sender] = block.timestamp + EMERGENCY_RELEASE_CHALLENGE_PERIOD;\r\n\r\n        emit StartEmergencyRelease(msg.sender);\r\n    }\r\n\r\n        function resetEmergencyRelease(address traderAddr) private {\r\n        if (emergencyReleaseSince[traderAddr] != 0) {\r\n            emergencyReleaseSince[traderAddr] = 0;\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function depositEther(address account) external payable {\r\n        emit Deposit(0, account, msg.value);\r\n\r\n        addBalance(0, account, msg.value);\r\n    }\r\n\r\n    function depositERC20Token(uint176 tokenAccount, uint amount) external {\r\n        uint16 tokenCode = uint16(tokenAccount >> 160);\r\n        address tokenContract = tokenContracts[tokenCode];\r\n\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n                require (safeTransferFrom(tokenContract, msg.sender, address(this), amount),\r\n                 \"Could not transfer ERC-20 tokens using transferFrom.\");\r\n\r\n        address account = address(tokenAccount);\r\n        emit Deposit(tokenCode, account, amount);\r\n\r\n        addBalance(tokenCode, account, amount);\r\n    }\r\n\r\n    \r\n    function emergencyReleaseEther() external emergencyReleasePossible(msg.sender) {\r\n        uint amount = deductFullBalance(0, msg.sender);\r\n\r\n        emit EmergencyRelease(0, msg.sender, amount);\r\n\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function emergencyReleaseERC20Token(uint16 tokenCode) external emergencyReleasePossible(msg.sender) {\r\n        uint amount = deductFullBalance(tokenCode, msg.sender);\r\n\r\n        emit EmergencyRelease(tokenCode, msg.sender, amount);\r\n\r\n        address tokenContract = tokenContracts[tokenCode];\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n        require (safeTransfer(tokenContract, msg.sender, amount),\r\n                 \"Could not transfer ERC-20 tokens using transfer.\");\r\n    }\r\n\r\n            \r\n    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external\r\n        onlyActive()\r\n        onlyApprovedExchange(traderAddr) {\r\n\r\n        deductBalance(0, traderAddr, amount);\r\n        resetEmergencyRelease(traderAddr);\r\n\r\n        emit Withdrawal(0, traderAddr, withdrawalAddr, amount);\r\n\r\n        withdrawalAddr.transfer(amount);\r\n    }\r\n\r\n    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external\r\n        onlyActive()\r\n        onlyApprovedExchange(traderAddr) {\r\n\r\n        deductBalance(tokenCode, traderAddr, amount);\r\n        resetEmergencyRelease(traderAddr);\r\n\r\n        address tokenContract = tokenContracts[tokenCode];\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n        require (safeTransfer(tokenContract, withdrawalAddr, amount),\r\n                 \"Could not transfer ERC-20 tokens using transfer.\");\r\n\r\n        emit Withdrawal(tokenCode, traderAddr, withdrawalAddr, amount);\r\n    }\r\n\r\n                    \r\n            function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external\r\n        onlyActive() onlyApprovedExchange(fromAddr) {\r\n\r\n        resetEmergencyRelease(fromAddr);\r\n\r\n        deductBalance(tokenCode, fromAddr, amount);\r\n        addBalance(tokenCode, toAddr, amount);\r\n    }\r\n\r\n        function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external\r\n        onlyActive() onlyApprovedExchange(fromAddr) {\r\n\r\n        resetEmergencyRelease(fromAddr);\r\n\r\n        deductBalance(tokenCode, fromAddr, amount1 + amount2);\r\n\r\n        addBalance(tokenCode, toAddr1, amount1);\r\n        addBalance(tokenCode, toAddr2, amount2);\r\n    }\r\n\r\n                function exchangeTokens(\r\n        uint16 tokenCode1, uint16 tokenCode2,\r\n        address addr1, address addr2, address addrFee,\r\n        uint amount1, uint fee1,\r\n        uint amount2, uint fee2) external onlyActive() onlyApprovedExchangeBoth(addr1, addr2) {\r\n\r\n        resetEmergencyRelease(addr1);\r\n        resetEmergencyRelease(addr2);\r\n\r\n        deductBalance(tokenCode1, addr1, amount1 + fee1);\r\n        deductBalance(tokenCode2, addr2, amount2 + fee2);\r\n\r\n        addBalance(tokenCode1, addr2, amount1);\r\n        addBalance(tokenCode2, addr1, amount2);\r\n        addBalance(tokenCode1, addrFee, fee1);\r\n        addBalance(tokenCode2, addrFee, fee2);\r\n    }\r\n\r\n        \r\n    function deductBalance(uint tokenCode, address addr, uint amount) private {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        uint before = tokenAmounts[tokenAccount];\r\n        require (before >= amount, \"Enough funds.\");\r\n        tokenAmounts[tokenAccount] = before - amount;\r\n    }\r\n\r\n    function deductFullBalance(uint tokenCode, address addr) private returns (uint amount) {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        amount = tokenAmounts[tokenAccount];\r\n        tokenAmounts[tokenAccount] = 0;\r\n    }\r\n\r\n    function addBalance(uint tokenCode, address addr, uint amount) private {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        uint before = tokenAmounts[tokenAccount];\r\n        require (before + amount >= before, \"No overflow.\");\r\n        tokenAmounts[tokenAccount] = before + amount;\r\n    }\r\n\r\n            \r\n    function safeTransfer(address tokenContract, address to, uint value) internal returns (bool success)\r\n    {\r\n                (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n\r\n        success = false;\r\n\r\n        if (call_success) {\r\n            if (return_data.length == 0) {\r\n                                success = true;\r\n\r\n            } else if (return_data.length == 32) {\r\n                                assembly { success := mload(add(return_data, 0x20)) }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address tokenContract, address from, address to, uint value) internal returns (bool success)\r\n    {\r\n                (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n\r\n        success = false;\r\n\r\n        if (call_success) {\r\n            if (return_data.length == 0) {\r\n                success = true;\r\n\r\n            } else if (return_data.length == 32) {\r\n                assembly { success := mload(add(return_data, 0x20)) }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}",
        "label": false,
        "name": "0x12345678979f29ebc99e00bdc5693ddea564ca80.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public{\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nuint256 public VAR3 = 20000000 * 1 ether;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) public VAR5;\nstring public VAR6 = \"EGM Token\";\nstring public VAR7 = \"EGM\";\nuint256 public VAR8 = 18;\nconstructor () public{\nVAR4[msg.sender] = VAR3;\n}\nfunction FUN3(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0 && VAR4[msg.sender] >= VAR10);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN4(address VAR11, address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0 && VAR4[VAR11] >= VAR10 && VAR5[VAR11][msg.sender] >= VAR10);\nVAR5[VAR11][msg.sender] = VAR5[VAR11][msg.sender].sub(VAR10);\nVAR4[VAR11] = VAR4[VAR11].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR10) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR10 > 0 && VAR10 <= VAR4[msg.sender]);\nVAR5[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN6(uint256 VAR10) public FUN1 returns (bool) {\nrequire(VAR10 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].add(VAR10);\nVAR3 = VAR3.add(VAR10);\nreturn true;\n}\nfunction FUN7(uint256 VAR10) public FUN1 returns (bool) {\nrequire(VAR10 > 0 && VAR10 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR10);\nVAR3 = VAR3.sub(VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x3c67e228c56aeea9a421f230a8768fe134ac7639.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public constant VAR2 = \"FDC\";\nstring public constant VAR3 = \"Freedom Coin\";\nuint8 public constant VAR4 = 18;\nuint256 public VAR5 = 100000000000000000000000000;\nuint256 public VAR6 = 5000000000000000000;\nmapping(address => uint256) VAR7;\nmapping(address => mapping (address => uint256)) VAR8;\nconstructor() public{\nVAR7[VAR1] = VAR5;\n}\nfunction () public payable {\nFUN3(msg.sender);\n}\nfunction FUN3(address VAR9) public payable {\nrequire(VAR9 != address(0));\nuint256 VAR10 = msg.value; uint256 VAR11 = VAR10.mul(10**18).div(VAR6);\nrequire(VAR11 <= VAR7[VAR1]);\nif(VAR10 > 0){\nVAR7[VAR9] += VAR11;\nVAR7[VAR1] -= VAR11;\n}\n}\nfunction FUN4(uint256 VAR11) public {\nuint256 VAR12 = VAR11.mul(VAR6).div(10**18);\nVAR7[VAR1] += VAR11;\nVAR7[msg.sender] -= VAR11;\n(msg.sender).FUN9(VAR12);\n}\nfunction FUN5(address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR7[VAR13];\n}\nfunction FUN6() public constant returns (uint256 VAR14) {\nreturn VAR7[VAR1];\n}\nfunction FUN7(address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR13.VAR14;\n}\nfunction FUN8(uint256 VAR12) FUN1 public{\nmsg.sender.FUN9(VAR12);\n}\nfunction FUN9(address VAR15, uint256 VAR16) public returns (bool VAR17) {\nrequire(VAR15 != address(0));\nif (VAR7[msg.sender] >= VAR16 && VAR16 > 0) {\nVAR7[msg.sender] -= VAR16;\nVAR7[VAR15] += VAR16;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN10(address VAR18) FUN1 public {\nrequire(VAR18 != address(0));\nVAR7[VAR18] = VAR7[VAR1];\nVAR7[VAR1] = 0;\nVAR1 = VAR18;\n}\n}",
        "label": false,
        "name": "0x7afd174e576e63b33c534ec9cc8ac2cfada28759.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor () internal {\nFUN8(msg.sender);\n}\nmodifier FUN5() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN6(address VAR4) public FUN5 {\nFUN8(VAR4);\n}\nfunction FUN7() public {\nFUN9(msg.sender);\n}\nfunction FUN8(address VAR4) internal {\nVAR3.add(VAR4);\n}\nfunction FUN9(address VAR4) internal {\nVAR3.remove(VAR4);\n}\n}\ncontract CON3 is CON2 {\nbool private VAR5;\nconstructor () internal {\nVAR5 = false;\n}\nmodifier FUN10() {\nrequire(!VAR5);\n_;\n}\nmodifier FUN11() {\nrequire(VAR5);\n_;\n}\nfunction FUN12() public FUN5 FUN10 {\nVAR5 = true;\n}\nfunction FUN13() public FUN5 FUN11 {\nVAR5 = false;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON1, CON3, CON4 {\nusing ECDSA for bytes32;\naddress payable private VAR6;\nmapping (bytes32 => bool) private VAR7;\nmapping (uint => uint) private VAR8;\nfunction FUN14(uint VAR9, uint VAR10, bytes calldata VAR11) external payable FUN17 FUN10 {\nrequire(msg.value != 0);\nbytes32 VAR12 = keccak256(abi.encodePacked(msg.sender, VAR9, VAR10));\naddress VAR13 = VAR12.toEthSignedMessageHash().recover(VAR11);\nrequire(VAR13 == owner());\nrequire(!VAR7[VAR12]);\nrequire(VAR8[VAR10] == msg.value);\nVAR6.transfer(msg.value);\nVAR7[VAR12] = true;\n}\nfunction FUN15(uint VAR10, uint VAR14) external FUN1 {\nrequire(VAR14 != 0);\nVAR8[VAR10] = VAR14;\n}\nfunction FUN16(address payable VAR15) external FUN1 {\nrequireNotEmptyAddress(VAR15);\nVAR6 = VAR15;\n}\nmodifier FUN17() {\nrequireNotEmptyAddress(VAR6);\n_;\n}\n}",
        "label": false,
        "name": "0xc46ef00408b400975b375ba81c6c227bb62c6539.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.VAR16;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new VAR20 is the zero address\");\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nstring private VAR3;\nstring private VAR4;\nuint8 private VAR5;\nconstructor (string memory VAR6, string memory VAR7, uint8 VAR8) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR9;\nmapping (address => mapping (address => uint256)) private VAR10;\nuint256 private VAR11;\nfunction FUN5(address VAR12, uint256 VAR13) public returns (bool) {\nFUN10(msg.VAR16, VAR12, VAR13);\nreturn true;\n}\nfunction FUN6(address VAR14, uint256 VAR15) public returns (bool) {\nFUN13(msg.VAR16, VAR14, VAR15);\nreturn true;\n}\nfunction FUN7(address VAR16, address VAR12, uint256 VAR13) public returns (bool) {\nFUN10(VAR16, VAR12, VAR13);\nFUN13(VAR16, msg.VAR16, VAR10[VAR16][msg.VAR16].sub(VAR13));\nreturn true;\n}\nfunction FUN8(address VAR14, uint256 VAR17) public returns (bool) {\nFUN13(msg.VAR16, VAR14, VAR10[msg.VAR16][VAR14].add(VAR17));\nreturn true;\n}\nfunction FUN9(address VAR14, uint256 VAR18) public returns (bool) {\nFUN13(msg.VAR16, VAR14, VAR10[msg.VAR16][VAR14].sub(VAR18));\nreturn true;\n}\nfunction FUN10(address VAR16, address VAR12, uint256 VAR13) internal {\nrequire(VAR16 != address(0), \"ERC20: FUN5 VAR25 the zero address\");\nrequire(VAR12 != address(0), \"ERC20: FUN5 VAR24 the zero address\");\nVAR9[VAR16] = VAR9[VAR16].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\n}\nfunction FUN11(address VAR19, uint256 VAR13) internal {\nrequire(VAR19 != address(0), \"ERC20: FUN20 VAR24 the zero address\");\nVAR11 = VAR11.add(VAR13);\nVAR9[VAR19] = VAR9[VAR19].add(VAR13);\n}\nfunction FUN12(address VAR19, uint256 VAR15) internal {\nrequire(VAR19 != address(0), \"ERC20: burn VAR25 the zero address\");\nVAR11 = VAR11.sub(VAR15);\nVAR9[VAR19] = VAR9[VAR19].sub(VAR15);\n}\nfunction FUN13(address VAR20, address VAR14, uint256 VAR15) internal {\nrequire(VAR20 != address(0), \"ERC20: FUN6 VAR25 the zero address\");\nrequire(VAR14 != address(0), \"ERC20: FUN6 VAR24 the zero address\");\nVAR10[VAR20][VAR14] = VAR15;\n}\nfunction FUN14(address VAR19, uint256 VAR13) internal {\nFUN12(VAR19, VAR13);\nFUN13(VAR19, msg.VAR16, VAR10[VAR19][msg.VAR16].sub(VAR13));\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR21;\nconstructor () internal {\nFUN18(msg.VAR16);\n}\nmodifier FUN15() {\nrequire(isMinter(msg.VAR16), \"MinterRole: caller does not have the Minter role\");\n_;\n}\nfunction FUN16(address VAR19) public FUN15 {\nFUN18(VAR19);\n}\nfunction FUN17() public {\nFUN19(msg.VAR16);\n}\nfunction FUN18(address VAR19) internal {\nVAR21.add(VAR19);\n}\nfunction FUN19(address VAR19) internal {\nVAR21.remove(VAR19);\n}\n}\ncontract CON6 is CON4, CON5 {\nfunction FUN20(address VAR19, uint256 VAR13) public FUN15 returns (bool) {\nFUN11(VAR19, VAR13);\nreturn true;\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR22;\nconstructor () internal {\nFUN24(msg.VAR16);\n}\nmodifier FUN21() {\nrequire(isPauser(msg.VAR16), \"PauserRole: caller does not have the Pauser role\");\n_;\n}\nfunction FUN22(address VAR19) public FUN21 {\nFUN24(VAR19);\n}\nfunction FUN23() public {\nFUN25(msg.VAR16);\n}\nfunction FUN24(address VAR19) internal {\nVAR22.add(VAR19);\n}\nfunction FUN25(address VAR19) internal {\nVAR22.remove(VAR19);\n}\n}\ncontract CON8 is CON7 {\nbool private VAR23;\nconstructor () internal {\nVAR23 = false;\n}\nmodifier FUN26() {\nrequire(!VAR23, \"Pausable: paused\");\n_;\n}\nmodifier FUN27() {\nrequire(VAR23, \"Pausable: not paused\");\n_;\n}\nfunction FUN28() public FUN21 FUN26 {\nVAR23 = true;\n}\nfunction FUN29() public FUN21 FUN27 {\nVAR23 = false;\n}\n}\ncontract CON9 is CON4, CON8 {\nfunction FUN5(address VAR24, uint256 VAR15) public FUN26 returns (bool) {\nreturn super.FUN5(VAR24, VAR15);\n}\nfunction FUN7(address VAR25, address VAR24, uint256 VAR15) public FUN26 returns (bool) {\nreturn super.FUN7(VAR25, VAR24, VAR15);\n}\nfunction FUN6(address VAR14, uint256 VAR15) public FUN26 returns (bool) {\nreturn super.FUN6(VAR14, VAR15);\n}\nfunction FUN8(address VAR14, uint VAR17) public FUN26 returns (bool) {\nreturn super.FUN8(VAR14, VAR17);\n}\nfunction FUN9(address VAR14, uint VAR18) public FUN26 returns (bool) {\nreturn super.FUN9(VAR14, VAR18);\n}\n}\ncontract CON10 is CON3, CON6, CON9, CON1 {\naddress[] public VAR26;\nconstructor (string memory VAR3, string memory VAR4, uint8 VAR5) CON3(VAR3,VAR4,VAR5) public {\n}\nfunction FUN20(address VAR19, uint256 VAR13) public FUN15 returns (bool) {\nif (balanceOf(VAR19) == 0) {\nVAR26.push(VAR19);\n}\nreturn super.FUN20(VAR19, VAR13);\n}\nfunction FUN30(address VAR27,address VAR28) external FUN1{\nFUN16(VAR27);\nFUN16(VAR28);\nFUN22(VAR27);\nFUN22(VAR28);\n}\n}",
        "label": false,
        "name": "0x334a934fa07fce4fb7b1c89457fe9754c08f4d41.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\naddress public VAR1;\nfunction CON1() public {VAR1 = msg.sender;}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nmodifier FUN3 {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4, bool VAR5) public FUN1 {\nVAR3[VAR4] = VAR5;\n}\n}\ncontract CON3 is CON2 {\nmapping(bytes32 => uint) VAR6;\nmapping(bytes32 => string) VAR7;\nmapping(bytes32 => address) VAR8;\nmapping(bytes32 => bytes) VAR9;\nmapping(bytes32 => bool) VAR10;\nmapping(bytes32 => int) VAR11;\nfunction FUN5(bytes32 VAR12, uint VAR13) FUN3 external {\nVAR6[VAR12] = VAR13;\n}\nfunction FUN6(bytes32 VAR12, string VAR13) FUN3 external {\nVAR7[VAR12] = VAR13;\n}\nfunction FUN7(bytes32 VAR12, address VAR13) FUN3 external {\nVAR8[VAR12] = VAR13;\n}\nfunction FUN8(bytes32 VAR12, bytes VAR13) FUN3 external {\nVAR9[VAR12] = VAR13;\n}\nfunction FUN9(bytes32 VAR12, bool VAR13) FUN3 external {\nVAR10[VAR12] = VAR13;\n}\nfunction FUN10(bytes32 VAR12, int VAR13) FUN3 external {\nVAR11[VAR12] = VAR13;\n}\nfunction FUN11(bytes32 VAR12) FUN3 external {\ndelete VAR6[VAR12];\n}\nfunction FUN12(bytes32 VAR12) FUN3 external {\ndelete VAR7[VAR12];\n}\nfunction FUN13(bytes32 VAR12) FUN3 external {\ndelete VAR8[VAR12];\n}\nfunction FUN14(bytes32 VAR12) FUN3 external {\ndelete VAR9[VAR12];\n}\nfunction FUN15(bytes32 VAR12) FUN3 external {\ndelete VAR10[VAR12];\n}\nfunction FUN16(bytes32 VAR12) FUN3 external {\ndelete VAR11[VAR12];\n}\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nCON3 public VAR14;\nmapping(bytes32 => mapping(string => Funding)) VAR15;\nstruct Funding {\naddress[] VAR16; address[] VAR17; mapping(address => TokenFunding) VAR18;\n}\nstruct TokenFunding {\nmapping(address => uint256) VAR19;\nuint256 VAR20;\n}\nconstructor(address VAR21) public {\nVAR14 = CON3(VAR21);\n}\nfunction FUN17(address VAR22, bytes32 VAR23, string VAR24) public FUN3 {\nbool VAR25 = VAR14.getBool(keccak256(abi.encodePacked(\"funds.userHasFunded\", VAR23, VAR24, VAR22)));\nif (!VAR25) {\nuint VAR26 = getFunderCount(VAR23, VAR24);\nVAR14.FUN7(keccak256(abi.encodePacked(\"funds.VAR16.address\", VAR23, VAR24, VAR26)), VAR22);\nVAR14.FUN5(keccak256(abi.encodePacked(\"funds.funderCount\", VAR23, VAR24)), VAR26.add(1));\n}\n}\nfunction FUN18(address VAR22, bytes32 VAR23, string VAR24, address VAR27, uint256 VAR13) public FUN3 {\nif (VAR14.getBool(keccak256(abi.encodePacked(\"funds.token.address\", VAR23, VAR24, VAR27))) == false) {\nVAR14.FUN9(keccak256(abi.encodePacked(\"funds.token.address\", VAR23, VAR24, VAR27)), true);\nuint VAR28 = getFundedTokenCount(VAR23, VAR24);\nVAR14.FUN7(keccak256(abi.encodePacked(\"funds.token.address\", VAR23, VAR24, VAR28)), VAR27);\nVAR14.FUN5(keccak256(abi.encodePacked(\"funds.tokenCount\", VAR23, VAR24)), VAR28.add(1));\n}\nVAR14.FUN5(keccak256(abi.encodePacked(\"funds.tokenBalance\", VAR23, VAR24, VAR27)), VAR19(VAR23, VAR24, VAR27).add(VAR13));\nVAR14.FUN5(keccak256(abi.encodePacked(\"funds.amountFundedByUser\", VAR23, VAR24, VAR22, VAR27)), amountFunded(VAR23, VAR24, VAR22, VAR27).add(VAR13));\nVAR14.FUN9(keccak256(abi.encodePacked(\"funds.userHasFunded\", VAR23, VAR24, VAR22)), true);\n}\nfunction FUN19(bytes32 VAR29, string VAR30, address VAR27) public FUN3 returns (uint256) {\nrequire(!issueResolved(VAR29, VAR30), \"Can't claim token, issue is already resolved.\");\nuint256 VAR20 = VAR19(VAR29, VAR30, VAR27);\nVAR14.FUN11(keccak256(abi.encodePacked(\"funds.tokenBalance\", VAR29, VAR30, VAR27)));\nreturn VAR20;\n}\nfunction FUN20(bytes32 VAR23, string VAR24, address VAR31, address VAR27) public FUN3 returns (uint256) {\nrequire(!issueResolved(VAR23, VAR24), \"Can't refund token, issue is already resolved.\");\nuint256 VAR32 = amountFunded(VAR23, VAR24, VAR31, VAR27);\nVAR14.FUN11(keccak256(abi.encodePacked(\"funds.amountFundedByUser\", VAR23, VAR24, VAR31, VAR27)));\nuint256 VAR33 = VAR19(VAR23, VAR24, VAR27);\nuint256 VAR34 = VAR33.sub(VAR32);\nrequire(VAR34 <= VAR33);\nVAR14.FUN5(keccak256(abi.encodePacked(\"funds.tokenBalance\", VAR23, VAR24, VAR27)), VAR34);\nreturn VAR32;\n}\nfunction FUN21(bytes32 VAR29, string VAR30) public FUN3 returns (bool) {\nVAR14.FUN9(keccak256(abi.encodePacked(\"funds.issueResolved\", VAR29, VAR30)), true);\nVAR14.FUN11(keccak256(abi.encodePacked(\"funds.funderCount\", VAR29, VAR30)));\nreturn true;\n}\n}",
        "label": false,
        "name": "0xce089b8b079597662614df7557e215f19ec8c3fa.sol"
    },
    {
        "source": "contract CON1 {\nstruct Report {\naddress VAR1;\nbytes32 VAR2;\n}\naddress public VAR3;\nReport[] public VAR4;\nfunction CON1() {\nVAR3 = msg.sender;\n}\nfunction FUN1(bytes32 VAR2) {\nVAR4.push(Report({VAR1: msg.sender,VAR2: VAR2}));\n}\n}",
        "label": false,
        "name": "0x62854fc64d74b7eb5e4d0a2910e277ffb4d3d1e3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 500000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Quick Transaction money\";\nstring constant public VAR14 = \"QTMTotal\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xe0cf1a976503b6e27250d710f7097c004b9a706b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nuint256 public VAR1 = 100000000 * 1 ether;\nmapping (address => uint256) public VAR2;\nmapping (address => mapping (address => uint256)) public VAR3;\nstring public VAR4 = \"CoinCasso Exchange Token\";\nstring public VAR5 = \"CCX\";\nuint256 public VAR6 = 18;\naddress public VAR7 ;\nconstructor () public{\nVAR7 = msg.sender;\nVAR2[VAR7] = VAR1;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction VAR1() public constant returns (uint256) {\nreturn VAR1;\n}\nfunction FUN2(address VAR8) public constant returns (uint256) {\nreturn VAR2[VAR8];\n}\nfunction FUN3(address VAR8, address VAR9) public constant returns (uint256) {\nreturn VAR3[VAR8][VAR9];\n}\nfunction FUN4(address VAR10, uint256 VAR11) public returns (bool) {\nrequire (VAR10 != address(0));\nrequire (VAR11 > 0);\nassert(VAR2[msg.sender] >= VAR11);\nVAR2[msg.sender] = VAR2[msg.sender] - VAR11;\nVAR2[VAR10] = VAR2[VAR10] + VAR11;\nreturn true;\n}\nfunction FUN5(address VAR8, address VAR10, uint256 VAR11) public returns (bool) {\nrequire (VAR8 != address(0));\nrequire (VAR10 != address(0));\nassert(VAR2[VAR8] >= VAR11);\nassert(VAR3[VAR8][msg.sender] >= VAR11);\nVAR3[VAR8][msg.sender] = VAR3[VAR8][msg.sender] - VAR11;\nVAR2[VAR8] = VAR2[VAR8] - VAR11;\nVAR2[VAR10] = VAR2[VAR10] + VAR11;\nreturn true;\n}\nfunction FUN6(address VAR9, uint256 VAR11) public returns (bool) {\nrequire (VAR9 != address(0));\nrequire (VAR11 > 0);\nVAR3[msg.sender][VAR9] = VAR11;\nreturn true;\n}\nfunction FUN7(uint256 VAR11) public FUN1 {\nrequire (VAR11 > 0);\nVAR2[msg.sender] = VAR2[msg.sender] - VAR11;\nVAR1 = VAR1 - VAR11;\n}\n}",
        "label": false,
        "name": "0x395dc9a82e3eef962b0355a3d4e6819e9af776d2.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 5;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x339910b5b50a12a6181c0ea452454a8991180617.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 1000000000000000000000000000;\nVAR6 = 1000000000000000000000000000;\nVAR3 = \"TROY\";\nVAR4 = \"TROY\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x91a09e43eeedbceefbd5928361d1f917818e3a3b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\naddress private VAR11;\nuint256 VAR12;\nbool VAR13 = false;\nfunction CON4 (uint256 VAR14) public {\nVAR11 = msg.sender;\nVAR12 = VAR14;\nVAR9 [msg.sender] = VAR14;\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN1 (VAR2, VAR3);\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN2 (VAR6, VAR2, VAR3);\n}\nfunction FUN3 (address VAR8, uint256 VAR15, uint256 VAR16)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR15)\nreturn FUN3 (VAR8, VAR16);\nelse return false;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool VAR4) {\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR12 = safeSub (VAR12, VAR3);\nreturn true;\n} else return true;\n}\nfunction FUN5 (address VAR17) public {\nrequire (msg.sender == VAR11);\nVAR11 = VAR17;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR11);\nif (!VAR13) {\nVAR13 = true;\nFreeze ();\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR11);\nif (VAR13) {\nVAR13 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0x291e2077ce361815a65126297956310dd1c740f4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4 (address VAR7, uint VAR8) public returns (bool VAR9) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR9) {\nuint VAR11 = VAR5[msg.sender][VAR7];\nif (VAR10 > VAR11) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON5 {\nusing SafeERC20 for CON1;\nCON1 public VAR12;\naddress public VAR13;\nuint64 public VAR14;\nconstructor(CON1 VAR15, address VAR16, uint64 VAR17) public {\nrequire(VAR17 > uint64(block.timestamp));\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\nfunction FUN6() public {\nrequire(uint64(block.timestamp) >= VAR14);\nuint256 VAR18 = VAR12.balanceOf(this);\nrequire(VAR18 > 0);\nVAR12.safeTransfer(VAR13, VAR18);\n}\n}\ncontract CON6 is CON2 {\nfunction FUN7(uint256 VAR4) public {\nFUN8(msg.sender, VAR4);\n}\nfunction FUN8(address VAR19, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR19]);\nVAR1[VAR19] = VAR1[VAR19].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON7 {\naddress public VAR20;\nconstructor() public {\nVAR20 = msg.sender;\n}\nmodifier FUN9 {\nrequire(msg.sender == VAR20);\n_;\n}\n}\ncontract CON8 is CON4, CON6, CON7 {\nstring public constant VAR21 = \"Depository Network Token\";\nstring public constant VAR22 = \"DEPO\";\nuint8 public constant VAR23 = 18;\nuint256 public constant VAR24 = 3000000000 * 10**uint256(VAR23);\naddress public VAR25;\naddress public VAR26;\naddress public VAR27;\naddress public VAR28;\naddress public VAR29;\nCON5 public VAR30;\nbool public VAR31 = false;\nmapping(address => bool) public VAR32;\nmodifier FUN10 {\nrequire(!VAR31);\n_;\n}\nconstructor(address VAR33, address VAR34, address VAR35,address VAR36, address VAR37) public {\nrequire(VAR33 != address(0));\nrequire(VAR34 != address(0));\nrequire(VAR35 != address(0));\nrequire(VAR36 != address(0));\nrequire(VAR37 != address(0));\nVAR28 = VAR33;\nVAR29 = VAR34;\nVAR27 = VAR35;\nVAR25 = VAR36;\nVAR26 = VAR37;\nVAR32[VAR25] = true;\nVAR32[VAR26] = true;\nuint256 VAR38 = 1500000000 * 10**uint256(VAR23);\nVAR2 = VAR38;\nVAR1[VAR25] = VAR38;\nuint256 VAR39 = 180000000 * 10**uint256(VAR23);\nVAR2 = VAR2.add(VAR39);\nVAR1[VAR26] = VAR39;\nuint256 VAR40 = 780000000 * 10**uint256(VAR23);\nVAR2 = VAR2.add(VAR40);\nVAR1[VAR27] = VAR40;\nuint256 VAR41 = 360000000 * 10**uint256(VAR23);\nVAR2 = VAR2.add(VAR41);\nVAR30 = new CON5(this, VAR28, uint64(now + 2 * 365 days));\nVAR1[address(VAR30)] = VAR41;\nuint256 VAR42 = 180000000 * 10**uint256(VAR23);\nVAR2 = VAR2.add(VAR42);\nVAR1[VAR29] = VAR42;\nrequire(VAR2 <= VAR24);\n}\nfunction FUN11() public FUN9 FUN10 {\nVAR31 = true;\n}\nfunction FUN12(address VAR43) external FUN9 {\nVAR32[VAR43] = true;\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nif(!VAR31) return false;\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nif(!VAR31 && !VAR32[msg.sender]) return false;\nreturn super.FUN1(VAR3, VAR4);\n}\n}",
        "label": false,
        "name": "0x89cbeac5e8a13f0ebb4c74fadfc69be81a501106.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\nCON1 VAR2;\naddress VAR3;\nuint VAR4;\nfunction CON2(CON1 VAR5, address VAR6, uint VAR7) {\nrequire(VAR7 > now);\nVAR2 = VAR5;\nVAR3 = VAR6;\nVAR4 = VAR7;\n}\nfunction FUN1() {\nrequire(msg.sender == VAR3);\nrequire(now >= VAR4);\nuint VAR8 = VAR2.balanceOf(this);\nrequire(VAR8 > 0);\nVAR2.transfer(VAR3, VAR8);\n}\n}",
        "label": false,
        "name": "0xfedd868e8153d56619912267f61f158382846068.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 100000000000000000000000000000;\nVAR6 = 100000000000000000000000000000;\nVAR3 = \"Entity Business Ecology\";\nVAR4 = \"EBE\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe25789d1b6f8eed8e421ba6aa9a8c2416efcc229.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public constant VAR1 = \"EurocoinToken\"; string public constant VAR2 = \"ECTE\"; uint8 public constant VAR3 = 18;\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 private VAR6 = 100000000000000000000000000;\nconstructor() public {\nVAR4[msg.sender] = VAR6; }\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool VAR9) {\nFUN6(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN2(address VAR10, uint256 VAR8) public returns (bool VAR9) {\nrequire(VAR10 != address(0));\nVAR5[msg.sender][VAR10] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR11, address VAR7, uint256 VAR8) public returns (bool VAR9) {\nrequire(VAR5[VAR11][msg.sender] >= VAR8);\nVAR5[VAR11][msg.sender] = VAR5[VAR11][msg.sender].sub(VAR8);\nFUN6(VAR11, VAR7, VAR8);\nreturn true;\n}\nfunction FUN4(address VAR10, uint256 VAR12) public returns (bool) {\nrequire(VAR10 != address(0));\nVAR5[msg.sender][VAR10] = VAR5[msg.sender][VAR10].add(VAR12);\nreturn true;\n}\nfunction FUN5(address VAR10, uint256 VAR13) public returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR5[msg.sender][VAR10] >= VAR13);\nVAR5[msg.sender][VAR10] = VAR5[msg.sender][VAR10].sub(VAR13);\nreturn true;\n}\nfunction FUN6(address VAR11, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nrequire(VAR4[VAR11] >= VAR8);\nVAR4[VAR11] = VAR4[VAR11].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\n}",
        "label": false,
        "name": "0xe9fa21e671bcfb04e6868784b89c19d5aa2424ea.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nuint256 constant VAR2 = 2**256 - 1;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool VAR5) {\nrequire(VAR9[msg.sender] >= VAR4);\nVAR9[msg.sender] -= VAR4;\nVAR9[VAR3] += VAR4;\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool VAR5) {\nuint256 VAR7 = VAR10[VAR6][msg.sender];\nrequire(VAR9[VAR6] >= VAR4 && VAR7 >= VAR4);\nVAR9[VAR3] += VAR4;\nVAR9[VAR6] -= VAR4;\nif (VAR7 < VAR2) {\nVAR10[VAR6][msg.sender] -= VAR4;\n}\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR4) public returns (bool VAR5) {\nVAR10[msg.sender][VAR8] = VAR4;\nreturn true;\n}\nmapping (address => uint256) VAR9;\nmapping (address => mapping (address => uint256)) VAR10;\n}\ncontract CON3 is CON2 {\nstring public VAR11; uint8 public VAR12; string public VAR13; string public VAR14 = 'H0.1';\nfunction CON3(uint256 VAR15,string VAR16,uint8 VAR17,string VAR18) public {\nVAR9[msg.sender] = VAR15; VAR1 = VAR15; VAR11 = VAR16; VAR12 = VAR17; VAR13 = VAR18; }\nfunction FUN4(address VAR8, uint256 VAR4, bytes VAR19) public returns (bool VAR5) {\nVAR10[msg.sender][VAR8] = VAR4;\nrequire(VAR8.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, VAR4, this, VAR19));\nreturn true;\n}\n}",
        "label": false,
        "name": "0x518d3f4aa7c544079e06f5930b0cbb24a8e762a1.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public constant VAR1 = \"HibayexCoin\";\nstring public constant VAR2 = \"HBC\";\nuint8 public constant VAR3 = 8;\nuint256 public constant VAR4 = 20000000000000000;\nmapping(address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) internal VAR6;\nfunction FUN1(address VAR7) public {\nVAR5[VAR7] = VAR4;\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR5[msg.sender]);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR9);\nVAR5[VAR8] = VAR5[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR8, uint256 VAR9) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR5[VAR10]);\nrequire(VAR9 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] = VAR5[VAR10].sub(VAR9);\nVAR5[VAR8] = VAR5[VAR8].add(VAR9);\nVAR6[VAR10][msg.sender] = VAR6[VAR10][msg.sender].sub(VAR9);\nreturn true;\n}\nfunction FUN4(address VAR11, uint256 VAR9) public returns (bool) {\nVAR6[msg.sender][VAR11] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR11, uint VAR12) public returns (bool) {\nVAR6[msg.sender][VAR11] = VAR6[msg.sender][VAR11].add(VAR12);\nreturn true;\n}\nfunction FUN6(address VAR11, uint VAR13) public returns (bool) {\nuint VAR14 = VAR6[msg.sender][VAR11];\nif (VAR13 > VAR14) {\nVAR6[msg.sender][VAR11] = 0;\n} else {\nVAR6[msg.sender][VAR11] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd91ce27eaeb590ce5e41d7fe1afc84eb9858f293.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nFUN6(msg.sender, VAR3, VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5, uint256 VAR4) public returns (bool) {\nFUN7(msg.sender, VAR5, VAR4);\nreturn true;\n}\nfunction FUN3(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nFUN6(VAR6, VAR3, VAR4);\nFUN7(VAR6, msg.sender, VAR2[VAR6][msg.sender].sub(VAR4));\nreturn true;\n}\nfunction FUN4(address VAR5, uint256 VAR7) public returns (bool) {\nFUN7(msg.sender, VAR5, VAR2[msg.sender][VAR5].add(VAR7));\nreturn true;\n}\nfunction FUN5(address VAR5, uint256 VAR8) public returns (bool) {\nFUN7(msg.sender, VAR5, VAR2[msg.sender][VAR5].sub(VAR8));\nreturn true;\n}\nfunction FUN6(address VAR6, address VAR3, uint256 VAR4) internal {\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\n}\nfunction FUN7(address VAR9, address VAR5, uint256 VAR4) internal {\nrequire(VAR5 != address(0));\nrequire(VAR9 != address(0));\nVAR2[VAR9][VAR5] = VAR4;\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR10 = 'CON3';\nstring public constant VAR11 = 'DAB';\nuint8 public constant VAR12 = 18;\nuint256 public constant VAR13 = (200 * 1e6) * (10 ** uint256(VAR12));\nconstructor(address VAR14) public {\nVAR1[VAR14] = VAR13;\n}\n}",
        "label": false,
        "name": "0x5e7ebea68ab05198f771d77a875480314f1d0aae.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() public payable { }\nfunction FUN7() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN8(address VAR4) FUN1 public {\nselfdestruct(VAR4);\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON3 {\nstruct Monster {\nuint64 VAR5;\nuint8 VAR6;\nuint16 VAR7;\nuint16 VAR8;\n}\nCON4 public VAR9 = CON4(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\nuint8 public constant VAR10 = 4;\nuint8 public constant VAR11 = 8;\nuint8 public constant VAR12 = 12;\nuint public constant VAR13 = 3;\nuint16 public VAR14 = 10;\nuint public VAR15 = 4;\nuint64 public VAR16 = 8 minutes;\nuint public VAR17 = 0.04 ether;\nuint public VAR18 = 0.1 ether;\nuint public VAR19;\nuint VAR20;\nmapping(uint => Monster) public VAR21;\nmapping(uint => uint) public VAR22;\nmapping(uint => uint) public VAR23;\nfunction FUN9() public payable {}\nfunction FUN10(uint VAR24) FUN3 FUN15 external payable {\nuint VAR25;\naddress VAR1;\n(,,, VAR25, VAR1,,) = VAR9.getHeroDetails(VAR24);\nrequire(msg.sender == VAR1);\nuint VAR26 = (VAR25 / (32 ** 12)) % 32 + 1;\nuint VAR27 = (VAR25 / (32 ** 8)) % 32 + 1;\nMonster memory VAR28 = VAR21[VAR24];\nuint VAR29 = VAR28.VAR6;\nuint VAR30 = VAR22[VAR24];\nbool VAR31;\nif (VAR29 == 0) {\nrequire(msg.value >= VAR17);\nVAR19 += VAR17;\nVAR21[VAR24] = Monster(uint64(now), 1, VAR14, VAR14);\nVAR28 = VAR21[VAR24];\nVAR22[VAR24] = VAR26;\nVAR30 = VAR26;\nif (msg.value > VAR17) {\nmsg.sender.transfer(msg.value - VAR17);\n}\n} else {\nrequire(VAR30 > 0);\nVAR31 = now > VAR28.VAR5 + VAR16 * 2 ||\n(VAR28.VAR8 == VAR28.VAR7 && now > VAR28.VAR5 + VAR16);\nif (VAR31) {\nuint VAR32 = VAR17 - VAR23[VAR24];\nVAR18 += VAR32;\nVAR19 -= VAR32;\nassert(VAR32 <= VAR17);\n}\nmsg.sender.transfer(msg.value);\n}\nif (!VAR31) {\nFUN13(VAR24, VAR25, VAR27, VAR30);\n}\n}\nfunction FUN11(address VAR33) FUN1 external {\nVAR9 = CON4(VAR33);\n}\nfunction FUN12(uint VAR34) FUN1 external {\nVAR17 = VAR34;\n}\nfunction FUN13(uint VAR24, uint VAR35, uint VAR36, uint VAR37) internal {\nMonster storage VAR28 = VAR21[VAR24];\nuint8 VAR29 = VAR28.VAR6;\nuint VAR38;\n(VAR38,,,,) = VAR9.getHeroPower(VAR35, VAR13);\nuint VAR39;\nuint VAR40;\nif (now > VAR28.VAR5 + VAR16) {\nVAR39 = VAR29 + VAR15;\n} else {\nif (VAR29 >= 2) {\nVAR39 = FUN14(VAR29 / 2);\n}\n}\nif (VAR39 >= VAR37) {\nVAR22[VAR24] = 0;\nuint VAR32 = VAR17 - VAR23[VAR24];\nVAR18 += VAR32;\nVAR19 -= VAR32;\nassert(VAR32 <= VAR17);\n} else {\nVAR22[VAR24] -= VAR39;\nif (now > VAR28.VAR5 + VAR16) {\nVAR29++;\nVAR21[VAR24] = Monster(uint64(VAR28.VAR5 + VAR16),VAR29, VAR29 * VAR14, VAR29 * VAR14);\nVAR28 = VAR21[VAR24];\n}\nVAR40 = (VAR36 * 1e9 + VAR38 * 1e9 / (10 * (1 + FUN14(5)))) / tx.gasprice;\nbool VAR41 = VAR40 >= VAR28.VAR8;\nuint VAR42;\nif (VAR41) {\nuint8 VAR43 = VAR29 + 1;\nVAR21[VAR24] = Monster(uint64(now), VAR43, VAR43 * VAR14, VAR43 * VAR14);\nVAR28 = VAR21[VAR24];\nif (VAR29 == VAR10) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR11) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR12) {\nVAR42 = VAR18 / 2;\nVAR18 -= VAR42;\n}\nmsg.sender.transfer(VAR42);\n} else {\nVAR28.VAR8 -= uint8(VAR40);\n}\n}\n}\nfunction FUN14(uint VAR44) private returns (uint) {\nVAR20 = uint(keccak256(VAR20,block.blockhash(block.number - 1),block.coinbase,block.difficulty));\nreturn VAR20 % VAR44;\n}\nmodifier FUN15() {\naddress VAR45 = msg.sender;\nuint VAR46;\nassembly { VAR46 := extcodesize(VAR45) }\nrequire(VAR46 == 0);\n_;\n}\n}",
        "label": false,
        "name": "0x5b6f03513fef300f8b3d804ea4040abdee1f3aa2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.IDR.IndonesianRupiah\";\nstring public constant VAR2 = \"Bank Sentral Republik Indonesia-Bank Indonesia\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0xf1a6c65d0aaf81db928c510f920302a149375ee8.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\naddress internal VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 returns (bool) {\nif (VAR2 != address(0)) {\nFUN4(VAR1, VAR2);\nVAR1 = VAR2;\n}\nreturn true;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3 {\nuint256 private VAR3 = 6 * 10 ** 16;\nfunction FUN3(uint256 VAR4) external FUN1 returns (bool) {\nVAR3 = VAR4;\nreturn true;\n}\nfunction FUN4(address, address) internal returns (bool) {\nreturn true;\n}\n}",
        "label": false,
        "name": "0x023e27edd55dfbeb0925685175afcc2867686aa6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"PumaPay\";\nstring public VAR16 = \"PMA\";\nuint8 public VAR17 = 18;\nfunction CON7() public {\n}\nmodifier FUN11() {\nrequire(VAR13);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\n}",
        "label": false,
        "name": "0x846c66cf71c43f80403b51fe3906b3599d63336f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1{\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\naddress public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR6[msg.sender] = 1000000000000000000000000000;\nVAR4 = 1000000000000000000000000000;\nVAR1 = \"BOBO Chain\";\nVAR2 = \"BOB\";\nVAR3 = 18;\nVAR5 = msg.sender;\n}\nfunction FUN1(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR6[msg.sender] >= VAR10);\nrequire(VAR6[VAR9] + VAR10 >= VAR6[VAR9]);\nuint VAR11 = VAR6[msg.sender] + VAR6[VAR9];\nVAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR10);\nVAR6[VAR9] = CON1.safeAdd(VAR6[VAR9], VAR10);\nassert(VAR6[msg.sender]+VAR6[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN3(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR6[VAR14] >= VAR10) ;\nrequire (VAR6[VAR9] + VAR10 > VAR6[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR6[VAR14] = CON1.safeSub(VAR6[VAR14], VAR10);\nVAR6[VAR9] = CON1.safeAdd(VAR6[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON1.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\nfunction FUN4(uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR6[msg.sender] >= VAR10);\nrequire (VAR10 > 0);\nVAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR10);\nVAR7[msg.sender] = CON1.safeAdd(VAR7[msg.sender], VAR10);\nreturn true;\n}\nfunction FUN5(uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR7[msg.sender] >= VAR10);\nrequire (VAR10 > 0) ;\nVAR7[msg.sender] = CON1.safeSub(VAR7[msg.sender], VAR10);\nVAR6[msg.sender] = CON1.safeAdd(VAR6[msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9161ffceede0e8b895be72daed25196e41a2dbec.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\nfunction FUN1(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 * VAR3;\nFUN9(VAR2 == 0 || VAR4 / VAR2 == VAR3);\nreturn VAR4;\n}\nfunction FUN2(uint VAR2, uint VAR3) internal returns (uint) {\nFUN9(VAR3 > 0);\nuint VAR4 = VAR2 / VAR3;\nFUN9(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);\nreturn VAR4;\n}\nfunction FUN3(uint VAR2, uint VAR3) internal returns (uint) {\nFUN9(VAR3 <= VAR2);\nreturn VAR2 - VAR3;\n}\nfunction FUN4(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 + VAR3;\nFUN9(VAR4>=VAR2 && VAR4>=VAR3);\nreturn VAR4;\n}\nfunction FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\nfunction FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\nfunction FUN9(bool VAR5) internal {\nif (!VAR5) {\nthrow;\n}\n}\n}\ncontract CON3 is CON1, CON2 {\nmapping(address => uint) VAR6;\nmapping (address => mapping (address => uint)) VAR7;\nmodifier FUN10(uint VAR8) {\nif(msg.data.length < VAR8 + 4) {\nthrow;\n}\n_;\n}\nfunction FUN11(address VAR9, uint VAR10) FUN10(2 * 32) returns (bool VAR11) {\nVAR6[msg.sender] = FUN3(VAR6[msg.sender], VAR10);\nVAR6[VAR9] = FUN4(VAR6[VAR9], VAR10);\nreturn true;\n}\nfunction FUN12(address VAR12, address VAR9, uint VAR10) returns (bool VAR11) {\nvar VAR13 = VAR7[VAR12][msg.sender];\nVAR6[VAR9] = FUN4(VAR6[VAR9], VAR10);\nVAR6[VAR12] = FUN3(VAR6[VAR12], VAR10);\nVAR7[VAR12][msg.sender] = FUN3(VAR13, VAR10);\nreturn true;\n}\nfunction FUN13(address VAR14) constant returns (uint VAR15) {\nreturn VAR6[VAR14];\n}\nfunction FUN14(address VAR16, uint VAR10) returns (bool VAR11) {\nif ((VAR10 != 0) && (VAR7[msg.sender][VAR16] != 0)) throw;\nVAR7[msg.sender][VAR16] = VAR10;\nreturn true;\n}\nfunction FUN15(address VAR14, address VAR16) constant returns (uint VAR17) {\nreturn VAR7[VAR14][VAR16];\n}\n}\ncontract CON4 {\nuint public VAR18;\nfunction FUN16() public constant returns (bool) {\nreturn true;\n}\n}\ncontract CON5 is CON3 {\naddress public VAR19;\nCON4 public VAR20;\nuint256 public VAR21;\nenum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\nfunction CON5(address VAR22) {\nVAR19 = VAR22;\n}\nfunction FUN17(uint256 VAR23) public {\nUpgradeState VAR24 = FUN19();\nif(!(VAR24 == UpgradeState.ReadyToUpgrade || VAR24 == UpgradeState.Upgrading)) {\nthrow;\n}\nif (VAR23 == 0) throw;\nVAR6[msg.sender] = FUN3(VAR6[msg.sender], VAR23);\nVAR1 = FUN3(VAR1, VAR23);\nVAR21 = FUN4(VAR21, VAR23);\nVAR20.upgradeFrom(msg.sender, VAR23);\n}\nfunction FUN18(address VAR25) external {\nif(!FUN21()) {\nthrow;\n}\nif (VAR25 == 0x0) throw;\nif (msg.sender != VAR19) throw;\nif (FUN19() == UpgradeState.Upgrading) throw;\nVAR20 = CON4(VAR25);\nif(!VAR20.FUN16()) throw;\nif (VAR20.VAR18() != VAR1) throw;\n}\nfunction FUN19() public constant returns(UpgradeState) {\nif(!FUN21()) return UpgradeState.NotAllowed;\nelse if(address(VAR20) == 0x00) return UpgradeState.WaitingForAgent;\nelse if(VAR21 == 0) return UpgradeState.ReadyToUpgrade;\nelse return UpgradeState.Upgrading;\n}\nfunction FUN20(address VAR26) public {\nif (VAR26 == 0x0) throw;\nif (msg.sender != VAR19) throw;\nVAR19 = VAR26;\n}\nfunction FUN21() public constant returns(bool) {\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR27;\nfunction CON6() {\nVAR27 = msg.sender;\n}\nmodifier FUN22() {\nif (msg.sender != VAR27) {\nthrow;\n}\n_;\n}\nfunction FUN23(address VAR28) FUN22 {\nif (VAR28 != address(0)) {\nVAR27 = VAR28;\n}\n}\n}\ncontract CON7 is CON1, CON6 {\naddress public VAR29;\nbool public VAR30 = false;\nmapping (address => bool) public VAR31;\nmodifier FUN24(address VAR32) {\nif(!VAR30) {\nif(!VAR31[VAR32]) {\nthrow;\n}\n}\n_;\n}\nfunction FUN25(address VAR33) FUN22 FUN28(false) public {\nVAR29 = VAR33;\n}\nfunction FUN26(address VAR33, bool VAR24) FUN22 FUN28(false) public {\nVAR31[VAR33] = VAR24;\n}\nfunction FUN27() public FUN29 {\nVAR30 = true;\n}\nmodifier FUN28(bool VAR34) {\nif(VAR34 != VAR30) {\nthrow;\n}\n_;\n}\nmodifier FUN29() {\nif(msg.sender != VAR29) {\nthrow;\n}\n_;\n}\nfunction FUN11(address VAR9, uint VAR10) FUN24(msg.sender) returns (bool VAR11) {\nreturn super.FUN11(VAR9, VAR10);\n}\nfunction FUN12(address VAR12, address VAR9, uint VAR10) FUN24(VAR12) returns (bool VAR11) {\nreturn super.FUN12(VAR12, VAR9, VAR10);\n}\n}\ncontract CON8 is CON3, CON6 {\nusing SafeMathLib for uint;\nbool public VAR35 = false;\nmapping (address => bool) public VAR36;\nfunction FUN30(address VAR37, uint VAR38) FUN32 FUN33 public {\nVAR1 = VAR1.plus(VAR38);\nVAR6[VAR37] = VAR6[VAR37].plus(VAR38);\n}\nfunction FUN31(address VAR33, bool VAR24) FUN22 FUN33 public {\nVAR36[VAR33] = VAR24;\n}\nmodifier FUN32() {\nif(!VAR36[msg.sender]) {\nthrow;\n}\n_;\n}\nmodifier FUN33() {\nif(VAR35) throw;\n_;\n}\n}\ncontract CON9 is CON7, CON8, CON5 {\nstring public VAR39;\nstring public VAR40;\nuint public VAR41;\nfunction CON9(string VAR42, string VAR43, uint VAR44, uint VAR45)\nCON5(msg.sender) {\nVAR27 = msg.sender;\nVAR39 = VAR42;\nVAR40 = VAR43;\nVAR1 = VAR44;\nVAR41 = VAR45;\nVAR6[VAR27] = VAR1;\n}\nfunction FUN27() public FUN29 {\nVAR35 = true;\nsuper.FUN27();\n}\nfunction FUN21() public constant returns(bool) {\nreturn VAR30;\n}\n}",
        "label": false,
        "name": "0x2285b7f262c741e9c555ab7df9009b87c29353cf.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1;\naddress VAR2;\naddress VAR3;\nfunction CON1(address VAR4, address VAR5) {\nVAR1 = VAR4;\nVAR3 = VAR5;\nVAR2 = msg.sender;\n}\nfunction FUN1() {\nif (msg.sender == VAR2 || msg.sender == VAR3)\nVAR1.send(this.balance);\n}\nfunction FUN2() {\nif (msg.sender == VAR1 || msg.sender == VAR3)\nVAR2.send(this.balance);\n}\n}",
        "label": false,
        "name": "0x9b27a23006b6612b2dfc840d0a25f4e347121d21.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR5[msg.sender]);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nrequire((VAR12 == 0) || (VAR6[msg.sender][VAR15] == 0));\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x2660d19429787705b645c67f31c260d42a182861.sol"
    },
    {
        "source": "contract AbstractDaoChallenge {\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);\r\n\tfunction tokenPrice() returns (uint256);\r\n}\r\n\r\ncontract DaoAccount\r\n{\r\n\t\r\n\r\n\t\r\n\r\n\t\r\n\t\r\n\r\n\taddress public daoChallenge; \r\n\t    address public challengeOwner;\r\n\r\n\t\r\n\r\n\tuint256 tokenBalance;   address owner;        \r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) noEther {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\t\ttokenBalance = 0;\r\n\r\n        challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tthrow;\r\n\t}\r\n\r\n\t\r\n\r\n\t\r\n\r\n\tfunction getOwnerAddress() constant returns (address ownerAddress) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction getTokenBalance() constant returns (uint256 tokens) {\r\n\t\treturn tokenBalance;\r\n\t}\r\n\r\n\tfunction buyTokens() onlyDaoChallenge returns (uint256 tokens) {\r\n\t\tuint256 amount = msg.value;\r\n\t\tuint256 tokenPrice = AbstractDaoChallenge(daoChallenge).tokenPrice();\r\n\r\n\t\t\t\tif (amount == 0) throw;\r\n\r\n\t\t\t\tif (amount % tokenPrice != 0) throw;\r\n\r\n\t\ttokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge {\r\n\t\tif (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n\t\tif (tokenBalance - tokens > tokenBalance) throw; \t\ttokenBalance -= tokens;\r\n\t\trecipient.receiveTokens(tokens);\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 tokens) {\r\n\t\t\t\tDaoAccount sender = DaoAccount(msg.sender);\r\n\t\tif (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw;\r\n\r\n\t\tif (tokens > sender.getTokenBalance()) throw;\r\n\r\n\t\t\t\tif (tokenBalance + tokens < tokenBalance) throw;\r\n\r\n\t\ttokenBalance += tokens;\r\n\t}\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\n\r\ncontract DaoChallenge\r\n{\r\n\t\r\n\r\n\r\n\t\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\tevent notifyTokenIssued(uint256 n, uint256 price, uint deadline);\r\n\r\n\tevent notifyNewAccount(address owner, address account);\r\n\tevent notifyBuyToken(address owner, uint256 tokens, uint256 price);\r\n\tevent notifyTransfer(address owner, address recipient, uint256 tokens);\r\n\r\n\t\r\n\r\n\t\tuint public tokenIssueDeadline = now;\r\n\tuint256 public tokensIssued = 0;\r\n\tuint256 public tokensToIssue = 0;\r\n\tuint256 public tokenPrice = 1000000000000000; \r\n\tmapping (address => DaoAccount) public daoAccounts;\r\n\r\n\t\r\n\r\n\t\taddress challengeOwner;\r\n\r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n\tfunction DaoChallenge () {\r\n\t\tchallengeOwner = msg.sender; \t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\r\n\t\tDaoAccount account = daoAccounts[accountOwner];\r\n\r\n\t\tif(account == DaoAccount(0x00) && createNew) {\r\n\t\t\taccount = new DaoAccount(accountOwner, challengeOwner);\r\n\t\t\tdaoAccounts[accountOwner] = account;\r\n\t\t\tnotifyNewAccount(accountOwner, address(account));\r\n\t\t}\r\n\r\n\t\treturn account;\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction createAccount () {\r\n\t\taccountFor(msg.sender, true);\r\n\t}\r\n\r\n\t\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) {\r\n\t\tif (account == DaoAccount(0x00)) return false;\r\n\t\tif (allegedOwnerAddress == 0x00) return false;\r\n\t\tif (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false;\r\n\t\t\t\tif (daoAccounts[allegedOwnerAddress] != account) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getTokenBalance () constant noEther returns (uint256 tokens) {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) return 0;\r\n\t\treturn account.getTokenBalance();\r\n\t}\r\n\r\n\t\t\t\tfunction issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner {\r\n\t\t\t\tif (now < tokenIssueDeadline) throw;\r\n\r\n\t\t\t\tif (deadline < now) throw;\r\n\r\n\t\t\t\tif (n == 0) throw;\r\n\r\n\t\ttokenPrice = price * 1000000000000;\r\n\t\ttokenIssueDeadline = deadline;\r\n\t\ttokensToIssue = n;\r\n\t\ttokensIssued = 0;\r\n\r\n\t\tnotifyTokenIssued(n, price, deadline);\r\n\t}\r\n\r\n\tfunction buyTokens () returns (uint256 tokens) {\r\n\t\ttokens = msg.value / tokenPrice;\r\n\r\n\t\tif (now > tokenIssueDeadline) throw;\r\n\t\tif (tokensIssued >= tokensToIssue) throw;\r\n\r\n\t\t\t\t\t\ttokensIssued += tokens;\r\n\t\tif (tokensIssued > tokensToIssue) throw;\r\n\r\n\t  DaoAccount account = accountFor(msg.sender, true);\r\n\t\tif (account.buyTokens.value(msg.value)() != tokens) throw;\r\n\r\n\t\tnotifyBuyToken(msg.sender, tokens, msg.value);\r\n\t\treturn tokens;\r\n \t}\r\n\r\n\tfunction transfer(uint256 tokens, address recipient) noEther {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) throw;\r\n\r\n\t\tDaoAccount recipientAcc = accountFor(recipient, false);\r\n\t\tif (recipientAcc == DaoAccount(0x00)) throw;\r\n\r\n\t\taccount.transfer(tokens, recipientAcc);\r\n\t\tnotifyTransfer(msg.sender, recipient, tokens);\r\n\t}\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}",
        "label": false,
        "name": "0xae42990ad29747c9ab0c16098b8c5393e53c6abe.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1=\"BINK Token\";\nstring public VAR2=\"BT\";\nuint8 public VAR3 = 18;\nuint256 public VAR4=6000000000;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x3be7770f5e6bd369689d82f4677308bfafab6dd2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is\nCON1\n{\nstring public VAR3 = \"Who are you?\";\nstring public VAR4 = \"20181018\";\nuint256 public VAR5 = 1539871627;\nuint256 public VAR6 = 35;\nuint256 public VAR7 = 51;\nstring public VAR8 = \"girl\";\nstring public VAR9 = \"\u718a\u709c\";\nstring public VAR10 = \"\u6c88\u96e8\u5a77\";\nconstructor () public {\nVAR1 = msg.sender;\n}\nfunction FUN5(string VAR11) public FUN1 {\nVAR3 = VAR11;\n}\n}",
        "label": false,
        "name": "0x6074bbb2236d78a5bd0db4931ccc45042ef92d39.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nuint256 VAR9 = VAR7[VAR8][msg.sender];\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR9.sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR10, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR10] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR7[VAR5][VAR10];\n}\nfunction FUN6 (address VAR10, uint VAR12)\nreturns (bool VAR13) {\nVAR7[msg.sender][VAR10] = VAR7[msg.sender][VAR10].add(VAR12);\nreturn true;\n}\nfunction FUN7 (address VAR10, uint VAR14)\nreturns (bool VAR13) {\nuint VAR15 = VAR7[msg.sender][VAR10];\nif (VAR14 > VAR15) {\nVAR7[msg.sender][VAR10] = 0;\n} else {\nVAR7[msg.sender][VAR10] = VAR15.sub(VAR14);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nstring public VAR16 = \"Lord Coin\";\nstring public VAR17 = \"LC\";\nuint256 public VAR18 = 18;\nuint256 public VAR19 = 20000000 * 1 ether;\nfunction CON5() {\nVAR1 = VAR19;\nVAR2[msg.sender] = VAR19;\n}\nfunction FUN8(uint256 VAR4) returns (bool VAR13) {\nrequire(VAR2[msg.sender] >= VAR4);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR1 = VAR1.sub(VAR4);\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR20;\nfunction CON6() {\nVAR20 = msg.sender;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR20);\n_;\n}\nfunction FUN10(address VAR21) FUN9 public {\nrequire(VAR21 != address(0));\nVAR20 = VAR21;\n}\n}\ncontract CON7 is CON6 {\nbool public VAR22 = false;\nmodifier FUN11() {\nrequire(!VAR22);\n_;\n}\nmodifier FUN12() {\nrequire(VAR22);\n_;\n}\nfunction FUN13() FUN9 FUN11 public {\nVAR22 = true;\n}\nfunction FUN14() FUN9 FUN12 public {\nVAR22 = false;\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint256;\nstring public constant VAR16 = \"Lord Coin ICO\";\nCON5 public VAR23;\naddress public VAR24;\nuint256 public VAR25;\nuint256 public VAR26;\nuint256 public VAR27 = 0;\nuint256 public VAR28 = 0;\nuint256 public VAR29 = 0;\nuint256 public VAR30 = 0;\nuint public VAR31;\nuint public VAR32;\nuint public VAR33;\nuint public VAR34;\nuint public constant VAR35 = 110;\nuint public constant VAR36 = 100;\nuint public constant VAR37 = 125;\nuint public constant VAR38 = 100;\nuint256 public constant VAR39 = 500 * 1 ether;\nbool public VAR40 = false;\nmodifier FUN15(uint VAR41) {\nrequire(FUN23() > VAR41);\n_;\n}\nmodifier FUN16(uint VAR41) {\nrequire(FUN23() < VAR41);\n_;\n}\nfunction CON8 (address VAR42,address VAR43,uint256 VAR44,uint256 VAR45,uint VAR46,uint VAR47,uint VAR48,uint VAR49) public {\nVAR23 = CON5(VAR42);\nVAR24 = VAR43;\nVAR25 = VAR44;\nVAR26 = VAR45;\nVAR31 = VAR46;\nVAR33 = VAR31 + VAR47 * 1 hours;\nVAR34 = VAR33 + VAR48 * 1 hours;\nVAR32 = VAR46 + VAR49 * 1 days;\n}\nfunction () external payable FUN11 {\nrequire(msg.value >= 0.01 * 1 ether);\nFUN20();\n}\nfunction FUN18(uint256 VAR4) external FUN9 {\nVAR24.FUN1(VAR4);\n}\nfunction FUN19() external FUN9 {\nVAR23.FUN1(VAR24, VAR23.FUN2(this));\nVAR40 = true;\n}\nfunction FUN20() private FUN15(VAR31) FUN16(VAR32) {\nrequire(!VAR40);\nrequire(msg.sender != address(0));\nuint256 VAR50 = msg.value.mul(VAR26).div(VAR25);\nif (FUN23() > VAR33 && FUN23() <= VAR34 && msg.value < VAR39) {\nVAR50 = VAR50.mul(VAR36).div(VAR35);\n}\nif (FUN23() > VAR34 && msg.value < VAR39) {\nVAR50 = VAR50.mul(VAR38).div(VAR37);\n}\nuint256 VAR51 = msg.value;\nif (VAR23.FUN2(this) < VAR50) {\nuint256 VAR52 = VAR50;\nVAR50 = VAR23.FUN2(this);\nVAR51 = msg.value.mul(VAR50).div(VAR52);\nmsg.sender.FUN1(msg.value.sub(VAR51));\n}\nFUN21(msg.sender, VAR51, VAR50);\n}\nfunction FUN21(address VAR53, uint256 VAR51, uint256 VAR54) private {\nif (VAR23.FUN2(VAR53) == 0) VAR28++;\nVAR23.FUN1(VAR53, VAR54);\nVAR29 = VAR29.add(VAR54);\nVAR27 = VAR27.add(VAR51);\nif (VAR23.FUN2(this) == 0) {\n}\n}\nfunction FUN22(address VAR53, uint256 VAR4) external FUN9 {\nFUN21(VAR53, 0, VAR4);\nVAR30 = VAR30.add(VAR4);\n}\nfunction FUN23() internal constant returns(uint256) {\nreturn now;\n}\n}",
        "label": false,
        "name": "0x47b8b6256f49cba6c8bd37361cac8b0fe324d605.sol"
    },
    {
        "source": "contract CON1{\nmapping (address => uint256) public VAR1;\nmapping (address => uint256) public VAR2;\nmapping (address => uint256) public VAR3;\naddress VAR4 = 0xF5c47144e20B78410f40429d78E7A18a2A429D0e;\naddress VAR5 = 0xC7a4Bf373476e265fC1b428CC4110E83aE32e8A3;\nfunction FUN1(address VAR6) public payable {\nrequire(msg.value >= 0.01 ether);\nif(getProfit(msg.sender) > 0){\nuint256 VAR7 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nuint256 VAR8 = msg.value;\nuint256 VAR9 = SafeMath.div(VAR8, 20);\nif(VAR6 != msg.sender && VAR6 != 0x1 && VAR6 != VAR4 && VAR6 != VAR5){\nVAR3[VAR6] = SafeMath.add(VAR3[VAR6], VAR9);\n}\nVAR3[VAR4] = SafeMath.add(VAR3[VAR4], VAR9);\nVAR3[VAR5] = SafeMath.add(VAR3[VAR5], VAR9);\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR8);\nVAR2[msg.sender] = now;\n}\nfunction FUN2() public{\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nfunction FUN3() public {\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR7);\n}\nfunction FUN4() public {\nrequire(VAR3[msg.sender] > 0);\nuint256 VAR9 = VAR3[msg.sender];\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR9);\n}\n}",
        "label": false,
        "name": "0x398301a2322fc2e2d052d04a926e7a4f643a156e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x0f4a37731b942e14744ad1c5186efca83357211e.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\naddress public VAR2;\naddress public VAR3;\nfunction CON2() public {\nVAR2 = msg.sender;\nVAR3 = address(0);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR4) public FUN1 {\nrequire(address(0) != VAR4);\nVAR3 = VAR4;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR3);\nVAR2 = msg.sender;\nVAR3 = address(0);\n}\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint;\nstring public VAR5;\nstring public VAR6;\nuint public VAR7; string public VAR8;\nuint public VAR1;\nuint public VAR9;\nbool public VAR10;\nbool public VAR11;\naddress public VAR12; uint public VAR13; uint public VAR14; uint public VAR15; uint public VAR16;\nmapping(address => uint) public VAR17;\nmapping(address => mapping(address => uint)) public VAR18;\nfunction CON3(uint VAR19,string VAR20,uint VAR21,string VAR22,string VAR23,uint VAR24) public\n{\nVAR1 = VAR19 * (10**VAR21);\nVAR5 = VAR20; VAR6 = VAR22; VAR7 = VAR21; VAR8 = VAR23; VAR9 = VAR24;\nVAR17[VAR2] = VAR1;\nVAR13 = 25e17;\nVAR14 = 15e17;\nVAR15 = 15e17;\nVAR16 = 1e19;\nVAR11 = true;\nVAR10 = true;\nVAR12 = 0x80eFc17CcDC8fE6A625cc4eD1fdaf71fD81A2C99;\n}\nfunction FUN4(uint VAR24) public payable {\nrequire(!VAR10);\nrequire(VAR15 == msg.value);\nVAR10 = true;\nVAR9 = VAR24;\nVAR12.FUN8(msg.value);\n}\nfunction FUN5() public payable {\nrequire(!VAR11);\nrequire(VAR16 == msg.value);\nVAR11 = true;\nVAR12.FUN8(msg.value);\n}\nfunction FUN6() public payable {\nrequire(VAR10);\nuint VAR25;\nVAR25 = (msg.value * (10**VAR7)) / VAR9;\nrequire(VAR17[VAR2] >= VAR25);\nVAR17[msg.sender] = VAR17[msg.sender].add(VAR25);\nVAR17[VAR2] = VAR17[VAR2].sub(VAR25);\nVAR2.FUN8(msg.value);\n}\nfunction FUN7(address VAR26, uint256 VAR27) public FUN1() {\nVAR17[VAR26] += VAR27;\nVAR1 += VAR27;\n}\nfunction FUN8(address VAR28, uint VAR29) public returns(bool) {\nrequire(VAR28 != address(0));\nrequire(VAR17[msg.sender] >= VAR29);\nVAR17[msg.sender] = VAR17[msg.sender].sub(VAR29);\nVAR17[VAR28] = VAR17[VAR28].add(VAR29);\nreturn true;\n}\nfunction FUN9(address VAR30, address VAR28, uint256 VAR29) public returns(bool VAR31) {\nrequire(VAR28 != address(0));\nrequire(VAR17[VAR30] >= VAR29); require(VAR29 <= VAR18[VAR30][msg.sender]); VAR17[VAR30] = VAR17[VAR30].sub(VAR29); VAR17[VAR28] = VAR17[VAR28].add(VAR29); VAR18[VAR30][msg.sender] = VAR18[VAR30][msg.sender].sub(VAR29);\nreturn true;\n}\nfunction FUN10(address VAR32, uint VAR29) public returns(bool) {\nVAR18[msg.sender][VAR32] = VAR29;\nreturn true;\n}\nfunction FUN11 (address VAR32, uint VAR33) public returns (bool VAR31) {\nVAR18[msg.sender][VAR32] = VAR18[msg.sender][VAR32].add(VAR33);\nreturn true;\n}\nfunction FUN12 (address VAR32, uint VAR34) public returns (bool VAR31) {\nuint VAR35 = VAR18[msg.sender][VAR32];\nif (VAR34 > VAR35) {\nVAR18[msg.sender][VAR32] = 0;\n} else {\nVAR18[msg.sender][VAR32] = VAR35.sub(VAR34);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0x21d5a14e625d767ce6b7a167491c2d18e0785fda.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor () internal {\nFUN8(msg.sender);\n}\nmodifier FUN5() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN6(address VAR4) public FUN5 {\nFUN8(VAR4);\n}\nfunction FUN7() public {\nFUN9(msg.sender);\n}\nfunction FUN8(address VAR4) internal {\nVAR3.add(VAR4);\n}\nfunction FUN9(address VAR4) internal {\nVAR3.remove(VAR4);\n}\n}\ncontract CON3 is CON2 {\nbool private VAR5;\nconstructor () internal {\nVAR5 = false;\n}\nmodifier FUN10() {\nrequire(!VAR5);\n_;\n}\nmodifier FUN11() {\nrequire(VAR5);\n_;\n}\nfunction FUN12() public FUN5 FUN10 {\nVAR5 = true;\n}\nfunction FUN13() public FUN5 FUN11 {\nVAR5 = false;\n}\n}\ncontract CON4 {\nuint256 public VAR6;\n}\ncontract CON5 is CON4 {\nstring public VAR7;\nstring public VAR8;\nuint8 public VAR9;\nconstructor (string memory VAR10, string memory VAR11, uint8 VAR12) public {\nVAR7 = VAR10;\nVAR8 = VAR11;\nVAR9 = VAR12;\n}\n}\ncontract CON6 is CON3, CON5, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) internal VAR14;\naddress public VAR15;\nuint256 public VAR16 = 0;\nconstructor(string memory VAR10, string memory VAR11, uint8 VAR12)\nCON5(VAR10, VAR11, VAR12)\nCON1()\npublic {\nVAR6 = 100 * (10**9) * 10**uint256(VAR9); }\nfunction FUN14(address VAR17) FUN1 public {\nVAR15 = VAR17;\n}\nfunction FUN15(address VAR18,uint256 VAR19) public returns (bool) {\nrequire(msg.sender == VAR15);\nrequire(VAR19 <= VAR6 - VAR16);\nVAR13[VAR18] = VAR13[VAR18].add(VAR19);\nVAR16 = VAR16.add(VAR19);\nreturn true;\n}\nfunction FUN16(address VAR20, uint256 VAR21) FUN10 public returns (bool) {\nrequire(VAR20 != address(0));\nrequire(VAR21 <= VAR13[msg.sender]);\nVAR13[msg.sender] = VAR13[msg.sender].sub(VAR21);\nVAR13[VAR20] = VAR13[VAR20].add(VAR21);\nreturn true;\n}\nfunction FUN17(address VAR22, address VAR20, uint256 VAR21) public FUN10 returns (bool) {\nrequire(VAR20 != address(0));\nrequire(VAR21 <= VAR13[VAR22]);\nrequire(VAR21 <= VAR14[VAR22][msg.sender]);\nVAR13[VAR22] = VAR13[VAR22].sub(VAR21);\nVAR13[VAR20] = VAR13[VAR20].add(VAR21);\nVAR14[VAR22][msg.sender] = VAR14[VAR22][msg.sender].sub(VAR21);\nreturn true;\n}\nfunction FUN18(address VAR23, uint256 VAR21) public FUN10 returns (bool) {\nVAR14[msg.sender][VAR23] = VAR21;\nreturn true;\n}\nfunction FUN19(address VAR23, uint VAR24) public FUN10 returns (bool) {\nVAR14[msg.sender][VAR23] = VAR14[msg.sender][VAR23].add(VAR24);\nreturn true;\n}\nfunction FUN20(address VAR23, uint VAR25) public FUN10 returns (bool) {\nuint VAR26 = VAR14[msg.sender][VAR23];\nif (VAR25 > VAR26) {\nVAR14[msg.sender][VAR23] = 0;\n} else {\nVAR14[msg.sender][VAR23] = VAR26.sub(VAR25);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0x17070be71f8082767509aa4552e0ded11bd667ec.sol"
    },
    {
        "source": "contract CON1 {\nmapping (string => address) VAR1;\nmapping (address => string) VAR2;\naddress private VAR3;\nconstructor (address VAR4) public {\nrequire(VAR4 != address(0), \"You must inform a valid address\");\nVAR3 = VAR4;\n}\nfunction FUN1 (string VAR5, address VAR6) public payable returns (bool) {\nrequire (msg.value >= 1000000000000000, \"Send more money\");\nrequire (VAR1[VAR5] == address(0), \"Name already registered\");\nrequire (keccak256(VAR2[VAR6]) == keccak256(\"\"), \"Address already registered\");\nVAR1[VAR5] = VAR6;\nVAR2[VAR6] = VAR5;\nVAR3.transfer(msg.value);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x023fa9e2a97799b3d87b3fa35674b50b8b5c9f4e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON1 {\nbool public VAR4 = false;\nmodifier FUN3() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4);\n_;\n}\nfunction VAR4() FUN1 FUN3 public {\nVAR4 = true;\n}\nfunction FUN5() FUN1 FUN4 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) VAR6;\nfunction FUN6(address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR7 != address(0));\nuint256 VAR10 = VAR6[VAR9][msg.sender];\nVAR5[VAR9] = VAR5[VAR9].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nVAR6[VAR9][msg.sender] = VAR10.sub(VAR8);\nreturn true;\n}\nfunction FUN8(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\nfunction FUN9(address VAR13, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN10(address VAR11, address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR6[VAR11][VAR13];\n}\n}\ncontract CON5 is CON4 {\nstring public VAR15 = \"Long Game Chain\";\nstring public VAR16 = \"LGC\";\nuint public VAR17 = 18;\nuint public constant VAR18 = 200000000e18;\naddress public constant VAR19 = 0x732F9D548183C7133A9bf76b4e9d217A20092b9d;\nfunction CON5() public {\nVAR5[msg.sender] = VAR18;\nVAR3 = VAR18;\n}\nfunction FUN11() public {\nif(FUN8(this) > 0)\nthis.FUN6(VAR19, FUN8(this));\n}\nfunction FUN12() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0x9fbd51ed85412ed7b5d0f12ebd29fa03d767de11.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"EXAT\";\nVAR5 = \"EXAToken\";\nVAR6 = 18;\nVAR7 = 21000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0));\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nrequire(VAR10!=address(0));\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xf8b127481e60c36465c04af489e27567c9a3014d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\nfunction FUN3() public FUN1 {\nVAR1 = address(0);\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN4() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN5() {\nrequire(VAR3);\n_;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = true;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN8(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN9(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN10(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN11(address VAR10,uint VAR11)\npublic\nreturns (bool)\n{\nVAR8[msg.sender][VAR10] = (VAR8[msg.sender][VAR10].add(VAR11));\nreturn true;\n}\nfunction FUN12(address VAR10,uint VAR12)\npublic\nreturns (bool)\n{\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN8(address VAR6,uint256 VAR7)\npublic\nFUN4\nreturns (bool)\n{\nreturn super.FUN8(VAR6, VAR7);\n}\nfunction FUN9(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN4\nreturns (bool)\n{\nreturn super.FUN9(VAR9, VAR6, VAR7);\n}\nfunction FUN10(address VAR10,uint256 VAR7)\npublic\nFUN4\nreturns (bool)\n{\nreturn super.FUN10(VAR10, VAR7);\n}\nfunction FUN11(address VAR10,uint VAR11)\npublic\nFUN4\nreturns (bool VAR14)\n{\nreturn super.FUN11(VAR10, VAR11);\n}\nfunction FUN12(address VAR10,uint VAR12)\npublic\nFUN4\nreturns (bool VAR14)\n{\nreturn super.FUN12(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nstring public VAR15 = \"SVTChain\";\nstring public VAR16 = \"SVT\";\nuint public VAR17 = 18;\nuint public VAR18 = 10**29;\nconstructor() public {\nVAR5 = VAR18;\nVAR4[msg.sender] = VAR18;\n}\n}",
        "label": false,
        "name": "0x3503be8049ff6ce3235a4c9087f4f6f5da63eac6.sol"
    },
    {
        "source": "contract CON1 { address public VAR1; bool public VAR2;\nconstructor() internal {\nVAR1 = 0xA0c6f96035d0FA5F44D781060F84A0Bc6B8D87Ee;\n}\nmodifier FUN1() { require(msg.sender == VAR1, \"Not Allowed\");\n_;\n}\nmodifier FUN2() { require(VAR2 == false, \"Supply is locked\");\n_;\n}\nfunction FUN3(address VAR3) public FUN1 { require(VAR3 != address(0), \"Not allowed\");\nVAR1 = VAR3;\n}\nfunction FUN4(bool VAR4) public FUN1 { VAR2 = VAR4;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint256;\nuint256 public VAR5;\nmapping(address => uint256) VAR6; mapping(address => mapping(address => uint256)) VAR7;\nfunction FUN5(address VAR8, uint256 VAR9) public returns(bool VAR10) {\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR11, address VAR8, uint256 VAR9) public returns(bool VAR10) {\nVAR7[VAR11][msg.sender] = VAR7[VAR11][msg.sender].sub(VAR9);\nVAR6[VAR11] = VAR6[VAR11].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN7(address VAR12, uint256 VAR9) public returns(bool VAR10) {\nVAR7[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN8(uint256 VAR9) public FUN1 {\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR9);\nVAR5 = VAR5.sub(VAR9);\n}\n}\ncontract CON4 is CON3 {\nstring public VAR13 = 'Orionix';\nuint8 public VAR14 = 18;\nstring public VAR15 = 'ORX';\nstring public VAR16 = '2';\nconstructor() public {\nVAR5 = 600000000 * (10 ** uint256(VAR14)); VAR6[0xA0c6f96035d0FA5F44D781060F84A0Bc6B8D87Ee] = VAR5;\n}\nfunction () external {\nrevert(\"This contract cannot receive direct payments or fallback calls\");\n}\n}",
        "label": false,
        "name": "0x4e84a65b5664d33b67750771f8beaec458bd6729.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public returns (bool VAR3) {\nVAR1 = VAR2;\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR4 = true;\nmodifier FUN3 {\nrequire(!VAR4);\n_;\n}\nfunction FUN4() FUN1 public {\nVAR4 = false;\n}\nfunction FUN5() FUN1 public {\nVAR4 = true;\n}\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON1, CON2, CON3, CON4 {\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7 = 18;\nuint256 public VAR8;\nmapping (address => uint256) public VAR9;\nmapping (address => mapping (address => uint256)) public VAR10;\nmapping (address => bool) public VAR11;\nconstructor(string VAR12, string VAR13) public {\nVAR8 = 200000000 * 10 ** uint256(VAR7);\nVAR9[msg.sender] = VAR8;\nVAR5 = VAR12;\nVAR6 = VAR13;\n}\nfunction FUN6(address VAR14, address VAR15, uint256 VAR16) internal {\nrequire (VAR15 != 0x0);\nrequire (VAR9[VAR14] >= VAR16);\nrequire(!VAR11[VAR14]);\nrequire(!VAR11[VAR15]);\nVAR9[VAR14] = sub(VAR9[VAR14], VAR16);\nVAR9[VAR15] = add(VAR9[VAR15], VAR16);\n}\nfunction FUN7(address VAR15, uint256 VAR16) FUN3 public returns(bool VAR3) {\nFUN6(msg.sender, VAR15, VAR16);\nreturn true;\n}\nfunction FUN8(address VAR14, address VAR15, uint256 VAR16) FUN3 public returns (bool VAR3) {\nrequire(VAR16 <= VAR10[VAR14][msg.sender]);\nVAR10[VAR14][msg.sender] = sub(VAR10[VAR14][msg.sender], VAR16);\nFUN6(VAR14, VAR15, VAR16);\nreturn true;\n}\nfunction FUN9(address VAR17, uint256 VAR16) FUN3 public returns (bool VAR3) {\nrequire(!VAR11[msg.sender]);\nrequire(!VAR11[VAR17]);\nVAR10[msg.sender][VAR17] = VAR16;\nreturn true;\n}\nfunction FUN10(address VAR17, uint256 VAR18) FUN3 public returns (bool VAR3) {\nrequire(!VAR11[msg.sender]);\nrequire(!VAR11[VAR17]);\nVAR10[msg.sender][VAR17] = add(VAR10[msg.sender][VAR17], VAR18);\nreturn true;\n}\nfunction FUN11(address VAR17, uint256 VAR19) FUN3 public returns (bool VAR3) {\nrequire(!VAR11[msg.sender]);\nrequire(!VAR11[VAR17]);\nuint256 VAR20 = VAR10[msg.sender][VAR17];\nif (VAR19 > VAR20) {\nVAR10[msg.sender][VAR17] = 0;\n} else {\nVAR10[msg.sender][VAR17] = sub(VAR20, VAR19);\n}\nreturn true;\n}\nfunction FUN12(address VAR21, bool VAR22) FUN3 FUN1 public returns (bool VAR3) {\nVAR11[VAR21] = VAR22;\nreturn true;\n}\nfunction FUN13(uint256 VAR16) FUN3 FUN1 public returns (bool VAR3) {\nrequire(!VAR11[msg.sender]);\nrequire(VAR9[msg.sender] >= VAR16);\nVAR9[msg.sender] = sub(VAR9[msg.sender], VAR16);\nVAR8 = sub(VAR8, VAR16);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x53864ece70ea808ce8a25632e8c67473b99fa93f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public{\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nuint256 public VAR3 = 250000000 * 1 ether;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) public VAR5;\nstring public VAR6 = \"Vera\";\nstring public VAR7 = \"Vera\";\nuint256 public VAR8 = 18;\nconstructor () public{\nVAR4[msg.sender] = VAR3;\n}\nfunction FUN3(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0 && VAR4[msg.sender] >= VAR10);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN4(address VAR11, address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0 && VAR4[VAR11] >= VAR10 && VAR5[VAR11][msg.sender] >= VAR10);\nVAR5[VAR11][msg.sender] = VAR5[VAR11][msg.sender].sub(VAR10);\nVAR4[VAR11] = VAR4[VAR11].sub(VAR10);\nVAR4[VAR9] = VAR4[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR10) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR10 > 0 && VAR10 <= VAR4[msg.sender]);\nVAR5[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN6(uint256 VAR10) public FUN1 returns (bool) {\nrequire(VAR10 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].add(VAR10);\nVAR3 = VAR3.add(VAR10);\nreturn true;\n}\nfunction FUN7(uint256 VAR10) public FUN1 returns (bool) {\nrequire(VAR10 > 0 && VAR10 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR10);\nVAR3 = VAR3.sub(VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x166f1a7ecae00bd43876a25b10a63c575e05c0e7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor() internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR7 <= VAR4[VAR9][msg.sender]);\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN11(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN9(address VAR8,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN10(address VAR8,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR7 <= VAR3[VAR9]);\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != 0);\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != 0);\nrequire(VAR7 <= VAR3[VAR2]);\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR2, uint256 VAR7) internal {\nrequire(VAR7 <= VAR4[VAR2][msg.sender]);\nVAR4[VAR2][msg.sender] = VAR4[VAR2][msg.sender].sub(VAR7);\nFUN13(VAR2, VAR7);\n}\n}\ncontract CON4 is CON3 {\nfunction FUN15(uint256 VAR7) public {\nFUN13(msg.sender, VAR7);\n}\nfunction FUN16(address VAR9, uint256 VAR7) public {\nFUN14(VAR9, VAR7);\n}\n}\ncontract CON5 is CON2 {\nbool private VAR12;\nconstructor() internal {\nVAR12 = false;\n}\nmodifier FUN17() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN18() {\nrequire(VAR12);\n_;\n}\nfunction FUN19() public FUN1 FUN17 {\nVAR12 = true;\n}\nfunction FUN20() public FUN1 FUN18 {\nVAR12 = false;\n}\n}\ncontract CON6 is CON3, CON5 {\nfunction FUN6(address VAR6,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN6(VAR6, VAR7);\n}\nfunction FUN8(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN7(address VAR8,uint256 VAR7)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN7(VAR8, VAR7);\n}\nfunction FUN9(address VAR8,uint VAR10)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN9(VAR8, VAR10);\n}\nfunction FUN10(address VAR8,uint VAR11)\npublic\nFUN17\nreturns (bool VAR13)\n{\nreturn super.FUN10(VAR8, VAR11);\n}\n}\ncontract CON7 is CON3, CON4, CON6{\nstring public constant VAR14 = \"Kingcuan\";\nstring public constant VAR15 = \"CUAN\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 12000000000 * (10 ** uint256(VAR16));\nconstructor() public {\nFUN12(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0xedf44412b47a76e452fd133794e45d9485e4cd4b.sol"
    },
    {
        "source": "{\"BUS.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\ncontract BUS is ERC20, ERC20Detailed, ERC20Burnable() {\\n  uint private INITIAL_SUPPLY = 10000000000e18;\\n\\n  constructor () public ERC20Detailed(\\\"CONSENBUS\\\", \\\"BUS\\\", 18)\\n  {\\n    _mint(msg.sender, INITIAL_SUPPLY);\\n  }\\n}\\n\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\\n    }\\n}\\n\\n\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract ERC20Burnable is ERC20 {\\n    \\n    function burn(uint256 value) public {\\n        _burn(msg.sender, value);\\n    }\\n\\n    \\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\\n\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    \\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    \\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    \\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\\n\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\n\\n\\n\\n\"}}",
        "label": false,
        "name": "0xee64bfd5676f7338c8e892c67e98341932efd3c7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint256;\nconstructor() public {\nVAR1 = 0x23a79F63133D315e7C16E3AF68701a7cD92217F9;\nVAR8 = address(this);\nVAR10[VAR1] = 4950000000 * 10 ** 18;\nVAR10[VAR8] = 50000000 * 10 ** 18;\n}\nstring public constant VAR4 = \"Ultra Rich Group\";\nstring public constant VAR5 = \"RICH\";\nuint256 public constant VAR6 = 18;\nuint256 public VAR7 = 5000000000 * 10 ** VAR6;\naddress private VAR8;\nuint256 public VAR9;\nmapping(address => uint256) VAR10;\nmapping(address => mapping (address => uint256)) public VAR11;\nfunction FUN4(address VAR12, uint VAR13) public returns (bool VAR14) {\nrequire(VAR10[msg.sender] >= VAR13);\nrequire(VAR12 != VAR8);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR11[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nrequire(VAR13 <= balanceOf(VAR16));\nrequire(VAR13 <= allowance(VAR16, VAR12));\nVAR10[VAR16] = VAR10[VAR16].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR16][VAR12] = VAR11[VAR16][VAR12].sub(VAR13);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN8(uint256 VAR17, address VAR12) public FUN1 {\nVAR10[VAR12] = VAR10[VAR12].add(VAR17);\nVAR7 = VAR7.add(VAR17);\n}\nfunction FUN9(uint256 VAR17, address VAR16) public FUN1 {\nrequire(VAR10[VAR16] >= VAR17);\nVAR10[VAR16] = VAR10[VAR16].sub(VAR17);\nVAR7 = VAR7.sub(VAR17);\n}\nfunction FUN10(uint256 VAR18) public FUN1 {\nVAR9 = VAR18;\n}\nfunction FUN11(uint256 VAR19) public FUN1 {\nrequire(VAR10[VAR1] >= VAR19);\nVAR10[VAR1] = VAR10[VAR1].sub(VAR19);\nVAR10[VAR8] = VAR10[VAR8].add(VAR19);\n}\nfunction FUN12() public payable {\nrequire(VAR9 > 0);\nrequire(msg.VAR13 >= VAR9);\nuint256 VAR20 = msg.VAR13 / VAR9;\nrequire(VAR10[VAR8] >= VAR20 * 10 ** VAR6);\nVAR10[VAR8] = VAR10[VAR8].sub(VAR20 * 10 ** VAR6);\nVAR10[msg.sender] = VAR10[msg.sender].add(VAR20 * 10 ** VAR6);\n}\nfunction FUN13() public FUN1 {\nmsg.sender.FUN4(VAR8.balance);\n}\nfunction FUN14(uint256 VAR19) public FUN1 {\nrequire(VAR10[VAR8] >= VAR19);\nVAR10[VAR8] = VAR10[VAR8].sub(VAR19);\nVAR10[VAR1] = VAR10[VAR1].add(VAR19);\n}\n}",
        "label": false,
        "name": "0x198482924b5ed2c8dd5a0c824fcd618c6b49e6e8.sol"
    },
    {
        "source": "contract CON1{\nfunction FUN1(address VAR1) {}\nfunction FUN2(uint VAR2) {}\nfunction FUN3() {}\n}\ncontract CON2{\naddress VAR1;\nCON1 VAR3;\nconstructor() public\n{\nVAR1 = msg.sender;\n}\nfunction FUN4(address VAR4) public\n{\nrequire(VAR1==msg.sender);\nVAR3 = CON1(VAR4);\n}\nfunction FUN5() payable public\n{\nrequire(VAR1==msg.sender);\nVAR3.FUN1(address(this));\nVAR3.FUN3();\n}\nfunction FUN6(uint VAR2) public\n{\nrequire(VAR1==msg.sender);\nVAR3.FUN2(VAR2);\nmsg.sender.transfer(VAR2 * (1 ether));\n}\nfunction () payable public\n{}\n}",
        "label": false,
        "name": "0x444147624d24efaf097c5c5417c4adc9ba20da66.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 10000000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Eabcoins\";\nstring constant public VAR14 = \"EAB\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x42f2d09a9471cc2cf0092e5c1aa55aa099041519.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nmodifier FUN3(uint VAR5) {\nrequire(msg.data.length >= VAR5 + 4);\n_;\n}\nfunction FUN4(address VAR6, uint256 VAR7) FUN3(2 * 32) public {\nVAR4[msg.sender] = VAR4[msg.sender].sub256(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add256(VAR7);\n}\nfunction FUN5(address VAR8) constant public returns (uint256 VAR9) {\nreturn VAR4[VAR8];\n}\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) VAR10;\nfunction FUN6(address VAR11, address VAR6, uint256 VAR7) FUN3(3 * 32) public {\nvar VAR12 = VAR10[VAR11][msg.sender];\nVAR4[VAR6] = VAR4[VAR6].add256(VAR7);\nVAR4[VAR11] = VAR4[VAR11].sub256(VAR7);\nVAR10[VAR11][msg.sender] = VAR12.sub256(VAR7);\n}\nfunction FUN7(address VAR13, uint256 VAR7) public {\nif ((VAR7 != 0) && (VAR10[msg.sender][VAR13] != 0)) revert();\nVAR10[msg.sender][VAR13] = VAR7;\n}\nfunction FUN8(address VAR8, address VAR13) constant public returns (uint256 VAR14) {\nreturn VAR10[VAR8][VAR13];\n}\n}\ncontract CON6 is CON5, CON1{\nstring public VAR15 = \"BlockchainEcoToken\";\nstring public VAR16 = \"ETS\";\nuint public VAR17 = 8;\nfunction CON6() public {\nVAR3 = (10 ** 8) * (10 ** VAR17);\nVAR4[msg.sender] = VAR3;\n}\nfunction FUN9(uint VAR7) FUN1 public {\nrequire(VAR4[msg.sender] >= VAR7);\nVAR4[msg.sender] = VAR4[msg.sender].sub256(VAR7);\nVAR3 = VAR3.sub256(VAR7);\n}\n}",
        "label": false,
        "name": "0x2630331ff97cef5b3913ff2302862318ef980495.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) public VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 {\nusing SafeERC20 for CON1;\nCON1 public VAR5;\naddress public VAR6;\nuint64 public VAR7;\nfunction CON4(CON1 VAR8, address VAR9, uint64 VAR10) public {\nrequire(VAR10 > uint64(block.timestamp));\nVAR5 = VAR8;\nVAR6 = VAR9;\nVAR7 = VAR10;\n}\nfunction FUN2() public {\nrequire(uint64(block.timestamp) >= VAR7);\nuint256 VAR11 = VAR5.balanceOf(this);\nrequire(VAR11 > 0);\nVAR5.safeTransfer(VAR6, VAR11);\n}\n}\ncontract CON5 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR12;\nfunction FUN3(address VAR13, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR13]);\nrequire(VAR4 <= VAR12[VAR13][msg.sender]);\nVAR2[VAR13] = VAR2[VAR13].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR12[VAR13][msg.sender] = VAR12[VAR13][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR14, uint256 VAR4) public returns (bool) {\nVAR12[msg.sender][VAR14] = VAR4;\nreturn true;\n}\nfunction FUN5 (address VAR14, uint VAR15) public returns (bool VAR16) {\nVAR12[msg.sender][VAR14] = VAR12[msg.sender][VAR14].add(VAR15);\nreturn true;\n}\nfunction FUN6 (address VAR14, uint VAR17) public returns (bool VAR16) {\nuint VAR18 = VAR12[msg.sender][VAR14];\nif (VAR17 > VAR18) {\nVAR12[msg.sender][VAR14] = 0;\n} else {\nVAR12[msg.sender][VAR14] = VAR18.sub(VAR17);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nfunction FUN7(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR2[msg.sender]);\naddress VAR19 = msg.sender;\nVAR2[VAR19] = VAR2[VAR19].sub(VAR4);\nVAR1 = VAR1.sub(VAR4);\n}\n}\ncontract CON7 {\naddress public VAR20;\nfunction CON7() public {\nVAR20 = msg.sender;\n}\nmodifier FUN8 {\nrequire(msg.sender == VAR20);\n_;\n}\n}\ncontract CON8 is CON6, CON7 {\nstring public constant VAR21 = \"Omnitude Token\";\nstring public constant VAR22 = \"ECOM\";\nuint8 public constant VAR23 = 18;\nuint256 public constant VAR24 = 100000000 * 10**uint256(VAR23);\nuint256 public constant VAR25 = 55000000 * 10**uint256(VAR23);\naddress public VAR26;\naddress public VAR27;\naddress public VAR28;\naddress public VAR29;\naddress public VAR30;\naddress public VAR31;\naddress public VAR32;\nuint64 private constant VAR33 = 1546300800;\nuint64 private constant VAR34 = 1577836800;\nuint64 private constant VAR35 = 1609459200;\nuint64 private constant VAR36 = 1640995200;\nuint64 private constant VAR37 = 1672531200;\nbool public VAR38 = false;\nmodifier FUN9 {\nrequire(VAR1 < VAR25 && !VAR38);\n_;\n}\nmodifier FUN10 {\nrequire(!VAR38);\n_;\n}\nfunction CON8(address VAR39, address VAR40) public {\nrequire(VAR39 != address(0));\nrequire(VAR40 != address(0));\nVAR26 = VAR39;\nVAR27 = VAR40;\nVAR1 = VAR25;\nVAR2[VAR20] = VAR25;\n}\nfunction FUN11() public FUN8 FUN10 {\nuint256 VAR41 = VAR2[VAR20];\nVAR2[VAR20] = 0;\nVAR1 = VAR1.sub(VAR41);\nuint256 VAR42 = 33000000 * 10**uint256(VAR23);\nVAR1 = VAR1.add(VAR42);\nVAR2[VAR27] = VAR42;\nuint256 VAR43 = 12000000 * 10**uint256(VAR23);\nVAR1 = VAR1.add(VAR43);\nuint256 VAR44 = 2400000 * 10**uint256(VAR23);\nCON4 VAR45 = new CON4(this, VAR26, VAR33);\nVAR28 = address(VAR45);\nVAR2[VAR28] = VAR44;\nuint256 VAR46 = 2400000 * 10**uint256(VAR23);\nCON4 VAR47 = new CON4(this, VAR26, VAR34);\nVAR29 = address(VAR47);\nVAR2[VAR29] = VAR46;\nuint256 VAR48 = 2400000 * 10**uint256(VAR23);\nCON4 VAR49 = new CON4(this, VAR26, VAR35);\nVAR30 = address(VAR49);\nVAR2[VAR30] = VAR48;\nuint256 VAR50 = 2400000 * 10**uint256(VAR23);\nCON4 VAR51 = new CON4(this, VAR26, VAR36);\nVAR31 = address(VAR51);\nVAR2[VAR31] = VAR50;\nuint256 VAR52 = 2400000 * 10**uint256(VAR23);\nCON4 VAR53 = new CON4(this, VAR26, VAR37);\nVAR32 = address(VAR53);\nVAR2[VAR32] = VAR52;\nVAR38 = true;\n}\nfunction FUN3(address VAR13, address VAR3, uint256 VAR4) public returns (bool) {\nif(msg.sender != VAR20 && !VAR38) return false;\nreturn super.FUN3(VAR13, VAR3, VAR4);\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nif(msg.sender != VAR20 && !VAR38) return false;\nreturn super.FUN1(VAR3, VAR4);\n}\n}",
        "label": false,
        "name": "0x171d750d42d661b62c277a6b486adb82348c3eca.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 450000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Adrenaline AI\";\nstring constant public VAR14 = \"ADAI\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR6[msg.sender] >= VAR2);\nrequire (msg.sender == VAR9);\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR11 = safeSub (VAR11, VAR2);\nreturn true;\n}\nfunction FUN6(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN8 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN9(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN10(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x01ff4933a07aa905be4a4242ba604b7fe65856d7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x8cb8a9255b7e52d33649eb7887c554c01d015418.sol"
    },
    {
        "source": "contract chal2sweep {\r\n    address chal = 0x08d698358b31ca6926e329879db9525504802abf;\r\n    address noel = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\r\n\r\n        modifier only_noel { if (msg.sender == noel) _ }\r\n        modifier msg_value_not(uint _amount) {\r\n        if (msg.value != _amount) _\r\n    }\r\n\r\n        function withdraw(uint _amount) only_noel {\r\n        if (!noel.send(_amount)) throw;\r\n    }\r\n\r\n        function kill() only_noel {\r\n        suicide(noel);\r\n    }\r\n\r\n        function () msg_value_not(10000000000000000000) {\r\n        if (!chal.call(\"withdrawEtherOrThrow\", 10000000000000000000))\r\n            throw;\r\n    }\r\n}",
        "label": false,
        "name": "0x6a3120d8a66fe96eb260cce4b6da02e7835b8426.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nstring private VAR4;\nstring private VAR5;\nuint8 private VAR6;\nconstructor (string memory VAR7, string memory VAR8, uint256 VAR9, uint8 VAR10) public {\nVAR4 = VAR7;\nVAR5 = VAR8;\nVAR6 = VAR10;\nVAR3 = VAR9 * (10 ** uint256(VAR10));\nVAR1[msg.sender] = VAR3;\n}\nfunction FUN1(address VAR11, uint256 VAR12) public returns (bool) {\nFUN6(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN2(address VAR13, uint256 VAR12) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR2[msg.sender][VAR13] = VAR12;\nreturn true;\n}\nfunction FUN3(address VAR14, address VAR11, uint256 VAR12) public returns (bool) {\nVAR2[VAR14][msg.sender] = VAR2[VAR14][msg.sender].sub(VAR12);\nFUN6(VAR14, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR13, uint256 VAR15) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR2[msg.sender][VAR13] = VAR2[msg.sender][VAR13].add(VAR15);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR16) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR2[msg.sender][VAR13] = VAR2[msg.sender][VAR13].sub(VAR16);\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR11, uint256 VAR12) internal {\nrequire(VAR11 != address(0));\nVAR1[VAR14] = VAR1[VAR14].sub(VAR12);\nVAR1[VAR11] = VAR1[VAR11].add(VAR12);\n}\n}",
        "label": false,
        "name": "0x33931870dfbdc15ec7e03c7d7a9cac657c309d12.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ninterface CON3 {\n}\ncontract CON4 is CON1{\nCON2 public VAR3;\nCON3 public VAR4;\naddress public VAR5;\nconstructor(CON2 VAR6,CON3 VAR7) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR1;\n}\nmodifier FUN3 {\nrequire(!VAR4.addressBelongsToAccount(msg.sender));\n_;\n}\nmodifier FUN4 {\nrequire(VAR4.addressBelongsToAccount(msg.sender));\n_;\n}\nmodifier FUN5(address VAR8) {\nrequire(VAR8 != 0);\n_;\n}\nmodifier FUN6 {\nrequire(msg.sender == VAR5);\n_;\n}\nmapping (bytes32 => bool) public VAR9;\nmapping(address => bool) public VAR10;\nfunction FUN7(CON2 VAR11) public FUN5(VAR11) FUN1 {\naddress VAR12 = VAR3;\nVAR3 = VAR11;\n}\nfunction FUN8(address VAR13) public FUN1 FUN5(VAR13) {\naddress VAR14 = VAR5;\nVAR5 = VAR13;\n}\nfunction FUN9(CON3 VAR15) public FUN5(VAR15) FUN1 {\naddress VAR16 = VAR4;\nVAR4 = VAR15;\n}\nfunction FUN10(bytes VAR17) public FUN4 {\naddress VAR18 = VAR3.recoverSigner(keccak256(abi.encodePacked(msg.sender)), VAR17);\nrequire(!VAR10[VAR18]);\nVAR10[VAR18] = true;\n}\nfunction FUN11(bytes VAR17) public FUN3 {\naddress VAR18 = VAR3.recoverSigner(keccak256(abi.encodePacked(msg.sender)), VAR17);\nrequire(VAR10[VAR18]);\nVAR10[VAR18] = false;\nFUN13(msg.sender);\n}\nfunction FUN12(address VAR19) public FUN6 {\nFUN13(VAR19);\n}\nfunction FUN13(address VAR19) internal FUN5(VAR19) {\nVAR4.createNewAccount(VAR19);\nuint256 VAR20 = VAR4.accountIdForAddress(VAR19);\n}\nfunction FUN14(address VAR21,bytes VAR22,bytes VAR23,address VAR24,bytes32 VAR25) public FUN6 {\nFUN16(VAR21, VAR22, VAR23, VAR24, VAR25);\n}\nfunction FUN15(address VAR21,bytes VAR22,bytes VAR23,bytes32 VAR25) public FUN4 {\nFUN16(VAR21, VAR22, VAR23, msg.sender, VAR25);\n}\nfunction FUN16(address VAR21,bytes VAR22,bytes VAR23,address VAR24,bytes32 VAR25) private FUN5(VAR21) {\nrequire(!VAR9[keccak256(abi.encodePacked(VAR22))], \"Signature not unique\");\nrequire(!VAR9[keccak256(abi.encodePacked(VAR23))], \"Signature not unique\");\nVAR9[keccak256(abi.encodePacked(VAR22))] = true;\nVAR9[keccak256(abi.encodePacked(VAR23))] = true;\nbytes32 VAR26 = VAR3.generateAddAddressSchemaHash(VAR21, VAR25);\nrequire(VAR24 == VAR3.recoverSigner(VAR26, VAR23));\nbytes32 VAR27 = VAR3.generateAddAddressSchemaHash(VAR24, VAR25);\nrequire(VAR21 == VAR3.recoverSigner(VAR27, VAR22));\nVAR4.FUN15(VAR21, VAR24);\nuint256 VAR20 = VAR4.accountIdForAddress(VAR21);\n}\nfunction FUN17(address VAR28) public FUN6 {\nuint256 VAR20 = VAR4.accountIdForAddress(VAR28);\nVAR4.removeAddressFromAccount(VAR28);\n}\n}",
        "label": false,
        "name": "0x017925fdb447544da8ed671b5305461cfc6c6e1d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor() internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint256;\nstring public constant VAR3 = \"Smart Tourism Matching Chain\";\nstring public constant VAR4 = \"STMC\";\nuint256 public constant VAR5 = 18;\nuint256 private constant VAR6 = 10 ** VAR5;\naddress private constant VAR7 = 0x81c0ebFcf9B75E93EaB96d735924b9aE43BCCb7f;\nmapping(address => uint256) private VAR8;\nmapping(address => mapping(address => uint256)) private VAR9;\nuint256 private VAR10;\nconstructor() public {\nFUN11(VAR7, 80 * (10 ** 8) * VAR6);\n}\nfunction FUN5(address VAR11, uint256 VAR12) public returns (bool) {\nFUN10(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR12) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR9[msg.sender][VAR13] = VAR12;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR11, uint256 VAR12) public returns (bool)\n{\nrequire(VAR12 <= VAR9[VAR14][msg.sender]);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR12);\nFUN10(VAR14, VAR11, VAR12);\nreturn true;\n}\nfunction FUN8(address VAR13, uint256 VAR15) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR9[msg.sender][VAR13] = (VAR9[msg.sender][VAR13].add(VAR15));\nreturn true;\n}\nfunction FUN9(address VAR13, uint256 VAR16) public returns (bool) {\nrequire(VAR13 != address(0));\nVAR9[msg.sender][VAR13] = (VAR9[msg.sender][VAR13].sub(VAR16));\nreturn true;\n}\nfunction FUN10(address VAR14, address VAR11, uint256 VAR12) internal {\nrequire(VAR12 <= VAR8[VAR14]);\nrequire(VAR11 != address(0));\nVAR8[VAR14] = VAR8[VAR14].sub(VAR12);\nVAR8[VAR11] = VAR8[VAR11].add(VAR12);\n}\nfunction FUN11(address VAR17, uint256 VAR12) internal {\nrequire(VAR17 != 0);\nVAR10 = VAR10.add(VAR12);\nVAR8[VAR17] = VAR8[VAR17].add(VAR12);\n}\n}",
        "label": false,
        "name": "0xd3fd0c2417e450f49200167874da542773bd116d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nstring public VAR6; uint8 public VAR7; string public VAR8;\nfunction CON4() public {\nVAR7 = 8;\nVAR2 = 1000000000 * 10 ** uint(VAR7);\nVAR1[msg.sender] = VAR2;\nVAR6 = \"FILO\";\nVAR8 = \"FILO\";\n}\nfunction FUN2(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR5[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR9][msg.sender] = VAR5[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR10, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR4;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x81ef75b414a70601317aba79a218715a1704a555.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing SafeERC20 for CON1;\nCON1 private VAR1;\naddress private VAR2;\nuint256 private VAR3;\nconstructor (CON1 VAR4, address VAR5, uint256 VAR6) public {\nrequire(VAR6 > block.timestamp);\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\nfunction FUN1() public {\nrequire(block.timestamp >= VAR3);\nuint256 VAR7 = VAR1.balanceOf(address(this));\nrequire(VAR7 > 0);\nVAR1.safeTransfer(VAR2, VAR7);\n}\n}",
        "label": false,
        "name": "0x65565ae3ef290215c87e956065a451e4b40e1823.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) public VAR3;\nmapping (address => address) public VAR4;\nfunction CON2() {\n}\nfunction FUN3(address VAR5) external FUN1 {\nrequire(VAR5 != 0x0 && !VAR3[VAR5]);\nVAR3[VAR5] = true;\n}\nfunction FUN4(address VAR5) external FUN1 {\nrequire(VAR5 != 0x0 && VAR3[VAR5]);\nVAR3[VAR5] = false;\n}\nfunction FUN5(address VAR5, address VAR6) external FUN1 {\nrequire(VAR5 != 0x0 && VAR6 != 0x0 && VAR4[VAR5] == 0x0 && VAR5 != VAR6);\nVAR4[VAR5] = VAR6;\n}\nfunction FUN6(address VAR5) constant external returns (bool VAR7) {\nreturn VAR3[VAR5];\n}\nfunction FUN7(address VAR5) constant external returns (address VAR7) {\nreturn VAR4[VAR5];\n}\n}",
        "label": false,
        "name": "0x618737029ae07215dfc2c0b4204b8f91e9909366.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nrequire((VAR4 == 0) || VAR5[msg.sender][VAR7]== 0);\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR11 = \"Moon\";\nstring public constant VAR12 = \"MOON\";\nuint8 public constant VAR13 = 18;\nuint256 public constant VAR14 = 1e27;\nconstructor() public {\nVAR2 = VAR14;\nVAR1[msg.sender] = VAR14;\n}\n}",
        "label": false,
        "name": "0x0597edbd535f2c76780818cd55cae87d7e035f5b.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) FUN3 {\nif (VAR8 != address(0)) {\nVAR7 = VAR8;\n}\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) returns (bool) {\nvar VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) returns (bool) {\nrequire((VAR4 == 0) || (VAR9[msg.sender][VAR12] == 0));\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\n}\ncontract CON6 is CON5, CON4\n{\nstring public VAR14 = \"Veritas Group Limited Equity Token\";\nstring public VAR15 = \"VGLE\";\nuint public VAR16 = 8;\nuint public VAR17 = 251;\nuint public VAR18 = 251;\nbool public VAR19 = true;\nbool public VAR20 = true;\nuint private VAR21 = 120*10**6;\nfunction () payable\n{\nFUN11(msg.sender);\n}\nfunction CON6()\n{\nVAR7 = msg.sender;\nVAR1 = VAR21;\nVAR2[VAR7] = VAR21;\n}\nfunction FUN4(address VAR8)\nFUN3\n{\naddress VAR22 = VAR7;\nVAR2[VAR8] = VAR2[VAR8].add(VAR2[VAR7]);\nVAR2[VAR7] = 0;\nsuper.FUN4(VAR8);\nOwnerTransfered(VAR22, VAR8);\n}\nfunction FUN9(uint VAR23)\nFUN3\n{\nrequire(VAR23 > 0);\nuint VAR24 = VAR17;\nVAR17 = VAR23;\nBuyRateChanged(VAR24, VAR23);\n}\nfunction FUN10(uint VAR23)\nFUN3\n{\nrequire(VAR23 > 0);\nuint VAR24 = VAR18;\nVAR18 = VAR23;\nSellRateChanged(VAR24, VAR23);\n}\nfunction FUN11(address VAR25)\nFUN19\npayable\n{\nrequire(VAR25 != 0x0);\nrequire(VAR25 != VAR7);\nrequire(msg.value > 0);\nuint VAR26 = msg.value;\nuint VAR27 = FUN15(VAR26);\nuint VAR28 = VAR27.mul(VAR17);\nVAR2[VAR25] = VAR2[VAR25].add(VAR28);\nVAR2[VAR7] = VAR2[VAR7].sub(VAR28);\nTokenPurchase(msg.sender, VAR25, VAR27, VAR28, VAR17);\n}\nfunction FUN12(uint VAR29)\nFUN20\n{\nrequire(msg.sender != VAR7);\nrequire(msg.sender != 0x0);\nrequire(VAR29 > 0);\nrequire(VAR2[msg.sender] >= VAR29);\nVAR2[VAR7] = VAR2[VAR7].add(VAR29);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR29);\nuint VAR30 = FUN16(VAR29.div(VAR18));\nif (!msg.sender.send(VAR30))\nrevert();\nelse\nTokenSold(msg.sender, VAR30, VAR18);\n}\nfunction FUN13()\nFUN3\n{\nVAR7.FUN1(this.VAR6);\n}\nfunction FUN14()\nFUN3\n{\nselfdestruct(VAR7);\n}\nfunction FUN15(uint VAR31) internal\nreturns (uint)\n{\nrequire(VAR31 > 0);\nreturn VAR31.div(1000000000000000000);\n}\nfunction FUN16(uint VAR31) internal\nreturns (uint)\n{\nrequire(VAR31 > 0);\nreturn VAR31.mul(1000000000000000000);\n}\nfunction FUN17()\nFUN3\n{ VAR19 = !VAR19; }\nfunction FUN18()\nFUN3\n{ VAR20 = !VAR20; }\nmodifier FUN19()\n{ require(VAR19); _; }\nmodifier FUN20()\n{ require(VAR20); _; }\n}",
        "label": false,
        "name": "0x2d358778da80081cd7f5865c5b7c49f45ebaa7cb.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nmodifier FUN5() {\nrequire(msg.sender == VAR3);\n_;\n}\nfunction FUN3(address VAR4) public FUN1 {\nVAR3 = VAR4;\n}\nfunction FUN6() public FUN5 {\nVAR1 = VAR3;\nVAR3 = address(0);\n}\n}\ncontract CON3 is CON2 {\naddress public VAR5;\nfunction FUN7(address VAR6) public FUN1 {\nVAR5 = VAR6;\n}\n}",
        "label": false,
        "name": "0xe8f99aea488ab288f4d787f7fd75b158a5685f8a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbool public VAR1;\naddress public VAR2;\naddress public VAR3;\nconstructor() public {\nFUN1();\n}\nfunction FUN1() public returns(bool) {\nif (VAR1) {\nreturn false;\n}\nVAR1 = true;\nVAR2 = msg.sender;\nreturn true;\n}\nmodifier FUN2() {\nif (VAR2 == msg.sender) {\n_;\n}\n}\nfunction FUN3(address VAR4) public FUN2() returns(bool) {\nVAR3 = VAR4;\nreturn true;\n}\nfunction FUN4() public returns(bool) {\nif (VAR3 != msg.sender) {\nreturn false;\n}\nVAR2 = VAR3;\ndelete VAR3;\nreturn true;\n}\nfunction FUN5(address VAR4) public FUN2() returns(bool) {\nVAR2 = VAR4;\nreturn true;\n}\n}\ncontract CON3 {\nfunction FUN6(bool VAR5, bytes32 VAR6) internal {\nif (VAR5) {\nreturn;\n}\nbool VAR7 = false;\nassembly {\nreturn(VAR7, 32)\n}\n}\n}\ncontract CON4 is CON3, CON2 {\nCON1 public VAR8;\nCON1 public VAR9;\nconstructor(CON1 VAR10, CON1 VAR11) public {\nrequire(address(VAR10) != 0x0);\nrequire(address(VAR11) != 0x0);\nVAR8 = VAR10;\nVAR9 = VAR11;\n}\nfunction FUN7(uint VAR12) public returns(bool) {\nFUN6(VAR8.transferFrom(msg.sender, address(this), VAR12), 'Old token transfer failed');\n_hardRequire(VAR9.transfer(msg.sender, VAR12), 'New token transfer failed');\nreturn true;\n}\nfunction FUN8() public returns(bool) {\nreturn FUN7(VAR8.balanceOf(msg.sender));\n}\nfunction FUN9() public FUN2() returns(bool) {\nmsg.sender.transfer(address(this).balance);\nreturn true;\n}\nfunction FUN10(CON1 VAR13) public FUN2() returns(bool) {\nreturn VAR13.transfer(msg.sender, VAR13.balanceOf(address(this)));\n}\n}",
        "label": false,
        "name": "0x6fc1a6f1acb9b143c79273878057ce5257c9e96c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) public VAR3;\nmodifier FUN3() {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4, bool VAR5) FUN1 public {\nVAR3[VAR4] = VAR5;\n}\n}\ncontract CON3 is CON1{\nstring public VAR6;\nfunction FUN5(string VAR7) FUN1 public {\nVAR6 = VAR7;\n}\n}\ncontract CON4 is CON3, CON2 {\nstring constant VAR8 = \"0.3\";\nbytes32 public VAR9;\nfunction CON4(string VAR10) public {\nrequire(bytes(VAR10).length > 0);\nVAR9 = keccak256(VAR10);\n}\nfunction FUN6(uint VAR11,address VAR12,uint32 VAR13,uint32 VAR14,bool VAR15,uint VAR16)\nexternal FUN3\n{\n}\nfunction FUN7(uint VAR11,address VAR12,uint32 VAR13,uint32 VAR14,uint VAR16,string VAR17)\nexternal FUN3\n{\n}\nfunction FUN8(uint VAR11,address VAR12,uint32 VAR13,uint32 VAR14,uint VAR16,string VAR18)\nexternal FUN3\n{\n}\n}",
        "label": false,
        "name": "0xcbdec1068921b3b216a0acb1097ba3023ea7c390.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 10000000000000000000000000000;\nVAR6 = 10000000000000000000000000000;\nVAR3 = \"Share Dollars\";\nVAR4 = \"SDS\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb3323480e26ddd6d5bd8a13b1b5f85e33dff3748.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor() internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ninterface CON3 {\n}\ncontract CON4 is CON3, CON1 {\nusing SafeMath for uint256;\nCON2 public VAR3;\nbool public VAR4 = false;\nmapping(uint128 => uint256) private VAR5;\nuint256 public VAR6 = 0;\nconstructor(address VAR7) public {\nVAR3 = CON2(VAR7);\n}\nfunction FUN5(uint128 VAR8, uint256 VAR9) public FUN1 {\nrequire(!VAR4, \"Pool is already completed\");\nassert(unallocated() >= VAR9);\nVAR6 = VAR6.add(VAR9);\nVAR5[VAR8] = VAR5[VAR8].add(VAR9);\n}\nfunction FUN6(uint128 VAR8, address VAR10, uint256 VAR9) public FUN1 {\nVAR5[VAR8] = VAR5[VAR8].sub(VAR9);\nuint256 VAR11 = address(this).VAR11;\nuint256 VAR12 = VAR11.mul(VAR9).div(VAR6);\nVAR6 = VAR6.sub(VAR9);\nVAR3.transfer(VAR10, VAR9);\nif (VAR12 > 0) {\nVAR10.transfer(VAR12);\n}\n}\nfunction FUN7() public FUN1 {\nVAR4 = true;\nVAR3.transfer(msg.sender, unallocated());\n}\nfunction () public payable {\nrequire(VAR4, \"Has VAR10 be VAR4 first\");\n}\n}",
        "label": false,
        "name": "0xcc9028ff5fafcd8de09f4b96b82fce98cf3a590e.sol"
    },
    {
        "source": "contract CON1 {\nstring public VAR1 = 'Token 0.1';\nstring public VAR2 = 'Forever Has Fallen';\nstring public VAR3 = 'FC';\nuint8 public VAR4 = 18;\n}\ncontract CON2 {\nstruct AddressTokenAllocation {\naddress VAR5;\nuint256 VAR6;\n}\nuint256 public VAR7 = 350e6;\nuint256 public VAR8 = 1525777200;\nuint256 public VAR9 = 1529406000;\nuint32 internal VAR10 = 1592564400;\nuint32 internal VAR11 = 1529406000;\nAddressTokenAllocation internal VAR12 = AddressTokenAllocation(0x265Fb686cdd2f9a853c519592078cC4d1718C15a, 350e6);\nAddressTokenAllocation internal VAR13 = AddressTokenAllocation(0x76d472C73681E3DF8a7fB3ca79E5f8915f9C5bA5, 450e6);\nAddressTokenAllocation internal VAR14 = AddressTokenAllocation(0x05d46150ceDF59ED60a86d5623baf522E0EB46a2, 170e6);\nAddressTokenAllocation internal VAR15 = AddressTokenAllocation(0x3d5fa25a3C0EB68690075eD810A10170e441413e, 48e5);\nAddressTokenAllocation internal VAR16 = AddressTokenAllocation(0xAc2099D2705434f75adA370420A8Dd397Bf7CCA1, 176e5);\nAddressTokenAllocation internal VAR17 = AddressTokenAllocation(0x438aB07D5EC30Dd9B0F370e0FE0455F93C95002e, 76e5);\naddress internal VAR18 = 0x8A40B0Cf87DaF12C689ADB5C74a1B2f23B3a33e1;\n}\ncontract CON3 {\naddress public VAR19;\nfunction CON3() public {\nVAR19 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR19);\n_;\n}\nfunction FUN2(address VAR20) FUN1 public {\nrequire(VAR20 != address(0));\nrequire(VAR20 != VAR19);\nVAR19 = VAR20;\n}\n}\ncontract CON4 is CON3, CON2 {\nCON1 private VAR21;\naddress private VAR22;\nuint private VAR23 = 10;\nuint public VAR24 = 0;\nuint public VAR25;\nbool public VAR26 = false;\nfunction CON4(address VAR27) public {\nVAR21 = CON1(VAR27);\nVAR23 = VAR23 ** VAR21.VAR4();\nVAR22 = CON2.VAR12.VAR5;\nVAR25 = CON2.VAR12.VAR6;\n}\nfunction FUN3() public constant returns (bool VAR28) {\nVAR28 = ((VAR8 <= now) && (now < VAR9) && (!VAR26));\nreturn VAR28;\n}\nfunction FUN4(address VAR29, uint VAR6) internal {\nrequire(FUN3());\nassert(msg.value > 0 finney);\nuint VAR30 = 10000;\nuint VAR31 = VAR6 * VAR30;\nuint VAR32 = VAR21.balanceOf(VAR22);\nif (VAR32 <= VAR31) {\nVAR31 = VAR32;\nVAR26 = true;\n}\nuint VAR33 = VAR31 / VAR30;\nVAR24 += VAR33;\nVAR21.transferFrom(VAR22, VAR29, VAR31);\nuint VAR34 = VAR6 - VAR33;\nif (VAR34 > 0) {\nif (VAR29.send(VAR34)) {\n}\nelse revert();\n}\n}\nfunction FUN5(uint VAR6) external FUN1 {\nrequire(this.balance >= VAR6);\nrequire(!FUN3());\nif (VAR19.send(VAR6)) {\n}\n}\nfunction () external payable {\nFUN4(msg.sender, msg.value);\n}\nfunction FUN7() external FUN1 {\nrequire(!FUN3());\nrequire(VAR8 < now);\nvar VAR35 = VAR21.balanceOf(VAR12.VAR5);\nVAR21.transferFrom(VAR12.VAR5, VAR18, VAR35);\nVAR9 = now;\n}\nfunction FUN8() external FUN1 {\nrequire(!FUN3());\nif (now < VAR8) {\nselfdestruct(VAR19);\n} else if (VAR21.balanceOf(VAR12.VAR5) == 0) {\nselfdestruct(VAR19);\n} else {\nrevert();\n}\n}\n}",
        "label": false,
        "name": "0xfb072e58741738fc26e86d2c49db3179ea8d5d55.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint public constant VAR1 = 99994138888;\nstring public constant VAR2 = \"EYO\";\nstring public constant VAR3 = \"ETHYOLO COIN\";\nuint8 public constant VAR4 = 18;\naddress public constant VAR5 = \"0xBAa21da3f332eBeAF33eB25412a8a82A160B4531\";\nuint256 public constant VAR6 = 74138888;\naddress public VAR7;\nmapping(address => uint256) VAR8;\nmapping(address => mapping(address => uint256)) VAR9;\nfunction CON2() {\nVAR7 = msg.sender;\n}\nfunction () payable {\nFUN2();\n}\nfunction FUN2() payable {\nrequire(msg.value > 0);\nuint256 VAR10= msg.value.mul(VAR6);\nVAR8[msg.sender] = VAR8[msg.sender].add(VAR10);\nVAR7.FUN5(msg.value);\n}\nfunction FUN3() constant returns (uint256 VAR1) {\nreturn VAR1;\n}\nfunction FUN4(address VAR11) constant returns (uint256 VAR12) {\nreturn VAR8[VAR11];\n}\nfunction FUN5(address VAR13, uint256 VAR14) returns (bool VAR15) {\nrequire(VAR8[msg.sender] >= VAR14&& VAR14 > 0);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN6(address VAR16, address VAR13, uint256 VAR14) returns (bool VAR15) {\nrequire(VAR9[VAR16][msg.sender] >= VAR14&& VAR8[VAR16] >= VAR14&& VAR14 > 0);\nVAR8[VAR16] = VAR8[VAR16].sub(VAR14);\nVAR8[VAR13] = VAR8[VAR13].add(VAR14);\nVAR9[VAR16][msg.sender] = VAR9 [VAR16][msg.sender].sub(VAR14);\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14) returns (bool VAR15) {\nVAR9[msg.sender][VAR17] = VAR14;\napproval(msg.sender, VAR17, VAR14);\nreturn true;\n}\nfunction FUN8(address VAR11, address VAR17) constant returns (uint256 VAR18) {\nreturn VAR9[VAR11][VAR17];\n}\n}",
        "label": false,
        "name": "0x577feb0b1805ec2dda594e1cf5e40d29893d49dc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public{\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nfunction CON2() public {\nif(RA(msg.sender) == false){\nVAR3[msg.sender] = VAR3[msg.sender].add(1);\n}\n}\nfunction FUN3(address VAR4) public FUN1{\nif(RA(VAR4) == true){\nVAR3[VAR4] = VAR3[VAR4].sub(0);\n}\n}\n}",
        "label": false,
        "name": "0x748d84c273334af1349ebee96bb48c2a17b3b416.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nCON3 internal VAR1;\nstring public VAR2 = \"Reserve Dollar\";\nstring public VAR3 = \"RSVD\";\nuint8 public constant VAR4 = 18;\nuint256 public VAR5;\nbool public VAR6;\naddress public VAR7;\naddress public VAR8;\naddress public VAR9;\naddress public VAR10;\naddress public VAR11;\nconstructor() public {\nVAR1 = new CON3(msg.sender);\nVAR7 = msg.sender;\nVAR9 = msg.sender;\n}\nmodifier FUN1(address VAR12) {\nrequire(msg.sender == VAR12, \"unauthorized: not VAR12 holder\");\n_;\n}\nmodifier FUN2(address VAR12) {\nrequire(msg.sender == VAR7 || msg.sender == VAR12, \"unauthorized: not VAR12 VAR27 and not owner\");\n_;\n}\nfunction FUN3(address VAR13) external FUN2(VAR8) {\nVAR8 = VAR13;\n}\nfunction FUN4(address VAR14) external FUN2(VAR9) {\nVAR9 = VAR14;\n}\nfunction FUN5(address VAR15) external FUN2(VAR10) {\nVAR10 = VAR15;\n}\nfunction FUN6(address VAR16) external FUN1(VAR7) {\nVAR11 = VAR16;\n}\nfunction FUN7() external FUN2(VAR11) {\nif (msg.sender != VAR7) {\n}\nVAR7 = msg.sender;\nVAR11 = address(0);\n}\nfunction FUN8() external FUN1(VAR7) {\nVAR7 = address(0);\n}\nfunction FUN9(address VAR17) external FUN1(VAR7) {\nVAR1.FUN29(VAR17);\n}\nfunction FUN10(string calldata VAR18, string calldata VAR19) external FUN1(VAR7) {\nVAR2 = VAR18;\nVAR3 = VAR19;\n}\nfunction FUN11() external FUN1(VAR9) {\nVAR6 = true;\n}\nfunction FUN12() external FUN1(VAR9) {\nVAR6 = false;\n}\nmodifier FUN13() {\nrequire(!VAR6, \"contract is paused\");\n_;\n}\nfunction FUN14(address VAR20) external FUN1(VAR10) {\nrequire(VAR1.VAR34(VAR20) == 0, \"account already frozen\");\nVAR1.FUN35(VAR20, now);\n}\nfunction FUN15(address VAR20) external FUN1(VAR10) {\nrequire(VAR1.VAR34(VAR20) > 0, \"account not frozen\");\nVAR1.FUN35(VAR20, 0);\n}\nmodifier FUN16(address VAR20) {\nrequire(VAR1.VAR34(VAR20) == 0, \"account frozen\");\n_;\n}\nfunction FUN17(address VAR20) external FUN1(VAR10) {\nrequire(VAR1.VAR34(VAR20) > 0, \"cannot FUN17 unfrozen account\");\nrequire(VAR1.VAR34(VAR20) + 4 weeks < now, \"cannot FUN17 frozen VAR20 before 4 weeks\");\nFUN26(VAR20, VAR1.VAR31(VAR20));\n}\nfunction FUN18(address VAR21, uint256 VAR22)\nexternal\nFUN13\nFUN16(msg.sender)\nFUN16(VAR21)\nreturns (bool)\n{\nFUN25(msg.sender, VAR21, VAR22);\nreturn true;\n}\nfunction FUN19(address VAR23, uint256 VAR22)\nexternal\nFUN13\nFUN16(msg.sender)\nFUN16(VAR23)\nreturns (bool)\n{\nFUN27(msg.sender, VAR23, VAR22);\nreturn true;\n}\nfunction FUN20(address VAR24, address VAR21, uint256 VAR22)\nexternal\nFUN13\nFUN16(msg.sender)\nFUN16(VAR24)\nFUN16(VAR21)\nreturns (bool)\n{\nFUN25(VAR24, VAR21, VAR22);\nFUN27(VAR24, msg.sender, VAR1.VAR33(VAR24, msg.sender).sub(VAR22));\nreturn true;\n}\nfunction FUN21(address VAR23, uint256 VAR25)\nexternal\nFUN13\nFUN16(msg.sender)\nFUN16(VAR23)\nreturns (bool)\n{\nFUN27(msg.sender, VAR23, VAR1.VAR33(msg.sender, VAR23).add(VAR25));\nreturn true;\n}\nfunction FUN22(address VAR23, uint256 VAR26)\nexternal\nFUN13\nFUN16(msg.sender)\nreturns (bool)\n{\nFUN27(msg.sender, VAR23, VAR1.VAR33(msg.sender, VAR23).sub(VAR26));\nreturn true;\n}\nfunction FUN23(address VAR20, uint256 VAR22)\nexternal\nFUN13\nFUN16(VAR20)\nFUN1(VAR8)\n{\nrequire(VAR20 != address(0), \"can't FUN23 VAR21 address zero\");\nVAR5 = VAR5.add(VAR22);\nVAR1.FUN31(VAR20, VAR22);\n}\nfunction FUN24(address VAR20, uint256 VAR22)\nexternal\nFUN13\nFUN16(VAR20)\nFUN1(VAR8)\n{\nFUN26(VAR20, VAR22);\nFUN27(VAR20, msg.sender, VAR1.VAR33(VAR20, msg.sender).sub(VAR22));\n}\nfunction FUN25(address VAR24, address VAR21, uint256 VAR22) internal {\nrequire(VAR21 != address(0), \"can't FUN18 VAR21 address zero\");\nVAR1.FUN32(VAR24, VAR22);\nVAR1.FUN31(VAR21, VAR22);\n}\nfunction FUN26(address VAR20, uint256 VAR22) internal {\nrequire(VAR20 != address(0), \"can't burn VAR24 address zero\");\nVAR5 = VAR5.sub(VAR22);\nVAR1.FUN32(VAR20, VAR22);\n}\nfunction FUN27(address VAR27, address VAR23, uint256 VAR22) internal {\nrequire(VAR23 != address(0), \"spender cannot be address zero\");\nrequire(VAR27 != address(0), \"holder cannot be address zero\");\nVAR1.FUN34(VAR27, VAR23, VAR22);\n}\n}\ncontract CON3 {\nusing SafeMath for uint256;\naddress public VAR7;\naddress public VAR28;\nconstructor(address VAR29) public {\nVAR7 = msg.sender;\nVAR28 = VAR29;\n}\nmodifier FUN28() {\nrequire(msg.sender == VAR7, \"onlyOwner\");\n_;\n}\nfunction FUN29(address VAR17) external {\nrequire(msg.sender == VAR7 || msg.sender == VAR28, \"not authorized\");\nVAR7 = VAR17;\n}\nfunction FUN30(address VAR30) external {\nrequire(msg.sender == VAR28, \"not authorized\");\nVAR28 = VAR30;\n}\nmapping(address => uint256) public VAR31;\nfunction FUN31(address VAR32, uint256 VAR22) external FUN28 {\nVAR31[VAR32] = VAR31[VAR32].add(VAR22);\n}\nfunction FUN32(address VAR32, uint256 VAR22) external FUN28 {\nVAR31[VAR32] = VAR31[VAR32].sub(VAR22);\n}\nfunction FUN33(address VAR32, uint256 VAR22) external FUN28 {\nVAR31[VAR32] = VAR22;\n}\nmapping(address => mapping(address => uint256)) public VAR33;\nfunction FUN34(address VAR24, address VAR21, uint256 VAR22) external FUN28 {\nVAR33[VAR24][VAR21] = VAR22;\n}\nmapping(address => uint256) public VAR34;\nfunction FUN35(address VAR35, uint256 VAR36) external FUN28 {\nVAR34[VAR35] = VAR36;\n}\n}",
        "label": false,
        "name": "0xffceeba0bdb21304a9f3d575dbcfebe583192c24.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction FUN1(address VAR2) FUN2 {\nif (VAR2 == 0x0) throw;\nVAR1 = VAR2;\n}\nmodifier FUN2 {\nif (msg.sender != VAR1) throw;\n_;\n}\n}\ncontract CON2 is CON1 {\nbool VAR3 = false;\nmodifier FUN3 {\nif (VAR3) throw;\nVAR3 = true;\n_;\nVAR3 = false;\n}\nfunction FUN4() FUN2 {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint256;\nCON4 public VAR4;\nuint256 public VAR5 = 0;\nstring public VAR6;\nuint8 public VAR7;\nstring public VAR8;\nstring public VAR9 = '0.2';\nbool public VAR10 = true;\nconstructor(address VAR11, string VAR12, uint8 VAR13,string VAR14, address VAR15) public {\nrequire(VAR11 != address(0), \"address cannot be null\");\nVAR1 = VAR11;\nVAR6 = VAR12;\nVAR7 = VAR13;\nVAR8 = VAR14;\nVAR4 = CON4(VAR15);\n}\nfunction FUN5(address VAR2) FUN2 public {\nrequire(VAR2 != address(0), \"address cannot be null\");\nVAR4 = CON4(VAR2);\n}\nfunction FUN6(address VAR16) FUN2 FUN3 public {\nrequire(VAR16 != address(0), \"address cannot be null\");\nuint256 VAR17 = VAR4.FUN20(VAR16);\nVAR5 = VAR5.add(VAR17);\nVAR4.FUN25(VAR16, 0);\n}\nfunction FUN7(address VAR18, uint256 VAR19) FUN2 public {\nrequire(VAR19 <= VAR5, \"amount greater than lockedSupply\");\nVAR5 = VAR5.sub(VAR19);\nuint256 VAR20 = VAR4.FUN20(VAR18);\nVAR20 = VAR20.add(VAR19);\nVAR4.FUN25(VAR18, VAR20);\n}\nfunction FUN8() FUN2 public {\nVAR10 = false;\n}\nfunction FUN9() FUN2 public {\nVAR10 = true;\n}\nfunction FUN10(uint256 VAR21) public {\nuint256 VAR22 = VAR4.FUN20(msg.sender);\nrequire(VAR21 <= VAR22, \"not enough balance\");\nVAR4.FUN25(msg.sender, VAR22.sub(VAR21));\n}\nfunction FUN11(address VAR23, uint256 VAR24) public returns(bool) {\nrequire(VAR10 || msg.sender == VAR1, \"transferring disabled\");\nrequire(VAR4.FUN16(msg.sender, VAR23, VAR24), \"transfer failed\");\nreturn true;\n}\nfunction FUN12(address VAR25, address VAR23, uint256 VAR24) public returns (bool) {\nrequire(VAR10 || msg.sender == VAR1, \"transferring disabled\");\nrequire(VAR4.FUN17(msg.sender, VAR25, VAR23, VAR24), \"transferFrom failed\");\nuint256 VAR26 = FUN22(VAR25, msg.sender);\nreturn true;\n}\nfunction FUN13(address VAR27, uint256 VAR24) public returns (bool) {\nrequire(VAR4.FUN21(msg.sender, VAR27, VAR24), \"approve failed\");\nreturn true;\n}\n}\ncontract CON4 is CON1 {\nmapping (address => uint) VAR28;\nmapping (address => uint) VAR29;\nmapping (address => bool) VAR30;\naddress[] public VAR31;\nmapping (address => mapping (address => uint256)) VAR26;\naddress VAR32;\nuint public VAR33 = 0;\nfunction CON4(address VAR11, uint VAR34, uint VAR35) {\nif (VAR11 == 0x0) throw;\nVAR1 = VAR11;\nVAR30[VAR11] = true;\nVAR31.push(VAR11);\nVAR33 = VAR34 *VAR35;\nVAR28[VAR11] = VAR33;\n}\nmodifier FUN14 {\nif (msg.sender != VAR32) throw;\n_;\n}\nmodifier FUN15 {\nif (msg.sender != VAR32 && msg.sender != VAR1) throw;\n_;\n}\nfunction FUN16(address VAR25, address VAR23, uint VAR19) FUN14 returns(bool) {\nif (VAR19 > VAR28[VAR25]) return false;\nif ((VAR28[VAR23] + VAR19) < VAR28[VAR23]) return false;\nif (VAR19 == 0) { return false; }\nVAR28[VAR25] -= VAR19;\nVAR28[VAR23] += VAR19;\nif (VAR30[VAR23] == false) {\nVAR31.push(VAR23);\nVAR30[VAR23] = true;\n}\nreturn true;\n}\nfunction FUN17(address VAR36, address VAR25, address VAR23, uint VAR19) FUN14 returns(bool) {\nif (VAR26[VAR25][VAR36] <= VAR19) return false;\nif (VAR19 > FUN20(VAR25)) return false;\nif (VAR19 == 0) return false;\nif ((VAR28[VAR23] + VAR19) < VAR19) return false;\nVAR28[VAR25] -= VAR19;\nVAR28[VAR23] += VAR19;\nVAR26[VAR25][VAR36] -= VAR19;\nif (VAR30[VAR23] == false) {\nVAR31.push(VAR23);\nVAR30[VAR23] = true;\n}\nreturn true;\n}\nfunction FUN18(address VAR2, int VAR19) FUN14 {\nint VAR37 = int(VAR29[VAR2]) + VAR19;\nVAR29[VAR2] = uint(VAR37);\n}\nfunction FUN19(uint8 VAR38, uint8 VAR39) FUN15 returns(uint8) {\nuint8 VAR40;\nfor (uint VAR41 = 0; VAR41 < VAR39 && VAR41 + VAR38 < VAR31.length; VAR41++) {\nif (VAR29[VAR31[VAR41+VAR38]] != 0) {\ndelete VAR29[VAR31[VAR41+VAR38]];\nVAR40++;\n}\n}\nreturn VAR40;\n}\nfunction FUN20(address VAR2) constant returns (uint) {\nif (VAR29[VAR2] >= VAR28[VAR2]) { return 0;}\nreturn VAR28[VAR2] - VAR29[VAR2];\n}\nfunction FUN21(address VAR25, address VAR27, uint256 VAR24) FUN14 returns (bool) {\nVAR26[VAR25][VAR27] = VAR24;\nreturn true;\n}\nfunction FUN22(address VAR11, address VAR27) constant returns (uint256 VAR42) {\nreturn VAR26[VAR11][VAR27];\n}\nfunction FUN23(address VAR43) FUN2 {\nVAR32 = CON3(VAR43);\n}\nfunction FUN24(uint VAR19) FUN14 {\nif (VAR19 > VAR33) throw;\nVAR33 -= VAR19;\n}\nfunction FUN25(address VAR2, uint VAR19) FUN15 {\nif (VAR28[VAR2] == VAR19) { return; }\nif (VAR28[VAR2] < VAR19) {\nuint VAR44 = VAR19 - VAR28[VAR2];\nVAR33 += VAR44;\n} else {\nuint VAR45 = VAR28[VAR2] - VAR19;\nVAR33 -= VAR45;\n}\nVAR28[VAR2] = VAR19;\n}\n}",
        "label": false,
        "name": "0x305de070488c8469dfac957226c9c900c4bfba22.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nbool public VAR5;\nmodifier FUN3() {\nrequire(VAR5);\n_;\n}\nfunction FUN4() public FUN1 {\nVAR5 = true;\n}\nfunction FUN5(address VAR6, uint256 VAR7) FUN3() public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN6(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n}\nelse {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR14 = false;\nmapping(address => bool) public VAR15;\nmodifier FUN10() {\nrequire(!VAR14);\n_;\n}\nmodifier FUN11() {\nrequire(VAR15[msg.sender] || msg.sender == VAR1);\n_;\n}\nfunction FUN12(address VAR16) public FUN1 {\nVAR15[VAR16] = true;\n}\nfunction FUN13(address VAR16) public FUN1 {\ndelete VAR15[VAR16];\n}\nfunction FUN14(address VAR6, uint256 VAR17) FUN11 FUN10 public returns (bool) {\nrequire(VAR6 != address(0));\nVAR3 = VAR3.add(VAR17);\nVAR4[VAR6] = VAR4[VAR6].add(VAR17);\nreturn true;\n}\nfunction FUN15() FUN1 FUN10 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR18;\nfunction CON7(uint256 VAR19) public {\nrequire(VAR19 > 0);\nVAR18 = VAR19;\n}\nfunction FUN14(address VAR6, uint256 VAR17) FUN11 FUN10 public returns (bool) {\nrequire(VAR3.add(VAR17) <= VAR18);\nreturn super.FUN14(VAR6, VAR17);\n}\n}\ncontract CON8 is CON7 {\nstring public VAR20;\nstring public VAR21;\nuint256 public VAR22;\nfunction CON8(string VAR23, string VAR24, uint256 VAR25, uint256 VAR26) public CON7(VAR26 * 10 ** VAR25) {\nVAR20 = VAR23;\nVAR21 = VAR24;\nVAR22 = VAR25;\n}\n}\ncontract CON9 is CON8 {\nfunction CON9() public CON8(\"TORQ Coin\", \"TORQ\", 18, 30000000) {\n}\n}",
        "label": false,
        "name": "0x1c65c261cb89178b02cf2aee20058b992787d770.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public VAR11 = \"Bither Platform Token\";\nstring public VAR12 = \"BTR\";\nuint256 public VAR13 = 18;\nconstructor() public {\nFUN7(msg.sender, 47000000 * (10 ** VAR13));\n}\n}",
        "label": false,
        "name": "0xcbf15fb8246f679f9df0135881cb29a3746f734b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nCON1 public VAR1;\nfunction CON2(CON1 VAR2) public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\nfunction FUN1(address VAR3) public {\nVAR1.FUN1(VAR3);\n}\n}",
        "label": false,
        "name": "0xeca04bb23612857650d727b8ed008f80952654ee.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON2;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\nbool public VAR8;\nmapping (address => uint256) public VAR9;\nmapping (address => bool) public VAR10;\nfunction CON4(address VAR11, uint256 VAR12, uint256 VAR13, uint256 VAR14, bool VAR15) public {\nrequire(VAR11 != address(0));\nrequire(VAR13 <= VAR14);\nVAR4 = VAR11;\nVAR8 = VAR15;\nVAR7 = VAR14;\nVAR5 = VAR12.add(VAR13);\nVAR6 = VAR12;\n}\nfunction FUN3(CON2 VAR16) public {\nuint256 VAR17 = releasableAmount(VAR16);\nrequire(VAR17 > 0);\nVAR9[VAR16] = VAR9[VAR16].add(VAR17);\nVAR16.safeTransfer(VAR4, VAR17);\n}\nfunction FUN4(CON2 VAR16) public FUN1 {\nrequire(VAR8);\nrequire(!VAR10[VAR16]);\nuint256 VAR18 = VAR16.balanceOf(this);\nuint256 VAR17 = releasableAmount(VAR16);\nuint256 VAR19 = VAR18.sub(VAR17);\nVAR10[VAR16] = true;\nVAR16.safeTransfer(VAR1, VAR19);\n}\n}",
        "label": false,
        "name": "0x7ac337cd5ef210cf9e308dfe9be1a8b5d13da9c3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1 = 'PouyanToken';\nstring public VAR2 = 'PURC';\nuint8 public VAR3 = 0;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = 4500000000;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x21a1ea599eba5f383a978d7ad7b21acef0f76ece.sol"
    },
    {
        "source": "contract CON1 {\nstruct Race {\nuint VAR1;\nuint VAR2;\nuint VAR3;\nBoat[10] VAR4;\nuint VAR5;\n}\nstruct Boat {\naddress VAR6;\nuint8 VAR7;\nuint8 VAR8;\nbool VAR9;\n}\nmapping(address => uint) VAR10;\nmapping(address => bytes32) VAR11;\nmapping(uint => Race) VAR12;\naddress VAR13;\nfunction FUN1(address VAR14) external{\nrequire(msg.sender == VAR13,\"impostor\");\nVAR13 = VAR14;\n}\nuint VAR15;\nuint constant VAR16 = 50;\nuint constant VAR17 = 10;\nuint[3] VAR18 = [\n20 finney,\n70 finney,\n120 finney\n];\nuint[3] VAR19 = [\n100, 115, 130 ];\nuint constant VAR20 = 2;\nuint constant VAR21 = 3;\nuint constant VAR22 = 3;\nconstructor() public{\nVAR13 = msg.sender;\n}\nfunction FUN2() public {\nrequire(VAR12[VAR15].VAR2 != 0,\"unstarted\");\nrequire(block.number > VAR12[VAR15].VAR2 + 255,\"not_void\");\nrequire(VAR12[VAR15].VAR3 == 0,\"finished\");\nFUN3();\nuint VAR23 = VAR10[msg.sender];\nVAR10[msg.sender] = 0;\nmsg.sender.transfer( VAR23 );\n}\nfunction FUN3() internal {\nVAR12[VAR15].VAR3 = VAR12[VAR15].VAR2;\nVAR10[ VAR13 ] += VAR12[VAR15].VAR1 * 99/100;\nVAR10[ msg.sender ] += VAR12[VAR15].VAR1 /100;\n}\nfunction FUN4(uint VAR3) external {\nrequire(VAR12[VAR15].VAR2 != 0,\"unstarted\");\nrequire(VAR3 < block.number, \"undetermined\");\nrequire(block.number <= VAR12[VAR15].VAR2 + 255,\"void\");\nif( VAR12[VAR15].VAR3 != 0 ){\nuint VAR23 = VAR10[msg.sender];\nrequire(VAR23 > 0, \"finished\");\nVAR10[msg.sender] = 0;\nmsg.sender.transfer( VAR23 );\nreturn;\n}\nFUN5(VAR3);\nuint VAR23 = VAR10[msg.sender];\nVAR10[msg.sender] = 0;\nmsg.sender.transfer( VAR23 );\n}\nfunction FUN5(uint VAR3) internal {\nuint VAR24 = 11;\nuint VAR25;\nuint[10] memory VAR26;\nuint VAR27;\nbool VAR28;\nfor(uint VAR29 = VAR12[VAR15].VAR2; VAR29 <= VAR3; VAR29++){\nuint VAR30 = uint(blockhash(VAR29));\nuint VAR31 = VAR30%3;\nfor(uint VAR32 = 0; VAR32 < VAR12[VAR15].VAR5; VAR32++){\nif(VAR24 != VAR32){\nVAR26[VAR32] += increment_boat(VAR30,VAR31,VAR32,VAR12[VAR15].VAR4[VAR32].VAR7,VAR12[VAR15].VAR4[VAR32].VAR8);\n}\nif(VAR26[VAR32] >= VAR26[VAR25]){\nVAR25 = VAR32;\n}\nif(VAR29 == VAR3 - 1){\nrequire(VAR26[VAR32] < VAR16,\"passed\");\n}else if(VAR29 == VAR3){\nVAR28 = VAR28 || VAR26[VAR32] >= VAR16;\nif(VAR26[VAR32] >= VAR16){\nVAR27++;\n}\n}\n}\nif(VAR26[VAR25] < VAR16 && VAR26[VAR25] > VAR16/2 && !VAR12[VAR15].VAR4[VAR25].VAR9 && VAR24 == 11 && uint(VAR30)%VAR22 == 0){\nVAR24 = VAR25;\n}\n}\nrequire(VAR28,\"unfinished\");\nVAR12[VAR15].VAR3 = VAR3;\nuint VAR33 = 0;\nuint VAR34 = VAR12[VAR15].VAR1 * 95 / VAR27 /100;\nfor( uint VAR32 = 0; VAR32 < VAR12[VAR15].VAR5; VAR32++){\nif(VAR26[VAR32] >= VAR16){\nVAR10[\nVAR12[VAR15].VAR4[VAR32].VAR6\n] += VAR34;\nVAR33 += VAR34;\n}\n}\nVAR10[ msg.sender ] += VAR12[VAR15].VAR1 /100;\nVAR33 += VAR12[VAR15].VAR1 /100;\nVAR10[ VAR13 ] += VAR12[VAR15].VAR1 - VAR33;\n}\nfunction FUN6(uint8 VAR7, uint8 VAR8, bool VAR9) public payable{\nrequire(VAR12[VAR15].VAR3 != 0 || VAR15 == 0,\"unfinished\");\nrequire(VAR7 < 3,\"class\");\nuint VAR35 = calculate_fee(VAR7,VAR9);\nuint VAR36 = calculate_fee(VAR7,false);\nrequire( msg.value == VAR35, \"payment\");\nrequire(VAR8 < 3,\"variant\");\nVAR15++;\nVAR12[VAR15].VAR5 = 2;\nVAR12[VAR15].VAR4[0] = Boat(msg.sender,VAR7,VAR8,VAR9);\nVAR12[VAR15].VAR1 += VAR36;\nif(VAR35 > VAR36){\nVAR10[VAR13] += VAR35 - VAR36;\n}\n}\nfunction FUN7(uint8 VAR7, uint8 VAR8, bool VAR9) public payable{\nrequire(VAR7 < 3,\"class\");\nuint VAR35 = calculate_fee(VAR7,VAR9);\nuint VAR36 = calculate_fee(VAR7,false);\nrequire( msg.value == VAR35, \"payment\");\nrequire(VAR8 < 3,\"variant\");\nrequire(!check_race_started(),\"started\");\nrequire(!check_race_finished(),\"finished\");\nrequire(VAR12[VAR15].VAR5 < 10,\"full\");\nrequire(VAR15 > 0,\"undeclared\");\nif(VAR12[VAR15].VAR2 == 0){\nVAR12[VAR15].VAR2 = block.number + VAR21;\nVAR12[VAR15].VAR4[1] = Boat(msg.sender,VAR7,VAR8,VAR9);\n}else{\nVAR12[VAR15].VAR4[\nVAR12[VAR15].VAR5\n] = Boat(msg.sender,VAR7,VAR8,VAR9);\nVAR12[VAR15].VAR5++;\n}\nVAR12[VAR15].VAR1 += VAR36;\nif(VAR35 > VAR36){\nVAR10[VAR13] += VAR35 - VAR36;\n}\n}\nfunction FUN8(uint VAR37) internal {\nif(VAR15 == 0){\n}else if(VAR12[VAR15].VAR2 != 0&& VAR12[VAR15].VAR2 == VAR12[VAR15].VAR3){\n}else\nif(VAR37 != 0&& VAR12[VAR15].VAR3 == 0&& VAR12[VAR15].VAR2 != 0&& VAR12[VAR15].VAR2 < block.number&& VAR37 < block.number){\nFUN5(VAR37);\n}else\nif(VAR37 == 0&& VAR12[VAR15].VAR3 == 0&& VAR12[VAR15].VAR2 != 0&& VAR12[VAR15].VAR2 + 255 < block.number){\nFUN3();\n}\n}\nfunction FUN9(uint VAR37, uint8 VAR7, uint8 VAR8, bool VAR9) external payable{\nFUN8(VAR37);\nif(VAR12[VAR15].VAR3 != 0 || VAR15 == 0){\nFUN6(VAR7,VAR8,VAR9);\n}else{\nFUN7(VAR7,VAR8,VAR9);\n}\n}\nfunction FUN10(uint VAR37) external {\nFUN8(VAR37);\nFUN12();\n}\nfunction FUN11(bytes32 VAR38) external {\nVAR11[msg.sender] = VAR38;\n}\nfunction FUN12() public {\nuint VAR23 = VAR10[msg.sender];\nrequire(VAR23 > 0,\"broke\");\nVAR10[msg.sender] = 0;\nmsg.sender.transfer( VAR23 );\n}\n}",
        "label": false,
        "name": "0x5b7939811749068f6c3d7e689e396c66aad9854a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint public constant VAR1 = 1512399600; uint public constant VAR2 = 1514214000; address public constant VAR3 = 0xbb12800E7446A51395B2d853D6Ce7F22210Bb5E5;\naddress public constant VAR4 = 0x83984d6142934bb535793A82ADB0a46EF0F66B6d; address public constant VAR5 = 0x1Ff21eCa1c3ba96ed53783aB9C92FfbF77862584;\nuint public constant VAR6 = 470;\nuint public constant VAR7 = 0.04 ether / VAR6; uint public constant VAR8 = 10000; uint public constant VAR9 = 20; uint public constant VAR10 = 1000 ether;\nuint public constant VAR11 = 6700 ether;\nuint public constant VAR12 = 10 ether;\nuint public constant VAR13 = 1100 ether;\nuint public VAR14;\nmapping(address => uint) public VAR15;\nmapping(address => bool) public VAR16;\nfunction FUN1() payable returns(bool) {\nreturn FUN2(msg.sender);\n}\nfunction FUN2(address VAR17) payable returns(bool) {\nrequire(now >= VAR1);\nrequire(now < VAR2);\nrequire((VAR15[VAR17] + msg.value) >= VAR12);\nrequire((VAR15[VAR17] + msg.value) <= VAR13);\nrequire((VAR14 + msg.value) <= VAR11);\nrequire(VAR16[VAR17]);\nuint VAR18 = (msg.value * VAR8) / VAR7;\nrequire(VAR18 > 0);\nuint VAR19 = (VAR18 * VAR9) / 100;\nuint VAR20 = VAR18 + VAR19;\nrequire(CON1(VAR4).transferFrom(VAR3, VAR17, VAR20));\nVAR14 += msg.value;\nVAR15[VAR17] += msg.value;\nVAR3.transfer(msg.value);\nreturn true;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR5 || msg.sender == VAR3);\n_;\n}\nfunction FUN4(address VAR17) FUN3() returns(bool) {\nif (VAR16[VAR17]) {\nreturn true;\n}\nVAR16[VAR17] = true;\nreturn true;\n}\nfunction FUN5(address VAR17) FUN3() returns(bool) {\nif (!VAR16[VAR17]) {\nreturn true;\n}\nVAR16[VAR17] = false;\nreturn true;\n}\nfunction FUN6() constant returns(bool) {\nreturn VAR14 >= VAR10;\n}\nfunction () payable {\nFUN1();\n}\n}",
        "label": false,
        "name": "0x1194f98ccfb7428e77f081da20fd07255dc5dae9.sol"
    },
    {
        "source": "contract CON1\n{\n}\ncontract CON2 is CON1\n{\nusing SafeMath for uint256;\nuint256 constant public VAR1 = 10 ** 18;\nstring public constant VAR2 = \"OppOpenWiFi Token\";\nstring public constant VAR3 = \"OPP\";\nuint256 public VAR4 = 4165000000 * VAR1;\naddress public VAR5;\nuint8 public constant VAR6 = 18;\nmapping(address => mapping(address => uint256)) VAR7;\nmapping(address => uint256) VAR8;\nmodifier FUN1()\n{\nrequire(msg.sender == VAR5);\n_;\n}\nconstructor() public\n{\nVAR5 = msg.sender;\nVAR8[address(this)] = VAR4;\n}\nfunction FUN2(address VAR9, address VAR10, uint256 VAR11) public returns (bool)\n{\nif (VAR11 == 0)\n{\nreturn;\n}\nrequire(VAR10 != address(0x0));\nrequire(VAR8[VAR9] >= VAR11 && VAR7[VAR9][msg.sender] >= VAR11 && VAR11 >= 0);\nVAR8[VAR9] = VAR8[VAR9].sub(VAR11);\nVAR7[VAR9][msg.sender] = VAR7[VAR9][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN3(address VAR12, uint256 VAR13)public returns(bool)\n{\nrequire(VAR12 != address(0x0));\nVAR7[msg.sender][VAR12] = VAR13;\nreturn true;\n}\nfunction FUN4(address VAR14, uint256 VAR13)public returns(bool)\n{\nif (VAR13 == 0)\n{\nreturn;\n}\nrequire(VAR14 != address(0x0));\nrequire(VAR8[msg.sender] >= VAR13);\nVAR8[msg.sender] = (VAR8[msg.sender]).sub(VAR13);\nVAR8[VAR14] = (VAR8[VAR14]).add(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR14, uint256 VAR13) external FUN1 returns(bool)\n{\nrequire( VAR14 != address(0x0));\nrequire( VAR8[address(this)] >= VAR13.mul(VAR1) && VAR13.mul(VAR1) > 0);\nVAR8[address(this)] = ( VAR8[address(this)]).sub(VAR13.mul(VAR1));\nVAR8[VAR14] = (VAR8[VAR14]).add(VAR13.mul(VAR1));\nreturn true;\n}\nfunction FUN6(address VAR15)public FUN1\n{\nrequire( VAR15 != address(0x0));\nVAR8[VAR15] = (VAR8[VAR15]).add(VAR8[VAR5]);\nVAR8[VAR5] = 0;\nVAR5 = VAR15;\n}\nfunction FUN7(address VAR12, uint256 VAR16) public returns (bool VAR17)\n{\nVAR7[msg.sender][VAR12] = VAR7[msg.sender][VAR12].add(VAR16);\nreturn true;\n}\nfunction FUN8(address VAR12, uint256 VAR18) public returns (bool VAR17)\n{\nuint256 VAR19 = VAR7[msg.sender][VAR12];\nif (VAR18 > VAR19)\n{\nVAR7[msg.sender][VAR12] = 0;\n}\nelse\n{\nVAR7[msg.sender][VAR12] = VAR19.sub(VAR18);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9a8c7f9080d6e2b5438b07ff056e03d39fd16e52.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x91b455ce6c6437873ea59b39423f1c7357090a23.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 6;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe93cbcd749a0a6bdba4177bd78842bd5f1a0bd10.sol"
    },
    {
        "source": "contract CON1 {\nbool private VAR1;\nbool private VAR2;\nmodifier FUN1() {\nrequire(VAR2 || isConstructor() || !VAR1, \"Contract instance has already been initialized\");\nbool VAR3 = !VAR2;\nif (VAR3) {\nVAR2 = true;\nVAR1 = true;\n}\n_;\nif (VAR3) {\nVAR2 = false;\n}\n}\nuint256[50] private VAR4;\n}\ncontract CON2 {\naddress private VAR5;\nconstructor () internal {\nVAR5 = msg.sender;\n}\nmodifier FUN2() {\nrequire(isOwner());\n_;\n}\nfunction FUN3() public FUN2 {\nVAR5 = address(0);\n}\nfunction FUN4(address VAR6) public FUN2 {\nFUN5(VAR6);\n}\nfunction FUN5(address VAR6) internal {\nrequire(VAR6 != address(0));\nVAR5 = VAR6;\n}\n}\ncontract CON3 {\n}\ncontract CON4 {\nCON3 public VAR7;\nuint256 public VAR8;\nstruct Data {\nstring VAR9;\nstring VAR10;\n}\nmapping (string => address) VAR11;\nmapping (address => Data) public VAR12;\nmapping (address => bool) public VAR13;\n}\ncontract CON5 is CON2, CON1, CON4 {\nfunction FUN6(CON3 VAR14,address VAR5)\npublic FUN1\n{\nVAR7 = VAR14;\nVAR8 = 100000000000000000000;\nVAR13[VAR5] = true;\nFUN4(VAR5);\n}\nmodifier FUN7() {\nrequire(VAR13[msg.sender] == true,\"The sender is not VAR13 to register a username\");\n_;\n}\nfunction FUN8(address VAR15, bool VAR16) external FUN2 {\nrequire(VAR15 != msg.sender, \"You can not manage your role\");\nVAR13[VAR15] = VAR16;\n}\nfunction FUN9(address VAR17,string memory VAR18,string memory VAR19)\ninternal\n{\n_requireBalance(VAR17);\n_requireUsernameValid(VAR18);\nrequire(isUsernameAvailable(VAR18), \"The VAR9 was already taken\");\nVAR11[VAR18] = VAR17;\nData storage VAR20 = VAR12[VAR17];\ndelete VAR11[VAR20.VAR9];\nVAR20.VAR9 = VAR18;\nbytes memory VAR10 = bytes(VAR19);\nif (VAR10.length > 0) {\nVAR20.VAR10 = VAR19;\n}\n}\nfunction FUN10(address VAR17,string calldata VAR18,string calldata VAR19)\nexternal\nFUN7\n{\nFUN9(VAR17, VAR18, VAR19);\n}\nfunction FUN11(string calldata VAR19) external {\nrequire(userExists(msg.sender), \"The VAR12 does not exist\");\nVAR12[msg.sender].VAR10 = VAR19;\n}\n}",
        "label": false,
        "name": "0x29ef355ccd3b273f114189468014998cf9275b46.sol"
    },
    {
        "source": "{\"Controlled.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract Controlled {\\n\\n  event ControllerChangedEvent(address newController);\\n\\n  /// @notice The address of the controller is the only address that can call\\n  ///  a function with this modifier\\n  modifier onlyController { require(msg.sender == controller); _; }\\n\\n  address public controller;\\n\\n  function Controlled() public { controller = msg.sender;}\\n\\n  /// @notice Changes the controller of the contract\\n  /// @param _newController The new controller of the contract\\n  function changeController(address _newController) public onlyController {\\n    controller = _newController;\\n    emit ControllerChangedEvent(_newController);\\n  }\\n}\\n\"},\"DankFaucet.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./oraclizeAPI.sol\\\";\\nimport \\\"./DankToken.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n\\ncontract DankFaucet is usingOraclize, DSAuth {\\n\\n  DankToken public constant dankToken = DankToken(0x0cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe);\\n\\n  // A request to allocate dank to a phone number.\\n  struct PhoneNumberRequest {\\n    address sender;\\n    bytes32 hashedPhoneNumber;\\n  }\\n\\n  // Tracks the DANK allocated to a hashed phone number.\\n  mapping(bytes32 =\\u003e uint) public allocatedDank;\\n\\n  // A mapping between the Oraclize query id and a combination of the\\n  // hashed phone number and the sender so the callback from Oraclize\\n  // can track who\\u0027s been allocated what DANK.\\n  mapping(bytes32 =\\u003e PhoneNumberRequest) public phoneNumberRequests;\\n\\n  // The number of DANK tokens a person gets when they initially sing up.\\n  uint public allotment;\\n\\n  // An event for letting the caller know that they didn\\u0027t supply enough\\n  // ETH to complete the transaction.\\n  event NotEnoughETH(string description, uint ethRequired);\\n\\n  // An event for communicating success/failure of the steps of the\\n  // verification process, including calls to the Oraclize service.\\n  event DankEvent(bytes32 hashedPhoneNumber, bool successful, string description);\\n\\n  // An event for communicating the id from Oraclize and a message.\\n  event OraclizeCall(bytes32 id, string msg);\\n\\n  // An event fired when a person\\u0027s allotment is reset by the faucet.\\n  event DankReset(bytes32 hashedPhoneNumber);\\n\\n  \\n  constructor(uint initialDank) public {\\n    allotment = initialDank;\\n\\n    // Comment out this line when deploying to production\\n    // See: https://github.com/oraclize/ethereum-bridge\\n    //OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\\n  }\\n\\n  \\n  function verifyAndAcquireDank(bytes32 hashedPhoneNumber, string oraclizeQuery) public {\\n    if (oraclize_getPrice(\\\"URL\\\") \\u003e address(this).balance) {\\n      emit NotEnoughETH(\\\"Oraclize query for phone number verification was NOT sent, add more ETH.\\\", oraclize_getPrice(\\\"URL\\\"));\\n    } else {\\n      bytes32 queryId = oraclize_query(\\\"nested\\\", oraclizeQuery);\\n      phoneNumberRequests[queryId] = PhoneNumberRequest(msg.sender, hashedPhoneNumber);\\n    }\\n  }\\n\\n  \\n  function __callback(bytes32 queryId, string result) public {\\n    emit OraclizeCall(queryId, result);\\n\\n    if (msg.sender != oraclize_cbAddress()) {\\n        revert(\\\"The sender\\u0027s address does not match Oraclize\\u0027s address.\\\");\\n    }\\n    else {\\n        PhoneNumberRequest storage phoneNumberRequest = phoneNumberRequests[queryId];\\n        uint previouslyAllocatedDank = allocatedDank[phoneNumberRequest.hashedPhoneNumber];\\n\\n        if ((previouslyAllocatedDank \\u003c= 0) \\u0026\\u0026 (dankToken.balanceOf(address(this)) \\u003e= allotment)) {\\n          bool dankTransfered = dankToken.transfer(phoneNumberRequest.sender, allotment);\\n          if (dankTransfered) {\\n            allocatedDank[phoneNumberRequest.hashedPhoneNumber] = allotment;\\n            emit DankEvent(phoneNumberRequest.hashedPhoneNumber, dankTransfered, \\\"DANK transfered\\\");\\n          }\\n        }\\n        else {\\n          emit DankEvent(phoneNumberRequest.hashedPhoneNumber, false, \\\"DANK already allocated.\\\");\\n        }\\n    }\\n  }\\n\\n  \\n  function getBalance() public view returns (uint256) {\\n      return address(this).balance;\\n  }\\n\\n  \\n  function sendEth() public payable { }\\n\\n  \\n  function resetAllocatedDankForPhoneNumber(bytes32 hashedPhoneNumber) auth {\\n    delete allocatedDank[hashedPhoneNumber];\\n    emit DankReset(hashedPhoneNumber);\\n  }\\n\\n  \\n  function resetAllotment(uint initialDank) auth {\\n    allotment = initialDank;\\n  }\\n}\\n\"},\"DankToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./MiniMeToken.sol\\\";\\n\\n\\n\\ncontract DankToken is MiniMeToken {\\n  function DankToken(address _tokenFactory, uint _mintedAmount)\\n  MiniMeToken(\\n    _tokenFactory,\\n    0x0,\\n    0,\\n    \\\"Dank Token\\\",\\n    18,\\n    \\\"DANK\\\",\\n    true\\n  )\\n  {\\n    generateTokens(msg.sender, _mintedAmount);\\n    changeController(0x0);\\n  }\\n}\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"MiniMeToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n\\n/// @title MiniMeToken Contract\\n/// @author Jordi Baylina\\n/// @dev This token contract\\u0027s goal is to make it easy for anyone to clone this\\n///  token using the token distribution at a given block, this will allow DAO\\u0027s\\n///  and DApps to upgrade their features in a decentralized manner without\\n///  affecting the original token\\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\\n\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\n\\ncontract ApproveAndCallFallBack {\\n  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\\n}\\n\\n/// @dev The actual token contract, the default controller is the msg.sender\\n///  that deploys the contract, so usually this token will be deployed by a\\n///  token controller contract, which Giveth will call a \\\"Campaign\\\"\\ncontract MiniMeToken is Controlled {\\n\\n  string public name;                //The Token\\u0027s name: e.g. DigixDAO Tokens\\n  uint8 public decimals;             //Number of decimals of the smallest unit\\n  string public symbol;              //An identifier: e.g. REP\\n  string public version = \\u0027MMT_0.2\\u0027; //An arbitrary versioning scheme\\n\\n\\n  /// @dev `Checkpoint` is the structure that attaches a block number to a\\n  ///  given value, the block number attached is the one that last changed the\\n  ///  value\\n  struct  Checkpoint {\\n\\n    // `fromBlock` is the block number that the value was generated from\\n    uint128 fromBlock;\\n\\n    // `value` is the amount of tokens at a specific block number\\n    uint128 value;\\n  }\\n\\n  // `parentToken` is the Token address that was cloned to produce this token;\\n  //  it will be 0x0 for a token that was not cloned\\n  MiniMeToken public parentToken;\\n\\n  // `parentSnapShotBlock` is the block number from the Parent Token that was\\n  //  used to determine the initial distribution of the Clone Token\\n  uint public parentSnapShotBlock;\\n\\n  // `creationBlock` is the block number that the Clone Token was created\\n  uint public creationBlock;\\n\\n  // `balances` is the map that tracks the balance of each address, in this\\n  //  contract when the balance changes the block number that the change\\n  //  occurred is also included in the map\\n  mapping (address =\\u003e Checkpoint[]) balances;\\n\\n  // `allowed` tracks any extra transfer rights as in all ERC20 tokens\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n  // Tracks the history of the `totalSupply` of the token\\n  Checkpoint[] totalSupplyHistory;\\n\\n  // Flag that determines if the token is transferable or not.\\n  bool public transfersEnabled;\\n\\n  // The factory used to create new clone tokens\\n  MiniMeTokenFactory public tokenFactory;\\n\\n  ////////////////\\n  // Constructor\\n  ////////////////\\n\\n  /// @notice Constructor to create a MiniMeToken\\n  /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\\n  ///  will create the Clone token contracts, the token factory needs to be\\n  ///  deployed first\\n  /// @param _parentToken Address of the parent token, set to 0x0 if it is a\\n  ///  new token\\n  /// @param _parentSnapShotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token, set to 0 if it\\n  ///  is a new token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  function MiniMeToken(\\n    address _tokenFactory,\\n    address _parentToken,\\n    uint _parentSnapShotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public {\\n    tokenFactory = MiniMeTokenFactory(_tokenFactory);\\n    name = _tokenName;                                 // Set the name\\n    decimals = _decimalUnits;                          // Set the decimals\\n    symbol = _tokenSymbol;                             // Set the symbol\\n    parentToken = MiniMeToken(_parentToken);\\n    parentSnapShotBlock = _parentSnapShotBlock;\\n    transfersEnabled = _transfersEnabled;\\n    creationBlock = block.number;\\n  }\\n\\n\\n  ///////////////////\\n  // ERC20 Methods\\n  ///////////////////\\n\\n  /// @notice Send `_amount` tokens to `_to` from `msg.sender`\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return Whether the transfer was successful or not\\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n    doTransfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\\n  ///  is approved by `_from`\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function transferFrom(address _from, address _to, uint256 _amount\\n  ) public returns (bool success) {\\n\\n    // The controller of this contract can move tokens around at will,\\n    //  this is important to recognize! Confirm that you trust the\\n    //  controller of this contract, which in most situations should be\\n    //  another open source smart contract or 0x0\\n    if (msg.sender != controller) {\\n      require(transfersEnabled);\\n\\n      // The standard ERC 20 transferFrom functionality\\n      require(allowed[_from][msg.sender] \\u003e= _amount);\\n      allowed[_from][msg.sender] -= _amount;\\n    }\\n    doTransfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This is the actual transfer function in the token contract, it can\\n  ///  only be called by other functions in this contract.\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function doTransfer(address _from, address _to, uint _amount\\n  ) internal {\\n\\n    if (_amount == 0) {\\n      Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\\n      return;\\n    }\\n\\n    require(parentSnapShotBlock \\u003c block.number);\\n\\n    // Do not allow transfer to 0x0 or the token contract itself\\n    require((_to != 0) \\u0026\\u0026 (_to != address(this)));\\n\\n    // If the amount being transfered is more than the balance of the\\n    //  account the transfer throws\\n    var previousBalanceFrom = balanceOfAt(_from, block.number);\\n\\n    require(previousBalanceFrom \\u003e= _amount);\\n\\n    // Alerts the token controller of the transfer\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onTransfer(_from, _to, _amount));\\n    }\\n\\n    // First update the balance array with the new value for the address\\n    //  sending the tokens\\n    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\\n\\n    // Then update the balance array with the new value for the address\\n    //  receiving the tokens\\n    var previousBalanceTo = balanceOfAt(_to, block.number);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\\n\\n    // An event to make the transfer easy to find on the blockchain\\n    Transfer(_from, _to, _amount);\\n\\n  }\\n\\n  /// @param _owner The address that\\u0027s balance is being requested\\n  /// @return The balance of `_owner` at the current block\\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\\n    return balanceOfAt(_owner, block.number);\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\\n  ///  its behalf. This is a modified version of the ERC20 approve function\\n  ///  to be a little bit safer\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the approval was successful\\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender,0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    // Alerts the token controller of the approve function call\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\\n    }\\n\\n    allowed[msg.sender][_spender] = _amount;\\n    Approval(msg.sender, _spender, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to read the `allowed[]` map\\n  /// @param _owner The address of the account that owns the token\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\\n  ///  to spend\\n  function allowance(address _owner, address _spender\\n  ) public constant returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\\n  ///  its behalf, and then a function is triggered in the contract that is\\n  ///  being approved, `_spender`. This allows users to use their tokens to\\n  ///  interact with contracts in one function call instead of two\\n  /// @param _spender The address of the contract able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the function call was successful\\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData\\n  ) public returns (bool success) {\\n    require(approve(_spender, _amount));\\n\\n    ApproveAndCallFallBack(_spender).receiveApproval(\\n      msg.sender,\\n      _amount,\\n      this,\\n      _extraData\\n    );\\n\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to get the total number of tokens\\n  /// @return The total number of tokens\\n  function totalSupply() public constant returns (uint) {\\n    return totalSupplyAt(block.number);\\n  }\\n\\n\\n  ////////////////\\n  // Query balance and totalSupply in History\\n  ////////////////\\n\\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\\n  /// @param _owner The address from which the balance will be retrieved\\n  /// @param _blockNumber The block number when the balance is queried\\n  /// @return The balance at `_blockNumber`\\n  function balanceOfAt(address _owner, uint _blockNumber) public constant\\n  returns (uint) {\\n\\n    // These next few lines are used when the balance of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.balanceOfAt` be queried at the\\n    //  genesis block for that token as this contains initial balance of\\n    //  this token\\n    if ((balances[_owner].length == 0)\\n      || (balances[_owner][0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        // Has no parent\\n        return 0;\\n      }\\n\\n      // This will return the expected balance during normal situations\\n    } else {\\n      return getValueAt(balances[_owner], _blockNumber);\\n    }\\n  }\\n\\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\\n  /// @param _blockNumber The block number when the totalSupply is queried\\n  /// @return The total amount of tokens at `_blockNumber`\\n  function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\\n\\n    // These next few lines are used when the totalSupply of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\\n    //  genesis block for this token as that contains totalSupply of this\\n    //  token at this block number.\\n    if ((totalSupplyHistory.length == 0)\\n      || (totalSupplyHistory[0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        return 0;\\n      }\\n\\n      // This will return the expected totalSupply during normal situations\\n    } else {\\n      return getValueAt(totalSupplyHistory, _blockNumber);\\n    }\\n  }\\n\\n  ////////////////\\n  // Clone Token Method\\n  ////////////////\\n\\n  /// @notice Creates a new clone token with the initial distribution being\\n  ///  this token at `_snapshotBlock`\\n  /// @param _cloneTokenName Name of the clone token\\n  /// @param _cloneDecimalUnits Number of decimals of the smallest unit\\n  /// @param _cloneTokenSymbol Symbol of the clone token\\n  /// @param _snapshotBlock Block when the distribution of the parent token is\\n  ///  copied to set the initial distribution of the new clone token;\\n  ///  if the block is zero than the actual block, the current block is used\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  /// @return The address of the new MiniMeToken Contract\\n  function createCloneToken(\\n    string _cloneTokenName,\\n    uint8 _cloneDecimalUnits,\\n    string _cloneTokenSymbol,\\n    uint _snapshotBlock,\\n    bool _transfersEnabled\\n  ) public returns(address) {\\n    if (_snapshotBlock == 0) _snapshotBlock = block.number;\\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\\n      this,\\n      _snapshotBlock,\\n      _cloneTokenName,\\n      _cloneDecimalUnits,\\n      _cloneTokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    cloneToken.changeController(msg.sender);\\n\\n    // An event to make the token easy to find on the blockchain\\n    NewCloneToken(address(cloneToken), _snapshotBlock);\\n    return address(cloneToken);\\n  }\\n\\n  ////////////////\\n  // Generate and destroy tokens\\n  ////////////////\\n\\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\\n  /// @param _owner The address that will be assigned the new tokens\\n  /// @param _amount The quantity of tokens generated\\n  /// @return True if the tokens are generated correctly\\n  function generateTokens(address _owner, uint _amount\\n  ) public onlyController returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply + _amount \\u003e= curTotalSupply); // Check for overflow\\n    uint previousBalanceTo = balanceOf(_owner);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\\n    Transfer(0, _owner, _amount);\\n    return true;\\n  }\\n\\n\\n  /// @notice Burns `_amount` tokens from `_owner`\\n  /// @param _owner The address that will lose the tokens\\n  /// @param _amount The quantity of tokens to burn\\n  /// @return True if the tokens are burned correctly\\n  function destroyTokens(address _owner, uint _amount\\n  ) onlyController public returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply \\u003e= _amount);\\n    uint previousBalanceFrom = balanceOf(_owner);\\n    require(previousBalanceFrom \\u003e= _amount);\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\\n    Transfer(_owner, 0, _amount);\\n    return true;\\n  }\\n\\n  ////////////////\\n  // Enable tokens transfers\\n  ////////////////\\n\\n\\n  /// @notice Enables token holders to transfer their tokens freely if true\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  function enableTransfers(bool _transfersEnabled) public onlyController {\\n    transfersEnabled = _transfersEnabled;\\n  }\\n\\n  ////////////////\\n  // Internal helper functions to query and set a value in a snapshot array\\n  ////////////////\\n\\n  /// @dev `getValueAt` retrieves the number of tokens at a given block number\\n  /// @param checkpoints The history of values being queried\\n  /// @param _block The block number to retrieve the value at\\n  /// @return The number of tokens being queried\\n  function getValueAt(Checkpoint[] storage checkpoints, uint _block\\n  ) constant internal returns (uint) {\\n    if (checkpoints.length == 0) return 0;\\n\\n    // Shortcut for the actual value\\n    if (_block \\u003e= checkpoints[checkpoints.length-1].fromBlock)\\n      return checkpoints[checkpoints.length-1].value;\\n    if (_block \\u003c checkpoints[0].fromBlock) return 0;\\n\\n    // Binary search of the value in the array\\n    uint min = 0;\\n    uint max = checkpoints.length-1;\\n    while (max \\u003e min) {\\n      uint mid = (max + min + 1)/ 2;\\n      if (checkpoints[mid].fromBlock\\u003c=_block) {\\n        min = mid;\\n      } else {\\n        max = mid-1;\\n      }\\n    }\\n    return checkpoints[min].value;\\n  }\\n\\n  /// @dev `updateValueAtNow` used to update the `balances` map and the\\n  ///  `totalSupplyHistory`\\n  /// @param checkpoints The history of data being updated\\n  /// @param _value The new number of tokens\\n  function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\\n  ) internal  {\\n    if ((checkpoints.length == 0)\\n      || (checkpoints[checkpoints.length -1].fromBlock \\u003c block.number)) {\\n      Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\\n      newCheckPoint.fromBlock =  uint128(block.number);\\n      newCheckPoint.value = uint128(_value);\\n    } else {\\n      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\\n      oldCheckPoint.value = uint128(_value);\\n    }\\n  }\\n\\n  /// @dev Internal function to determine if an address is a contract\\n  /// @param _addr The address being queried\\n  /// @return True if `_addr` is a contract\\n  function isContract(address _addr) constant internal returns(bool) {\\n    uint size;\\n    if (_addr == 0) return false;\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return size\\u003e0;\\n  }\\n\\n  /// @dev Helper function to return a min betwen the two uints\\n  function min(uint a, uint b) pure internal returns (uint) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n  /// @notice The fallback function: If the contract\\u0027s controller has not been\\n  ///  set to 0, then the `proxyPayment` method is called which relays the\\n  ///  ether and creates tokens as described in the token controller contract\\n  function () public payable {\\n    require(isContract(controller));\\n    require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\\n  }\\n\\n  //////////\\n  // Safety Methods\\n  //////////\\n\\n  /// @notice This method can be used by the controller to extract mistakenly\\n  ///  sent tokens to this contract.\\n  /// @param _token The address of the token contract that you want to recover\\n  ///  set to 0 in case you want to extract ether.\\n  function claimTokens(address _token) public onlyController {\\n    if (_token == 0x0) {\\n      controller.transfer(this.balance);\\n      return;\\n    }\\n\\n    MiniMeToken token = MiniMeToken(_token);\\n    uint balance = token.balanceOf(this);\\n    token.transfer(controller, balance);\\n    ClaimedTokens(_token, controller, balance);\\n  }\\n\\n  ////////////////\\n  // Events\\n  ////////////////\\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\\n  event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _amount\\n  );\\n\\n}\\n\\n\\n////////////////\\n// MiniMeTokenFactory\\n////////////////\\n\\n/// @dev This contract is used to generate clone contracts from a contract.\\n///  In solidity this is the way to create a contract from a contract of the\\n///  same class\\ncontract MiniMeTokenFactory {\\n\\n  /// @notice Update the DApp by creating a new token with new functionalities\\n  ///  the msg.sender becomes the controller of this clone token\\n  /// @param _parentToken Address of the token being cloned\\n  /// @param _snapshotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  /// @return The address of the new token contract\\n  function createCloneToken(\\n    address _parentToken,\\n    uint _snapshotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public returns (MiniMeToken) {\\n    MiniMeToken newToken = new MiniMeToken(\\n      this,\\n      _parentToken,\\n      _snapshotBlock,\\n      _tokenName,\\n      _decimalUnits,\\n      _tokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    newToken.changeController(msg.sender);\\n    return newToken;\\n  }\\n}\\n\"},\"oraclizeAPI.sol\":{\"content\":\"// \\u003cORACLIZE_API\\u003e\\r\\n\\r\\n\\r\\n// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\\r\\n\\r\\npragma solidity \\u003e=0.4.18;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\\r\\n\\r\\ncontract OraclizeI {\\r\\n    address public cbAddress;\\r\\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\\r\\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\\r\\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\\r\\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function getPrice(string _datasource) public returns (uint _dsprice);\\r\\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\\r\\n    function setProofType(byte _proofType) external;\\r\\n    function setCustomGasPrice(uint _gasPrice) external;\\r\\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\\r\\n}\\r\\n\\r\\ncontract OraclizeAddrResolverI {\\r\\n    function getAddress() public returns (address _addr);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract usingOraclize {\\r\\n    uint constant day = 60*60*24;\\r\\n    uint constant week = 60*60*24*7;\\r\\n    uint constant month = 60*60*24*30;\\r\\n    byte constant proofType_NONE = 0x00;\\r\\n    byte constant proofType_TLSNotary = 0x10;\\r\\n    byte constant proofType_Ledger = 0x30;\\r\\n    byte constant proofType_Android = 0x40;\\r\\n    byte constant proofType_Native = 0xF0;\\r\\n    byte constant proofStorage_IPFS = 0x01;\\r\\n    uint8 constant networkID_auto = 0;\\r\\n    uint8 constant networkID_mainnet = 1;\\r\\n    uint8 constant networkID_testnet = 2;\\r\\n    uint8 constant networkID_morden = 2;\\r\\n    uint8 constant networkID_consensys = 161;\\r\\n\\r\\n    OraclizeAddrResolverI OAR;\\r\\n\\r\\n    OraclizeI oraclize;\\r\\n    modifier oraclizeAPI {\\r\\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\\r\\n            oraclize_setNetwork(networkID_auto);\\r\\n\\r\\n        if(address(oraclize) != OAR.getAddress())\\r\\n            oraclize = OraclizeI(OAR.getAddress());\\r\\n\\r\\n        _;\\r\\n    }\\r\\n    modifier coupon(string code){\\r\\n        oraclize = OraclizeI(OAR.getAddress());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\\r\\n      return oraclize_setNetwork();\\r\\n      networkID; // silence the warning and remain backwards compatible\\r\\n    }\\r\\n    function oraclize_setNetwork() internal returns(bool){\\r\\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)\\u003e0){ //mainnet\\r\\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\\r\\n            oraclize_setNetworkName(\\\"eth_mainnet\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)\\u003e0){ //ropsten testnet\\r\\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\\r\\n            oraclize_setNetworkName(\\\"eth_ropsten3\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)\\u003e0){ //kovan testnet\\r\\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\\r\\n            oraclize_setNetworkName(\\\"eth_kovan\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)\\u003e0){ //rinkeby testnet\\r\\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\\r\\n            oraclize_setNetworkName(\\\"eth_rinkeby\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)\\u003e0){ //ethereum-bridge\\r\\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)\\u003e0){ //ether.camp ide\\r\\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)\\u003e0){ //browser-solidity\\r\\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function __callback(bytes32 myid, string result) public {\\r\\n        __callback(myid, result, new bytes(0));\\r\\n    }\\r\\n    function __callback(bytes32 myid, string result, bytes proof) public {\\r\\n      return;\\r\\n      myid; result; proof; // Silence compiler warnings\\r\\n    }\\r\\n\\r\\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\\r\\n        return oraclize.getPrice(datasource);\\r\\n    }\\r\\n\\r\\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\\r\\n        return oraclize.getPrice(datasource, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query.value(price)(0, datasource, arg);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query.value(price)(timestamp, datasource, arg);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(0, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(0, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\\r\\n        return oraclize.cbAddress();\\r\\n    }\\r\\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\\r\\n        return oraclize.setProofType(proofP);\\r\\n    }\\r\\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\\r\\n        return oraclize.setCustomGasPrice(gasPrice);\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\\r\\n        return oraclize.randomDS_getSessionPubKeyHash();\\r\\n    }\\r\\n\\r\\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\\r\\n        assembly {\\r\\n            _size := extcodesize(_addr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function parseAddr(string _a) internal pure returns (address){\\r\\n        bytes memory tmp = bytes(_a);\\r\\n        uint160 iaddr = 0;\\r\\n        uint160 b1;\\r\\n        uint160 b2;\\r\\n        for (uint i=2; i\\u003c2+2*20; i+=2){\\r\\n            iaddr *= 256;\\r\\n            b1 = uint160(tmp[i]);\\r\\n            b2 = uint160(tmp[i+1]);\\r\\n            if ((b1 \\u003e= 97)\\u0026\\u0026(b1 \\u003c= 102)) b1 -= 87;\\r\\n            else if ((b1 \\u003e= 65)\\u0026\\u0026(b1 \\u003c= 70)) b1 -= 55;\\r\\n            else if ((b1 \\u003e= 48)\\u0026\\u0026(b1 \\u003c= 57)) b1 -= 48;\\r\\n            if ((b2 \\u003e= 97)\\u0026\\u0026(b2 \\u003c= 102)) b2 -= 87;\\r\\n            else if ((b2 \\u003e= 65)\\u0026\\u0026(b2 \\u003c= 70)) b2 -= 55;\\r\\n            else if ((b2 \\u003e= 48)\\u0026\\u0026(b2 \\u003c= 57)) b2 -= 48;\\r\\n            iaddr += (b1*16+b2);\\r\\n        }\\r\\n        return address(iaddr);\\r\\n    }\\r\\n\\r\\n    function strCompare(string _a, string _b) internal pure returns (int) {\\r\\n        bytes memory a = bytes(_a);\\r\\n        bytes memory b = bytes(_b);\\r\\n        uint minLength = a.length;\\r\\n        if (b.length \\u003c minLength) minLength = b.length;\\r\\n        for (uint i = 0; i \\u003c minLength; i ++)\\r\\n            if (a[i] \\u003c b[i])\\r\\n                return -1;\\r\\n            else if (a[i] \\u003e b[i])\\r\\n                return 1;\\r\\n        if (a.length \\u003c b.length)\\r\\n            return -1;\\r\\n        else if (a.length \\u003e b.length)\\r\\n            return 1;\\r\\n        else\\r\\n            return 0;\\r\\n    }\\r\\n\\r\\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\\r\\n        bytes memory h = bytes(_haystack);\\r\\n        bytes memory n = bytes(_needle);\\r\\n        if(h.length \\u003c 1 || n.length \\u003c 1 || (n.length \\u003e h.length))\\r\\n            return -1;\\r\\n        else if(h.length \\u003e (2**128 -1))\\r\\n            return -1;\\r\\n        else\\r\\n        {\\r\\n            uint subindex = 0;\\r\\n            for (uint i = 0; i \\u003c h.length; i ++)\\r\\n            {\\r\\n                if (h[i] == n[0])\\r\\n                {\\r\\n                    subindex = 1;\\r\\n                    while(subindex \\u003c n.length \\u0026\\u0026 (i + subindex) \\u003c h.length \\u0026\\u0026 h[i + subindex] == n[subindex])\\r\\n                    {\\r\\n                        subindex++;\\r\\n                    }\\r\\n                    if(subindex == n.length)\\r\\n                        return int(i);\\r\\n                }\\r\\n            }\\r\\n            return -1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\\r\\n        bytes memory _ba = bytes(_a);\\r\\n        bytes memory _bb = bytes(_b);\\r\\n        bytes memory _bc = bytes(_c);\\r\\n        bytes memory _bd = bytes(_d);\\r\\n        bytes memory _be = bytes(_e);\\r\\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\r\\n        bytes memory babcde = bytes(abcde);\\r\\n        uint k = 0;\\r\\n        for (uint i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\r\\n        for (i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\r\\n        for (i = 0; i \\u003c _bc.length; i++) babcde[k++] = _bc[i];\\r\\n        for (i = 0; i \\u003c _bd.length; i++) babcde[k++] = _bd[i];\\r\\n        for (i = 0; i \\u003c _be.length; i++) babcde[k++] = _be[i];\\r\\n        return string(babcde);\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    // parseInt\\r\\n    function parseInt(string _a) internal pure returns (uint) {\\r\\n        return parseInt(_a, 0);\\r\\n    }\\r\\n\\r\\n    // parseInt(parseFloat*10^_b)\\r\\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\\r\\n        bytes memory bresult = bytes(_a);\\r\\n        uint mint = 0;\\r\\n        bool decimals = false;\\r\\n        for (uint i=0; i\\u003cbresult.length; i++){\\r\\n            if ((bresult[i] \\u003e= 48)\\u0026\\u0026(bresult[i] \\u003c= 57)){\\r\\n                if (decimals){\\r\\n                   if (_b == 0) break;\\r\\n                    else _b--;\\r\\n                }\\r\\n                mint *= 10;\\r\\n                mint += uint(bresult[i]) - 48;\\r\\n            } else if (bresult[i] == 46) decimals = true;\\r\\n        }\\r\\n        if (_b \\u003e 0) mint *= 10**_b;\\r\\n        return mint;\\r\\n    }\\r\\n\\r\\n    function uint2str(uint i) internal pure returns (string){\\r\\n        if (i == 0) return \\\"0\\\";\\r\\n        uint j = i;\\r\\n        uint len;\\r\\n        while (j != 0){\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len - 1;\\r\\n        while (i != 0){\\r\\n            bstr[k--] = byte(48 + i % 10);\\r\\n            i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n\\r\\n    using CBOR for Buffer.buffer;\\r\\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\\r\\n        safeMemoryCleaner();\\r\\n        Buffer.buffer memory buf;\\r\\n        Buffer.init(buf, 1024);\\r\\n        buf.startArray();\\r\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\r\\n            buf.encodeString(arr[i]);\\r\\n        }\\r\\n        buf.endSequence();\\r\\n        return buf.buf;\\r\\n    }\\r\\n\\r\\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\\r\\n        safeMemoryCleaner();\\r\\n        Buffer.buffer memory buf;\\r\\n        Buffer.init(buf, 1024);\\r\\n        buf.startArray();\\r\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\r\\n            buf.encodeBytes(arr[i]);\\r\\n        }\\r\\n        buf.endSequence();\\r\\n        return buf.buf;\\r\\n    }\\r\\n\\r\\n    string oraclize_network_name;\\r\\n    function oraclize_setNetworkName(string _network_name) internal {\\r\\n        oraclize_network_name = _network_name;\\r\\n    }\\r\\n\\r\\n    function oraclize_getNetworkName() internal view returns (string) {\\r\\n        return oraclize_network_name;\\r\\n    }\\r\\n\\r\\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\\r\\n        require((_nbytes \\u003e 0) \\u0026\\u0026 (_nbytes \\u003c= 32));\\r\\n        // Convert from seconds to ledger timer ticks\\r\\n        _delay *= 10;\\r\\n        bytes memory nbytes = new bytes(1);\\r\\n        nbytes[0] = byte(_nbytes);\\r\\n        bytes memory unonce = new bytes(32);\\r\\n        bytes memory sessionKeyHash = new bytes(32);\\r\\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\\r\\n        assembly {\\r\\n            mstore(unonce, 0x20)\\r\\n            // the following variables can be relaxed\\r\\n            // check relaxed random contract under ethereum-examples repo\\r\\n            // for an idea on how to override and replace comit hash vars\\r\\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\\r\\n            mstore(sessionKeyHash, 0x20)\\r\\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\\r\\n        }\\r\\n        bytes memory delay = new bytes(32);\\r\\n        assembly {\\r\\n            mstore(add(delay, 0x20), _delay)\\r\\n        }\\r\\n\\r\\n        bytes memory delay_bytes8 = new bytes(8);\\r\\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\\r\\n\\r\\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\\r\\n        bytes32 queryId = oraclize_query(\\\"random\\\", args, _customGasLimit);\\r\\n\\r\\n        bytes memory delay_bytes8_left = new bytes(8);\\r\\n\\r\\n        assembly {\\r\\n            let x := mload(add(delay_bytes8, 0x20))\\r\\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\\r\\n\\r\\n        }\\r\\n\\r\\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\\r\\n        return queryId;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\\r\\n        oraclize_randomDS_args[queryId] = commitment;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32=\\u003ebytes32) oraclize_randomDS_args;\\r\\n    mapping(bytes32=\\u003ebool) oraclize_randomDS_sessionKeysHashVerified;\\r\\n\\r\\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\\r\\n        bool sigok;\\r\\n        address signer;\\r\\n\\r\\n        bytes32 sigr;\\r\\n        bytes32 sigs;\\r\\n\\r\\n        bytes memory sigr_ = new bytes(32);\\r\\n        uint offset = 4+(uint(dersig[3]) - 0x20);\\r\\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\\r\\n        bytes memory sigs_ = new bytes(32);\\r\\n        offset += 32 + 2;\\r\\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\\r\\n\\r\\n        assembly {\\r\\n            sigr := mload(add(sigr_, 32))\\r\\n            sigs := mload(add(sigs_, 32))\\r\\n        }\\r\\n\\r\\n\\r\\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\\r\\n        if (address(keccak256(pubkey)) == signer) return true;\\r\\n        else {\\r\\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\\r\\n            return (address(keccak256(pubkey)) == signer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\\r\\n        bool sigok;\\r\\n\\r\\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\\r\\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\\r\\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\\r\\n\\r\\n        bytes memory appkey1_pubkey = new bytes(64);\\r\\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\\r\\n\\r\\n        bytes memory tosign2 = new bytes(1+65+32);\\r\\n        tosign2[0] = byte(1); //role\\r\\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\\r\\n        bytes memory CODEHASH = hex\\\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\\\";\\r\\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\\r\\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\\r\\n\\r\\n        if (sigok == false) return false;\\r\\n\\r\\n\\r\\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\\r\\n        bytes memory LEDGERKEY = hex\\\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\\\";\\r\\n\\r\\n        bytes memory tosign3 = new bytes(1+65);\\r\\n        tosign3[0] = 0xFE;\\r\\n        copyBytes(proof, 3, 65, tosign3, 1);\\r\\n\\r\\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\\r\\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\\r\\n\\r\\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\\r\\n\\r\\n        return sigok;\\r\\n    }\\r\\n\\r\\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\\r\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\r\\n        require((_proof[0] == \\\"L\\\") \\u0026\\u0026 (_proof[1] == \\\"P\\\") \\u0026\\u0026 (_proof[2] == 1));\\r\\n\\r\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\r\\n        require(proofVerified);\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\\r\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\r\\n        if ((_proof[0] != \\\"L\\\")||(_proof[1] != \\\"P\\\")||(_proof[2] != 1)) return 1;\\r\\n\\r\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\r\\n        if (proofVerified == false) return 2;\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\\r\\n        bool match_ = true;\\r\\n\\r\\n        require(prefix.length == n_random_bytes);\\r\\n\\r\\n        for (uint256 i=0; i\\u003c n_random_bytes; i++) {\\r\\n            if (content[i] != prefix[i]) match_ = false;\\r\\n        }\\r\\n\\r\\n        return match_;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\\r\\n\\r\\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\\r\\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\\r\\n        bytes memory keyhash = new bytes(32);\\r\\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\\r\\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\\r\\n\\r\\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\\r\\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\\r\\n\\r\\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if \\u0027result\\u0027 is the prefix of sha256(sig1)\\r\\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\\r\\n\\r\\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\\r\\n        // This is to verify that the computed args match with the ones specified in the query.\\r\\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\\r\\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\\r\\n\\r\\n        bytes memory sessionPubkey = new bytes(64);\\r\\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\\r\\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\\r\\n\\r\\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\\r\\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\\r\\n            delete oraclize_randomDS_args[queryId];\\r\\n        } else return false;\\r\\n\\r\\n\\r\\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\\r\\n        bytes memory tosign1 = new bytes(32+8+1+32);\\r\\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\\r\\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\\r\\n\\r\\n        // verify if sessionPubkeyHash was verified already, if not.. let\\u0027s do it!\\r\\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\\r\\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\\r\\n        }\\r\\n\\r\\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\\r\\n        uint minLength = length + toOffset;\\r\\n\\r\\n        // Buffer too small\\r\\n        require(to.length \\u003e= minLength); // Should be a better way?\\r\\n\\r\\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\\r\\n        uint i = 32 + fromOffset;\\r\\n        uint j = 32 + toOffset;\\r\\n\\r\\n        while (i \\u003c (32 + fromOffset + length)) {\\r\\n            assembly {\\r\\n                let tmp := mload(add(from, i))\\r\\n                mstore(add(to, j), tmp)\\r\\n            }\\r\\n            i += 32;\\r\\n            j += 32;\\r\\n        }\\r\\n\\r\\n        return to;\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    // Duplicate Solidity\\u0027s ecrecover, but catching the CALL return value\\r\\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\\r\\n        // We do our own memory management here. Solidity uses memory offset\\r\\n        // 0x40 to store the current end of memory. We write past it (as\\r\\n        // writes are memory extensions), but don\\u0027t update the offset so\\r\\n        // Solidity will reuse it. The memory used here is only needed for\\r\\n        // this context.\\r\\n\\r\\n        // FIXME: inline assembly can\\u0027t access return values\\r\\n        bool ret;\\r\\n        address addr;\\r\\n\\r\\n        assembly {\\r\\n            let size := mload(0x40)\\r\\n            mstore(size, hash)\\r\\n            mstore(add(size, 32), v)\\r\\n            mstore(add(size, 64), r)\\r\\n            mstore(add(size, 96), s)\\r\\n\\r\\n            // NOTE: we can reuse the request memory because we deal with\\r\\n            //       the return code\\r\\n            ret := call(3000, 1, 0, size, 128, size, 32)\\r\\n            addr := mload(size)\\r\\n        }\\r\\n\\r\\n        return (ret, addr);\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        if (sig.length != 65)\\r\\n          return (false, 0);\\r\\n\\r\\n        // The signature format is a compact form of:\\r\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\r\\n        // Compact means, uint8 is not padded to 32 bytes.\\r\\n        assembly {\\r\\n            r := mload(add(sig, 32))\\r\\n            s := mload(add(sig, 64))\\r\\n\\r\\n            // Here we are loading the last 32 bytes. We exploit the fact that\\r\\n            // \\u0027mload\\u0027 will pad with zeroes if we overread.\\r\\n            // There is no \\u0027mload8\\u0027 to do this, but that would be nicer.\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n\\r\\n            // Alternative solution:\\r\\n            // \\u0027byte\\u0027 is not working due to the Solidity parser, so lets\\r\\n            // use the second best option, \\u0027and\\u0027\\r\\n            // v := and(mload(add(sig, 65)), 255)\\r\\n        }\\r\\n\\r\\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\\r\\n        // to match the YP range of [27, 28]\\r\\n        //\\r\\n        // geth uses [0, 1] and some clients have followed. This might change, see:\\r\\n        //  https://github.com/ethereum/go-ethereum/issues/2053\\r\\n        if (v \\u003c 27)\\r\\n          v += 27;\\r\\n\\r\\n        if (v != 27 \\u0026\\u0026 v != 28)\\r\\n            return (false, 0);\\r\\n\\r\\n        return safer_ecrecover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    function safeMemoryCleaner() internal pure {\\r\\n        assembly {\\r\\n            let fmem := mload(0x40)\\r\\n            codecopy(fmem, codesize, sub(msize, fmem))\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\\r\\n// \\u003c/ORACLIZE_API\\u003e\\r\\n\"},\"TokenController.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/// @dev The token controller contract must implement these functions\\ncontract TokenController {\\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\\n  /// @param _owner The address that sent the ether to create tokens\\n  /// @return True if the ether is accepted, false if it throws\\n  function proxyPayment(address _owner) public payable returns(bool);\\n\\n  /// @notice Notifies the controller about a token transfer allowing the\\n  ///  controller to react if desired\\n  /// @param _from The origin of the transfer\\n  /// @param _to The destination of the transfer\\n  /// @param _amount The amount of the transfer\\n  /// @return False if the controller does not authorize the transfer\\n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\\n\\n  /// @notice Notifies the controller about an approval allowing the\\n  ///  controller to react if desired\\n  /// @param _owner The address that calls `approve()`\\n  /// @param _spender The spender in the `approve()` call\\n  /// @param _amount The amount in the `approve()` call\\n  /// @return False if the controller does not authorize the approval\\n  function onApprove(address _owner, address _spender, uint _amount) public\\n  returns(bool);\\n}\\n\"}}",
        "label": false,
        "name": "0xe1d528e294e835329a461d8b398a82e7323641c8.sol"
    },
    {
        "source": "contract SellOrder {\r\n  \r\n\r\n  \r\n\r\n  \r\n\r\n      address public challengeOwner;\r\n  address public owner;   uint256 public tokens;\r\n  uint256 public price; \r\n  \r\n\r\n\r\n  \r\n\r\n  modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n  modifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n  modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n  \r\n\r\n  function SellOrder (uint256 _tokens, uint256 _price, address _challengeOwner) noEther {\r\n    owner = msg.sender;\r\n\r\n    tokens = _tokens;\r\n    price = _price;\r\n\r\n        challengeOwner = _challengeOwner;\r\n  }\r\n\r\n  function () {\r\n    throw;\r\n  }\r\n\r\n  \r\n\r\n  \r\n\r\n  function cancel () noEther onlyOwner {\r\n    suicide(owner);\r\n  }\r\n\r\n  function execute () {\r\n    if (msg.value != tokens * price) throw;\r\n\r\n            suicide(owner);\r\n  }\r\n\r\n    function terminate() noEther onlyChallengeOwner {\r\n    suicide(challengeOwner);\r\n  }\r\n}\r\ncontract AbstractDaoChallenge {\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);\r\n\tfunction tokenPrice() returns (uint256);\r\n}\r\n\r\ncontract DaoAccount\r\n{\r\n\t\r\n\r\n\t\r\n\r\n\t\r\n\t\r\n\r\n\taddress public daoChallenge; \r\n\t    address public challengeOwner;\r\n\r\n\t\r\n\r\n\tuint256 tokenBalance;   address owner;        \r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) noEther {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\t\ttokenBalance = 0;\r\n\r\n        challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tthrow;\r\n\t}\r\n\r\n\t\r\n\r\n\t\r\n\r\n\tfunction getOwnerAddress() constant returns (address ownerAddress) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction getTokenBalance() constant returns (uint256 tokens) {\r\n\t\treturn tokenBalance;\r\n\t}\r\n\r\n\tfunction buyTokens() onlyDaoChallenge returns (uint256 tokens) {\r\n\t\tuint256 amount = msg.value;\r\n\t\tuint256 tokenPrice = AbstractDaoChallenge(daoChallenge).tokenPrice();\r\n\r\n\t\t\t\tif (amount == 0) throw;\r\n\r\n\t\t\t\tif (amount % tokenPrice != 0) throw;\r\n\r\n\t\ttokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge {\r\n\t\tif (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n\t\tif (tokenBalance - tokens > tokenBalance) throw; \t\ttokenBalance -= tokens;\r\n\t\trecipient.receiveTokens(tokens);\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 tokens) {\r\n\t\t\t\tDaoAccount sender = DaoAccount(msg.sender);\r\n\t\tif (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw;\r\n\r\n\t\tif (tokens > sender.getTokenBalance()) throw;\r\n\r\n\t\t\t\tif (tokenBalance + tokens < tokenBalance) throw;\r\n\r\n\t\ttokenBalance += tokens;\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther onlyDaoChallenge returns (SellOrder) {\r\n    if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n    if (tokenBalance - tokens > tokenBalance) throw;     tokenBalance -= tokens;\r\n\r\n    SellOrder order = new SellOrder(tokens, price, challengeOwner);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(SellOrder order) noEther onlyDaoChallenge {\r\n    uint256 tokens = order.tokens();\r\n    tokenBalance += tokens;\r\n    order.cancel();\r\n  }\r\n\r\n  function executeSellOrder(SellOrder order) onlyDaoChallenge {\r\n    uint256 tokens = order.tokens();\r\n    tokenBalance += tokens;\r\n    order.execute.value(msg.value)();\r\n  }\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\n\r\ncontract DaoChallenge\r\n{\r\n\t\r\n\r\n\r\n\t\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\tevent notifyTokenIssued(uint256 n, uint256 price, uint deadline);\r\n\r\n\tevent notifyNewAccount(address owner, address account);\r\n\tevent notifyBuyToken(address owner, uint256 tokens, uint256 price);\r\n\tevent notifyTransfer(address owner, address recipient, uint256 tokens);\r\n  event notifyPlaceSellOrder(uint256 tokens, uint256 price);\r\n  event notifyCancelSellOrder();\r\n  event notifyExecuteSellOrder(uint256 tokens, uint256 price);\r\n\r\n\t\r\n\r\n\t\tuint public tokenIssueDeadline = now;\r\n\tuint256 public tokensIssued = 0;\r\n\tuint256 public tokensToIssue = 0;\r\n\tuint256 public tokenPrice = 1000000000000000; \r\n\tmapping (address => DaoAccount) public daoAccounts;\r\n  mapping (address => SellOrder) public sellOrders;\r\n\r\n    address public challengeOwner;\r\n\r\n\t\r\n\r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n\tfunction DaoChallenge () {\r\n\t\tchallengeOwner = msg.sender; \t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\r\n\t\tDaoAccount account = daoAccounts[accountOwner];\r\n\r\n\t\tif(account == DaoAccount(0x00) && createNew) {\r\n\t\t\taccount = new DaoAccount(accountOwner, challengeOwner);\r\n\t\t\tdaoAccounts[accountOwner] = account;\r\n\t\t\tnotifyNewAccount(accountOwner, address(account));\r\n\t\t}\r\n\r\n\t\treturn account;\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction createAccount () {\r\n\t\taccountFor(msg.sender, true);\r\n\t}\r\n\r\n\t\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) {\r\n\t\tif (account == DaoAccount(0x00)) return false;\r\n\t\tif (allegedOwnerAddress == 0x00) return false;\r\n\t\tif (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false;\r\n\t\t\t\tif (daoAccounts[allegedOwnerAddress] != account) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n  function getBalance () constant noEther returns (uint256) {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) return 0;\r\n    return account.balance;\r\n  }\r\n\r\n\tfunction getTokenBalance () constant noEther returns (uint256 tokens) {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) return 0;\r\n\t\treturn account.getTokenBalance();\r\n\t}\r\n\r\n\t\t\t\tfunction issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner {\r\n\t\t\t\tif (now < tokenIssueDeadline) throw;\r\n\r\n\t\t\t\tif (deadline < now) throw;\r\n\r\n\t\t\t\tif (n == 0) throw;\r\n\r\n\t\ttokenPrice = price;\r\n\t\ttokenIssueDeadline = deadline;\r\n\t\ttokensToIssue = n;\r\n\t\ttokensIssued = 0;\r\n\r\n\t\tnotifyTokenIssued(n, price, deadline);\r\n\t}\r\n\r\n\tfunction buyTokens () returns (uint256 tokens) {\r\n\t\ttokens = msg.value / tokenPrice;\r\n\r\n\t\tif (now > tokenIssueDeadline) throw;\r\n\t\tif (tokensIssued >= tokensToIssue) throw;\r\n\r\n\t\t\t\t\t\ttokensIssued += tokens;\r\n\t\tif (tokensIssued > tokensToIssue) throw;\r\n\r\n\t  DaoAccount account = accountFor(msg.sender, true);\r\n\t\tif (account.buyTokens.value(msg.value)() != tokens) throw;\r\n\r\n\t\tnotifyBuyToken(msg.sender, tokens, msg.value);\r\n\t\treturn tokens;\r\n \t}\r\n\r\n\tfunction transfer(uint256 tokens, address recipient) noEther {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) throw;\r\n\r\n\t\tDaoAccount recipientAcc = accountFor(recipient, false);\r\n\t\tif (recipientAcc == DaoAccount(0x00)) throw;\r\n\r\n\t\taccount.transfer(tokens, recipientAcc);\r\n\t\tnotifyTransfer(msg.sender, recipient, tokens);\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther returns (SellOrder) {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = account.placeSellOrder(tokens, price);\r\n\r\n    sellOrders[address(order)] = order;\r\n\r\n    notifyPlaceSellOrder(tokens, price);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(address addr) noEther {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = sellOrders[addr];\r\n    if (order == SellOrder(0x00)) throw;\r\n\r\n    if (order.owner() != address(account)) throw;\r\n\r\n    sellOrders[addr] = SellOrder(0x00);\r\n\r\n    account.cancelSellOrder(order);\r\n\r\n    notifyCancelSellOrder();\r\n  }\r\n\r\n  function executeSellOrder(address addr) {\r\n        if (msg.value == 0) throw;\r\n\r\n    DaoAccount account = accountFor(msg.sender, true);\r\n\r\n    SellOrder order = sellOrders[addr];\r\n    if (order == SellOrder(0x00)) throw;\r\n\r\n        if (order.owner() == address(account)) throw;\r\n\r\n    uint256 tokens = order.tokens();\r\n    uint256 price = order.price();\r\n\r\n        sellOrders[addr] = SellOrder(0x00);\r\n\r\n    account.executeSellOrder.value(msg.value)(order);\r\n\r\n    notifyExecuteSellOrder(tokens, price);\r\n  }\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}",
        "label": false,
        "name": "0x66230ca3603e071c942f9c1c8824be91c91f3a90.sol"
    },
    {
        "source": "{\"Cereneum.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./CereneumImplementation.sol\\\";\\n\\n/// @author AshKetchumNakamoto09\\n/// @title A Trustless Interest-bearing Cryptographic Certificate of Interest on Ethereum\\ncontract Cereneum is CereneumImplementation\\n{\\n\\tusing SafeMath for uint256;\\n\\n\\tconstructor(\\n\\t\\t\\tbytes32 a_hBTCMerkleTreeRoot,\\n\\t\\t\\tbytes32 a_hBCHMerkleTreeRoot,\\n\\t\\t\\tbytes32 a_hBSVMerkleTreeRoot,\\n\\t\\t\\tbytes32 a_hETHMerkleTreeRoot,\\n\\t\\t\\tbytes32 a_hLTCMerkleTreeRoot\\n  )\\n\\tpublic\\n\\t{\\n\\t\\t//Store the launch time of the contract\\n    m_tContractLaunchTime = block.timestamp;\\n    m_hMerkleTreeRootsArray[0] = a_hBTCMerkleTreeRoot;\\n\\t\\tm_hMerkleTreeRootsArray[1] = a_hBCHMerkleTreeRoot;\\n\\t\\tm_hMerkleTreeRootsArray[2] = a_hBSVMerkleTreeRoot;\\n\\t\\tm_hMerkleTreeRootsArray[3] = a_hETHMerkleTreeRoot;\\n\\t\\tm_hMerkleTreeRootsArray[4] = a_hLTCMerkleTreeRoot;\\n\\n\\t\\t//These ratios will be updated on snapshot day\\n\\t\\t//All ratios have an invisible 0.0 in front of them\\n\\t\\tm_blockchainRatios[0] = 5128; //BCH\\n\\t  m_blockchainRatios[1] = 2263; //BSV\\n\\t  m_blockchainRatios[2] = 3106; //ETH\\n\\t  m_blockchainRatios[3] = 1311; //LTC\\n\\n\\t\\t//Binance 1\\n\\t\\tm_exchangeAirdropAddresses[0] = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE;\\n\\t\\tm_exchangeAirdropAmounts[0] = 17400347788910;\\n\\n\\t\\t//Binance 2\\n\\t\\tm_exchangeAirdropAddresses[1] = 0xD551234Ae421e3BCBA99A0Da6d736074f22192FF;\\n\\t\\tm_exchangeAirdropAmounts[1] = 6758097982665;\\n\\n\\t\\t//Binance 3\\n\\t\\tm_exchangeAirdropAddresses[2] = 0x564286362092D8e7936f0549571a803B203aAceD;\\n\\t\\tm_exchangeAirdropAmounts[2] = 5557947334680;\\n\\n\\t\\t//Binance 4\\n\\t\\tm_exchangeAirdropAddresses[3] = 0x0681d8Db095565FE8A346fA0277bFfdE9C0eDBBF;\\n\\t\\tm_exchangeAirdropAmounts[3] = 5953786344335;\\n\\n\\t\\t//Binance 5 has little ether in it\\n\\n\\t\\t//Binance 6\\n\\t\\tm_exchangeAirdropAddresses[4] = 0x4E9ce36E442e55EcD9025B9a6E0D88485d628A67;\\n\\t\\tm_exchangeAirdropAmounts[4] = 779918770916450;\\n\\n\\t\\t//Bittrex1\\n\\t\\tm_exchangeAirdropAddresses[5] = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98;\\n\\t\\tm_exchangeAirdropAmounts[5] = 84975797259280;\\n\\n\\t\\t//Bittrex3\\n\\t\\tm_exchangeAirdropAddresses[6] = 0x66f820a414680B5bcda5eECA5dea238543F42054;\\n\\t\\tm_exchangeAirdropAmounts[6] = 651875804471280;\\n\\n\\t\\t//KuCoin1\\n\\t\\tm_exchangeAirdropAddresses[7] = 0x2B5634C42055806a59e9107ED44D43c426E58258;\\n\\t\\tm_exchangeAirdropAmounts[7] = 6609673761160;\\n\\n\\t\\t//KuCoin2\\n\\t\\tm_exchangeAirdropAddresses[8] = 0x689C56AEf474Df92D44A1B70850f808488F9769C;\\n\\t\\tm_exchangeAirdropAmounts[8] = 4378334643430;\\n\\n\\t\\t//LAToken\\n\\t\\tm_exchangeAirdropAddresses[9] = 0x7891b20C690605F4E370d6944C8A5DBfAc5a451c;\\n\\t\\tm_exchangeAirdropAmounts[9] = 6754951284855;\\n\\n\\t\\t//Huobi Global\\n\\t\\tm_exchangeAirdropAddresses[10] = 0xDc76CD25977E0a5Ae17155770273aD58648900D3;\\n\\t\\tm_exchangeAirdropAmounts[10] = 427305320984440;\\n\\n\\t\\t//CoinBene\\n\\t\\tm_exchangeAirdropAddresses[11] = 0x33683b94334eeBc9BD3EA85DDBDA4a86Fb461405;\\n\\t\\tm_exchangeAirdropAmounts[11] = 2414794474090;\\n\\n    //Mint all claimable coins to contract wallet\\n    _mint(address(this), m_nMaxRedeemable);\\n\\t}\\n\\n\\t//ERC20 Constants\\n  string public constant name = \\\"Cereneum\\\";\\n  string public constant symbol = \\\"CER\\\";\\n  uint public constant decimals = 8;\\n\\n\\t/// @dev A one time callable function to airdrop Ethereum chain CER tokens to some exchange wallets.\\n\\t/// The amounts granted had the standard whale penalties applied and were removed from the UTXO\\n\\t/// set before the Merkle Tree was built so they cannot be claimed a second time.\\n\\tfunction ExchangeEthereumAirdrops() external\\n\\t{\\n\\t\\tUpdateDailyData();\\n\\n\\t\\trequire(m_bHasAirdroppedExchanges == false);\\n\\t\\tm_bHasAirdroppedExchanges = true;\\n\\n\\t\\t//The following Ethereum exchange addresses are removed from the claimable UTXO set and automatically airdropped\\n\\t\\t//To encourage early exchange support.\\n\\t\\tuint256 nGenesisBonuses = 0;\\n\\t\\tuint256 nPublicReferralBonuses = 0;\\n\\t\\tuint256 nTokensRedeemed = 0;\\n\\t\\tuint256 nBonuses = 0;\\n\\t\\tuint256 nPenalties = 0;\\n\\n\\t\\tfor(uint256 i=0; i \\u003c 12; ++i)\\n\\t\\t{\\n\\t\\t\\t(nTokensRedeemed, nBonuses, nPenalties) = GetRedeemAmount(m_exchangeAirdropAmounts[i], BlockchainType.Ethereum);\\n\\n\\t\\t\\t//Transfer coins from contracts wallet to claim wallet\\n\\t\\t\\t_transfer(address(this), m_exchangeAirdropAddresses[i], nTokensRedeemed);\\n\\n\\t\\t\\t//Mint speed bonus and 10% referral bonus to claiming address\\n\\t\\t\\t_mint(m_exchangeAirdropAddresses[i], nBonuses.add(nTokensRedeemed.div(10)));\\n\\n\\t\\t\\t//Speed bonus and referral bonus matched for genesis address (20% for referral and 10% for claimer referral = 30%)\\n\\t\\t\\tnGenesisBonuses = nGenesisBonuses.add(nBonuses.add(nTokensRedeemed.mul(1000000000000).div(3333333333333)));\\n\\n\\t\\t\\t//Grant 20% bonus of tokens to referrer\\n\\t\\t\\tnPublicReferralBonuses = nPublicReferralBonuses.add(nTokensRedeemed.div(5));\\n\\n\\t\\t\\tm_nTotalRedeemed = m_nTotalRedeemed.add(GetRedeemRatio(m_exchangeAirdropAmounts[i], BlockchainType.Ethereum));\\n\\t\\t\\tm_nRedeemedCount = m_nRedeemedCount.add(1);\\n\\t\\t}\\n\\n\\t\\t//Mint all of the referrer bonuses in a single call\\n\\t\\t_mint(m_publicReferralAddress, nPublicReferralBonuses);\\n\\n\\t\\t//Mint all of the genesis bonuses in a single call\\n\\t\\t_mint(m_genesis, nGenesisBonuses);\\n\\t}\\n}\\n\"},\"CereneumData.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract CereneumData is ERC20\\n{\\n\\tusing SafeMath for uint256;\\n\\n  //Launch timestamp of contract used to track how long contract has been running\\n  uint256 internal m_tContractLaunchTime;\\n\\n\\t//Root hashes of the 5 UTXO Merkle trees. Used to verify claims.\\n  //0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  bytes32[5] public m_hMerkleTreeRootsArray;\\n\\n\\t//Total number of UTXO\\u0027s at snapshot. Used for calculating bonus rewards.\\n  uint256 public constant m_nUTXOCountAtSnapshot = 85997439;\\n\\n  //Maximum number of redeemable coins at snapshot.\\n  uint256 public constant m_nMaxRedeemable = 21275254524468718;\\n\\n  //For Prosperous bonus we need to use the adjusted redeemable amount\\n  //That has the whale penalties applied (lowering claimable supply)\\n  uint256 public constant m_nAdjustedMaxRedeemable = 15019398043400000;\\n\\n\\t//Genesis Address\\n  address constant internal m_genesis = 0xb26165df612B1c9dc705B9872178B3F48151b24d;\\n\\n\\t//Eth Pool Genesis Address\\n\\taddress payable constant internal m_EthGenesis = 0xbe9CEF4196a835F29B117108460ed6fcA299b611;\\n\\n\\t//The public donation address for referrals\\n\\taddress payable constant internal m_publicReferralAddress = 0x8eAf4Fec503da352EB66Ef1E2f75C63e5bC635e1;\\n\\n  //Store the BTC ratios for BCH, BSV, ETH and LTC\\n  uint16[4] public m_blockchainRatios;\\n\\n  enum AddressType { LegacyUncompressed, LegacyCompressed, SegwitUncompressed, SegwitCompressed }\\n  enum BlockchainType { Bitcoin, BitcoinCash, BitcoinSV, Ethereum, Litecoin }\\n\\n\\t//Track how many tokens and UTXOs have been redeemed.\\n\\t//These are used for calculating bonus rewards.\\n  uint256 public m_nTotalRedeemed = 0;\\n  uint256 public m_nRedeemedCount = 0;\\n\\n  //Map of redeemed UTXOs to boolean (true/false if redeemed or not)\\n  mapping(uint8 =\\u003e mapping(bytes32 =\\u003e bool)) internal m_claimedUTXOsMap;\\n\\n  //Store the last day UpdateDailyData() was successfully executed\\n\\t//Starts at 14 to give a two week buffer after contract launch\\n  uint256 internal m_nLastUpdatedDay = 14;\\n\\n  //Daily data\\n  struct DailyDataStuct\\n\\t{\\n    uint256 nPayoutAmount;\\n    uint256 nTotalStakeShares;\\n\\t\\tuint256 nTotalEthStaked;\\n  }\\n\\n\\t//Map to store daily historical data.\\n  mapping(uint256 =\\u003e DailyDataStuct) public m_dailyDataMap;\\n\\n  //Stakes Storage\\n  struct StakeStruct\\n\\t{\\n    uint256 nAmountStaked;\\n    uint256 nSharesStaked;\\t//Get bonus shares for longer stake times\\n\\t\\tuint256 nCompoundedPayoutAccumulated;\\n    uint256 tLockTime;\\n    uint256 tEndStakeCommitTime;\\n\\t\\tuint256 tLastCompoundedUpdateTime;\\n    uint256 tTimeRemovedFromGlobalPool;\\n\\t\\tuint8 nVotedOnMultiplier;\\n\\t\\tbool bIsInGlobalPool;\\n    bool bIsLatePenaltyAlreadyPooled;\\n  }\\n\\n\\t//Eth Pool Stakes Storage\\n  struct EthStakeStruct\\n\\t{\\n    uint256 nAmount;\\n    uint256 nDay;\\n  }\\n\\n\\t//Map of addresses to StakeStructs.\\n  mapping(address =\\u003e StakeStruct[]) public m_staked;\\n\\n\\t//Map of addresses to ETH amount (in Wei) participating in the Eth pool\\n\\tmapping(address =\\u003e EthStakeStruct[]) public m_EthereumStakers;\\n\\n\\t//Accumulated early/late unstake penalties to go into next staker pool as rewards\\n  uint256 internal m_nEarlyAndLateUnstakePool;\\n\\n\\t//Track the number of staked tokens and shares\\n  uint256 public m_nTotalStakedTokens;\\n  uint256 public m_nTotalStakeShares;\\n\\n\\t//The daily amount of ETH in the ETH pool\\n\\tuint256 public m_nTotalEthStaked = 0;\\n\\n\\t//The latest interest multiplier voted on by the majority of the staker pool\\n  uint8 public m_nInterestMultiplier = 1;\\n\\n\\t//The number of stake shares voting for each interest multiplier\\n\\t//1 keeps the base 5% interest (minimum), 2 is 10%, ... 10 is 50% (maximum)\\n\\tmapping(uint8 =\\u003e uint256) public m_votingMultiplierMap;\\n\\n  //Maximum stake time allowed\\n  uint256 internal constant m_nMaxStakingTime = 365 days * 5;\\t//years is deprecated because of leap years\\n\\n\\t//Two week buffer window after launch before interest starts\\n\\tuint256 internal constant m_nClaimPhaseBufferDays = 14;\\n\\n\\tuint256 public m_nLastEthWithdrawalTime = 0;\\n\\n\\tbool internal m_bHasAirdroppedExchanges = false;\\n\\n\\taddress[12] internal m_exchangeAirdropAddresses;\\n\\tuint256[12] internal m_exchangeAirdropAmounts;\\n}\\n\"},\"CereneumImplementation.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./CereneumData.sol\\\";\\n\\ncontract CereneumImplementation is CereneumData\\n{\\n\\tusing SafeMath for uint256;\\n\\n\\t//Events\\n  event ClaimEvent(\\n    uint256 nOriginalClaimAmount,\\n    uint256 nAmountGranted,\\n    uint256 nBonuses,\\n\\t\\tuint256 nPenalties,\\n    bool bWasReferred\\n  );\\n\\n  event StartStakeEvent(\\n    uint256 nAmount,\\n    uint256 nDays\\n  );\\n\\n\\tevent CompoundInterestEvent(\\n\\t\\tuint256 nInterestCompounded\\n\\t);\\n\\n  event EndStakeEvent(\\n    uint256 nPrincipal,\\n    uint256 nPayout,\\n    uint256 nDaysServed,\\n    uint256 nPenalty,\\n    uint256 nStakeShares,\\n    uint256 nDaysCommitted\\n  );\\n\\n  event EndStakeForAFriendEvent(\\n    uint256 nShares,\\n    uint256 tStakeEndTimeCommit\\n  );\\n\\n\\tevent StartEthStakeEvent(\\n    uint256 nEthAmount\\n  );\\n\\n\\tevent EndEthStakeEvent(\\n    uint256 nPayout\\n  );\\n\\n\\t/// @dev Returns the number of current stakes for given address.\\n\\t///\\t@param a_address Address of stake to lookup\\n\\t///\\t@return The number of stakes.\\n\\tfunction GetNumberOfStakes(\\n\\t\\taddress a_address\\n\\t)\\n\\texternal view returns (uint256)\\n\\t{\\n\\t\\treturn m_staked[a_address].length;\\n\\t}\\n\\n\\t/// @dev Returns the number of current Eth pool stakes for given address.\\n\\t///\\t@param a_address Address of stake to lookup\\n\\t///\\t@return The number of stakes.\\n\\tfunction GetNumberOfEthPoolStakes(\\n\\t\\taddress a_address\\n\\t)\\n\\texternal view returns (uint256)\\n\\t{\\n\\t\\treturn m_EthereumStakers[a_address].length;\\n\\t}\\n\\n  /// @dev Returns the timestamp until the next daily update\\n\\t///\\t@return The time until the next daily update.\\n\\tfunction GetTimeUntilNextDailyUpdate() external view returns (uint256)\\n\\t{\\n    uint256 nDay = 1 days;\\n\\t\\treturn nDay.sub((block.timestamp.sub(m_tContractLaunchTime)).mod(1 days));\\n\\t}\\n\\n\\t/// @dev Calculates difference between 2 timestamps in days\\n \\t/// @param a_nStartTime beginning timestamp\\n  /// @param a_nEndTime ending timestamp\\n  /// @return Difference between timestamps in days\\n  function DifferenceInDays(\\n    uint256 a_nStartTime,\\n    uint256 a_nEndTime\\n  ) public pure returns (uint256)\\n\\t{\\n    return (a_nEndTime.sub(a_nStartTime).div(1 days));\\n  }\\n\\n  /// @dev Calculates the number of days since contract launch for a given timestamp.\\n  /// @param a_tTimestamp Timestamp to calculate from\\n  /// @return Number of days into contract\\n  function TimestampToDaysSinceLaunch(\\n    uint256 a_tTimestamp\\n  ) public view returns (uint256)\\n\\t{\\n    return (a_tTimestamp.sub(m_tContractLaunchTime).div(1 days));\\n  }\\n\\n  /// @dev Gets the number of days since the launch of the contract\\n  /// @return Number of days since contract launch\\n  function DaysSinceLaunch() public view returns (uint256)\\n\\t{\\n    return (TimestampToDaysSinceLaunch(block.timestamp));\\n  }\\n\\n  /// @dev Checks if we\\u0027re still in the claimable phase (first 52 weeks)\\n  /// @return Boolean on if we are still in the claimable phase\\n  function IsClaimablePhase() public view returns (bool)\\n\\t{\\n    return (DaysSinceLaunch() \\u003c 364);\\n  }\\n\\n\\t/// @dev Starts a 1 day stake in the ETH pool. Requires minimum of 0.01 ETH\\n\\tfunction StartEthStake() external payable\\n\\t{\\n\\t\\t//Require the minimum value for staking\\n\\t\\trequire(msg.value \\u003e= 0.01 ether, \\\"ETH Sent not above minimum value\\\");\\n\\n\\t\\trequire(DaysSinceLaunch() \\u003e= m_nClaimPhaseBufferDays, \\\"Eth Pool staking doesn\\u0027t begin until after the buffer window\\\");\\n\\n\\t\\tUpdateDailyData();\\n\\n\\t\\tm_EthereumStakers[msg.sender].push(\\n      EthStakeStruct(\\n        msg.value, // Ethereum staked\\n\\t\\t\\t\\tDaysSinceLaunch()\\t//Day staked\\n      )\\n    );\\n\\n\\t\\temit StartEthStakeEvent(\\n      msg.value\\n    );\\n\\n\\t\\tm_nTotalEthStaked = m_nTotalEthStaked.add(msg.value);\\n  }\\n\\n\\t/// @dev The default function\\n\\tfunction() external payable\\n\\t{\\n\\n  }\\n\\n\\t/// @dev Withdraw CER from the Eth pool after stake has completed\\n \\t/// @param a_nIndex The index of the stake to be withdrawn\\n\\tfunction WithdrawFromEthPool(uint256 a_nIndex) external\\n\\t{\\n\\t\\t//Require that the stake index doesn\\u0027t go out of bounds\\n\\t\\trequire(m_EthereumStakers[msg.sender].length \\u003e a_nIndex, \\\"Eth stake does not exist\\\");\\n\\n\\t\\tUpdateDailyData();\\n\\n\\t\\tuint256 nDay = m_EthereumStakers[msg.sender][a_nIndex].nDay;\\n\\n\\t\\trequire(nDay \\u003c DaysSinceLaunch(), \\\"Must wait until next day to withdraw\\\");\\n\\n\\t\\tuint256 nAmount = m_EthereumStakers[msg.sender][a_nIndex].nAmount;\\n\\n\\t\\tuint256 nPayoutAmount = m_dailyDataMap[nDay].nPayoutAmount.div(10);\\t//10%\\n\\n\\t\\tuint256 nEthPoolPayout = nPayoutAmount.mul(nAmount)\\n\\t\\t\\t.div(m_dailyDataMap[nDay].nTotalEthStaked);\\n\\n\\t\\t_mint(msg.sender, nEthPoolPayout);\\n\\n\\t\\temit EndEthStakeEvent(\\n      nEthPoolPayout\\n    );\\n\\n\\t\\tuint256 nEndingIndex = m_EthereumStakers[msg.sender].length.sub(1);\\n\\n    //Only copy if we aren\\u0027t removing the last index\\n    if(nEndingIndex != a_nIndex)\\n    {\\n      //Copy last stake in array over stake we are removing\\n      m_EthereumStakers[msg.sender][a_nIndex] = m_EthereumStakers[msg.sender][nEndingIndex];\\n    }\\n\\n    //Lower array length by 1\\n    m_EthereumStakers[msg.sender].length = nEndingIndex;\\n\\t}\\n\\n\\t/// @dev Transfers ETH in the contract to the genesis address\\n\\t/// Only callable once every 12 weeks.\\n\\tfunction TransferContractETH() external\\n  {\\n  \\trequire(address(this).balance != 0, \\\"No Eth to transfer\\\");\\n\\n\\t\\trequire(m_nLastEthWithdrawalTime.add(12 weeks) \\u003c= block.timestamp, \\\"Can only withdraw once every 3 months\\\");\\n\\n    m_EthGenesis.transfer(address(this).balance);\\n\\n\\t\\tm_nLastEthWithdrawalTime = block.timestamp;\\n  }\\n\\n\\t/// @dev Updates and stores the global interest for each day.\\n\\t/// Additionally adds the frenzy/prosperous bonuses and the Early/Late unstake penalties.\\n\\t/// This function gets called at the start of popular public functions to continuously update.\\n  function UpdateDailyData() public\\n\\t{\\n    for(m_nLastUpdatedDay; DaysSinceLaunch() \\u003e m_nLastUpdatedDay; m_nLastUpdatedDay++)\\n\\t\\t{\\n\\t\\t\\t//Gives 5% inflation per 365 days\\n      uint256 nPayoutRound = totalSupply().div(7300);\\n\\n      uint256 nUnclaimedCoins = 0;\\n    \\t//Frenzy/Prosperous bonuses and Unclaimed redistribution only available during claims phase.\\n      if(m_nLastUpdatedDay \\u003c 364)\\n\\t\\t\\t{\\n        nUnclaimedCoins = m_nMaxRedeemable.sub(m_nTotalRedeemed);\\n\\t\\t\\t\\tnUnclaimedCoins = GetRobinHoodMonthlyAmount(nUnclaimedCoins, m_nLastUpdatedDay);\\n\\n        nPayoutRound = nPayoutRound.add(nUnclaimedCoins);\\n\\n\\t\\t\\t\\t//Pay frenzy and Prosperous bonuses to genesis address\\n        _mint(m_genesis, nPayoutRound.mul(m_nRedeemedCount).div(m_nUTXOCountAtSnapshot)); // Frenzy\\n        _mint(m_genesis, nPayoutRound.mul(m_nTotalRedeemed).div(m_nAdjustedMaxRedeemable)); // Prosperous\\n\\n        nPayoutRound = nPayoutRound.add(\\n          //Frenzy bonus 0-100% based on total users claiming\\n          nPayoutRound.mul(m_nRedeemedCount).div(m_nUTXOCountAtSnapshot)\\n        ).add(\\n          //Prosperous bonus 0-100% based on size of claims\\n          nPayoutRound.mul(m_nTotalRedeemed).div(m_nAdjustedMaxRedeemable)\\n        );\\n      }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t//If we are not in the claimable phase anymore apply the voted on interest multiplier\\n\\n\\t\\t\\t\\t//First we need to check if there is a new \\\"most voted on\\\" multiplier\\n\\t\\t\\t\\tuint8 nVoteMultiplier = 1;\\n\\t\\t\\t\\tuint256 nVoteCount = m_votingMultiplierMap[1];\\n\\n\\t\\t\\t\\tfor(uint8 i=2; i \\u003c= 10; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(m_votingMultiplierMap[i] \\u003e nVoteCount)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnVoteCount = m_votingMultiplierMap[i];\\n\\t\\t\\t\\t\\t\\tnVoteMultiplier = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnPayoutRound = nPayoutRound.mul(nVoteMultiplier);\\n\\n\\t\\t\\t\\t//Store last interest multiplier for public viewing\\n\\t\\t\\t\\tm_nInterestMultiplier = nVoteMultiplier;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Add nPayoutRound to contract\\u0027s balance\\n\\t\\t\\t_mint(address(this), nPayoutRound.sub(nUnclaimedCoins));\\n\\n      //Add early and late unstake pool to payout round\\n\\t\\t\\tif(m_nEarlyAndLateUnstakePool != 0)\\n\\t\\t\\t{\\n      \\tnPayoutRound = nPayoutRound.add(m_nEarlyAndLateUnstakePool);\\n\\t\\t\\t\\t//Reset back to 0 for next day\\n      \\tm_nEarlyAndLateUnstakePool = 0;\\n\\t\\t\\t}\\n\\n    \\t//Store daily data\\n      m_dailyDataMap[m_nLastUpdatedDay] = DailyDataStuct(\\n        nPayoutRound,\\n        m_nTotalStakeShares,\\n\\t\\t\\t\\tm_nTotalEthStaked\\n      );\\n\\n\\t\\t\\tm_nTotalEthStaked = 0;\\n    }\\n  }\\n\\n  /// @dev Gets the circulating supply (total supply minus staked coins).\\n  /// @return Circulating Supply\\n  function GetCirculatingSupply() external view returns (uint256)\\n\\t{\\n    return totalSupply().sub(balanceOf(address(this)));\\n  }\\n\\n  /// @dev Verify a Merkle proof using the UTXO Merkle tree\\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\\n  /// @param a_hMerkleLeaf Merkle leaf hash that must be present in the UTXO Merkle tree\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Boolean on validity of proof\\n  function VerifyProof(\\n    bytes32[] memory a_hMerkleTreeBranches,\\n    bytes32 a_hMerkleLeaf,\\n    BlockchainType a_nWhichChain\\n  ) public view returns (bool)\\n\\t{\\n    require(uint8(a_nWhichChain) \\u003e= 0 \\u0026\\u0026 uint8(a_nWhichChain) \\u003c= 4, \\\"Invalid blockchain option\\\");\\n\\n    return MerkleProof.verify(a_hMerkleTreeBranches, m_hMerkleTreeRootsArray[uint8(a_nWhichChain)], a_hMerkleLeaf);\\n  }\\n\\n  /// @dev Validate the ECDSA parameters of signed message\\n  /// ECDSA public key associated with the specified Ethereum address\\n  /// @param a_addressClaiming Address within signed message\\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key\\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key\\n  /// @param a_v v parameter of ECDSA signature\\n  /// @param a_r r parameter of ECDSA signature\\n  /// @param a_s s parameter of ECDSA signature\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Boolean on if the signature is valid\\n  function ECDSAVerify(\\n    address a_addressClaiming,\\n    bytes32 a_publicKeyX,\\n    bytes32 a_publicKeyY,\\n    uint8 a_v,\\n    bytes32 a_r,\\n    bytes32 a_s,\\n    BlockchainType a_nWhichChain\\n  ) public pure returns (bool)\\n\\t{\\n    bytes memory addressAsHex = GenerateSignatureMessage(a_addressClaiming, a_nWhichChain);\\n\\n    bytes32 hHash;\\n    if(a_nWhichChain != BlockchainType.Ethereum)  //All Bitcoin chains and Litecoin do double sha256 hash\\n    {\\n      hHash = sha256(abi.encodePacked(sha256(abi.encodePacked(addressAsHex))));\\n    }\\n    else //Otherwise ETH\\n    {\\n      hHash = keccak256(abi.encodePacked(addressAsHex));\\n    }\\n\\n    return ValidateSignature(\\n      hHash,\\n      a_v,\\n      a_r,\\n      a_s,\\n      PublicKeyToEthereumAddress(a_publicKeyX, a_publicKeyY)\\n    );\\n  }\\n\\n  /// @dev Convert an uncompressed ECDSA public key into an Ethereum address\\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key\\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key\\n  /// @return Ethereum address generated from the ECDSA public key\\n  function PublicKeyToEthereumAddress(\\n    bytes32 a_publicKeyX,\\n    bytes32 a_publicKeyY\\n  ) public pure returns (address)\\n\\t{\\n\\t\\tbytes32 hash = keccak256(abi.encodePacked(a_publicKeyX, a_publicKeyY));\\n    return address(uint160(uint256((hash))));\\n  }\\n\\n  /// @dev Calculate the Bitcoin-style address associated with an ECDSA public key\\n  /// @param a_publicKeyX First half of ECDSA public key\\n  /// @param a_publicKeyY Second half of ECDSA public key\\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address and if it was compressed\\n  /// @return Raw Bitcoin address\\n  function PublicKeyToBitcoinAddress(\\n    bytes32 a_publicKeyX,\\n    bytes32 a_publicKeyY,\\n    AddressType a_nAddressType\\n  ) public pure returns (bytes20)\\n\\t{\\n    bytes20 publicKey;\\n    uint8 initialByte;\\n    if(a_nAddressType == AddressType.LegacyCompressed || a_nAddressType == AddressType.SegwitCompressed)\\n\\t\\t{\\n      //Hash the compressed format\\n      initialByte = (uint256(a_publicKeyY) \\u0026 1) == 0 ? 0x02 : 0x03;\\n      publicKey = ripemd160(abi.encodePacked(sha256(abi.encodePacked(initialByte, a_publicKeyX))));\\n    }\\n\\t\\telse\\n\\t\\t{\\n      //Hash the uncompressed format\\n      initialByte = 0x04;\\n      publicKey = ripemd160(abi.encodePacked(sha256(abi.encodePacked(initialByte, a_publicKeyX, a_publicKeyY))));\\n    }\\n\\n    if(a_nAddressType == AddressType.LegacyUncompressed || a_nAddressType == AddressType.LegacyCompressed)\\n    {\\n      return publicKey;\\n    }\\n    else if(a_nAddressType == AddressType.SegwitUncompressed || a_nAddressType == AddressType.SegwitCompressed)\\n    {\\n      return ripemd160(abi.encodePacked(sha256(abi.encodePacked(hex\\\"0014\\\", publicKey))));\\n    }\\n  }\\n\\n  /// @dev Appends an Ethereum address onto the expected string for a Bitcoin signed message\\n  /// @param a_address Ethereum address\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Correctly formatted message for bitcoin signing\\n\\tfunction GenerateSignatureMessage(\\n    address a_address,\\n    BlockchainType a_nWhichChain\\n  ) public pure returns(bytes memory)\\n\\t{\\n\\t\\tbytes16 hexDigits = \\\"0123456789abcdef\\\";\\n\\t\\tbytes memory prefix;\\n    uint8 nPrefixLength = 0;\\n\\n    //One of the bitcoin chains\\n    if(a_nWhichChain \\u003e= BlockchainType.Bitcoin \\u0026\\u0026 a_nWhichChain \\u003c= BlockchainType.BitcoinSV)\\n    {\\n      nPrefixLength = 46;\\n      prefix = new bytes(nPrefixLength);\\n      prefix = \\\"\\\\x18Bitcoin Signed Message:\\\\n\\\\x3CClaim_Cereneum_to_0x\\\";\\n    }\\n    else if(a_nWhichChain == BlockchainType.Ethereum) //Ethereum chain\\n    {\\n      nPrefixLength = 48;\\n      prefix = new bytes(nPrefixLength);\\n      prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n60Claim_Cereneum_to_0x\\\";\\n    }\\n    else  //Otherwise LTC\\n    {\\n      nPrefixLength = 47;\\n      prefix = new bytes(nPrefixLength);\\n      prefix = \\\"\\\\x19Litecoin Signed Message:\\\\n\\\\x3CClaim_Cereneum_to_0x\\\";\\n    }\\n\\n\\t\\tbytes20 addressBytes = bytes20(a_address);\\n\\t\\tbytes memory message = new bytes(nPrefixLength + 40);\\n\\t\\tuint256 nOffset = 0;\\n\\n\\t\\tfor(uint i = 0; i \\u003c nPrefixLength; i++)\\n\\t\\t{\\n    \\tmessage[nOffset++] = prefix[i];\\n    }\\n\\n\\t\\tfor(uint i = 0; i \\u003c 20; i++)\\n\\t\\t{\\n      message[nOffset++] = hexDigits[uint256(uint8(addressBytes[i] \\u003e\\u003e 4))];\\n      message[nOffset++] = hexDigits[uint256(uint8(addressBytes[i] \\u0026 0x0f))];\\n    }\\n\\n\\t\\treturn message;\\n\\t}\\n\\n  /// @dev Validate ECSDA signature was signed by the specified address\\n  /// @param a_hash Hash of signed data\\n  /// @param a_v v parameter of ECDSA signature\\n  /// @param a_r r parameter of ECDSA signature\\n  /// @param a_s s parameter of ECDSA signature\\n  /// @param a_address Ethereum address matching the signature\\n  /// @return Boolean on if the signature is valid\\n  function ValidateSignature(\\n    bytes32 a_hash,\\n    uint8 a_v,\\n    bytes32 a_r,\\n    bytes32 a_s,\\n    address a_address\\n  ) public pure returns (bool)\\n\\t{\\n    return ecrecover(\\n      a_hash,\\n      a_v,\\n      a_r,\\n      a_s\\n    ) == a_address;\\n  }\\n\\n  /// @dev Verify that a UTXO with the Merkle leaf hash can be claimed\\n  /// @param a_hMerkleLeafHash Merkle tree hash of the UTXO to be checked\\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Boolean on if the UTXO from the given hash can be redeemed\\n  function CanClaimUTXOHash(\\n    bytes32 a_hMerkleLeafHash,\\n    bytes32[] memory a_hMerkleTreeBranches,\\n    BlockchainType a_nWhichChain\\n  ) public view returns (bool)\\n\\t{\\n    //Check that the UTXO has not yet been redeemed and that it exists in the Merkle tree\\n    return(\\n\\t\\t\\t(m_claimedUTXOsMap[uint8(a_nWhichChain)][a_hMerkleLeafHash] == false) \\u0026\\u0026 VerifyProof(a_hMerkleTreeBranches, a_hMerkleLeafHash, a_nWhichChain)\\n    );\\n  }\\n\\n  /// @dev Check if address can make a claim\\n  /// @param a_addressRedeeming Raw Bitcoin address (no base58-check encoding)\\n  /// @param a_nAmount Amount of UTXO to redeem\\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Boolean on if the UTXO can be redeemed\\n  function CanClaim(\\n    bytes20 a_addressRedeeming,\\n    uint256 a_nAmount,\\n    bytes32[] memory a_hMerkleTreeBranches,\\n    BlockchainType a_nWhichChain\\n  ) public view returns (bool)\\n\\t{\\n    //Calculate the hash of the Merkle leaf associated with this UTXO\\n    bytes32 hMerkleLeafHash = keccak256(\\n      abi.encodePacked(\\n        a_addressRedeeming,\\n        a_nAmount\\n      )\\n    );\\n\\n    //Check if it can be redeemed\\n    return CanClaimUTXOHash(hMerkleLeafHash, a_hMerkleTreeBranches, a_nWhichChain);\\n  }\\n\\n\\t/// @dev Calculates the monthly Robin Hood reward\\n  /// @param a_nAmount The amount to calculate from\\n  /// @param a_nDaysSinceLaunch The number of days since contract launch\\n  /// @return The amount after applying monthly Robin Hood calculation\\n\\tfunction GetRobinHoodMonthlyAmount(uint256 a_nAmount, uint256 a_nDaysSinceLaunch) public pure returns (uint256)\\n\\t{\\n\\t\\tuint256 nScaledAmount = a_nAmount.mul(1000000000000);\\n\\t\\tuint256 nScalar = 400000000000000;\\t// 0.25%\\n\\t\\t//Month 1 - 0.25% late penalty\\n\\t\\tif(a_nDaysSinceLaunch \\u003c 43)\\n\\t\\t{\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 2 - Additional 0.5% penalty\\n\\t\\t// 0.25% + 0.5% = .75%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 72)\\n\\t\\t{\\n\\t\\t\\tnScalar = 200000000000000;\\t// 0.5%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 3 - Additional 0.75% penalty\\n\\t\\t// 0.25% + 0.5% + .75% = 1.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 101)\\n\\t\\t{\\n\\t\\t\\tnScalar = 133333333333333;\\t// 0.75%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 4 - Additional 1.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% = 3%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 130)\\n\\t\\t{\\n\\t\\t\\tnScalar = 66666666666666;\\t// 1.5%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 5 - Additional 3%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% = 6%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 159)\\n\\t\\t{\\n\\t\\t\\tnScalar = 33333333333333;\\t// 3%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 6 - Additional 6%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% = 12%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 188)\\n\\t\\t{\\n\\t\\t\\tnScalar = 16666666666666;\\t// 6%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 7 - Additional 8%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% = 20%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 217)\\n\\t\\t{\\n\\t\\t\\tnScalar = 12499999999999;\\t// 8%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 8 - Additional 10%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% = 30%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 246)\\n\\t\\t{\\n\\t\\t\\tnScalar = 10000000000000;\\t// 10%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 9 - Additional 12.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% = 42.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 275)\\n\\t\\t{\\n\\t\\t\\tnScalar = 7999999999999;\\t// 12.5%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 10 - Additional 15%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% = 57.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 304)\\n\\t\\t{\\n\\t\\t\\tnScalar = 6666666666666;\\t// 15%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 11 - Additional 17.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% = 75%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 334)\\n\\t\\t{\\n\\t\\t\\tnScalar = 5714285714290;\\t// 17.5%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(30));\\n\\t\\t}\\n\\t\\t//Month 12 - Additional 25%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% + 25% = 100%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 364)\\n\\t\\t{\\n\\t\\t\\tnScalar = 4000000000000;\\t// 25%\\n\\t\\t\\treturn nScaledAmount.div(nScalar.mul(30));\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Calculates the monthly late penalty\\n  /// @param a_nAmount The amount to calculate from\\n  /// @param a_nDaysSinceLaunch The number of days since contract launch\\n  /// @return The amount after applying monthly late penalty\\n\\tfunction GetMonthlyLatePenalty(uint256 a_nAmount, uint256 a_nDaysSinceLaunch) public pure returns (uint256)\\n\\t{\\n\\t\\tif(a_nDaysSinceLaunch \\u003c= m_nClaimPhaseBufferDays)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 nScaledAmount = a_nAmount.mul(1000000000000);\\n\\t\\tuint256 nPreviousMonthPenalty = 0;\\n\\t\\tuint256 nScalar = 400000000000000;\\t// 0.25%\\n\\t\\t//Month 1 - 0.25% late penalty\\n\\t\\tif(a_nDaysSinceLaunch \\u003c= 43)\\n\\t\\t{\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(14);\\n\\t\\t\\treturn nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t}\\n\\t\\t//Month 2 - Additional 0.5% penalty\\n\\t\\t// 0.25% + 0.5% = .75%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 72)\\n\\t\\t{\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(43);\\n\\t\\t\\tnScalar = 200000000000000;\\t// 0.5%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 3 - Additional 0.75% penalty\\n\\t\\t// 0.25% + 0.5% + .75% = 1.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 101)\\n\\t\\t{\\n\\t\\t\\tnScalar = 133333333333333;\\t// 0.75%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(72);\\n\\t\\t\\tnScalar = 133333333333333;\\t// 0.75%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 4 - Additional 1.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% = 3%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 130)\\n\\t\\t{\\n\\t\\t\\tnScalar = 66666666666666;\\t// 1.5%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(101);\\n\\t\\t\\tnScalar = 66666666666666;\\t// 1.5%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 5 - Additional 3%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% = 6%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 159)\\n\\t\\t{\\n\\t\\t\\tnScalar = 33333333333333;\\t// 3%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(130);\\n\\t\\t\\tnScalar = 33333333333333;\\t// 3%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 6 - Additional 6%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% = 12%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 188)\\n\\t\\t{\\n\\t\\t\\tnScalar = 16666666666666;\\t// 6%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(159);\\n\\t\\t\\tnScalar = 16666666666666;\\t// 6%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 7 - Additional 8%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% = 20%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 217)\\n\\t\\t{\\n\\t\\t\\tnScalar = 8333333333333;\\t// 12%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(188);\\n\\t\\t\\tnScalar = 12499999999999;\\t// 8%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 8 - Additional 10%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% = 30%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 246)\\n\\t\\t{\\n\\t\\t\\tnScalar = 5000000000000;\\t// 20%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(217);\\n\\t\\t\\tnScalar = 10000000000000;\\t// 10%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 9 - Additional 12.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% = 42.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 275)\\n\\t\\t{\\n\\t\\t\\tnScalar = 3333333333333;\\t// 30%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(246);\\n\\t\\t\\tnScalar = 7999999999999;\\t// 12.5%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 10 - Additional 15%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% = 57.5%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 304)\\n\\t\\t{\\n\\t\\t\\tnScalar = 2352941176472;\\t// 42.5%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(275);\\n\\t\\t\\tnScalar = 6666666666666;\\t// 15%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 11 - Additional 17.5%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% = 75%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c= 334)\\n\\t\\t{\\n\\t\\t\\tnScalar = 1739130434782;\\t// 57.5%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(304);\\n\\t\\t\\tnScalar = 5714285714290;\\t// 17.5%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(30));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\t//Month 12 - Additional 25%\\n\\t\\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% + 25% = 100%\\n\\t\\telse if(a_nDaysSinceLaunch \\u003c 364)\\n\\t\\t{\\n\\t\\t\\tnScalar = 1333333333333;\\t// 75%\\n\\t\\t\\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\\n\\t\\t\\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(334);\\n\\t\\t\\tnScalar = 4000000000000;\\t// 25%\\n\\t\\t\\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(30));\\n\\t\\t\\treturn nScaledAmount.add(nPreviousMonthPenalty);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn a_nAmount;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns claim amount with deduction based on weeks since contract launch.\\n\\t/// @param a_nAmount Amount of claim from UTXO\\n\\t/// @return Amount after any late penalties\\n\\tfunction GetLateClaimAmount(uint256 a_nAmount) internal view returns (uint256)\\n\\t{\\n\\t\\tuint256 nDaysSinceLaunch = DaysSinceLaunch();\\n\\n\\t\\treturn a_nAmount.sub(GetMonthlyLatePenalty(a_nAmount, nDaysSinceLaunch));\\n\\t}\\n\\n  /// @dev Calculates speed bonus for claiming early\\n  /// @param a_nAmount Amount of claim from UTXO\\n  /// @return Speed bonus amount\\n  function GetSpeedBonus(uint256 a_nAmount) internal view returns (uint256)\\n\\t{\\n\\t\\tuint256 nDaysSinceLaunch = DaysSinceLaunch();\\n\\n\\t\\t//We give a two week buffer after contract launch before penalties\\n\\t\\tif(nDaysSinceLaunch \\u003c m_nClaimPhaseBufferDays)\\n\\t\\t{\\n\\t\\t\\tnDaysSinceLaunch = 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnDaysSinceLaunch = nDaysSinceLaunch.sub(m_nClaimPhaseBufferDays);\\n\\t\\t}\\n\\n    uint256 nMaxDays = 350;\\n    a_nAmount = a_nAmount.div(5);\\n    return a_nAmount.mul(nMaxDays.sub(nDaysSinceLaunch)).div(nMaxDays);\\n  }\\n\\n\\t/// @dev Gets the redeem amount with the blockchain ratio applied.\\n\\t/// @param a_nAmount Amount of UTXO in satoshis\\n\\t/// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Amount with blockchain ratio applied\\n\\tfunction GetRedeemRatio(uint256 a_nAmount, BlockchainType a_nWhichChain) internal view returns (uint256)\\n\\t{\\n\\t\\tif(a_nWhichChain != BlockchainType.Bitcoin)\\n\\t\\t{\\n\\t\\t\\tuint8 nWhichChain = uint8(a_nWhichChain);\\n\\t\\t\\t--nWhichChain;\\n\\n\\t\\t\\t//Many zeros to avoid rounding errors\\n\\t\\t\\tuint256 nScalar = 100000000000000000;\\n\\n\\t\\t\\tuint256 nRatio = nScalar.div(m_blockchainRatios[nWhichChain]);\\n\\n\\t\\t\\ta_nAmount = a_nAmount.mul(1000000000000).div(nRatio);\\n\\t\\t}\\n\\n\\t\\treturn a_nAmount;\\n\\t}\\n\\n  /// @dev Gets the redeem amount and bonuses based on time since contract launch\\n  /// @param a_nAmount Amount of UTXO in satoshis\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @return Claim amount, bonuses and penalty\\n  function GetRedeemAmount(uint256 a_nAmount, BlockchainType a_nWhichChain) public view returns (uint256, uint256, uint256)\\n\\t{\\n    a_nAmount = GetRedeemRatio(a_nAmount, a_nWhichChain);\\n\\n    uint256 nAmount = GetLateClaimAmount(a_nAmount);\\n    uint256 nBonus = GetSpeedBonus(a_nAmount);\\n\\n    return (nAmount, nBonus, a_nAmount.sub(nAmount));\\n  }\\n\\n\\t/// @dev Verify claim ownership from signed message\\n\\t/// @param a_nAmount Amount of UTXO claim\\n\\t/// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\\n\\t/// @param a_addressClaiming Ethereum address within signed message\\n\\t/// @param a_pubKeyX First half of uncompressed ECDSA public key from signed message\\n\\t/// @param a_pubKeyY Second half of uncompressed ECDSA public key from signed message\\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address\\n\\t/// @param a_v v parameter of ECDSA signature\\n\\t/// @param a_r r parameter of ECDSA signature\\n\\t/// @param a_s s parameter of ECDSA signature\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  function ValidateOwnership(\\n    uint256 a_nAmount,\\n    bytes32[] memory a_hMerkleTreeBranches,\\n    address a_addressClaiming,\\n    bytes32 a_pubKeyX,\\n    bytes32 a_pubKeyY,\\n    AddressType a_nAddressType,\\n    uint8 a_v,\\n    bytes32 a_r,\\n    bytes32 a_s,\\n    BlockchainType a_nWhichChain\\n  ) internal\\n\\t{\\n    //Calculate the UTXO Merkle leaf hash for the correct chain\\n    bytes32 hMerkleLeafHash;\\n    if(a_nWhichChain != BlockchainType.Ethereum)  //All Bitcoin chains and Litecoin have the same raw address format\\n    {\\n      hMerkleLeafHash = keccak256(abi.encodePacked(PublicKeyToBitcoinAddress(a_pubKeyX, a_pubKeyY, a_nAddressType), a_nAmount));\\n    }\\n    else //Otherwise ETH\\n    {\\n      hMerkleLeafHash = keccak256(abi.encodePacked(PublicKeyToEthereumAddress(a_pubKeyX, a_pubKeyY), a_nAmount));\\n    }\\n\\n    //Require that the UTXO can be redeemed\\n    require(CanClaimUTXOHash(hMerkleLeafHash, a_hMerkleTreeBranches, a_nWhichChain), \\\"UTXO Cannot be redeemed.\\\");\\n\\n    //Verify the ECDSA parameters match the signed message\\n    require(\\n      ECDSAVerify(\\n        a_addressClaiming,\\n        a_pubKeyX,\\n        a_pubKeyY,\\n        a_v,\\n        a_r,\\n        a_s,\\n        a_nWhichChain\\n      ),\\n\\t\\t\\t\\\"ECDSA verification failed.\\\"\\n    );\\n\\n    //Save the UTXO as redeemed in the global map\\n    m_claimedUTXOsMap[uint8(a_nWhichChain)][hMerkleLeafHash] = true;\\n  }\\n\\n  /// @dev Claim tokens from a UTXO at snapshot block\\n  /// granting CER tokens proportional to amount of UTXO.\\n  /// BCH, BSV, ETH \\u0026 LTC chains get proportional BTC ratio awards.\\n  /// @param a_nAmount Amount of UTXO\\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\\n  /// @param a_addressClaiming The Ethereum address for the claimed CER tokens to be sent to\\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key from UTXO\\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key from UTXO\\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address and if it was compressed\\n  /// @param a_v v parameter of ECDSA signature\\n  /// @param a_r r parameter of ECDSA signature\\n  /// @param a_s s parameter of ECDSA signature\\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\\n  /// @param a_referrer Optional address of referrer. Address(0) for no referral\\n  /// @return The number of tokens redeemed, if successful\\n  function Claim(\\n    uint256 a_nAmount,\\n    bytes32[] memory a_hMerkleTreeBranches,\\n    address a_addressClaiming,\\n    bytes32 a_publicKeyX,\\n    bytes32 a_publicKeyY,\\n    AddressType a_nAddressType,\\n    uint8 a_v,\\n    bytes32 a_r,\\n    bytes32 a_s,\\n    BlockchainType a_nWhichChain,\\n    address a_referrer\\n  ) public returns (uint256)\\n\\t{\\n    //No claims after the first 50 weeks of contract launch\\n    require(IsClaimablePhase(), \\\"Claim is outside of claims period.\\\");\\n\\n    require(uint8(a_nWhichChain) \\u003e= 0 \\u0026\\u0026 uint8(a_nWhichChain) \\u003c= 4, \\\"Incorrect blockchain value.\\\");\\n\\n    require(a_v \\u003c= 30 \\u0026\\u0026 a_v \\u003e= 27, \\\"V parameter is invalid.\\\");\\n\\n    ValidateOwnership(\\n      a_nAmount,\\n      a_hMerkleTreeBranches,\\n      a_addressClaiming,\\n      a_publicKeyX,\\n      a_publicKeyY,\\n      a_nAddressType,\\n      a_v,\\n      a_r,\\n      a_s,\\n      a_nWhichChain\\n    );\\n\\n    UpdateDailyData();\\n\\n    m_nTotalRedeemed = m_nTotalRedeemed.add(GetRedeemRatio(a_nAmount, a_nWhichChain));\\n\\n    (uint256 nTokensRedeemed, uint256 nBonuses, uint256 nPenalties) = GetRedeemAmount(a_nAmount, a_nWhichChain);\\n\\n\\t\\t//Transfer coins from contracts wallet to claim wallet\\n    _transfer(address(this), a_addressClaiming, nTokensRedeemed);\\n\\n    //Mint speed bonus to claiming address\\n    _mint(a_addressClaiming, nBonuses);\\n\\t\\t//Speed bonus matched for genesis address\\n    _mint(m_genesis, nBonuses);\\n\\n    m_nRedeemedCount = m_nRedeemedCount.add(1);\\n\\n    if(a_referrer != address(0))\\n\\t\\t{\\n\\t\\t\\t//Grant 10% bonus token to the person being referred\\n\\t\\t\\t_mint(a_addressClaiming, nTokensRedeemed.div(10));\\n\\t\\t\\tnBonuses = nBonuses.add(nTokensRedeemed.div(10));\\n\\n      //Grant 20% bonus of tokens to referrer\\n      _mint(a_referrer, nTokensRedeemed.div(5));\\n\\n\\t\\t\\t//Match referral bonus for genesis address (20% for referral and 10% for claimer referral = 30%)\\n      _mint(m_genesis, nTokensRedeemed.mul(1000000000000).div(3333333333333));\\n    }\\n\\n    emit ClaimEvent(\\n      a_nAmount,\\n      nTokensRedeemed,\\n      nBonuses,\\n\\t\\t\\tnPenalties,\\n      a_referrer != address(0)\\n    );\\n\\n    //Return the number of tokens redeemed\\n    return nTokensRedeemed.add(nBonuses);\\n  }\\n\\n  /// @dev Calculates stake payouts for a given stake\\n  /// @param a_nStakeShares Number of shares to calculate payout for\\n  /// @param a_tLockTime Starting timestamp of stake\\n  /// @param a_tEndTime Ending timestamp of stake\\n  /// @return payout amount\\n  function CalculatePayout(\\n    uint256 a_nStakeShares,\\n    uint256 a_tLockTime,\\n    uint256 a_tEndTime\\n  ) public view returns (uint256)\\n\\t{\\n\\t\\tif(m_nLastUpdatedDay == 0)\\n\\t\\t\\treturn 0;\\n\\n    uint256 nPayout = 0;\\n\\n\\t\\tuint256 tStartDay = TimestampToDaysSinceLaunch(a_tLockTime);\\n\\n    //Calculate what day stake was closed\\n    uint256 tEndDay = TimestampToDaysSinceLaunch(a_tEndTime);\\n\\n    //Iterate through each day and sum up the payout\\n    for(uint256 i = tStartDay; i \\u003c tEndDay; i++)\\n\\t\\t{\\n      uint256 nDailyPayout = m_dailyDataMap[i].nPayoutAmount.mul(a_nStakeShares)\\n        .div(m_dailyDataMap[i].nTotalStakeShares);\\n\\n      //Keep sum of payouts\\n      nPayout = nPayout.add(nDailyPayout);\\n    }\\n\\n    return nPayout;\\n  }\\n\\n  /// @dev Updates current amount of stake to apply compounding interest\\n\\t/// @notice This applies all of your earned interest to future payout calculations\\n  /// @param a_nStakeIndex index of stake to compound interest for\\n  function CompoundInterest(\\n\\t\\tuint256 a_nStakeIndex\\n\\t) external\\n\\t{\\n\\t\\trequire(m_nLastUpdatedDay != 0, \\\"First update day has not finished.\\\");\\n\\n    //Get a reference to the stake to save gas from constant map lookups\\n    StakeStruct storage rStake = m_staked[msg.sender][a_nStakeIndex];\\n\\n\\t\\trequire(block.timestamp \\u003c rStake.tEndStakeCommitTime, \\\"Stake has already matured.\\\");\\n\\n\\t\\tUpdateDailyData();\\n\\n\\t\\tuint256 nInterestEarned = CalculatePayout(\\n\\t\\t\\trStake.nSharesStaked,\\n\\t\\t  rStake.tLastCompoundedUpdateTime,\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\n\\t\\tif(nInterestEarned != 0)\\n\\t\\t{\\n\\t\\t\\trStake.nCompoundedPayoutAccumulated = rStake.nCompoundedPayoutAccumulated.add(nInterestEarned);\\n\\t\\t\\trStake.nSharesStaked = rStake.nSharesStaked.add(nInterestEarned);\\n\\n\\t\\t\\t//InterestRateMultiplier votes\\n\\t\\t\\tm_votingMultiplierMap[rStake.nVotedOnMultiplier] = m_votingMultiplierMap[rStake.nVotedOnMultiplier].add(nInterestEarned);\\n\\n\\t\\t\\tm_nTotalStakeShares = m_nTotalStakeShares.add(nInterestEarned);\\n\\t\\t\\trStake.tLastCompoundedUpdateTime = block.timestamp;\\n\\n\\t\\t\\temit CompoundInterestEvent(\\n\\t\\t\\t\\tnInterestEarned\\n\\t\\t\\t);\\n\\t\\t}\\n  }\\n\\n  /// @dev Starts a stake\\n  /// @param a_nAmount Amount of token to stake\\n  /// @param a_nDays Number of days to stake\\n\\t/// @param a_nInterestMultiplierVote Pooled interest rate to vote for (1-10 =\\u003e 5%-50% interest)\\n  function StartStake(\\n    uint256 a_nAmount,\\n    uint256 a_nDays,\\n\\t\\tuint8 a_nInterestMultiplierVote\\n  ) external\\n\\t{\\n\\t\\trequire(DaysSinceLaunch() \\u003e= m_nClaimPhaseBufferDays, \\\"Staking doesn\\u0027t begin until after the buffer window\\\");\\n\\n    //Verify account has enough tokens\\n    require(balanceOf(msg.sender) \\u003e= a_nAmount, \\\"Not enough funds for stake.\\\");\\n\\n    //Don\\u0027t allow 0 amount stakes\\n    require(a_nAmount \\u003e 0, \\\"Stake amount must be greater than 0\\\");\\n\\n\\t\\trequire(a_nDays \\u003e= 7, \\\"Stake is under the minimum time required.\\\");\\n\\n\\t\\trequire(a_nInterestMultiplierVote \\u003e= 1 \\u0026\\u0026 a_nInterestMultiplierVote \\u003c= 10, \\\"Interest multiplier range is 1-10.\\\");\\n\\n\\t\\t//Calculate Unlock time\\n    uint256 tEndStakeCommitTime = block.timestamp.add(a_nDays.mul(1 days));\\n\\n    //Don\\u0027t allow stakes over the maximum stake time\\n    require(tEndStakeCommitTime \\u003c= block.timestamp.add(m_nMaxStakingTime), \\\"Stake time exceeds maximum.\\\");\\n\\n    UpdateDailyData();\\n\\n\\t\\t//Calculate bonus interest for longer stake periods (20% bonus per year)\\n\\t\\tuint256 nSharesModifier = 0;\\n\\n\\t\\t//Minimum stake time of 3 months to get amplifier bonus\\n\\t\\tif(a_nDays \\u003e= 90)\\n\\t\\t{\\n\\t\\t\\t//We can\\u0027t have a fractional modifier such as .5 so we need to use whole numbers and divide later\\n\\t\\t\\tnSharesModifier = a_nDays.mul(2000000).div(365);\\n\\t\\t}\\n\\n    //20% bonus shares per year of committed stake time\\n    uint256 nStakeShares = a_nAmount.add(a_nAmount.mul(nSharesModifier).div(10000000));\\n\\n    //Create and store the stake\\n    m_staked[msg.sender].push(\\n      StakeStruct(\\n        a_nAmount, // nAmountStaked\\n        nStakeShares, // nSharesStaked\\n\\t\\t\\t\\t0,\\t//Accumulated Payout from CompoundInterest\\n        block.timestamp, // tLockTime\\n        tEndStakeCommitTime, // tEndStakeCommitTime\\n\\t\\t\\t\\tblock.timestamp, //tLastCompoundedUpdateTime\\n        0, // tTimeRemovedFromGlobalPool\\n\\t\\t\\t\\ta_nInterestMultiplierVote,\\n\\t\\t\\t\\ttrue, // bIsInGlobalPool\\n        false // bIsLatePenaltyAlreadyPooled\\n      )\\n    );\\n\\n    emit StartStakeEvent(\\n      a_nAmount,\\n      a_nDays\\n    );\\n\\n\\t\\t//InterestRateMultiplier\\n\\t\\tm_votingMultiplierMap[a_nInterestMultiplierVote] = m_votingMultiplierMap[a_nInterestMultiplierVote].add(nStakeShares);\\n\\n    //Globally track staked tokens\\n    m_nTotalStakedTokens = m_nTotalStakedTokens.add(a_nAmount);\\n\\n    //Globally track staked shares\\n    m_nTotalStakeShares = m_nTotalStakeShares.add(nStakeShares);\\n\\n    //Transfer staked tokens to contract wallet\\n    _transfer(msg.sender, address(this), a_nAmount);\\n  }\\n\\n  /// @dev Calculates penalty for unstaking late\\n  /// @param a_tEndStakeCommitTime Timestamp stake matured\\n  /// @param a_tTimeRemovedFromGlobalPool Timestamp stake was removed from global pool\\n  /// @param a_nInterestEarned Interest earned from stake\\n  /// @return penalty value\\n  function CalculateLatePenalty(\\n    uint256 a_tEndStakeCommitTime,\\n    uint256 a_tTimeRemovedFromGlobalPool,\\n    uint256 a_nInterestEarned\\n  ) public pure returns (uint256)\\n\\t{\\n    uint256 nPenalty = 0;\\n\\n\\t\\t//One week grace period\\n    if(a_tTimeRemovedFromGlobalPool \\u003e a_tEndStakeCommitTime.add(1 weeks))\\n\\t\\t{\\n      //Penalty is 1% per day after the 1 week grace period\\n      uint256 nPenaltyPercent = DifferenceInDays(a_tEndStakeCommitTime.add(1 weeks), a_tTimeRemovedFromGlobalPool);\\n\\n\\t\\t\\t//Cap max percent at 100\\n\\t\\t\\tif(nPenaltyPercent \\u003e 100)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnPenaltyPercent = 100;\\n\\t\\t\\t}\\n\\n      //Calculate penalty\\n\\t\\t\\tnPenalty = a_nInterestEarned.mul(nPenaltyPercent).div(100);\\n    }\\n\\n    return nPenalty;\\n  }\\n\\n  /// @dev Calculates penalty for unstaking early\\n\\t/// @param a_tLockTime Starting timestamp of stake\\n  /// @param a_nEndStakeCommitTime Timestamp the stake matures\\n  /// @param a_nAmount Amount that was staked\\n\\t/// @param a_nInterestEarned Interest earned from stake\\n  /// @return penalty value\\n  function CalculateEarlyPenalty(\\n\\t\\tuint256 a_tLockTime,\\n\\t\\tuint256 a_nEndStakeCommitTime,\\n    uint256 a_nAmount,\\n\\t\\tuint256 a_nInterestEarned\\n  ) public view returns (uint256)\\n\\t{\\n    uint256 nPenalty = 0;\\n\\n    if(block.timestamp \\u003c a_nEndStakeCommitTime)\\n\\t\\t{\\n\\t\\t\\t//If they didn\\u0027t stake for at least 1 full day we give them no interest\\n\\t\\t\\t//To prevent any abuse\\n\\t\\t\\tif(DifferenceInDays(a_tLockTime, block.timestamp) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnPenalty = a_nInterestEarned;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Base penalty is half of earned interest\\n\\t\\t\\t\\tnPenalty = a_nInterestEarned.div(2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tuint256 nCommittedStakeDays = DifferenceInDays(a_tLockTime, a_nEndStakeCommitTime);\\n\\n\\t\\t\\tif(nCommittedStakeDays \\u003e= 90)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Take another 10% per year of committed stake\\n\\t\\t\\t\\tnPenalty = nPenalty.add(nPenalty.mul(nCommittedStakeDays).div(3650));\\n\\t\\t\\t}\\n\\n\\t\\t\\t//5% yearly interest converted to daily interest multiplied by stake time\\n\\t\\t\\tuint256 nMinimumPenalty = a_nAmount.mul(nCommittedStakeDays).div(7300);\\n\\n\\t\\t\\tif(nMinimumPenalty \\u003e nPenalty)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnPenalty = nMinimumPenalty;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    return nPenalty;\\n  }\\n\\n  /// @dev Removes completed stake from global pool\\n  /// @notice Removing finished stakes will increase the payout to other stakers.\\n  /// @param a_nStakeIndex Index of stake to process\\n\\t/// @param a_address Address of the staker\\n  function EndStakeForAFriend(\\n    uint256 a_nStakeIndex,\\n\\t\\taddress a_address\\n  ) external\\n\\t{\\n\\t\\t//Require that the stake index doesn\\u0027t go out of bounds\\n\\t\\trequire(m_staked[a_address].length \\u003e a_nStakeIndex, \\\"Stake does not exist\\\");\\n\\n    //Require that the stake has been matured\\n    require(block.timestamp \\u003e m_staked[a_address][a_nStakeIndex].tEndStakeCommitTime, \\\"Stake must be matured.\\\");\\n\\n\\t\\tProcessStakeEnding(a_nStakeIndex, a_address, true);\\n  }\\n\\n \\t/// @dev Ends a stake, even if it is before it has matured.\\n\\t/// @notice If stake has matured behavior is the same as EndStakeSafely\\n  /// @param a_nStakeIndex Index of stake to close\\n  function EndStakeEarly(\\n    uint256 a_nStakeIndex\\n  ) external\\n\\t{\\n\\t\\t//Require that the stake index doesn\\u0027t go out of bounds\\n\\t\\trequire(m_staked[msg.sender].length \\u003e a_nStakeIndex, \\\"Stake does not exist\\\");\\n\\n    ProcessStakeEnding(a_nStakeIndex, msg.sender, false);\\n  }\\n\\n  /// @dev Ends a stake safely. Will only execute if a stake is matured.\\n  /// @param a_nStakeIndex Index of stake to close\\n  function EndStakeSafely(\\n    uint256 a_nStakeIndex\\n  ) external\\n\\t{\\n\\t\\t//Require that the stake index doesn\\u0027t go out of bounds\\n\\t\\trequire(m_staked[msg.sender].length \\u003e a_nStakeIndex, \\\"Stake does not exist\\\");\\n\\n\\t\\t//Require that stake is matured\\n\\t\\trequire(block.timestamp \\u003e m_staked[msg.sender][a_nStakeIndex].tEndStakeCommitTime, \\\"Stake must be matured.\\\");\\n\\n    ProcessStakeEnding(a_nStakeIndex, msg.sender, false);\\n  }\\n\\n\\tfunction ProcessStakeEnding(\\n    uint256 a_nStakeIndex,\\n\\t\\taddress a_address,\\n\\t\\tbool a_bWasForAFriend\\n  ) internal\\n\\t{\\n\\t\\tUpdateDailyData();\\n\\n    //Get a reference to the stake to save gas from constant map lookups\\n    StakeStruct storage rStake = m_staked[a_address][a_nStakeIndex];\\n\\n    uint256 tEndTime = block.timestamp \\u003e rStake.tEndStakeCommitTime ?\\n\\t\\t\\trStake.tEndStakeCommitTime : block.timestamp;\\n\\n\\t\\t//Calculate Payout\\n\\t\\tuint256 nTotalPayout = CalculatePayout(\\n\\t\\t\\trStake.nSharesStaked,\\n\\t\\t\\trStake.tLastCompoundedUpdateTime,\\n\\t\\t\\ttEndTime\\n\\t\\t);\\n\\n\\t\\t//Add any accumulated interest payout from user calling CompoundInterest\\n\\t\\tnTotalPayout = nTotalPayout.add(rStake.nCompoundedPayoutAccumulated);\\n\\n\\t\\t//Add back the original amount staked\\n\\t\\tnTotalPayout = nTotalPayout.add(rStake.nAmountStaked);\\n\\n\\t\\t//Is stake still in the global pool?\\n\\t\\tif(rStake.bIsInGlobalPool)\\n\\t\\t{\\n\\t\\t\\t//Update global staked token tracking\\n\\t\\t\\tm_nTotalStakedTokens = m_nTotalStakedTokens.sub(rStake.nAmountStaked);\\n\\n\\t\\t\\t//Update global stake shares tracking\\n\\t\\t\\tm_nTotalStakeShares = m_nTotalStakeShares.sub(rStake.nSharesStaked);\\n\\n\\t\\t\\t//InterestRateMultiplier\\n\\t\\t\\tm_votingMultiplierMap[rStake.nVotedOnMultiplier] = m_votingMultiplierMap[rStake.nVotedOnMultiplier].sub(rStake.nSharesStaked);\\n\\n\\t\\t\\t//Set time removed\\n\\t\\t\\trStake.tTimeRemovedFromGlobalPool = block.timestamp;\\n\\n\\t\\t\\t//Set flag that it is no longer in the global pool\\n\\t\\t\\trStake.bIsInGlobalPool = false;\\n\\n\\t\\t\\tif(a_bWasForAFriend)\\n\\t\\t\\t{\\n\\t\\t\\t\\temit EndStakeForAFriendEvent(\\n\\t\\t\\t\\t\\trStake.nSharesStaked,\\n\\t\\t\\t\\t\\trStake.tEndStakeCommitTime\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//Calculate penalties if any\\n\\t\\tuint256 nPenalty = 0;\\n\\t\\tif(!a_bWasForAFriend)\\t//Can\\u0027t have an early penalty if it was called by EndStakeForAFriend\\n \\t\\t{\\n\\t\\t\\tnPenalty = CalculateEarlyPenalty(\\n\\t\\t\\t\\trStake.tLockTime,\\n\\t\\t\\t\\trStake.tEndStakeCommitTime,\\n\\t\\t\\t\\trStake.nAmountStaked,\\n\\t\\t\\t\\tnTotalPayout.sub(rStake.nAmountStaked)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t//Only calculate late penalty if there wasn\\u0027t an early penalty\\n\\t\\tif(nPenalty == 0)\\n\\t\\t{\\n\\t\\t\\tnPenalty = CalculateLatePenalty(\\n\\t\\t\\t\\trStake.tEndStakeCommitTime,\\n\\t\\t\\t\\trStake.tTimeRemovedFromGlobalPool,\\n\\t\\t\\t\\tnTotalPayout.sub(rStake.nAmountStaked)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t//Don\\u0027t payout penalty amount that has already been paid out\\n\\t\\tif(nPenalty != 0 \\u0026\\u0026 !rStake.bIsLatePenaltyAlreadyPooled)\\n\\t\\t{\\n\\t\\t\\t//Split penalty between genesis and pool\\n\\t\\t\\tm_nEarlyAndLateUnstakePool = m_nEarlyAndLateUnstakePool.add(nPenalty.div(2));\\n\\t\\t\\t_transfer(address(this), m_genesis, nPenalty.div(2));\\n\\t\\t}\\n\\n\\t\\tif(a_bWasForAFriend)\\n\\t\\t{\\n\\t\\t\\t//Set flag\\n\\t\\t\\trStake.bIsLatePenaltyAlreadyPooled =\\ttrue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t//Apply penalty\\n\\t\\t\\tnTotalPayout = nTotalPayout.sub(nPenalty);\\n\\n\\t\\t\\temit EndStakeEvent(\\n\\t\\t\\t\\trStake.nAmountStaked,\\n\\t\\t\\t\\tnTotalPayout,\\n        block.timestamp \\u003c rStake.tEndStakeCommitTime ?\\n  \\t\\t\\t\\tDifferenceInDays(rStake.tLockTime, block.timestamp) :\\n  \\t\\t\\t\\tDifferenceInDays(rStake.tLockTime, rStake.tTimeRemovedFromGlobalPool),\\n\\t\\t\\t\\tnPenalty,\\n\\t\\t\\t\\trStake.nSharesStaked,\\n\\t\\t\\t\\tDifferenceInDays(rStake.tLockTime, rStake.tEndStakeCommitTime)\\n\\t\\t\\t);\\n\\n\\t\\t\\t//Payout staked coins from contract\\n\\t\\t\\t_transfer(address(this), a_address, nTotalPayout);\\n\\n\\t\\t\\t//Remove stake\\n\\t\\t\\tRemoveStake(a_address, a_nStakeIndex);\\n\\t\\t}\\n\\t}\\n\\n  /// @dev Remove stake from array\\n  /// @param a_address address of staker\\n  /// @param a_nStakeIndex index of the stake to delete\\n  function RemoveStake(\\n    address a_address,\\n    uint256 a_nStakeIndex\\n  ) internal\\n\\t{\\n    uint256 nEndingIndex = m_staked[a_address].length.sub(1);\\n\\n    //Only copy if we aren\\u0027t removing the last index\\n    if(nEndingIndex != a_nStakeIndex)\\n    {\\n      //Copy last stake in array over stake we are removing\\n      m_staked[a_address][a_nStakeIndex] = m_staked[a_address][nEndingIndex];\\n    }\\n\\n    //Lower array length by 1\\n    m_staked[a_address].length = nEndingIndex;\\n  }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\n\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"MerkleProof.sol\":{\"content\":\"pragma solidity \\u003e=0.4.25 \\u003c0.6.0;\\n\\n\\n\\n\\n\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity \\u003e=0.4.25 \\u003c0.6.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\n\\n\\n\\n\"}}",
        "label": false,
        "name": "0xd9d4a7ca154fe137c808f7eedbe24b639b7af5a6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = 0x1d9E8E5c8Fe34a9D17e541E34AEB218607453Dad;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"BWT\";\nVAR5 = \"Bitwin Token\";\nVAR6 = 18;\nVAR7 = 450000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xa7f1863212762d6b6f7b958b46a21ba9e4818422.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: mint to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR13;\nstring private VAR14;\nuint8 private VAR15;\nconstructor (string memory VAR16, string memory VAR17, uint8 VAR18) public {\nVAR13 = VAR16;\nVAR14 = VAR17;\nVAR15 = VAR18;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring private VAR13 = \"NeuronxD\";\nstring private VAR14 = \"NXDD\";\nuint8 private VAR15 = 2;\naddress VAR11 = msg.VAR8;\nuint256 VAR7 = 13 * 1e3 * 1e2;\nconstructor() CON3( VAR13, VAR14, VAR15) public {\nFUN7(VAR11, VAR7);\n}\n}",
        "label": false,
        "name": "0x6001de41576fd5d2fb2862a3fb0039ca6c589a0d.sol"
    },
    {
        "source": "contract CON1 {\nbool private VAR1 = false;\nmodifier FUN1() {\nrequire(!VAR1);\nVAR1 = true;\n_;\nVAR1 = false;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstruct Transaction{\naddress[2] VAR2;\nuint VAR3;\nuint256 VAR4;\n}\nTransaction private VAR5;\nuint256 constant public VAR6 = 2;\nmapping(address => bool) private VAR7;\nfunction CON2() public {\nVAR7[0xA45fb4e5A96D267c2BDc5efDD2E93a92b9516232] = true;\nVAR7[0x877994c4192184F18E24083Be0aA51BAA325FD9c] = true;\nVAR7[0x5Aa9E0727b57cF9aC354626A3Ea137317a30E636] = true;\nVAR7[0x8ee5De18c0b70Ccb7844768BAe07db6e208c7082] = true;\nVAR7[0x81e9b014d9cd8c5b76bb712cf03eae9a2669e765] = true;\nVAR7[0xed4c73ad76d90715d648797acd29a8529ed511a0] = true;\n}\nfunction FUN2(address VAR8, uint256 VAR9) external FUN11 FUN1 {\nrequire( VAR8 != 0x00 );\nrequire( VAR9 > 0 );\nrequire( address(this).balance >= VAR9 );\nuint VAR10;\nif(VAR5.VAR3 == 0){\nVAR5.VAR2[VAR5.VAR3] = msg.sender;\nVAR5.VAR4 = VAR9;\nVAR5.VAR3 = VAR5.VAR3.add(1);\nVAR10 = VAR6.sub(VAR5.VAR3);\nreturn;\n}\nif(VAR5.VAR4 != VAR9){\nFUN3(\"Incorrect VAR9 of wei passed\");\nreturn;\n}\nif(msg.sender == VAR5.VAR2[0]){\nFUN3(\"Signer is spamming\");\nreturn;\n}\nVAR5.VAR2[VAR5.VAR3] = msg.sender;\nVAR5.VAR3 = VAR5.VAR3.add(1);\nVAR10 = VAR6.sub(VAR5.VAR3);\nif(VAR10 == 0){\nif(msg.sender == VAR5.VAR2[0]){\nFUN3(\"One of signers is spamming\");\nreturn;\n}\n}\nif (VAR5.VAR3 == 2){\nif(VAR8.send(VAR9)){\n} else {\n}\nFUN4();\n}\n}\nfunction FUN3(string VAR11) private {\nFUN4();\n}\nfunction FUN4() internal {\ndelete VAR5;\n}\nfunction FUN5() external FUN11{\nFUN4();\n}\nfunction() payable public {\nif (msg.value > 0)\n}\nfunction FUN7(address VAR12) public constant returns (bool) {\nreturn VAR7[VAR12];\n}\nstruct KeyUpdate{\naddress[2] VAR2;\nuint VAR3;\naddress VAR13;\naddress VAR14;\n}\nKeyUpdate private VAR15;\nfunction FUN8(address VAR16, address VAR17) external FUN11 {\nrequire(FUN7(VAR16));\nrequire( VAR17 != 0x00 );\nrequire(!FUN7(VAR17));\nrequire( msg.sender != VAR16 );\nuint256 VAR10;\nif( VAR15.VAR3 == 0){\nVAR15.VAR2[VAR15.VAR3] = msg.sender;\nVAR15.VAR13 = VAR16;\nVAR15.VAR14 = VAR17;\nVAR15.VAR3 = VAR15.VAR3.add(1);\nVAR10 = VAR6.sub(VAR15.VAR3);\nreturn;\n}\nif(VAR15.VAR13 != VAR16){\nFUN9();\nreturn;\n}\nif(VAR15.VAR14 != VAR17){\nFUN9();\nreturn;\n}\nif(msg.sender == VAR15.VAR2[0]){\nFUN9();\nreturn;\n}\nVAR15.VAR2[VAR15.VAR3] = msg.sender;\nVAR15.VAR3 = VAR15.VAR3.add(1);\nVAR10 = VAR6.sub(VAR15.VAR3);\nif( VAR10 == 0){\nif(msg.sender == VAR15.VAR2[0]){\nFUN9();\nreturn;\n}\n}\nif( VAR15.VAR3 == 2 ){\nFUN9();\ndelete VAR7[VAR16];\nVAR7[VAR17] = true;\nreturn;\n}\n}\nfunction FUN9() internal\n{\ndelete VAR15;\n}\nfunction FUN10() external FUN11{\nFUN9();\n}\nmodifier FUN11(){\nif( !VAR7[msg.sender] ){\nrevert();\n}\n_;\n}\n}",
        "label": false,
        "name": "0x2bd66db7fef6403bece86620ea43f5c9922eb679.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nuint256 public VAR3 = 1547209085;\nuint256 public VAR4 = 1547209085;\nconstructor() public {\nVAR1 = 0xf9C45AD22Be5f0a5eBC9643c1BE1166A4C124C93;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2(uint VAR5) {\nrequire(now >= VAR5);\n_;\n}\nfunction FUN3(address VAR6) public FUN1 {\nVAR2 = VAR6;\n}\nfunction FUN4() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 is CON2 {\nstring public VAR7;\nstring public VAR8;\nuint8 public VAR9 = 18;\nuint256 public VAR10;\naddress public VAR11 = 0x9c8483a7d4ebeC3A3e768cB14e191bef2a3AC712;\nmapping (address => uint256) public VAR12;\nmapping (address => mapping (address => uint256)) public VAR13;\nconstructor() public {\nVAR10 = 1000 * 10 ** uint256(VAR9); VAR7 = \"AUMKII Token\"; VAR8 = \"AUMKII\";\nVAR12[VAR1] = 400 * 10 ** uint256(VAR9);\nVAR12[VAR11] = 600 * 10 ** uint256(VAR9);\n}\nfunction FUN5(uint VAR5) public FUN1{\nVAR4 = VAR5;\n}\nfunction FUN6(address VAR14, address VAR15, uint VAR16, uint VAR17) internal {\nrequire(msg.sender != address(0x0));\nrequire(VAR16 >= 1);\nrequire(VAR12[VAR14] >= VAR16);\nrequire(VAR12[VAR15] + VAR16 >= VAR12[VAR15]);\nuint VAR18 = VAR12[VAR14] + VAR12[VAR15];\nVAR12[VAR14] -= VAR16;\nVAR12[VAR15] += VAR16;\nassert(VAR12[VAR14] + VAR12[VAR15] == VAR18);\n}\nfunction FUN7(address VAR14, address VAR15, uint VAR16) internal {\nrequire(VAR15 != address(0x0));\nrequire(VAR12[VAR14] >= VAR16);\nrequire(VAR12[VAR15] + VAR16 >= VAR12[VAR15]);\nuint VAR18 = VAR12[VAR14] + VAR12[VAR15];\nVAR12[VAR14] -= VAR16;\nVAR12[VAR15] += VAR16;\nassert(VAR12[VAR14] + VAR12[VAR15] == VAR18);\n}\nfunction FUN8(address VAR15, uint256 VAR16) public returns (bool VAR19) {\nFUN7(msg.sender, VAR15, VAR16);\nreturn true;\n}\nfunction FUN9(address VAR14, address VAR15, uint256 VAR16) public returns (bool VAR19) {\nrequire(VAR16 <= VAR13[VAR14][msg.sender]); VAR13[VAR14][msg.sender] -= VAR16;\nFUN7(VAR14, VAR15, VAR16);\nreturn true;\n}\nfunction FUN10(address VAR20, uint256 VAR16) public\nreturns (bool VAR19) {\nVAR13[msg.sender][VAR20] = VAR16;\nreturn true;\n}\nfunction FUN11(address VAR20, uint256 VAR16, bytes memory VAR21)\npublic\nreturns (bool VAR19) {\nCON1 VAR22 = CON1(VAR20);\nif (FUN10(VAR20, VAR16)) {\nVAR22.receiveApproval(msg.sender, VAR16, address(this), VAR21);\nreturn true;\n}\n}\nfunction FUN12(uint256 VAR16) public returns (bool VAR19) {\nrequire(VAR12[msg.sender] >= VAR16); VAR12[msg.sender] -= VAR16; VAR10 -= VAR16;\nreturn true;\n}\nfunction FUN13() public FUN1{\nuint256 VAR23 = address(this).VAR23;\nmsg.sender.FUN8(VAR23);\n}\nfunction () external payable {\nuint VAR24 = msg.value * 1000;\nFUN7(VAR1, msg.sender, VAR24);\n}\n}",
        "label": false,
        "name": "0xf3d739a2eb84ed16ed42d9fc1493152a9f945818.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 8;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb8e9781d234a4ebd38f15956315c2da3c7fd6c06.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 210000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = \"DEXFin\"; VAR2 = \"DXF\"; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x087ac3213f938a60795860a5808b48d8f822267d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nCON1 public VAR1;\nuint256 constant public VAR2 = 10000;\nuint256 constant public VAR3 = 20000000 * (10 ** 18);\nuint256 public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\nbool public VAR8 = true;\naddress public VAR9;\naddress public VAR10;\nmapping(address => uint256) VAR11;\nfunction CON2(uint256 VAR12, uint256 VAR13, address VAR14, address VAR15, address VAR16) public {\nrequire(VAR12 < VAR13);\nrequire(VAR14 != address(0));\nrequire(VAR15 != address(0));\nrequire(VAR16 != address(0));\nVAR4 = VAR12;\nVAR5 = VAR13;\nVAR9 = VAR14;\nVAR10 = VAR16;\nVAR1 = CON1(VAR15);\n}\nfunction () external payable {\nFUN2(msg.sender);\n}\nfunction FUN2(address VAR17) public payable {\nrequire(VAR17 != address(0));\nrequire(now >= VAR4 && now <= VAR5);\nrequire(VAR8);\nrequire(msg.value != 0);\nuint256 VAR18 = msg.value;\nuint256 VAR19 = VAR18.mul(VAR2);\nrequire(VAR7.add(VAR19) <= VAR3);\nVAR6 = VAR6.add(VAR18);\nVAR7 = VAR7.add(VAR19);\nVAR11[VAR17] = VAR11[VAR17].add(VAR18);\nassert(VAR1.transferFrom(VAR10, VAR17, VAR19));\nVAR9.transfer(msg.value);\n}\nfunction FUN3(bool VAR20) public {\nrequire(msg.sender == VAR10);\nVAR8 = VAR20;\n}\nfunction FUN4(address VAR21) external constant returns (uint256 VAR22) {\nreturn VAR11[VAR21];\n}\n}",
        "label": false,
        "name": "0xb613aa71ce4630e955548a61d089617e8e2f509a.sol"
    },
    {
        "source": "contract CON1\n{\n}\ncontract CON2 is CON1\n{\nmapping(address => uint256) VAR1;\nmapping(address => mapping (address => uint256)) VAR2;\nuint256 public VAR3;\nuint public VAR4;\nstring public VAR5;\nconstructor() public\n{\n}\nfunction FUN1(address VAR6, uint256 VAR7) public returns (bool)\n{\nuint256 VAR8;\nuint256 VAR9;\nrequire(VAR6!=address(0x0) && VAR6!=msg.VAR40&& VAR7!=0&& VAR7<=VAR1[msg.VAR40]);\nVAR8 = VAR1[msg.VAR40];\nVAR9 = VAR8 - VAR7;\nassert(VAR9 <= VAR8);\nVAR1[msg.VAR40] = VAR9;\nVAR8 = VAR1[VAR6];\nVAR9 = VAR8 + VAR7;\nassert(VAR9 >= VAR8);\nVAR1[VAR6] = VAR9;\nreturn true;\n}\nfunction FUN2(address VAR10, address VAR6, uint256 VAR7) public returns (bool)\n{\nrequire(VAR7!=0 &&VAR1[VAR10] >= VAR7 &&VAR2[VAR10][msg.VAR40] >= VAR7);\nuint256 VAR8 = VAR1[VAR10];\nuint256 VAR9 = VAR8 - VAR7;\nassert(VAR9 <= VAR8);\nVAR1[VAR10] = VAR9;\nVAR8 = VAR1[VAR6];\nVAR9 = VAR8 + VAR7;\nassert(VAR9 >= VAR8);\nVAR1[VAR6] = VAR9;\nVAR8 = VAR2[VAR10][msg.VAR40];\nVAR9 = VAR8 - VAR7;\nassert(VAR9 <= VAR8);\nVAR2[VAR10][msg.VAR40] = VAR9;\nreturn true;\n}\nfunction FUN3(address VAR11, uint256 VAR12) public returns (bool VAR13)\n{\nVAR2[msg.VAR40][VAR11] = VAR12;\nreturn true;\n}\n}\ncontract CON3 is CON2\n{\naddress public VAR14;\nmodifier FUN4() { require(msg.VAR40==VAR14); _; }\nconstructor() public\n{\nVAR14 = msg.VAR40;\n}\nfunction FUN5(address VAR15, uint VAR16) FUN4 public\n{\nVAR1[VAR15] = safeAdd(VAR1[VAR15], VAR16);\nVAR3 = safeAdd(VAR3, VAR16);\n}\nfunction FUN6(address VAR15, uint VAR16) FUN4 public\n{\nrequire(VAR1[VAR15]>=VAR16);\nVAR1[VAR15] = safeSub(VAR1[VAR15], VAR16);\nVAR3 = safeSub(VAR3, VAR16);\n}\n}\ncontract CON4 is CON1\n{\naddress public VAR17; address public VAR18;\nuint public VAR19;\naddress VAR20 = address(0x0);\nmapping (address => mapping (address => uint)) public VAR21; mapping (address => mapping (bytes32 => bool)) public VAR22; mapping (address => mapping (bytes32 => uint)) public VAR23;\nmodifier FUN7() { require(msg.VAR40==VAR17); _; }\nconstructor() public\n{\nVAR17 = msg.VAR40;\nVAR19 = 3000000000000000;\nVAR18 = 0x88df955fc88f253e21beECcfdD81f01D141219c9;\n}\nfunction() external\n{\nassert(true==false);\n}\nfunction FUN9(address VAR24) FUN7 public\n{\nVAR17 = VAR24;\n}\nfunction FUN10(address VAR25) FUN7 public\n{\nVAR18 = VAR25;\n}\nfunction FUN11(uint VAR26) FUN7 public\n{\nrequire(VAR26<30000000000000000000);\nVAR19 = VAR26;\n}\nfunction FUN12() payable public\n{\nVAR21[VAR20][msg.VAR40] = safeAdd(VAR21[VAR20][msg.VAR40], msg.value);\n}\nfunction FUN13(uint VAR16) public\n{\nrequire(VAR21[VAR20][msg.VAR40]>=VAR16);\nVAR21[VAR20][msg.VAR40] = safeSub(VAR21[VAR20][msg.VAR40], VAR16);\nmsg.VAR40.FUN1(VAR16);\n}\nfunction FUN14(address VAR27, uint VAR16) public\n{\nrequire(VAR27!=address(0x0));\nif (!CON2(VAR27).FUN2(msg.VAR40, address(this), VAR16))\n{\nassert(true==false);\n}\nVAR21[VAR27][msg.VAR40] = safeAdd(VAR21[VAR27][msg.VAR40], VAR16);\n}\nfunction FUN15(address VAR27, uint VAR16) public\n{\nrequire(VAR27!=address(0x0));\nif (VAR21[VAR27][msg.VAR40] < VAR16) assert(true==false);\nVAR21[VAR27][msg.VAR40] = safeSub(VAR21[VAR27][msg.VAR40], VAR16);\nif (!CON2(VAR27).FUN1(msg.VAR40, VAR16)) assert(true==false);\n}\nfunction FUN16(address VAR28, uint VAR29,address VAR30,uint VAR31,uint VAR32,uint VAR33) public\n{\nbytes32 VAR34 = sha256(abi.encodePacked(this, VAR28, VAR29, VAR30, VAR31, VAR32, VAR33));\nVAR22[msg.VAR40][VAR34] = true;\n}\nfunction FUN17(address VAR28, uint VAR29,address VAR30,uint VAR31,uint VAR32,uint VAR33,address VAR35,uint8 VAR36,bytes32 VAR37,bytes32 VAR38,uint VAR16) public\n{\nbytes32 VAR34 = sha256(abi.encodePacked(this, VAR28, VAR29, VAR30, VAR31, VAR32, VAR33));\nif (!((VAR22[VAR35][VAR34] ||\necrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", VAR34)),VAR36,VAR37,VAR38) == VAR35) &&\nblock.number <= VAR32 &&\nsafeAdd(VAR23[VAR35][VAR34], VAR16) <= VAR29))\n{\nassert(true==false);\n}\nFUN18(VAR28, VAR29, VAR30, VAR31, VAR35, VAR16);\nVAR23[VAR35][VAR34] = safeAdd(VAR23[VAR35][VAR34], VAR16);\n}\nfunction FUN18(address VAR28, uint VAR29,address VAR30,uint VAR31,address VAR35,uint VAR16) private\n{\nuint VAR39 = safeMul(VAR16, VAR19) / (1 ether);\nVAR21[VAR28][msg.VAR40] = safeSub(VAR21[VAR28][msg.VAR40], safeAdd(VAR16, VAR39));\nVAR21[VAR28][VAR35] = safeAdd(VAR21[VAR28][VAR35], VAR16);\nVAR21[VAR28][VAR18] = safeAdd(VAR21[VAR28][VAR18], VAR39);\nVAR21[VAR30][VAR35] = safeSub(VAR21[VAR30][VAR35], safeMul(VAR31, VAR16) / VAR29);\nVAR21[VAR30][msg.VAR40] = safeAdd(VAR21[VAR30][msg.VAR40], safeMul(VAR31, VAR16) / VAR29);\n}\nfunction FUN19(address VAR28, uint VAR29,address VAR30,uint VAR31,uint VAR32,uint VAR33,address VAR35,uint8 VAR36,bytes32 VAR37,bytes32 VAR38,uint VAR16,address VAR40) public returns(bool)\n{\nif (!(VAR21[VAR28][VAR40] >= VAR16 &&availableVolume(VAR28, VAR29, VAR30, VAR31, VAR32, VAR33, VAR35, VAR36, VAR37, VAR38) >= VAR16))\n{\nreturn false;\n}\nreturn true;\n}\nfunction FUN20(address VAR28, uint VAR29,address VAR30,uint VAR31,uint VAR32,uint VAR33,uint8 VAR36,bytes32 VAR37,bytes32 VAR38) public\n{\nbytes32 VAR34 = sha256(abi.encodePacked(this, VAR28, VAR29, VAR30, VAR31, VAR32, VAR33));\nif (!(VAR22[msg.VAR40][VAR34] ||\necrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", VAR34)),VAR36,VAR37,VAR38) == msg.VAR40))\n{\nassert(true==false);\n}\nVAR23[msg.VAR40][VAR34] = VAR29;\n}\n}",
        "label": false,
        "name": "0xe1746aa4c9489acabab5e5fcfe154a8cd8f40edf.sol"
    },
    {
        "source": "contract CON1{\nusing SafeMath for uint;\nmapping (address => uint) public VAR1;\nmapping (address => uint) public VAR2;\nuint VAR3 = 5000;\nuint VAR4 = 10000;\nuint VAR5 = 15000;\nuint VAR6 = 20000;\nuint VAR7 = 25000;\nuint VAR8 = 1 days;\nuint public VAR9;\nuint public VAR10;\nuint public VAR11;\nuint public VAR12;\nmodifier FUN1(){\nrequire(VAR1[msg.sender] > 0, \"Please send something\");\n_;\n}\nmodifier FUN2(){\nrequire(now >= VAR2[msg.sender].add(VAR8), \"Too fast, bro, please wait a little\");\n_;\n}\nfunction FUN3()FUN1 FUN2 private {\nuint VAR13 = getDepositMultiplier();\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR13);\nVAR10+=VAR13;\nVAR12 =now;\n}\nfunction FUN4() private{\nif(msg.value > 0){\nif (VAR1[msg.sender] == 0){\nVAR11+=1;\n}\nif(getDepositMultiplier() > 0 && now >= VAR2[msg.sender].add(VAR8) ){\nFUN3();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR9+=msg.value;\n}else{\nFUN3();\n}\n}\nfunction() external payable{\nrequire((VAR1[msg.sender] + msg.value) >= VAR1[msg.sender]);\nFUN4();\n}\n}",
        "label": false,
        "name": "0x5bbc74110a757689572b90bf8d45e487391567c3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe2e6dc1571b42929dd9ffdf7567edbef2c255948.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON5 is CON2, CON4, CON3 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 4000000000 * (10 ** uint256(VAR18));\nconstructor() public CON4(\"EDOS Token\", \"EDOS\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0xb0644e54f627aa5292d66b2b98e93873adb8ea07.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nfunction CON4() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nuint256 public VAR8;\nuint256 public VAR9;\nmapping(address => uint) public VAR10;\nmapping(address => mapping(address => uint)) public VAR11;\nmapping (address => bool) public VAR12;\nmodifier FUN4(uint VAR13) {\nassert(msg.VAR19.length >= VAR13 + 4);\n_;\n}\nfunction CON5() public {\nVAR4 = \"INO8\";\nVAR5 = \"InnovateToken\";\nVAR6 = 18;\nVAR7 = 250000000 * 10**uint(VAR6);\nVAR10[VAR1] = VAR7;\n}\nfunction FUN5(address VAR14, uint VAR15) FUN4(safeMul(2,32)) public returns (bool VAR16) {\nFUN11(msg.sender, VAR14, VAR15); return true;\n}\nfunction FUN6(address VAR17, uint VAR15) public returns (bool VAR16) {\nVAR11[msg.sender][VAR17] = VAR15;\nreturn true;\n}\nfunction FUN7(address VAR18, address VAR14, uint VAR15) FUN4(safeMul(3,32)) public returns (bool VAR16) {\nrequire (VAR14 != 0x0); require (VAR10[VAR18] >= VAR15); require (safeAdd(VAR10[VAR14] , VAR15) >= VAR10[VAR14]); require(!VAR12[VAR18]); require(!VAR12[VAR14]);\nVAR10[VAR18] = safeSub(VAR10[VAR18], VAR15);\nVAR11[VAR18][msg.sender] = safeSub(VAR11[VAR18][msg.sender], VAR15);\nVAR10[VAR14] = safeAdd(VAR10[VAR14], VAR15);\nreturn true;\n}\nfunction FUN8(address VAR17, uint VAR15, bytes VAR19) public returns (bool VAR16) {\nVAR11[msg.sender][VAR17] = VAR15;\nCON3(VAR17).receiveApproval(msg.sender, VAR15, this, VAR19);\nreturn true;\n}\nfunction FUN9(address VAR20, uint256 VAR21) FUN1 public {\nVAR10[VAR20] = safeAdd(VAR10[VAR20], VAR21);\nVAR7 = safeAdd(VAR7, VAR21);\n}\nfunction FUN10(address VAR18, bool VAR22) FUN1 public {\nVAR12[VAR18] = VAR22;\n}\nfunction FUN11(address VAR23, address VAR24, uint VAR25) internal {\nrequire (VAR24 != 0x0); require (VAR10[VAR23] >= VAR25); require (safeAdd(VAR10[VAR24] , VAR25) >= VAR10[VAR24]); require(!VAR12[VAR23]); require(!VAR12[VAR24]);\nVAR10[VAR23] = safeSub(VAR10[VAR23], VAR25);\nVAR10[VAR24] = safeAdd(VAR10[VAR24], VAR25);\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR8 = VAR26;\nVAR9 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = safeDiv(msg.value , VAR9); FUN11(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(address(this).balance >= safeMul(VAR28 ,VAR8)); FUN11(msg.sender, this, VAR28); msg.sender.FUN5(safeMul(VAR28 ,VAR8)); }\nfunction FUN15(uint256 VAR25) public returns (bool VAR16) {\nrequire(VAR10[msg.sender] >= VAR25); VAR10[msg.sender] = safeSub(VAR10[msg.sender], VAR25); VAR7 = safeSub(VAR7, VAR25);\nreturn true;\n}\nfunction FUN16(address VAR23, uint256 VAR25) public returns (bool VAR16) {\nrequire(VAR10[VAR23] >= VAR25); require(VAR25 <= VAR11[VAR23][msg.sender]); VAR10[VAR23] = safeSub(VAR10[VAR23], VAR25); VAR11[VAR23][msg.sender] = safeSub(VAR11[VAR23][msg.sender], VAR25); VAR7 = safeSub(VAR7, VAR25);\nreturn true;\n}\nfunction FUN17(address VAR29, uint VAR15) public FUN1 returns (bool VAR16) {\nreturn CON2(VAR29).FUN5(VAR1, VAR15);\n}\n}",
        "label": false,
        "name": "0x9fcf7acdc11fd904c4b73a009909c7f00efc4844.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing Roles for Roles.Role;\nmapping (string => Roles.Role) private VAR3;\nstring public constant VAR4 = \"ceo\";\nstring public constant VAR5 = \"coo\"; string public constant VAR6 = \"cro\"; string public constant VAR7 = \"manager\"; string public constant VAR8 = \"reviewer\";\nconstructor() public{\nFUN13(msg.sender, VAR4);\n}\nfunction FUN3(address VAR9) FUN1 public {\nFUN13(VAR9, VAR4);\n}\nfunction FUN4(address VAR9) FUN1 public{\nFUN14(VAR9, VAR4);\n}\nfunction FUN5(address VAR9) FUN15 public {\nFUN13(VAR9, VAR5);\n}\nfunction FUN6(address VAR9) FUN15 public{\nFUN14(VAR9, VAR5);\n}\nfunction FUN7(address VAR9) FUN16 public {\nFUN13(VAR9, VAR7);\n}\nfunction FUN8(address VAR9) FUN16 public {\nFUN14(VAR9, VAR7);\n}\nfunction FUN9(address VAR9) FUN16 public {\nFUN13(VAR9, VAR8);\n}\nfunction FUN10(address VAR9) FUN16 public {\nFUN14(VAR9, VAR8);\n}\nfunction FUN11(address VAR9) FUN16 public {\nFUN13(VAR9, VAR6);\n}\nfunction FUN12(address VAR9) FUN16 public {\nFUN14(VAR9, VAR6);\n}\nfunction FUN13(address VAR9, string VAR10) internal {\nVAR3[VAR10].add(VAR9);\n}\nfunction FUN14(address VAR9, string VAR10) internal {\nVAR3[VAR10].remove(VAR9);\n}\nmodifier FUN15() {\ncheckRole(msg.sender, VAR4);\n_;\n}\nmodifier FUN16() {\ncheckRole(msg.sender, VAR5);\n_;\n}\nmodifier FUN17() {\ncheckRole(msg.sender, VAR6);\n_;\n}\nmodifier FUN18() {\ncheckRole(msg.sender, VAR7);\n_;\n}\nmodifier FUN19() {\ncheckRole(msg.sender, VAR8);\n_;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3, CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR11;\nuint256 VAR12;\nuint256 public VAR13; uint256 public VAR14; address public VAR15;\nfunction FUN20(address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR11[msg.sender]);\nuint256 VAR18 = (VAR17.mul(VAR13)).div(10000);\nif (VAR18 > VAR14) {\nVAR18 = VAR14;\n}\nuint256 VAR19 = VAR17.sub(VAR18);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR17);\nVAR11[VAR16] = VAR11[VAR16].add(VAR19);\nif (VAR18 > 0) {\nVAR11[VAR15] = VAR11[VAR15].add(VAR18);\n}\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR20;\nfunction FUN21(address VAR21, address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR11[VAR21]);\nrequire(VAR17 <= VAR20[VAR21][msg.sender]);\nuint256 VAR18 = (VAR17.mul(VAR13)).div(10000);\nif (VAR18 > VAR14) {\nVAR18 = VAR14;\n}\nuint256 VAR19 = VAR17.sub(VAR18);\nVAR11[VAR21] = VAR11[VAR21].sub(VAR17);\nVAR11[VAR16] = VAR11[VAR16].add(VAR19);\nVAR20[VAR21][msg.sender] = VAR20[VAR21][msg.sender].sub(VAR17);\nif (VAR18 > 0) {\nVAR11[VAR15] = VAR11[VAR15].add(VAR18);\n}\nreturn true;\n}\nfunction FUN22(address VAR22, uint256 VAR17) public returns (bool) {\nVAR20[msg.sender][VAR22] = VAR17;\nreturn true;\n}\nfunction FUN23(address VAR22, uint VAR23) public returns (bool) {\nVAR20[msg.sender][VAR22] = VAR20[msg.sender][VAR22].add(VAR23);\nreturn true;\n}\nfunction FUN24(address VAR22, uint VAR24) public returns (bool) {\nuint VAR25 = VAR20[msg.sender][VAR22];\nif (VAR24 > VAR25) {\nVAR20[msg.sender][VAR22] = 0;\n} else {\nVAR20[msg.sender][VAR22] = VAR25.sub(VAR24);\n}\nreturn true;\n}\n}\ncontract CON7 is CON2 {\nbool public VAR26 = false;\nmodifier FUN25() {\nrequire(!VAR26);\n_;\n}\nmodifier FUN26() {\nrequire(VAR26);\n_;\n}\nfunction FUN27() FUN15 FUN25 public {\nVAR26 = true;\n}\nfunction FUN28() FUN15 FUN26 public {\nVAR26 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN20(address VAR16, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN20(VAR16, VAR17);\n}\nfunction FUN21(address VAR21, address VAR16, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN21(VAR21, VAR16, VAR17);\n}\nfunction FUN22(address VAR22, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN22(VAR22, VAR17);\n}\nfunction FUN23(address VAR22, uint VAR23) public FUN25 returns (bool VAR27) {\nreturn super.FUN23(VAR22, VAR23);\n}\nfunction FUN24(address VAR22, uint VAR24) public FUN25 returns (bool VAR27) {\nreturn super.FUN24(VAR22, VAR24);\n}\n}\ncontract CON9 is CON8 {\nmapping (address => bool) public VAR28;\nfunction FUN29 (address VAR29) public FUN17 {\nVAR28[VAR29] = true;\n}\nfunction FUN30 (address VAR30) public FUN17 {\nVAR28[VAR30] = false;\n}\nfunction FUN31 (address VAR31) public FUN15 {\nrequire(VAR28[VAR31]);\nuint VAR32 = balanceOf(VAR31);\nVAR11[VAR31] = 0;\nVAR12 = VAR12.sub(VAR32);\n}\n}\ncontract CON10 is CON9{\nstruct MethodParam {\nstring VAR33; uint VAR34; bool VAR35; }\nmapping (string => MethodParam) VAR36;\nstring public constant VAR37 = \"issue\";\nstring public constant VAR38 = \"redeem\";\nfunction FUN32(uint VAR17) public FUN18 {\nVAR36[VAR37] = MethodParam(VAR37, VAR17, true);\n}\nfunction FUN33(uint VAR17) public FUN19 {\nrequire(VAR36[VAR37].VAR34 == VAR17);\nrequire(VAR36[VAR37].VAR35 == true);\nVAR11[VAR15]=VAR11[VAR15].add(VAR17);\nVAR12 = VAR12.add(VAR17);\nVAR36[VAR37].VAR35=false;\n}\nfunction FUN34(uint VAR17) public FUN18 {\nVAR36[VAR38] = MethodParam(VAR38, VAR17, true);\n}\nfunction FUN35(uint VAR17) public FUN19 {\nrequire(VAR36[VAR38].VAR34 == VAR17);\nrequire(VAR36[VAR38].VAR35 == true);\nVAR11[VAR15]=VAR11[VAR15].sub(VAR17);\nVAR12 = VAR12.sub(VAR17);\nVAR36[VAR38].VAR35=false;\n}\n}\ncontract CON11 {\n}\ncontract CON12 is CON10 {\nstring public constant VAR39 = \"Wealth in Token\";\nstring public constant VAR40 = \"WIT\";\nuint8 public constant VAR41 = 18;\naddress public VAR42;\nbool public VAR43;\nmodifier FUN36( address VAR44 ) {\nrequire(VAR44 != address(0x0));\nrequire(VAR44 != address(this));\n_;\n}\nconstructor ( uint VAR45 ) public {\nVAR13 = 0;\nVAR14 = 0;\nVAR12 = VAR45;\nVAR11[msg.sender] = VAR45;\nVAR43 = false;\nVAR15 = msg.sender;\n}\nfunction FUN20(address VAR16, uint VAR17) public FUN36(VAR16) returns (bool) {\nrequire(!VAR28[msg.sender]);\nif (VAR43) {\nreturn CON11(VAR42).transferByLegacy(msg.sender, VAR16, VAR17);\n} else {\nreturn super.FUN20(VAR16, VAR17);\n}\n}\nfunction FUN21(address VAR21, address VAR16, uint VAR17) public FUN36(VAR16) returns (bool) {\nrequire(!VAR28[VAR21]);\nif (VAR43) {\nreturn CON11(VAR42).transferFromByLegacy(msg.sender, VAR21, VAR16, VAR17);\n} else {\nreturn super.FUN21(VAR21, VAR16, VAR17);\n}\n}\nfunction FUN22(address VAR22, uint256 VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).approveByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN22(VAR22, VAR17);\n}\n}\nfunction FUN23(address VAR22, uint VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).increaseApprovalByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN23(VAR22, VAR17);\n}\n}\nfunction FUN24(address VAR22, uint VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).decreaseApprovalByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN24(VAR22, VAR17);\n}\n}\nfunction FUN37(address VAR46) public FUN15 FUN26 {\nVAR43 = true;\nVAR42 = VAR46;\n}\nfunction FUN38(uint VAR47, uint VAR48) public FUN15 {\nVAR13 = VAR47;\nVAR14 = VAR48.mul(uint(10)**VAR41);\n}\nfunction FUN39(address VAR49) public FUN15 {\nrequire(VAR49 != address(0));\nVAR15 = VAR49;\n}\n}",
        "label": false,
        "name": "0x0be4a987fd8dcbd2fff64ba4131d3a208307f667.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) FUN3 {\nrequire(VAR8 != address(0));\nVAR7 = VAR8;\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) returns (bool) {\nvar VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) returns (bool) {\nrequire((VAR4 == 0) || (VAR9[msg.sender][VAR12] == 0));\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\n}\ncontract CON6 is CON5, CON4 {\nbool public VAR14 = false;\nmodifier FUN8() {\nrequire(!VAR14);\n_;\n}\nfunction FUN9(address VAR3, uint256 VAR15) FUN3 FUN8 returns (bool) {\nVAR1 = VAR1.add(VAR15);\nVAR2[VAR3] = VAR2[VAR3].add(VAR15);\nreturn true;\n}\nfunction FUN10() FUN3 returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6\n{\nstring public VAR16 = \"BsdbWealth\";\nstring public VAR17 = \"BSDB\";\nuint public VAR18 = 8;\nuint private VAR19 = 81*10**(6+8);\nfunction CON7()\n{\nVAR7 = msg.sender;\nVAR1 = VAR19;\nVAR2[VAR7] = VAR19;\n}\n}",
        "label": false,
        "name": "0xd92eaf047744e65d0f40a3651f318d08f7eb835f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN4(uint256 VAR6) public {\nrequire(VAR6 <= VAR3[msg.sender]);\naddress VAR7 = msg.sender;\nVAR3[VAR7] = VAR3[VAR7].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON5 is CON2 {\n}\ncontract CON6 is CON5, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR9]);\nrequire(VAR6 <= VAR8[VAR9][msg.sender]);\nVAR3[VAR9] = VAR3[VAR9].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR6) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON1 {\naddress public VAR14;\nbool VAR15;\nbool public VAR16 = false;\nfunction FUN9(address VAR17) external {\nrequire(VAR17 != address(0));\nrequire(VAR15 == false);\nVAR14 = VAR17;\nVAR15 = true;\n}\nmodifier FUN10() {\nif(msg.sender != VAR14) {\nrequire(!VAR16);\n}\n_;\n}\nmodifier FUN11() {\nrequire(VAR16);\n_;\n}\nfunction FUN12() FUN1 FUN10 public {\nVAR16 = true;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR16 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\nfunction FUN6(address VAR10, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN6(VAR10, VAR6);\n}\nfunction FUN7(address VAR10, uint VAR11) public FUN10 returns (bool VAR18) {\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN8(address VAR10, uint VAR12) public FUN10 returns (bool VAR18) {\nreturn super.FUN8(VAR10, VAR12);\n}\n}\ncontract CON9 is CON6, CON1 {\nmapping (address => bool) public VAR19;\nfunction FUN14(address VAR20) public FUN1 {\nVAR19[VAR20] = true;\n}\nfunction FUN15(address VAR20) public FUN1 {\nVAR19[VAR20] = false;\n}\nmodifier FUN16(address VAR21) {\nrequire(!VAR19[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN16(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN16(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON10 is CON6, CON1 {\nmapping (address => uint) public VAR22;\nfunction FUN17(address VAR20, uint VAR23) public FUN1 {\nuint VAR24;\nVAR24 = now + (VAR23 * 1 days);\nVAR22[VAR20] = VAR24;\n}\nfunction FUN18(address VAR20) public FUN1 {\nVAR22[VAR20] = now;\n}\nmodifier FUN19(address VAR21) {\nrequire(now >= VAR22[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN19(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN19(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON11 is CON10, CON9, CON8, CON4 {\nstring public constant VAR25 = \"GINICON\";\nstring public constant VAR26 = \"GN\";\nuint public constant VAR27 = 18;\nuint public constant VAR28 = 10000000000 * (10 ** VAR27);\nconstructor() public {\nVAR4 = VAR28;\nVAR3[msg.sender] = VAR4;\n}\n}",
        "label": false,
        "name": "0x616a74e4895bfe762da00b95877f25bef0d0d3c8.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN17 to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN18 from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nstring public VAR13 = \"\"; string public VAR14 = \"\"; uint8 public constant VAR15 = 18; uint256 public VAR16 = 0;\nconstructor(string memory VAR17, string memory VAR18, uint256 VAR19) public {\nVAR13 = VAR17;\nVAR14 = VAR18;\nVAR16 = VAR19 * 10**uint256(VAR15);\nsuper.FUN7(msg.VAR8, VAR16);\nVAR12 = msg.VAR8;\n}\naddress public VAR12;\nmodifier FUN11() {\nrequire(msg.VAR8 == VAR12, \"Not owner\");\n_;\n}\nfunction FUN12() public FUN11 {\nVAR12 = address(0);\n}\nfunction FUN13(address VAR20) public FUN11 {\nFUN14(VAR20);\n}\nfunction FUN14(address VAR20) internal {\nrequire(VAR20 != address(0), \"Already owner\");\nVAR12 = VAR20;\n}\naddress public VAR21;\nfunction FUN15(address VAR22) public FUN11 {\nrequire(VAR22 != address(0), \"Invalid Address\");\nVAR21 = VAR22;\n}\nmodifier FUN16() {\nrequire(msg.VAR8 == VAR21, \"Not crc\");\n_;\n}\nfunction FUN17(address VAR23,uint256 VAR24)\npublic FUN16\nreturns (bool)\n{\nsuper.FUN7(VAR23, VAR24);\nreturn true;\n}\nfunction FUN18(address VAR25, uint256 VAR26) public FUN16 returns (bool) {\nrequire(VAR26 <= super.balanceOf(VAR25), \"Balance is too small.\");\nsuper.FUN8(VAR25, VAR26);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd8505a2eb3b16a7c1085678c8b236a942a1107c5.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\nuint public VAR2;\nuint public VAR3;\nuint public VAR4;\naddress public VAR5 = msg.sender;\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction FUN2(uint VAR6, uint VAR7, uint VAR8, uint VAR9) FUN1 public {\nVAR1 = VAR6;\nVAR2 = VAR7;\nVAR3 = VAR8;\nVAR4 = VAR9;\n}\n}",
        "label": false,
        "name": "0x7326cdc1308541a97a18d6c98df142b98adc26f3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing Roles for Roles.Role;\nmapping (string => Roles.Role) private VAR3;\nstring public constant VAR4 = \"ceo\";\nstring public constant VAR5 = \"coo\"; string public constant VAR6 = \"cro\"; string public constant VAR7 = \"manager\"; string public constant VAR8 = \"reviewer\";\nconstructor() public{\nFUN13(msg.sender, VAR4);\n}\nfunction FUN3(address VAR9) FUN1 public {\nFUN13(VAR9, VAR4);\n}\nfunction FUN4(address VAR9) FUN1 public{\nFUN14(VAR9, VAR4);\n}\nfunction FUN5(address VAR9) FUN15 public {\nFUN13(VAR9, VAR5);\n}\nfunction FUN6(address VAR9) FUN15 public{\nFUN14(VAR9, VAR5);\n}\nfunction FUN7(address VAR9) FUN16 public {\nFUN13(VAR9, VAR7);\n}\nfunction FUN8(address VAR9) FUN16 public {\nFUN14(VAR9, VAR7);\n}\nfunction FUN9(address VAR9) FUN16 public {\nFUN13(VAR9, VAR8);\n}\nfunction FUN10(address VAR9) FUN16 public {\nFUN14(VAR9, VAR8);\n}\nfunction FUN11(address VAR9) FUN16 public {\nFUN13(VAR9, VAR6);\n}\nfunction FUN12(address VAR9) FUN16 public {\nFUN14(VAR9, VAR6);\n}\nfunction FUN13(address VAR9, string VAR10) internal {\nVAR3[VAR10].add(VAR9);\n}\nfunction FUN14(address VAR9, string VAR10) internal {\nVAR3[VAR10].remove(VAR9);\n}\nmodifier FUN15() {\ncheckRole(msg.sender, VAR4);\n_;\n}\nmodifier FUN16() {\ncheckRole(msg.sender, VAR5);\n_;\n}\nmodifier FUN17() {\ncheckRole(msg.sender, VAR6);\n_;\n}\nmodifier FUN18() {\ncheckRole(msg.sender, VAR7);\n_;\n}\nmodifier FUN19() {\ncheckRole(msg.sender, VAR8);\n_;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3, CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR11;\nuint256 VAR12;\nuint256 public VAR13; uint256 public VAR14; address public VAR15;\nfunction FUN20(address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR11[msg.sender]);\nuint256 VAR18 = (VAR17.mul(VAR13)).div(10000);\nif (VAR18 > VAR14) {\nVAR18 = VAR14;\n}\nuint256 VAR19 = VAR17.sub(VAR18);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR17);\nVAR11[VAR16] = VAR11[VAR16].add(VAR19);\nif (VAR18 > 0) {\nVAR11[VAR15] = VAR11[VAR15].add(VAR18);\n}\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR20;\nfunction FUN21(address VAR21, address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR11[VAR21]);\nrequire(VAR17 <= VAR20[VAR21][msg.sender]);\nuint256 VAR18 = (VAR17.mul(VAR13)).div(10000);\nif (VAR18 > VAR14) {\nVAR18 = VAR14;\n}\nuint256 VAR19 = VAR17.sub(VAR18);\nVAR11[VAR21] = VAR11[VAR21].sub(VAR17);\nVAR11[VAR16] = VAR11[VAR16].add(VAR19);\nVAR20[VAR21][msg.sender] = VAR20[VAR21][msg.sender].sub(VAR17);\nif (VAR18 > 0) {\nVAR11[VAR15] = VAR11[VAR15].add(VAR18);\n}\nreturn true;\n}\nfunction FUN22(address VAR22, uint256 VAR17) public returns (bool) {\nVAR20[msg.sender][VAR22] = VAR17;\nreturn true;\n}\nfunction FUN23(address VAR22, uint VAR23) public returns (bool) {\nVAR20[msg.sender][VAR22] = VAR20[msg.sender][VAR22].add(VAR23);\nreturn true;\n}\nfunction FUN24(address VAR22, uint VAR24) public returns (bool) {\nuint VAR25 = VAR20[msg.sender][VAR22];\nif (VAR24 > VAR25) {\nVAR20[msg.sender][VAR22] = 0;\n} else {\nVAR20[msg.sender][VAR22] = VAR25.sub(VAR24);\n}\nreturn true;\n}\n}\ncontract CON7 is CON2 {\nbool public VAR26 = false;\nmodifier FUN25() {\nrequire(!VAR26);\n_;\n}\nmodifier FUN26() {\nrequire(VAR26);\n_;\n}\nfunction FUN27() FUN15 FUN25 public {\nVAR26 = true;\n}\nfunction FUN28() FUN15 FUN26 public {\nVAR26 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN20(address VAR16, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN20(VAR16, VAR17);\n}\nfunction FUN21(address VAR21, address VAR16, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN21(VAR21, VAR16, VAR17);\n}\nfunction FUN22(address VAR22, uint256 VAR17) public FUN25 returns (bool) {\nreturn super.FUN22(VAR22, VAR17);\n}\nfunction FUN23(address VAR22, uint VAR23) public FUN25 returns (bool VAR27) {\nreturn super.FUN23(VAR22, VAR23);\n}\nfunction FUN24(address VAR22, uint VAR24) public FUN25 returns (bool VAR27) {\nreturn super.FUN24(VAR22, VAR24);\n}\n}\ncontract CON9 is CON8 {\nmapping (address => bool) public VAR28;\nfunction FUN29 (address VAR29) public FUN17 {\nVAR28[VAR29] = true;\n}\nfunction FUN30 (address VAR30) public FUN17 {\nVAR28[VAR30] = false;\n}\nfunction FUN31 (address VAR31) public FUN15 {\nrequire(VAR28[VAR31]);\nuint VAR32 = balanceOf(VAR31);\nVAR11[VAR31] = 0;\nVAR12 = VAR12.sub(VAR32);\n}\n}\ncontract CON10 is CON9{\nstruct MethodParam {\nstring VAR33; uint VAR34; bool VAR35; }\nmapping (string => MethodParam) VAR36;\nstring public constant VAR37 = \"issue\";\nstring public constant VAR38 = \"redeem\";\nfunction FUN32(uint VAR17) public FUN18 {\nVAR36[VAR37] = MethodParam(VAR37, VAR17, true);\n}\nfunction FUN33(uint VAR17) public FUN19 {\nrequire(VAR36[VAR37].VAR34 == VAR17);\nrequire(VAR36[VAR37].VAR35 == true);\nVAR11[VAR15]=VAR11[VAR15].add(VAR17);\nVAR12 = VAR12.add(VAR17);\nVAR36[VAR37].VAR35=false;\n}\nfunction FUN34(uint VAR17) public FUN18 {\nVAR36[VAR38] = MethodParam(VAR38, VAR17, true);\n}\nfunction FUN35(uint VAR17) public FUN19 {\nrequire(VAR36[VAR38].VAR34 == VAR17);\nrequire(VAR36[VAR38].VAR35 == true);\nVAR11[VAR15]=VAR11[VAR15].sub(VAR17);\nVAR12 = VAR12.sub(VAR17);\nVAR36[VAR38].VAR35=false;\n}\n}\ncontract CON11 {\n}\ncontract CON12 is CON10 {\nstring public constant VAR39 = \"Wealth in Tokens\";\nstring public constant VAR40 = \"WIT\";\nuint8 public constant VAR41 = 18;\naddress public VAR42;\nbool public VAR43;\nmodifier FUN36( address VAR44 ) {\nrequire(VAR44 != address(0x0));\nrequire(VAR44 != address(this));\n_;\n}\nconstructor ( uint VAR45 ) public {\nVAR13 = 0;\nVAR14 = 0;\nVAR12 = VAR45;\nVAR11[msg.sender] = VAR45;\nVAR43 = false;\nVAR15 = msg.sender;\n}\nfunction FUN20(address VAR16, uint VAR17) public FUN36(VAR16) returns (bool) {\nrequire(!VAR28[msg.sender]);\nif (VAR43) {\nreturn CON11(VAR42).transferByLegacy(msg.sender, VAR16, VAR17);\n} else {\nreturn super.FUN20(VAR16, VAR17);\n}\n}\nfunction FUN21(address VAR21, address VAR16, uint VAR17) public FUN36(VAR16) returns (bool) {\nrequire(!VAR28[VAR21]);\nif (VAR43) {\nreturn CON11(VAR42).transferFromByLegacy(msg.sender, VAR21, VAR16, VAR17);\n} else {\nreturn super.FUN21(VAR21, VAR16, VAR17);\n}\n}\nfunction FUN22(address VAR22, uint256 VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).approveByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN22(VAR22, VAR17);\n}\n}\nfunction FUN23(address VAR22, uint VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).increaseApprovalByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN23(VAR22, VAR17);\n}\n}\nfunction FUN24(address VAR22, uint VAR17) public returns (bool) {\nif (VAR43) {\nreturn CON11(VAR42).decreaseApprovalByLegacy(msg.sender, VAR22, VAR17);\n} else {\nreturn super.FUN24(VAR22, VAR17);\n}\n}\nfunction FUN37(address VAR46) public FUN15 FUN26 {\nVAR43 = true;\nVAR42 = VAR46;\n}\nfunction FUN38(uint VAR47, uint VAR48) public FUN15 {\nVAR13 = VAR47;\nVAR14 = VAR48.mul(uint(10)**VAR41);\n}\nfunction FUN39(address VAR49) public FUN15 {\nrequire(VAR49 != address(0));\nVAR15 = VAR49;\n}\n}",
        "label": false,
        "name": "0x1bd3435b7db7dd77753b1283e2a9d751f000367b.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nCON2 VAR3;\nmapping(bytes32 => uint) public VAR4;\nconstructor(address VAR5) public {\nVAR3 = CON2(VAR5);\n}\nfunction FUN5(bytes32 VAR6, uint VAR7) external {\nassert(VAR3.transferFrom(msg.sender, address(this), VAR7));\nVAR4[VAR6] = VAR4[VAR6].add( VAR7);\n}\nfunction FUN6(address VAR5, uint VAR7) external FUN1 {\nassert(VAR3.transfer(VAR5, VAR7));\n}\n}",
        "label": false,
        "name": "0x1691ffdc054b07567d47743ef064a0de37528584.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 9;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xddf51cd4e33d2627966cae8a45cd4a2592c49e39.sol"
    },
    {
        "source": "contract CON1 {\nbool public VAR1;\nfunction FUN1() public returns (bool VAR2) {\nVAR1 = !VAR1;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x70a9c7a1977792fa4eb7f89ecfc02d3d14dba054.sol"
    },
    {
        "source": "\r\n\r\n\r\ninterface RTCoinInterface {\r\n    \r\n\r\n    \r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(address _owner, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool approved);\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    \r\n    function mint(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function stakeContractAddress() external view returns (address);\r\n\r\n    function mergedMinerValidatorAddress() external view returns (address);\r\n    \r\n    \r\n    function freezeTransfers() external returns (bool);\r\n\r\n    function thawTransfers() external returns (bool);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n    function owner() external view returns (address);\r\n    function decimals() external view returns (uint8);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\ncontract Stake {\r\n\r\n    using SafeMath for uint256;\r\n\r\n            uint256 constant private MINSTAKE = 1000000000000000000;\r\n        uint256 constant private MULTIPLIER = 100000000000000000;\r\n        uint256 constant private BLOCKHOLDPERIOD = 2103840;\r\n                uint256 constant private BLOCKSEC = 15;\r\n    string  constant public VERSION = \"production\";\r\n        address  constant public TOKENADDRESS = 0xecc043b92834c1ebDE65F2181B59597a6588D616;\r\n        RTCoinInterface   constant public RTI = RTCoinInterface(TOKENADDRESS);\r\n\r\n        uint256 public activeStakes;\r\n        address public admin;\r\n        bool public newStakesAllowed;\r\n\r\n        enum StakeStateEnum { nil, staking, staked }\r\n\r\n    struct StakeStruct {\r\n                uint256 initialStake;\r\n                uint256 blockLocked;\r\n                uint256 blockUnlocked;\r\n                uint256 releaseDate;\r\n                uint256 totalCoinsToMint;\r\n                uint256 coinsMinted;\r\n                uint256 rewardPerBlock;\r\n                uint256 lastBlockWithdrawn;\r\n                StakeStateEnum    state;\r\n    }\r\n\r\n    event StakesDisabled();\r\n    event StakesEnabled();\r\n    event StakeDeposited(address indexed _staker, uint256 indexed _stakeNum, uint256 _coinsToMint, uint256 _releaseDate, uint256 _releaseBlock);\r\n    event StakeRewardWithdrawn(address indexed _staker, uint256 indexed _stakeNum, uint256 _reward);\r\n    event InitialStakeWithdrawn(address indexed _staker, uint256 indexed _stakeNumber, uint256 _amount);\r\n    event ForeignTokenTransfer(address indexed _sender, address indexed _recipient, uint256 _amount);\r\n\r\n        mapping (address => mapping (uint256 => StakeStruct)) public stakes;\r\n        mapping (address => uint256) public numberOfStakes;\r\n        mapping (address => uint256) public internalRTCBalances;\r\n\r\n    modifier validInitialStakeRelease(uint256 _stakeNum) {\r\n                require(stakes[msg.sender][_stakeNum].state == StakeStateEnum.staking, \"stake is not active\");\r\n        require(\r\n                                    now >= stakes[msg.sender][_stakeNum].releaseDate && block.number >= stakes[msg.sender][_stakeNum].blockUnlocked, \r\n            \"attempting to withdraw initial stake before unlock block and date\"\r\n        );\r\n        require(internalRTCBalances[msg.sender] >= stakes[msg.sender][_stakeNum].initialStake, \"invalid internal rtc balance\");\r\n        _;\r\n    }\r\n\r\n    modifier validMint(uint256 _stakeNumber) {\r\n                require(\r\n            stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staking || stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, \r\n            \"stake must be active or inactive in order to mint tokens\"\r\n        );\r\n                require(\r\n            stakes[msg.sender][_stakeNumber].coinsMinted < stakes[msg.sender][_stakeNumber].totalCoinsToMint, \r\n            \"current coins minted must be less than total\"\r\n        );\r\n        uint256 currentBlock = block.number;\r\n        uint256 lastBlockWithdrawn = stakes[msg.sender][_stakeNumber].lastBlockWithdrawn;\r\n                require(currentBlock > lastBlockWithdrawn, \"current block must be one higher than last withdrawal\");\r\n        _;\r\n    }\r\n\r\n    modifier stakingEnabled(uint256 _numRTC) {\r\n                require(canMint(), \"staking contract is unable to mint tokens\");\r\n                require(newStakesAllowed, \"new stakes are not allowed\");\r\n                require(_numRTC >= MINSTAKE, \"specified stake is lower than minimum amount\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"sender is not admin\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        require(TOKENADDRESS != address(0), \"token address not set\");\r\n        admin = _admin;\r\n    }\r\n\r\n    \r\n    function disableNewStakes() public onlyAdmin returns (bool) {\r\n        newStakesAllowed = false;\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowNewStakes() public onlyAdmin returns (bool) {\r\n        newStakesAllowed = true;\r\n        require(RTI.stakeContractAddress() == address(this), \"rtc token contract is not set to use this contract as the staking contract\");\r\n        return true;\r\n    }\r\n\r\n    \r\n    function mint(uint256 _stakeNumber) public validMint(_stakeNumber) returns (bool) {\r\n                uint256 mintAmount = calculateMint(_stakeNumber);\r\n                stakes[msg.sender][_stakeNumber].coinsMinted = stakes[msg.sender][_stakeNumber].coinsMinted.add(mintAmount);\r\n                stakes[msg.sender][_stakeNumber].lastBlockWithdrawn = block.number;\r\n                emit StakeRewardWithdrawn(msg.sender, _stakeNumber, mintAmount);\r\n                require(RTI.mint(msg.sender, mintAmount), \"token minting failed\");\r\n        return true;\r\n    }\r\n\r\n    \r\n    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {\r\n                uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;\r\n                stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;\r\n                activeStakes = activeStakes.sub(1);\r\n                internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);\r\n                emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);\r\n                require(RTI.transfer(msg.sender, initialStake), \"unable to transfer tokens likely due to incorrect balance\");\r\n        return true;\r\n    }\r\n\r\n    \r\n    function depositStake(uint256 _numRTC) public stakingEnabled(_numRTC) returns (bool) {\r\n        uint256 stakeCount = getStakeCount(msg.sender);\r\n\r\n                (uint256 blockLocked, \r\n        uint256 blockReleased, \r\n        uint256 releaseDate, \r\n        uint256 totalCoinsMinted,\r\n        uint256 rewardPerBlock) = calculateStake(_numRTC);\r\n\r\n                StakeStruct memory ss = StakeStruct({\r\n            initialStake: _numRTC,\r\n            blockLocked: blockLocked,\r\n            blockUnlocked: blockReleased,\r\n            releaseDate: releaseDate,\r\n            totalCoinsToMint: totalCoinsMinted,\r\n            coinsMinted: 0,\r\n            rewardPerBlock: rewardPerBlock,\r\n            lastBlockWithdrawn: blockLocked,\r\n            state: StakeStateEnum.staking\r\n        });\r\n\r\n                stakes[msg.sender][stakeCount] = ss;\r\n                numberOfStakes[msg.sender] = numberOfStakes[msg.sender].add(1);\r\n                internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].add(_numRTC);\r\n                activeStakes = activeStakes.add(1);\r\n                emit StakeDeposited(msg.sender, stakeCount, totalCoinsMinted, releaseDate, blockReleased);\r\n                require(RTI.transferFrom(msg.sender, address(this), _numRTC), \"transfer from failed, likely needs approval\");\r\n        return true;\r\n    }\r\n\r\n\r\n    \r\n    \r\n    function calculateStake(uint256 _numRTC) \r\n        internal\r\n        view\r\n        returns (\r\n            uint256 blockLocked, \r\n            uint256 blockReleased, \r\n            uint256 releaseDate, \r\n            uint256 totalCoinsMinted,\r\n            uint256 rewardPerBlock\r\n        ) \r\n    {\r\n                blockLocked = block.number;\r\n                blockReleased = blockLocked.add(BLOCKHOLDPERIOD);\r\n                                releaseDate = now.add(BLOCKHOLDPERIOD.mul(BLOCKSEC));\r\n                totalCoinsMinted = _numRTC.mul(MULTIPLIER);\r\n                totalCoinsMinted = totalCoinsMinted.div(1 ether);\r\n                rewardPerBlock = totalCoinsMinted.div(BLOCKHOLDPERIOD);\r\n    }\r\n\r\n    \r\n    function calculateMint(uint256 _stakeNumber)\r\n        internal\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n                uint256 currentBlock = calculateCurrentBlock(_stakeNumber);\r\n                uint256 lastBlockWithdrawn = stakes[msg.sender][_stakeNumber].lastBlockWithdrawn;\r\n                uint256 blocksToReward = currentBlock.sub(lastBlockWithdrawn);\r\n                reward = blocksToReward.mul(stakes[msg.sender][_stakeNumber].rewardPerBlock);\r\n                uint256 totalToMint = stakes[msg.sender][_stakeNumber].totalCoinsToMint;\r\n                uint256 currentCoinsMinted = stakes[msg.sender][_stakeNumber].coinsMinted;\r\n                uint256 newCoinsMinted = currentCoinsMinted.add(reward);\r\n                if (newCoinsMinted > totalToMint) {\r\n            reward = newCoinsMinted.sub(totalToMint);\r\n        }\r\n    }\r\n\r\n    \r\n    function transferForeignToken(\r\n        address _tokenAddress,\r\n        address _recipient,\r\n        uint256 _amount)\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        require(_recipient != address(0), \"recipient address can't be empty\");\r\n                require(_tokenAddress != TOKENADDRESS, \"token can't be RTC\");\r\n        ERC20Interface eI = ERC20Interface(_tokenAddress);\r\n        require(eI.transfer(_recipient, _amount), \"token transfer failed\");\r\n        emit ForeignTokenTransfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function calculateCurrentBlock(uint256 _stakeNumber) internal view returns (uint256 currentBlock) {\r\n        currentBlock = block.number;\r\n                        if (currentBlock >= stakes[msg.sender][_stakeNumber].blockUnlocked) {\r\n            currentBlock = stakes[msg.sender][_stakeNumber].blockUnlocked;\r\n        }\r\n    }\r\n    \r\n    \r\n    function getStakeCount(address _staker) internal view returns (uint256) {\r\n        return numberOfStakes[_staker];\r\n    }\r\n\r\n    \r\n    function canMint() public view returns (bool) {\r\n        require(RTI.stakeContractAddress() == address(this), \"rtc token contract is not set to use this contract as the staking contract\");\r\n        return true;\r\n    }\r\n}",
        "label": false,
        "name": "0xd6e33c11cff866162787b7198030aac101a61f29.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring public constant VAR18 = \"Interdax Token\";\nstring public constant VAR19 = \"ITDX\";\nuint8 public constant VAR20 = 18;\nuint256 public constant VAR21 = 10000000000 * (10 ** uint256(VAR20));\nconstructor () public CON3(VAR18, VAR19, VAR20) {\nFUN7(msg.sender, VAR21);\n}\n}",
        "label": false,
        "name": "0x2192effd72861e7c275a64e77e26b0fab2b33a7a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, \"\");\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0), \"\");\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nmodifier FUN3() {\nrequire(VAR3[msg.sender], \"\");\n_;\n}\nfunction FUN4(address VAR4) public FUN1 returns (bool VAR5) {\nif (!VAR3[VAR4]) {\nrequire(VAR4 != address(0), \"\");\nVAR3[VAR4] = true;\nVAR5 = true;\n}\n}\nfunction FUN5(address VAR4) public FUN1 returns (bool VAR5) {\nif (VAR3[VAR4]) {\nVAR3[VAR4] = false;\nVAR5 = true;\n}\n}\n}\ncontract CON3 is CON2 {\nmapping(address => bool) public VAR6;\nfunction FUN6(address VAR7) public FUN3 {\nrequire(VAR7 != address(0), \"\");\nVAR6[VAR7] = true;\n}\nfunction FUN7(address VAR7) public FUN3 {\nrequire(VAR7 != address(0), \"\");\nVAR6[VAR7] = false;\n}\n}",
        "label": false,
        "name": "0x2c7e1bc8490b14a1f059b9bb9b91f351db1987b1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nCON1 public VAR1;\naddress VAR2;\naddress VAR3 = 0x81Ae4b8A213F3933B0bE3bF25d13A3646F293A64;\nuint256 public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7 = 0;\nfunction CON2() public {\nVAR2 = msg.sender;\nVAR4 = 1515974400; VAR6 = 500;\nVAR1 = CON1(0xC42de4250cA009C767818eC6f8fb1eacBa859f38);\n}\nfunction FUN1(address VAR8) public {\nrequire(msg.sender == VAR2);\nVAR3 = VAR8;\n}\nfunction FUN2(address VAR9) public {\nrequire(msg.sender == VAR2);\nVAR2 = VAR9;\n}\nfunction FUN3(uint256 VAR10) public {\nrequire(msg.sender == VAR2);\nVAR4 = VAR10;\n}\nfunction FUN4(uint256 VAR11) public {\nrequire(msg.sender == VAR2);\nVAR5 = VAR11;\n}\nfunction FUN5(uint256 VAR12) public {\nrequire(msg.sender == VAR2);\nVAR6 = VAR12;\n}\nfunction FUN6(address VAR13, uint VAR14) public {\nrequire(msg.sender == VAR2);\nVAR1.transfer(VAR13, VAR14);\n}\nfunction () payable public {\nrequire(msg.value > 0);\nrequire(now > VAR4);\nrequire(VAR7 < 100000001);\nuint VAR14 = msg.value / 10 finney;\nrequire(VAR14 > 5);\nuint VAR15;\nif(now > VAR4 && now < 1518480000) {\nVAR6 = 700;\nVAR14 *= VAR6 * 100;\nVAR15 = VAR14 / 20;\nVAR14 += VAR15 * 8;\n}\nif(now > 1518480000 && now < 1519084800) {\nVAR6 = 625;\nVAR14 *= VAR6 * 100;\nVAR14 += VAR14 / 4;\n}\nif(now > 1519084800 && now < 1519689600) {\nVAR6 = 575;\nVAR14 *= VAR6 * 100;\nVAR15 = VAR14 / 20;\nVAR14 += VAR15 * 3;\n}\nif(now > 1519689600 && now < 1520294400) {\nVAR6 = 550;\nVAR14 *= VAR6 * 100;\nVAR14 += VAR14 / 10;\n}\nif(now > 1520294400) {\nVAR6 = 500;\nVAR14 *= VAR6 * 100;\n}\nVAR7 += VAR14;\nVAR1.transfer(msg.sender, VAR14);\nVAR3.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x67793426747f8c79332520c1291c4fc6443c8407.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x90cb9491dbb0a50ca049204c4f64b8dce07b3470.sol"
    },
    {
        "source": "contract CON1{\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns (uint256){\nif (VAR1 == 0) {\nreturn 0;\n}\nuint256 VAR3 = VAR1 * VAR2;\nassert(VAR3 / VAR1 == VAR2);\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns (uint256){\nreturn VAR1 / VAR2;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns (uint256){\nassert(VAR2 <= VAR1);\nreturn VAR1 - VAR2;\n}\nfunction FUN4(uint256 VAR1, uint256 VAR2) internal returns (uint256){\nuint256 VAR3 = VAR1 + VAR2;\nassert(VAR3 >= VAR1);\nreturn VAR3;\n}\nmodifier FUN5(uint VAR4){\nassert(msg.data.length >= VAR4 * 32 + 4);\n_;\n}\n}\ncontract CON2{\n}\ncontract CON3 is CON2, CON1{\nfunction FUN6(address VAR5, uint256 VAR6) public returns (bool VAR7){\nrequire(VAR5 != address(0));\nrequire(VAR15[msg.sender] >= VAR6 && VAR6 > 0);\nVAR15[msg.sender] = FUN3(VAR15[msg.sender], VAR6);\nVAR15[VAR5] = FUN4(VAR15[VAR5], VAR6);\nreturn true;\n}\nfunction FUN7(address VAR8, address VAR5, uint256 VAR6) FUN5(3) returns (bool VAR7){\nrequire(VAR5 != address(0));\nrequire(VAR15[VAR8] >= VAR6 && VAR16[VAR8][msg.sender] >= VAR6 && VAR6 > 0);\nVAR15[VAR8] = FUN3(VAR15[VAR8], VAR6);\nVAR15[VAR5] = FUN4(VAR15[VAR5], VAR6);\nVAR16[VAR8][msg.sender] = FUN3(VAR16[VAR8][msg.sender], VAR6);\nreturn true;\n}\nfunction FUN8(address VAR9) constant returns (uint256 VAR10){\nreturn VAR15[VAR9];\n}\nfunction FUN9(address VAR11, uint256 VAR6) FUN5(2) returns (bool VAR7){\nrequire((VAR6 == 0) || (VAR16[msg.sender][VAR11] == 0));\nVAR16[msg.sender][VAR11] = VAR6;\nreturn true;\n}\nfunction FUN10(address VAR11, uint256 VAR12, uint256 VAR13) FUN5(3) returns (bool VAR7){\nrequire(VAR16[msg.sender][VAR11] == VAR12);\nVAR16[msg.sender][VAR11] = VAR13;\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR11) constant returns (uint256 VAR14){\nreturn VAR16[VAR9][VAR11];\n}\nmapping (address => uint256) VAR15;\nmapping (address => mapping (address => uint256)) VAR16;\n}\ncontract CON4 is CON3 {\nstring public VAR17 = \"Winsshar\";\nstring public VAR18 = \"WSR\";\nuint256 public VAR19 = 6;\nuint256 public VAR20 = 100000000000000000;\nuint256 public VAR21 = 1000000000000000;\nuint256 public VAR22 = 20000000000000;\naddress VAR23;\naddress VAR24;\nmapping (uint256 => address) public VAR25;\nuint256 public VAR26;\nfunction CON4 (address VAR27) {\nVAR26=0;\nVAR23 = msg.sender;\nVAR15[VAR23] = VAR21;\nVAR24 = VAR27;\nVAR15[VAR27] = VAR22;\n}\nmodifier FUN12 {\nrequire(VAR26 <= 1000000);\n_;\n}\nmodifier FUN13 {\nrequire(VAR23 == msg.sender);\n_;\n}\nmodifier FUN14 {\nrequire(VAR24 == msg.sender);\n_;\n}\nfunction FUN15(address VAR28) public FUN12 FUN13 {\nrequire(VAR28 != address(0));\nVAR26++;\nVAR25[VAR26]=VAR28;\nFUN6(VAR28,10000000);\n}\nfunction FUN16(address VAR29, uint256 VAR30) public FUN12 {\nrequire(VAR30 <= 2000);\nFUN6(VAR29,VAR30);\n}\nfunction FUN17(address VAR29, uint VAR30) public FUN14 {\nrequire(VAR29 != address(0));\nFUN6(VAR29,VAR30);\n}\nfunction FUN18(address VAR31) public FUN13 {\nVAR23 = VAR31;\nVAR15[VAR23] = VAR15[msg.sender];\nVAR15[msg.sender] = 0;\n}\nfunction FUN19(uint256 VAR32) public FUN13 {\nrequire(VAR20-VAR22 >= VAR21+VAR32);\nVAR21 = FUN4(VAR21,VAR32);\nVAR15[VAR23] = FUN4(VAR15[VAR23],VAR32);\n}\nfunction FUN20(uint256 VAR33) public FUN13{\nrequire(VAR21-VAR33 >= 0);\nVAR21 = FUN3(VAR21,VAR33);\nVAR15[VAR23] = FUN3(VAR15[VAR23],VAR33);\n}\nfunction() payable {\nrequire(tx.origin == msg.sender);\n}\n}",
        "label": false,
        "name": "0x36daecfc172fd44a165fb93be5569e72b09ceea2.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1 = 2e28;\n}\ncontract CON2 is CON1 {\nbytes32 public VAR2 = \"TOP Network\";\nbytes32 public VAR3 = \"TOP\";\nuint256 public VAR4 = 18;\naddress private VAR5 = address(0);\nbool private VAR6 = false;\nmapping(address => uint256) private VAR7;\nconstructor() public {\nVAR5 = msg.sender;\nVAR7[VAR5] = VAR1;\nVAR6 = true;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool) {\nrequire(VAR6);\nrequire(VAR8 != address(0));\nrequire(VAR8 != msg.sender);\nrequire(VAR9 <= VAR7[msg.sender]);\nuint256 VAR10 = VAR7[VAR8] + VAR9;\nrequire(VAR10 >= VAR7[VAR8]);\nVAR7[msg.sender] = VAR7[msg.sender] - VAR9;\nVAR7[VAR8] = VAR10;\nreturn true;\n}\nfunction FUN3() public FUN1 {\nVAR6 = false;\n}\nfunction FUN4() public FUN1 {\nVAR6 = true;\n}\nfunction FUN5(address VAR11) public FUN1 {\nrequire(VAR11 != address(0));\nVAR5 = VAR11;\n}\nfunction FUN6() public FUN1 {\nrequire(!VAR6);\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0xdcd85914b8ae28c1e62f1c488e1d968d5aaffe2b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR10) public FUN11 {\nFUN14(VAR10);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR10) internal {\nVAR18.add(VAR10);\n}\nfunction FUN15(address VAR10) internal {\nVAR18.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN16(address VAR4, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nuint256 private VAR19;\nconstructor (uint256 VAR20) public {\nrequire(VAR20 > 0);\nVAR19 = VAR20;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= VAR19);\nsuper.FUN7(VAR10, VAR5);\n}\n}\ncontract CON7 is CON2 {\nfunction FUN17(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN18(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON8 is CON2, CON3(\"OmCoin\", \"OM\", 18), CON6(10000000 * 10 ** 18), CON7 {\n}",
        "label": false,
        "name": "0x876230b33475d175ff1ba685c6523b00884f1cf2.sol"
    },
    {
        "source": "contract CON1 {\nstring constant public VAR1 = \"FakeToken\";\nstring constant public VAR2 = \"FTKN\";\nuint8 constant public VAR3 = 0;\nmapping (address => uint256) public VAR4;\nconstructor() public {\nVAR4[msg.sender] = 1000;\n}\nfunction FUN1(address VAR5, uint256 VAR6) public {\nFUN3(msg.sender, VAR5, VAR6);\n}\nfunction FUN2(address VAR7, uint256 VAR6) public {\nFUN3(VAR7, msg.sender, VAR6);\n}\nfunction FUN3(address VAR7, address VAR5, uint256 VAR6) internal {\nrequire(VAR4[VAR7] >= VAR6, \"Not enought balance\");\nrequire(VAR4[VAR5] + VAR6 >= VAR6, \"Overflow protection\");\nVAR4[VAR7] -= VAR6;\nVAR4[VAR5] += VAR6;\n}\n}",
        "label": false,
        "name": "0x1b6f5b9906e287767e8be7b65e843161857a2a07.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"GCCH\";\nstring public constant VAR2 = \"GCCHCOIN\";\nuint8 public constant VAR3 = 8;\nuint256 VAR4 = 5000000000000000;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nthrow;\n}\n_;\n}\nfunction CON2() {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2() constant returns (uint256 FUN2) {\nFUN2 = VAR4;\n}\nfunction FUN3(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR6[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR11) returns (bool VAR12) {\nif (VAR6[msg.sender] >= VAR11&& VAR11 > 0&& VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR13,address VAR10,uint256 VAR11) returns (bool VAR12) {\nif (VAR6[VAR13] >= VAR11&& VAR7[VAR13][msg.sender] >= VAR11&& VAR11 > 0&& VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[VAR13] -= VAR11;\nVAR7[VAR13][msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR14, uint256 VAR11) returns (bool VAR12) {\nVAR7[msg.sender][VAR14] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR8, address VAR14) constant returns (uint256 VAR15) {\nreturn VAR7[VAR8][VAR14];\n}\n}",
        "label": false,
        "name": "0x0b841f496c88ad7d465d4fea9e212f724fb6e226.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN2 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN4 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN5 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0), \"Cannot FUN1 VAR4 0x0 address\");\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"Cannot mint VAR4 0x0 address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR11 = \"Coineru Gold\";\nstring public constant VAR12 = \"CGLD\";\nuint8 public constant VAR13 = 8;\nuint256 public constant VAR14 = 26000000000 * (10 ** uint256(VAR13));\nconstructor () public {\nFUN7(msg.sender, VAR14);\n}\n}",
        "label": false,
        "name": "0x3f50e6cc943351f00971a9d01ac32739895df826.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\n}\ncontract CON2 {\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\naddress public VAR5;\nconstructor() public {\nVAR5 = msg.sender;\n}\naddress VAR6=0x0;\nfunction FUN2(address VAR7) public FUN1 {\nrequire(VAR7 != VAR5);\nVAR6 = VAR7;\n}\nfunction FUN3() public{\nrequire(msg.sender == VAR6);\nVAR5 = VAR6;\nVAR6 = 0x0;\n}\n}\ncontract CON3 is CON2{\nconstructor() public {\nFUN7(msg.sender,true);\n}\nbool public VAR8 = true;\nbool VAR9=true;\nmapping(address => bool) VAR10;\nmapping(address => bool) VAR11;\nfunction FUN4(bool VAR12) public FUN1 returns (bool VAR13){\nVAR8=VAR12;\nreturn true;\n}\nfunction FUN5(bool VAR12) public FUN1 returns (bool VAR13){\nVAR9=VAR12;\nreturn true;\n}\nfunction FUN6(address VAR14) public FUN1 returns (bool VAR13){\nrequire(VAR14!=msg.sender);\nVAR10[VAR14]=true;\nreturn true;\n}\nfunction FUN7(address VAR14,bool VAR12) public FUN1 returns (bool VAR13){\nVAR11[VAR14]=VAR12;\nreturn true;\n}\nfunction FUN8(address VAR14) public FUN1 returns (bool VAR13){\nVAR10[VAR14]=false;\nreturn true;\n}\nmodifier FUN9(address VAR14) {\nif (!VAR11[VAR14]) {\nrequire(VAR8,\"transfer is not enabeled now!\");\nif(VAR9){\nrequire(!VAR10[VAR14],\"you are VAR10!\");\n}\n}\n_;\n}\n}\ncontract CON4 is CON1,CON3 {\nmapping (address => uint256) public VAR15;\nmapping (address => mapping (address => uint256)) internal VAR16;\nconstructor() public {\nVAR4 = 1000000000; VAR1 = \"GECToken\";\nVAR2 = \"GECT\";\nVAR3 = 8;\nVAR15[msg.sender] = VAR4;\n}\nfunction FUN10(address VAR17, uint256 VAR18) public FUN1 {\nVAR15[VAR17] = VAR15[VAR17].add(VAR18);\nVAR4 = VAR4.add(VAR18);\n}\nfunction FUN11(address VAR19, uint256 VAR20) public FUN9(msg.sender) returns (bool VAR13) {\nrequire(VAR19 != address(0));\nrequire(VAR20 <= VAR15[msg.sender]);\nVAR15[msg.sender] = VAR15[msg.sender].sub(VAR20);\nVAR15[VAR19] = VAR15[VAR19].add(VAR20);\nreturn true;\n}\nfunction FUN12(address VAR21, address VAR19, uint256 VAR20) public FUN9(VAR21) returns (bool VAR13) {\nrequire(VAR19 != address(0));\nrequire(VAR20 <= VAR15[VAR21]);\nrequire(VAR20 <= VAR16[VAR21][msg.sender]);\nVAR15[VAR21] = VAR15[VAR21].sub(VAR20);\nVAR15[VAR19] = VAR15[VAR19].add(VAR20);\nVAR16[VAR21][msg.sender] = VAR16[VAR21][msg.sender].sub(VAR20);\nreturn true;\n}\nfunction FUN13(address VAR22, uint256 VAR20) public returns (bool VAR13) {\nVAR16[msg.sender][VAR22] = VAR20;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa1638c4aaf3399a6edff55e874b93bd545b88457.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress VAR2;\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nconstructor() public {\nVAR2 = msg.sender;\n}\nfunction FUN2(address VAR3) external FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) external FUN1 {\nVAR1 = VAR4;\n}\n}",
        "label": false,
        "name": "0x5a37ae1b841c0cd4c394d6c58c81c1a166f54053.sol"
    },
    {
        "source": "# Modified from: https:\r\ncontract ERC721Receiver:\r\n    def onERC721Received(\r\n        _operator: address,\r\n        _from: address,\r\n        _tokenId: uint256,\r\n        _data: bytes[1024]\r\n    ) -> bytes32: modifying\r\n\r\n# contract URI:\r\n#     def tokenURI(_tokenId: uint256) -> string[128]: constant\r\n\r\ncontract Socks:\r\n    def totalSupply() -> uint256: constant\r\n\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _tokenId: indexed(uint256)})\r\nApproval: event({_owner: indexed(address), _approved: indexed(address), _tokenId: indexed(uint256)})\r\nApprovalForAll: event({_owner: indexed(address), _operator: indexed(address), _approved: bool})\r\n\r\nname: public(string[32])\r\nsymbol: public(string[32])\r\ntotalSupply: public(uint256)\r\n\r\nminter: public(address)\r\n# socks: public(Socks)\r\nnewURI: public(string[128])\r\n\r\nownerOf: public(map(uint256, address))                     # map(tokenId, owner)\r\nbalanceOf: public(map(address, uint256))                   # map(owner, balance)\r\ngetApproved: public(map(uint256, address))                 # map(tokenId, approvedSpender)\r\nisApprovedForAll: public(map(address, map(address, bool))) # map(owner, map(operator, bool))\r\nsupportsInterface: public(map(bytes32, bool))              # map(interfaceId, bool)\r\nownerIndexToTokenId: map(address, map(uint256, uint256))   # map(owner, map(index, tokenId))\r\ntokenIdToIndex: map(uint256, uint256)                      # map(tokenId, index)\r\n\r\nERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7\r\nERC721_ENUMERABLE_INTERFACE_ID: constant(bytes32) = 0x00000000000000000000000000000000000000000000000000000000780e9d63\r\nERC721_METADATA_INTERFACE_ID: constant(bytes32) = 0x000000000000000000000000000000000000000000000000000000005b5e139f\r\nERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd\r\n\r\n# @public\r\n# def __init__(_socks: address):\r\n@public\r\ndef __init__():\r\n    self.name = 'Digital Unisocks Edition 0'\r\n    self.symbol = 'S0CKS'\r\n    self.minter = msg.sender\r\n    # self.socks = Socks(_socks)\r\n    self.newURI = 'https:    self.supportsInterface[ERC165_INTERFACE_ID] = True\r\n    self.supportsInterface[ERC721_ENUMERABLE_INTERFACE_ID] = True\r\n    self.supportsInterface[ERC721_METADATA_INTERFACE_ID] = True\r\n    self.supportsInterface[ERC721_INTERFACE_ID] = True\r\n\r\n\r\n@public\r\n@constant\r\ndef tokenURI(_tokenId: uint256) -> string[128]:\r\n    return self.newURI\r\n\r\n@public\r\ndef changeURI(_newURI: string[128]):\r\n    self.newURI = _newURI\r\n\r\n@public\r\ndef killContract():\r\n    selfdestruct(msg.sender)\r\n\r\n# Token index is same as ID and can't change\r\n@public\r\n@constant\r\ndef tokenByIndex(_index: uint256) -> uint256:\r\n    assert _index < self.totalSupply\r\n    return _index\r\n\r\n@public\r\n@constant\r\ndef tokenOfOwnerByIndex(_owner: address, _index: uint256) -> uint256:\r\n    assert _index < self.balanceOf[_owner]\r\n    return self.ownerIndexToTokenId[_owner][_index]\r\n\r\n@private\r\ndef _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):\r\n    _owner: address = self.ownerOf[_tokenId]\r\n    # Check requirements\r\n    assert _owner == _from and _to != ZERO_ADDRESS\r\n    _senderIsOwner: bool = _sender == _owner\r\n    _senderIsApproved: bool = _sender == self.getApproved[_tokenId]\r\n    _senderIsApprovedForAll: bool = self.isApprovedForAll[_owner][_sender]\r\n    assert _senderIsOwner or _senderIsApproved or _senderIsApprovedForAll\r\n    # Update ownerIndexToTokenId for _from\r\n    _highestIndexFrom: uint256 = self.balanceOf[_from] - 1   # get highest index of _from\r\n    _tokenIdIndexFrom: uint256 = self.tokenIdToIndex[_tokenId] # get index of _from where _tokenId is\r\n    if _highestIndexFrom == _tokenIdIndexFrom:               # _tokenId is the last token in _from's list\r\n        self.ownerIndexToTokenId[_from][_highestIndexFrom] = 0\r\n    else:\r\n        self.ownerIndexToTokenId[_from][_tokenIdIndexFrom] = self.ownerIndexToTokenId[_from][_highestIndexFrom]\r\n        self.ownerIndexToTokenId[_from][_highestIndexFrom] = 0\r\n    # Update ownerIndexToTokenId for _to\r\n    _newHighestIndexTo: uint256 = self.balanceOf[_to]\r\n    self.ownerIndexToTokenId[_to][_newHighestIndexTo] = _tokenId\r\n    # Update tokenIdToIndex\r\n    self.tokenIdToIndex[_tokenId] = _newHighestIndexTo\r\n    # update ownerOf and balanceOf\r\n    self.ownerOf[_tokenId] = _to\r\n    self.balanceOf[_from] -= 1\r\n    self.balanceOf[_to] += 1\r\n    # Clear approval.\r\n    if self.getApproved[_tokenId] != ZERO_ADDRESS:\r\n        self.getApproved[_tokenId] = ZERO_ADDRESS\r\n    log.Transfer(_from, _to, _tokenId)\r\n\r\n\r\n@public\r\ndef transferFrom(_from: address, _to: address, _tokenId: uint256):\r\n    self._transferFrom(_from, _to, _tokenId, msg.sender)\r\n\r\n\r\n@public\r\ndef safeTransferFrom(_from: address, _to: address, _tokenId: uint256, _data: bytes[1024]=\"\"):\r\n    self._transferFrom(_from, _to, _tokenId, msg.sender)\r\n    if _to.is_contract:\r\n        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)\r\n        # Throws if transfer destination is a contract which does not implement 'onERC721Received'\r\n        assert returnValue == method_id('onERC721Received(address,address,uint256,bytes)', bytes32)\r\n\r\n\r\n@public\r\ndef approve(_approved: address, _tokenId: uint256):\r\n    owner: address = self.ownerOf[_tokenId]\r\n    # Check requirements\r\n    senderIsOwner: bool = msg.sender == owner\r\n    senderIsApprovedForAll: bool = (self.isApprovedForAll[owner])[msg.sender]\r\n    assert senderIsOwner or senderIsApprovedForAll\r\n    # Set the approval\r\n    self.getApproved[_tokenId] = _approved\r\n    log.Approval(owner, _approved, _tokenId)\r\n\r\n\r\n@public\r\ndef setApprovalForAll(_operator: address, _approved: bool):\r\n    assert _operator != msg.sender\r\n    self.isApprovedForAll[msg.sender][_operator] = _approved\r\n    log.ApprovalForAll(msg.sender, _operator, _approved)\r\n\r\n\r\n@public\r\ndef mint(_to: address) -> bool:\r\n    assert msg.sender == self.minter and _to != ZERO_ADDRESS\r\n    _tokenId: uint256 = self.totalSupply\r\n    _toBal: uint256 = self.balanceOf[_to]\r\n    # can only mint if a sock has been burned\r\n    # _socksSupply: uint256 = self.socks.totalSupply()\r\n    # _socksBurned: uint256 = 500 * 10**18 - _socksSupply\r\n    # assert _tokenId * 10**18 < _socksBurned\r\n    # update mappings\r\n    self.ownerOf[_tokenId] = _to\r\n    self.balanceOf[_to] += 1\r\n    self.ownerIndexToTokenId[_to][_toBal] = _tokenId\r\n    self.tokenIdToIndex[_tokenId] = _toBal\r\n    self.totalSupply += 1\r\n    log.Transfer(ZERO_ADDRESS, _to, _tokenId)\r\n    return True\r\n\r\n\r\n@public\r\ndef changeMinter(_minter: address):\r\n    assert msg.sender == self.minter\r\n    self.minter = _minter",
        "label": false,
        "name": "0xa0a4a2af46af4cf37eacc495eedcae269ef2720e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR4;\nuint256 internal VAR5;\nfunction FUN9(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR7 <= VAR4[msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic returns (bool) {\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN11(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN12(address VAR10, uint256 VAR11)\npublic returns (bool) {\nVAR8[msg.sender][VAR10] = (VAR8[msg.sender][VAR10].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR10, uint256 VAR12)\npublic returns (bool) {\nuint256 VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 >= VAR13) VAR8[msg.sender][VAR10] = 0;\nelse VAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\nreturn true;\n}\n}\ncontract CON7 is CON6, CON1 {\nfunction FUN14(address VAR14, uint256 VAR7) FUN1 public {\nrequire(VAR7 <= VAR4[VAR14]);\nVAR4[VAR14] = VAR4[VAR14].sub(VAR7);\nVAR5 = VAR5.sub(VAR7);\n}\n}\ncontract CON8 is CON6, CON1 {\nbool public VAR15 = false;\nmodifier FUN15() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN16() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN17(address VAR6, uint256 VAR16)\npublic FUN16 FUN15 returns (bool) {\nVAR5 = VAR5.add(VAR16);\nVAR4[VAR6] = VAR4[VAR6].add(VAR16);\nreturn true;\n}\nfunction FUN18() public FUN1 FUN15 returns (bool) {\nVAR15 = true;\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nuint256 public VAR17;\nconstructor(uint256 VAR18) public {\nrequire(VAR18 > 0);\nVAR17 = VAR18;\n}\nfunction FUN17(address VAR6, uint256 VAR16) public returns (bool) {\nrequire(VAR5.add(VAR16) <= VAR17);\nreturn super.FUN17(VAR6, VAR16);\n}\n}\ncontract CON10 is CON6, CON2 {\nfunction FUN9(address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7);\n}\nfunction FUN12(address VAR10, uint VAR11)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN12(VAR10, VAR11);\n}\nfunction FUN13(address VAR10, uint VAR12)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN13(VAR10, VAR12);\n}\n}\ncontract CON11 is CON7, CON10, CON9 {\naddress public VAR20;\nbool public VAR21;\nstring public VAR22 = \"contact@cryptocontrol.io\";\nstring public VAR23 = \"CryptoControl\";\nstring public VAR24;\nstring public VAR25 = \"CCIO\";\nuint8 public VAR26 = 18;\nconstructor () CON9(10000000000000000000) public {}\nmodifier FUN19(uint VAR27) {\nrequire(!(msg.data.length < VAR27 + 4), \"payload too big\");\n_;\n}\nfunction FUN9(address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferByLegacy(msg.sender, VAR6, VAR7);\nelse return super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferFromByLegacy(msg.sender, VAR9, VAR6, VAR7);\nelse return super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint VAR7) public FUN19(2 * 32) returns (bool) {\nif (VAR21) return CON12(VAR20).approveByLegacy(msg.sender, VAR10, VAR7);\nelse return super.FUN11(VAR10, VAR7);\n}\nfunction FUN20(address VAR28, string memory VAR29) public FUN1 {\nVAR21 = true;\nVAR20 = VAR28;\nVAR24 = VAR29;\n}\n}\ncontract CON12 is CON10 {\n}",
        "label": false,
        "name": "0xe80b90fdabcc18932e2bcda61df6010df69091c7.sol"
    },
    {
        "source": "contract CON1 {\nuint VAR1;\nuint VAR2;\naddress constant private VAR3 = 0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD;\nfunction FUN1(uint VAR4){\nrequire(msg.sender==VAR3);\nif (msg.sender==VAR3){\nVAR1=VAR4;\n}\n}\nfunction FUN2()returns(uint){\nreturn VAR1;\n}\nfunction FUN3(uint VAR5){\nrequire(msg.sender==VAR3);\nif (msg.sender==VAR3){\nVAR2=VAR5;\n}\n}\nfunction FUN4()returns(uint){\nreturn VAR2;\n}\n}",
        "label": false,
        "name": "0x6096b8d46e1e4e00fa1beadfc071bbe500ed397b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public VAR1 = \"CPAY Token\";\nstring public VAR2 = \"CPAY\";\nuint256 public VAR3 = 90414745;\nuint8 public VAR4 = 0;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nuint256 public VAR8;\nmapping(address => uint256) public VAR9;\nbool public VAR10 = false;\nuint256 VAR11;\nmodifier FUN1() {\nrequire(!VAR10);\n_;\n}\nmodifier FUN2() {\nrequire(VAR10);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction CON2() {\nVAR5 = msg.sender;\nVAR6[VAR5] = 90414745;\n}\nfunction VAR3() constant returns (uint256 VAR12) {\nreturn VAR3;\n}\nfunction FUN4(address VAR13) constant returns (uint256 VAR14) {\nreturn VAR6[VAR13];\n}\nfunction FUN5(address VAR15, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire(VAR15 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR16);\nVAR6[VAR15] = VAR6[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN6(address VAR18, address VAR15, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire(VAR15 != address(0));\nvar VAR19 = VAR7[VAR18][msg.sender];\nVAR6[VAR18] = VAR6[VAR18].sub(VAR16);\nVAR6[VAR15] = VAR6[VAR15].add(VAR16);\nVAR7[VAR18][msg.sender] = VAR19.sub(VAR16);\nreturn true;\n}\nfunction FUN7(address VAR20, uint256 VAR16) FUN1 returns (bool VAR17) {\nrequire((VAR16 == 0) || (VAR7[msg.sender][VAR20] == 0));\nVAR7[msg.sender][VAR20] = VAR16;\nreturn true;\n}\nfunction FUN8(address VAR21, address VAR20) constant returns (uint256 VAR22) {\nreturn VAR7[VAR21][VAR20];\n}\nfunction FUN9 (address VAR20, uint VAR23) FUN1 returns (bool VAR17) {\nVAR7[msg.sender][VAR20] = VAR7[msg.sender][VAR20].add(VAR23);\nreturn true;\n}\nfunction FUN10 (address VAR20, uint VAR24) FUN1 returns (bool VAR17) {\nuint VAR25 = VAR7[msg.sender][VAR20];\nif (VAR24 > VAR25) {\nVAR7[msg.sender][VAR20] = 0;\n} else {\nVAR7[msg.sender][VAR20] = VAR25.sub(VAR24);\n}\nreturn true;\n}\nfunction FUN11(uint VAR16) returns (bool VAR17)\n{\nrequire(VAR16 > 0);\naddress VAR26 = msg.sender;\nVAR6[VAR26] = VAR6[VAR26].sub(VAR16);\nVAR3 = VAR3.sub(VAR16);\nreturn true;\n}\nfunction FUN12(address VAR15, uint256 VAR27) FUN3 returns (bool VAR17) {\nVAR3 = VAR3.add(VAR27);\nVAR6[VAR15] = VAR6[VAR15].add(VAR27);\nreturn true;\n}\nfunction () payable {\n}\nfunction FUN14() FUN3 FUN1 {\nVAR10 = true;\n}\nfunction FUN15() FUN3 FUN2 {\nVAR10 = false;\n}\nfunction FUN16() FUN3 {\nselfdestruct(VAR5);\n}\nfunction FUN17(address VAR28) FUN3 {\nrequire(VAR28 != address(0));\nVAR5 = VAR28;\n}\nfunction FUN18(CON1 VAR29) external FUN3 {\nVAR11 = VAR29.FUN4(this);\nVAR29.FUN5(VAR5, VAR11);\nVAR11 = 0;\n}\nfunction FUN19(address VAR15, uint256 VAR27) FUN3 {\nVAR9[VAR15] = VAR9[VAR15].add(VAR27);\nVAR8 = VAR8.add(VAR27);\n}\nfunction FUN20() {\naddress VAR30 = msg.sender;\nuint256 VAR31 = VAR9[VAR30];\nrequire(VAR31 != 0);\nrequire(this.VAR14 >= VAR31);\nVAR8 = VAR8.sub(VAR31);\nVAR9[VAR30] = 0;\nVAR30.FUN5(VAR31);\n}\nfunction FUN21(address VAR15, uint256 VAR27) FUN3 {\nrequire(VAR15 != address(0));\nrequire(this.VAR14 >= VAR27);\nVAR15.FUN5(VAR27);\n}\n}",
        "label": false,
        "name": "0x0ebb614204e47c09b6c3feb9aaecad8ee060e23e.sol"
    },
    {
        "source": "{\"DOS.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\ncontract ERC20 {\\n    function allowance(address owner, address spender) public view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n    function approve(address spender, uint256 value) public returns (bool);\\n    function totalSupply() public view returns (uint256);\\n    function balanceOf(address who) public view returns (uint256);\\n    function transfer(address to, uint256 value) public returns (bool);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n\\n\\n\\n\\ncontract ERC865Plus677ish {\\n    event TransferAndCall(address indexed _from, address indexed _to, uint256 _value, bytes4 _methodName, bytes _args);\\n    function transferAndCall(address _to, uint256 _value, bytes4 _methodName, bytes memory _args) public returns (bytes memory);\\n\\n    event TransferPreSigned(address indexed _from, address indexed _to, address indexed _delegate,\\n        uint256 _amount, uint256 _fee);\\n    event TransferAndCallPreSigned(address indexed _from, address indexed _to, address indexed _delegate,\\n        uint256 _amount, uint256 _fee, bytes4 _methodName, bytes _args);\\n\\n    function transferPreSigned(bytes memory _signature, address _to, uint256 _value,\\n        uint256 _fee, uint256 _nonce) public returns (bool);\\n    function transferAndCallPreSigned(bytes memory _signature, address _to, uint256 _value,\\n        uint256 _fee, uint256 _nonce, bytes4 _methodName, bytes memory _args) public returns (bytes memory);\\n}\\n\\ncontract DOS is ERC20, ERC865Plus677ish {\\n    using SafeMath for uint256;\\n\\n    string public constant name = \\\"DOS Token\\\";\\n    string public constant symbol = \\\"DOS\\\";\\n    uint8 public constant decimals = 18;\\n\\n    mapping(address =\\u003e uint256) private balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\n    // nonces of transfers performed\\n    mapping(bytes =\\u003e bool) private signatures;\\n    mapping(address =\\u003e mapping (uint256 =\\u003e bool)) private nonces;\\n    mapping(address =\\u003e bool) private contractWhitelist;\\n\\n    uint256 private totalSupply_;\\n    uint256 public constant maxSupply = 900000000 * (10 ** uint256(decimals));\\n\\n    // token lockups\\n    mapping(address =\\u003e uint256) private lockups;\\n\\n    // ownership\\n    address public owner;\\n    address public tmpOwner;\\n    address public admin1;\\n    address public admin2;\\n\\n    //3 admins can disable the transfers, however, the balances remain.\\n    //this can be used to migrate to another contract. This flag can only\\n    //be set by 3 admins.\\n    bool public transfersEnabled1 = true;\\n    bool public transfersEnabled2 = true;\\n    bool public transfersEnabled3 = true;\\n\\n    // minting\\n    bool public mintingDone = false;\\n\\n    //vesting variables, check dates with https://www.epochconverter.com/ and https://www.unixtimestamp.com/\\n    uint256 public constant firstFeb19 = 1548979200;\\n    uint256 public constant sixMonth = 6 * 30 days;\\n\\n    event TokensLocked(address indexed _holder, uint256 _timeout);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    \\n    function transferOwnership(address _newOwner) public {\\n        require(owner == msg.sender);\\n        require(_newOwner != address(0));\\n        require(_newOwner != admin1);\\n        require(_newOwner != admin2);\\n        require(_newOwner != owner); //sanity check\\n\\n        tmpOwner = _newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(tmpOwner == msg.sender);\\n        owner = tmpOwner;\\n        tmpOwner = address(0);\\n    }\\n\\n    function setAdmin(address _admin1, address _admin2) public {\\n        require(owner == msg.sender);\\n        require(!mintingDone);\\n        require(_admin1 != address(0));\\n        require(_admin1 != owner);\\n        require(_admin2 != address(0));\\n        require(_admin2 != owner);\\n        require(_admin1 != _admin2);\\n\\n        admin1 = _admin1;\\n        admin2 = _admin2;\\n    }\\n\\n    function addWhitelist(address contractAddress) public {\\n        require(owner == msg.sender || admin1 == msg.sender || admin2 == msg.sender);\\n\\n        contractWhitelist[contractAddress] = true;\\n    }\\n\\n    function removeWhitelist(address contractAddress) public {\\n        require(owner == msg.sender || admin1 == msg.sender || admin2 == msg.sender);\\n\\n        delete contractWhitelist[contractAddress];\\n    }\\n\\n    // minting functionality\\n    function mint(address[] calldata _recipients, uint256[] calldata _amounts) external {\\n        require(owner == msg.sender);\\n        require(!mintingDone);\\n        require(_recipients.length == _amounts.length);\\n        require(_recipients.length \\u003c= 255);\\n\\n        for (uint8 i = 0; i \\u003c _recipients.length; i++) {\\n            uint256 amount = _amounts[i];\\n            totalSupply_ = totalSupply_.add(amount);\\n            require(totalSupply_ \\u003c= maxSupply); // enforce maximum token supply\\n\\n            address recipient = _recipients[i];\\n            balances[recipient] = balances[recipient].add(amount);\\n\\n            emit Transfer(address(0), recipient, amount);\\n        }\\n    }\\n\\n    \\n    function lockTokens(address[] calldata _holders, uint256[] calldata _sixMonthCliff) external {\\n        require(owner == msg.sender);\\n        require(!mintingDone);\\n        require(_holders.length == _sixMonthCliff.length);\\n        require(_holders.length \\u003c= 255);\\n\\n        for (uint8 i = 0; i \\u003c _holders.length; i++) {\\n            address holder = _holders[i];\\n            // make sure lockup period can not be overwritten\\n            require(lockups[holder] == 0);\\n\\n            uint256 timeout = (_sixMonthCliff[i].mul(sixMonth)).add(firstFeb19);\\n\\n            lockups[holder] = timeout;\\n            emit TokensLocked(holder, timeout);\\n        }\\n    }\\n\\n    //If this is called, no more tokens can be generated\\n    //The status of the contract can be checked with getMintingDone, as\\n    //this variable is set to public, thus, getters are generated automatically\\n    function finishMinting() public {\\n        require(owner == msg.sender);\\n        require(!mintingDone);\\n        require(admin1 != address(0));\\n        require(admin2 != address(0));\\n\\n        mintingDone = true;\\n    }\\n\\n    function transferDisable() public {\\n        if(msg.sender == owner) {\\n            transfersEnabled1 = false;\\n        } else if(msg.sender == admin1) {\\n            transfersEnabled2 = false;\\n        } else if(msg.sender == admin2) {\\n            transfersEnabled3 = false;\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n    function isTransferEnabled() public view returns (bool) {\\n        //all three must agree to disable the transfer\\n        return transfersEnabled1 || transfersEnabled2 || transfersEnabled3;\\n    }\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        _transfer(msg.sender, _to, _value, 0, address(0));\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n        _transfer(_from, _to, _value, 0, address(0));\\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_value));\\n        return true;\\n    }\\n\\n    function _transfer(address _from, address _to, uint256 _value, uint256 _fee, address _feeAddress) internal {\\n        require(isTransferEnabled());\\n        require(_to != address(0));\\n        require(_to != address(this));\\n        uint256 total = _value.add(_fee);\\n        require(mintingDone);\\n        require(now \\u003e= lockups[_from]); // check lockups\\n        require(total \\u003c= balances[_from]);\\n\\n        balances[_from] = balances[_from].sub(total);\\n\\n        if(_fee \\u003e 0 \\u0026\\u0026 _feeAddress != address(0)) {\\n            balances[_feeAddress] = balances[_feeAddress].add(_fee);\\n        }\\n\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    \\n    function balanceOf(address _owner) public view returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n\\n    \\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        _approve(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    \\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    \\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].add(_addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].sub(_subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _approve(address _owner, address _spender, uint256 _value) internal {\\n        require(_spender != address(0));\\n        require(_owner != address(0));\\n\\n        allowed[_owner][_spender] = _value;\\n        emit Approval(_owner, _spender, _value);\\n    }\\n\\n    function transferAndCall(address _to, uint256 _value, bytes4 _methodName, bytes memory _args) public returns (bytes memory) {\\n        require(contractWhitelist[_to]);\\n        require(transfer(_to, _value));\\n\\n        emit TransferAndCall(msg.sender, _to, _value, _methodName, _args);\\n\\n        // call receiver\\n        require(Utils.isContract(_to));\\n\\n        (bool success, bytes memory data) = _to.call(abi.encodePacked(abi.encodeWithSelector(_methodName, msg.sender, _value), _args));\\n        require(success);\\n        return data;\\n    }\\n\\n    //ERC 865 + delegate transfer and call\\n    //The signature only allows s \\u003c secp256k1n / 2 and v to be 27/28\\n    //If this is not the case the function will revert\\n    function transferPreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce) public returns (bool) {\\n\\n        require(!signatures[_signature]);\\n        bytes32 hashedTx = Utils.transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\\n        address from = Utils.recover(hashedTx, _signature);\\n\\n        require(from != address(0));\\n        require(!nonces[from][_nonce]);\\n\\n        _transfer(from, _to, _value, _fee, msg.sender);\\n        signatures[_signature] = true;\\n        nonces[from][_nonce] = true;\\n\\n        emit Transfer(from, msg.sender, _fee);\\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\\n        return true;\\n    }\\n\\n    //The signature only allows s \\u003c secp256k1n / 2 and v to be 27/28\\n    //If this is not the case the function will revert\\n    function transferAndCallPreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce,\\n        bytes4 _methodName, bytes memory _args) public returns (bytes memory) {\\n\\n        require(contractWhitelist[_to]);\\n        require(!signatures[_signature]);\\n        bytes32 hashedTx = Utils.transferAndCallPreSignedHashing(address(this), _to, _value, _fee, _nonce, _methodName, _args);\\n        address from = Utils.recover(hashedTx, _signature);\\n\\n        require(from != address(0));\\n        require(!nonces[from][_nonce]);\\n\\n        _transfer(from, _to, _value, _fee, msg.sender);\\n        signatures[_signature] = true;\\n        nonces[from][_nonce] = true;\\n\\n        emit Transfer(from, msg.sender, _fee);\\n        emit TransferAndCallPreSigned(from, _to, msg.sender, _value, _fee, _methodName, _args);\\n\\n        // call receiver\\n        require(Utils.isContract(_to));\\n\\n        //call on behalf of from and not msg.sender\\n        (bool success, bytes memory data) = _to.call(abi.encodePacked(abi.encodeWithSelector(_methodName, from, _value), _args));\\n        require(success);\\n        return data;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"//using: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/f80c65ff67957404c964af864ffb230e4cbb1cf4/contracts/math/SafeMath.sol\\npragma solidity 0.5.7;\\n\\n\\n\\n\"},\"Utils.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\n\\n\"}}",
        "label": false,
        "name": "0xd68fbc1bde2d9ee90a19340685ba43bc3477f49e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nfunction FUN6(uint256 VAR4) public {\nFUN7(msg.sender, VAR4);\n}\nfunction FUN7(address VAR11, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR11]);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON6 is CON5, CON4 {\nstring public VAR12 = \"AquaToken\";\nstring public VAR13 = \"AQAU\";\nuint public VAR14 = 18;\nuint public VAR15 = 100000000 * 1 ether;\nconstructor() public {\nVAR2 = VAR15;\nVAR1[msg.sender] = VAR15;\n}\n}",
        "label": false,
        "name": "0x77b9dd6f9df5b783a05a91f18ad2e9319653f469.sol"
    },
    {
        "source": "\r\n\r\n\r\ncontract Trickle {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event AgreementCreated(\r\n        uint256 indexed agreementId,\r\n        address token,\r\n        address indexed recipient,\r\n        address indexed sender,\r\n        uint256 start,\r\n        uint256 duration,\r\n        uint256 totalAmount,\r\n        uint256 createdAt\r\n    );\r\n    event AgreementCanceled(\r\n        uint256 indexed agreementId,\r\n        address token,\r\n        address indexed recipient,\r\n        address indexed sender,\r\n        uint256 start,\r\n        uint256 duration,\r\n        uint256 amountReleased,\r\n        uint256 amountCanceled,\r\n        uint256 canceledAt\r\n    );\r\n    event Withdraw(\r\n        uint256 indexed agreementId,\r\n        address token,\r\n        address indexed recipient,\r\n        address indexed sender,\r\n        uint256 amountReleased,\r\n        uint256 releasedAt\r\n    );\r\n\r\n    uint256 private lastAgreementId;\r\n\r\n    struct Agreement {\r\n        uint256 meta;                                                                           uint256 totalAmount;\r\n        uint256 releasedAmount;\r\n        address recipient;\r\n        address sender;\r\n    }\r\n\r\n    mapping (uint256 => Agreement) private agreements;\r\n\r\n    modifier agreementPartiesOnly(uint256 agreementId) {\r\n        require (\r\n            msg.sender == agreements[agreementId].sender ||\r\n            msg.sender == agreements[agreementId].recipient,\r\n            \"Allowed only for agreement's sender or recipient\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validAgreement(uint256 agreementId) {\r\n        require(agreements[agreementId].releasedAmount < agreements[agreementId].totalAmount, \"Agreement is completed or does not exists\");\r\n        _;\r\n    }\r\n\r\n    function createAgreement(IERC20 token, address recipient, uint256 totalAmount, uint48 duration, uint48 start) external {\r\n        require(duration > 0, \"Duration must be greater than zero\");\r\n        require(totalAmount > 0, \"Total Amount must be greater than zero\");\r\n        require(start > 0, \"Start must be greater than zero\");\r\n        require(token != IERC20(0x0), \"Token must be a valid Ethereum address\");\r\n        require(recipient != address(0x0), \"Recipient must be a valid Ethereum address\");\r\n\r\n        uint256 agreementId = ++lastAgreementId;\r\n\r\n        agreements[agreementId] = Agreement({\r\n            meta: encodeMeta(start, duration, uint256(address(token))),\r\n            recipient: recipient,\r\n            totalAmount: totalAmount,\r\n            sender: msg.sender,\r\n            releasedAmount: 0\r\n        });\r\n\r\n        token.transferFrom(agreements[agreementId].sender, address(this), agreements[agreementId].totalAmount);\r\n\r\n        emit AgreementCreated(\r\n            agreementId,\r\n            address(token),\r\n            recipient,\r\n            msg.sender,\r\n            start,\r\n            duration,\r\n            totalAmount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function getAgreement(uint256 agreementId) external view returns (\r\n        address token,\r\n        address recipient,\r\n        address sender,\r\n        uint256 start,\r\n        uint256 duration,\r\n        uint256 totalAmount,\r\n        uint256 releasedAmount\r\n    ) {\r\n        (start, duration, token) = decodeMeta(agreements[agreementId].meta);\r\n        sender = agreements[agreementId].sender;\r\n        totalAmount = agreements[agreementId].totalAmount;\r\n        releasedAmount = agreements[agreementId].releasedAmount;\r\n        recipient = agreements[agreementId].recipient;\r\n    }\r\n\r\n    function withdrawTokens(uint256 agreementId) public validAgreement(agreementId) {\r\n        uint256 unreleased = withdrawableAmount(agreementId);\r\n        require(unreleased > 0, \"Nothing to withdraw\");\r\n\r\n        agreements[agreementId].releasedAmount = agreements[agreementId].releasedAmount.add(unreleased);\r\n        (, , address token) = decodeMeta(agreements[agreementId].meta);\r\n        IERC20(token).transfer(agreements[agreementId].recipient, unreleased);\r\n\r\n        emit Withdraw(\r\n            agreementId,\r\n            token,\r\n            agreements[agreementId].recipient,\r\n            agreements[agreementId].sender,\r\n            unreleased,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function cancelAgreement(uint256 agreementId) external validAgreement(agreementId) agreementPartiesOnly(agreementId) {\r\n        if (withdrawableAmount(agreementId) > 0) {\r\n            withdrawTokens(agreementId);\r\n        }\r\n\r\n        uint256 releasedAmount = agreements[agreementId].releasedAmount;\r\n        uint256 canceledAmount = agreements[agreementId].totalAmount.sub(releasedAmount);\r\n\r\n        (uint256 start, uint256 duration, address token) = decodeMeta(agreements[agreementId].meta);\r\n\r\n        agreements[agreementId].releasedAmount = agreements[agreementId].totalAmount;\r\n        if (canceledAmount > 0) {\r\n            IERC20(token).transfer(agreements[agreementId].sender, canceledAmount);\r\n        }\r\n\r\n        emit AgreementCanceled(\r\n            agreementId,\r\n            token,\r\n            agreements[agreementId].recipient,\r\n            agreements[agreementId].sender,\r\n            start,\r\n            duration,\r\n            releasedAmount,\r\n            canceledAmount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function withdrawableAmount(uint256 agreementId) public view returns (uint256) {\r\n        return proportionalAmount(agreementId).sub(agreements[agreementId].releasedAmount);\r\n    }\r\n\r\n    function proportionalAmount(uint256 agreementId) private view returns (uint256) {\r\n        (uint256 start, uint256 duration, ) = decodeMeta(agreements[agreementId].meta);\r\n        if (block.timestamp >= start.add(duration)) {\r\n            return agreements[agreementId].totalAmount;\r\n        } else if (block.timestamp <= start) {\r\n            return 0;\r\n        } else {\r\n            return agreements[agreementId].totalAmount.mul(\r\n                block.timestamp.sub(start)\r\n            ).div(duration);\r\n        }\r\n    }\r\n\r\n    function encodeMeta(uint256 start, uint256 duration, uint256 token) private pure returns(uint256 result) {\r\n        require(\r\n            start < 2 ** 48 &&\r\n            duration < 2 ** 48 &&\r\n            token < 2 ** 160,\r\n            \"Start, Duration or Token Address provided have invalid values\"\r\n        );\r\n\r\n        result = start;\r\n        result |= duration << (48);\r\n        result |= token << (48 + 48);\r\n\r\n        return result;\r\n    }\r\n\r\n    function decodeMeta(uint256 meta) private pure returns(uint256 start, uint256 duration, address token) {\r\n        start = uint48(meta);\r\n        duration = uint48(meta >> (48));\r\n        token = address(meta >> (48 + 48));\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}",
        "label": false,
        "name": "0x7ec0a611e7d491fbeef62dbebbdb3e65e019bf9b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeERC20 for CON5;\nfunction FUN3(CON5 VAR3) external FUN1 {\nuint256 VAR4 = VAR3.balanceOf(this);\nVAR3.safeTransfer(VAR1, VAR4);\n}\n}\ncontract CON3 is CON1 {\nfunction FUN4(address VAR5) external FUN1 {\nCON1 VAR6 = CON1(VAR5);\nVAR6.FUN2(VAR1);\n}\n}\ncontract CON4 is CON2 {\nfunction FUN5(address VAR7, uint256 VAR8, bytes VAR9) external {\nVAR7;\nVAR8;\nVAR9;\nrevert();\n}\n}\ncontract CON5 {\n}\ncontract CON6 is CON5 {\n}\ncontract CON7 is CON5 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR10;\nuint256 VAR11;\nfunction FUN6(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\n}\ncontract CON8 is CON6, CON7 {\nmapping (address => mapping (address => uint256)) internal VAR14;\nfunction FUN7(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR10[VAR15]);\nrequire(VAR13 <= VAR14[VAR15][msg.sender]);\nVAR10[VAR15] = VAR10[VAR15].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR14[VAR15][msg.sender] = VAR14[VAR15][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN8(address VAR16, uint256 VAR13) public returns (bool) {\nVAR14[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN9(address VAR16, uint VAR17) public returns (bool) {\nVAR14[msg.sender][VAR16] = VAR14[msg.sender][VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN10(address VAR16, uint VAR18) public returns (bool) {\nuint VAR19 = VAR14[msg.sender][VAR16];\nif (VAR18 > VAR19) {\nVAR14[msg.sender][VAR16] = 0;\n} else {\nVAR14[msg.sender][VAR16] = VAR19.sub(VAR18);\n}\nreturn true;\n}\n}\ncontract CON9 is CON4, CON3, CON8 {\nstring public constant VAR20 = \"DULA Coin\";\nstring public constant VAR21 = \"DULA\";\nuint8 public constant VAR22 = 18;\nuint256 public constant VAR23 = 10 * 10 ** 9 * 10 ** uint256(VAR22);\nconstructor(address VAR24) public {\nrequire(VAR24 != address(0), \"Distributor address must not be 0!\");\nVAR11 = VAR11.add(VAR23);\nVAR10[VAR24] = VAR10[VAR24].add(VAR23);\n}\n}",
        "label": false,
        "name": "0x1a4e76811d9c319a953eada36f1def25156c8d93.sol"
    },
    {
        "source": "contract CON1 {\nstring public VAR1 = \"MORE\";\nstring public VAR2 = \"MORE Token\";\nuint256 public VAR3 = 18;\nuint256 VAR4;\nmapping (address => uint256) VAR5;\nfunction CON1() public {\nVAR4 = 10*(10**9)*(10**18);\nVAR5[msg.sender] = VAR4;\n}\nfunction FUN1(address VAR6, uint256 VAR7) public {\nrequire(VAR5[msg.sender] >= VAR7);\nVAR5[msg.sender] = sub(VAR5[msg.sender], VAR7);\nVAR5[VAR6] = add(VAR5[VAR6], VAR7);\n}\n}",
        "label": false,
        "name": "0x1af8f3265d8274bde624edd9ec97f852fa4a5856.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN1(bytes32 VAR2) public {\nrequire(VAR1==msg.sender);\n}\n}",
        "label": false,
        "name": "0xecbbdbe761b7e7b04ccb2aee2fe5894c2d015188.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\n}\ncontract CON2 {\naddress public VAR2;\naddress public VAR3;\nfunction CON2() public {\nVAR2 = msg.sender;\nVAR3 = address(0);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR4) public FUN1 {\nrequire(address(0) != VAR4);\nVAR3 = VAR4;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR3);\nVAR2 = msg.sender;\nVAR3 = address(0);\n}\n}\ncontract CON3 is CON1, CON2 {\nusing SafeMath for uint;\nstring public VAR5;\nstring public VAR6;\nuint public VAR7; string public VAR8;\nuint public VAR1;\nuint public VAR9;\nbool public VAR10;\naddress public VAR11;\nbool public VAR12;\naddress public VAR13; uint public VAR14; uint public VAR15; uint public VAR16; uint public VAR17;\nmapping(address => uint) public VAR18;\nmapping(address => mapping(address => uint)) public VAR19;\nmodifier FUN4() {\nif (msg.sender != VAR11)\nrevert();\n_;\n}\nfunction CON3(uint VAR20,string VAR21,uint VAR22,string VAR23,string VAR24,uint VAR25) public payable\n{\nVAR1 = VAR20 * (10**VAR22);\nVAR5 = VAR21; VAR6 = VAR23; VAR7 = VAR22; VAR8 = VAR24; VAR9 = VAR25;\nVAR18[0x4aC4E864C19c3261A3f25DA4f60F55147C2aB25b] = VAR1;\nVAR2 = 0x4aC4E864C19c3261A3f25DA4f60F55147C2aB25b;\nVAR12 = true;\nVAR10 = true;\n}\nfunction FUN5(uint VAR25) public payable {\nrequire(!VAR10);\nrequire(VAR16 == msg.value);\nVAR10 = true;\nVAR9 = VAR25;\nVAR13.FUN9(msg.value);\n}\nfunction FUN6() public payable {\nrequire(!VAR12);\nrequire(VAR17 == msg.value);\nVAR12 = true;\nVAR13.FUN9(msg.value);\n}\nfunction FUN7() public payable {\nrequire(VAR10);\nuint VAR26;\nVAR26 = (msg.value * (10**VAR7)) / VAR9;\nrequire(VAR18[VAR2] >= VAR26);\nVAR18[msg.sender] += VAR26;\nVAR18[VAR2] -= VAR26;\nVAR2.FUN9(msg.value);\n}\nfunction FUN8(address VAR27, uint256 VAR28) public FUN1() {\nVAR18[VAR27] += VAR28;\nVAR1 += VAR28;\n}\nfunction FUN9(address VAR29, uint VAR30) public returns(bool) {\nrequire(VAR29 != address(0));\nrequire(VAR18[msg.sender] >= VAR30);\nVAR18[msg.sender] = VAR18[msg.sender].sub(VAR30);\nVAR18[VAR29] = VAR18[VAR29].add(VAR30);\nreturn true;\n}\nfunction FUN10(address VAR31, address VAR29, uint256 VAR30) public returns(bool VAR32) {\nrequire(VAR29 != address(0));\nrequire(VAR18[VAR31] >= VAR30); require(VAR30 <= VAR19[VAR31][msg.sender]); VAR18[VAR31] = VAR18[VAR31].sub(VAR30); VAR18[VAR29] = VAR18[VAR29].add(VAR30); VAR19[VAR31][msg.sender] = VAR19[VAR31][msg.sender].sub(VAR30);\nreturn true;\n}\nfunction FUN11(address VAR33, uint VAR30) public returns(bool) {\nVAR19[msg.sender][VAR33] = VAR30;\nreturn true;\n}\nfunction FUN12 (address VAR33, uint VAR34) public returns (bool VAR32) {\nVAR19[msg.sender][VAR33] = VAR19[msg.sender][VAR33].add(VAR34);\nreturn true;\n}\nfunction FUN13 (address VAR33, uint VAR35) public returns (bool VAR32) {\nuint VAR36 = VAR19[msg.sender][VAR33];\nif (VAR35 > VAR36) {\nVAR19[msg.sender][VAR33] = 0;\n} else {\nVAR19[msg.sender][VAR33] = VAR36.sub(VAR35);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd45247c07379d94904e0a87b4481f0a1ddfa0c64.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN3(VAR2);\n}\nfunction FUN3(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nstruct Copyright\n{\nuint256 VAR3;\nstring VAR4;\nstring VAR5;\nuint256 VAR6;\naddress VAR7;\naddress VAR8;\n}\nCopyright[] public VAR9;\nbool public VAR10 = false;\nfunction FUN4(string VAR4,string VAR5,address VAR7) public FUN5 {\nrequire(!isContract(VAR7));\nCopyright memory VAR11 = Copyright({VAR3:VAR9.length,VAR4:VAR4,VAR5:VAR5,VAR6:block.timestamp,VAR7:VAR7,VAR8:msg.sender});\nVAR9.push(VAR11);\n}\nmodifier FUN5() {\nrequire(!VAR10);\n_;\n}\nmodifier FUN6() {\nrequire(VAR10);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR10 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR10 = false;\n}\n}",
        "label": false,
        "name": "0x303995ad2fbc92429dc7b4448a9787221a006ee6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nfunction CON4() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nfunction CON5() public {\nVAR4 = \"TXI\";\nVAR5 = \"TIXI\";\nVAR6 = 18;\nVAR7 = 3000000000 * 10 ** (VAR6);\nVAR8[0x01DC0e734D17b1F0Faa24addc3480dCDEbeDbEDF] = VAR7;\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7 - VAR8[address(0)];\n}\nfunction FUN5(address VAR10) public constant returns (uint VAR11) {\nreturn VAR8[VAR10];\n}\nfunction FUN6(address VAR12, uint VAR13) public returns (bool VAR14) {\nrequire(VAR12 != address(0));\nrequire(VAR13 > 0);\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nrequire(VAR16 != address(0));\nrequire(VAR12 != address(0));\nrequire(VAR13 > 0);\nVAR8[VAR16] = safeSub(VAR8[VAR16], VAR13);\nVAR9[VAR16][msg.sender] = safeSub(VAR9[VAR16][msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR15) public constant returns (uint VAR17) {\nreturn VAR9[VAR10][VAR15];\n}\nfunction FUN10(address VAR15, uint VAR13, bytes VAR18) public returns (bool VAR14) {\nrequire(VAR15 != address(0));\nrequire(VAR13 > 0);\nVAR9[msg.sender][VAR15] = VAR13;\nCON3(VAR15).receiveApproval(msg.sender, VAR13, this, VAR18);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN12(address VAR19, uint VAR13) public FUN1 returns (bool VAR14) {\nreturn CON2(VAR19).FUN6(VAR1, VAR13);\n}\n}",
        "label": false,
        "name": "0x9e4e85adcdc8149d96ec7845ca40c0ea1136f756.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 =18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9145b60407ccfd30fb74fc00959ce6511d1364b6.sol"
    },
    {
        "source": "contract CON1 {}\ncontract CON2 is CON1{}\ncontract CON3 is CON2{\nmapping(address => uint256) public VAR1;\n}\ncontract CON4 {\nCON3 public VAR2;\naddress public VAR3;\nconstructor (CON3 VAR4) public {\nVAR3 = 0x4f89aaCC3915132EcE2E0Fef02036c0F33879eA8;\nVAR2 = VAR4;\n}\nfunction FUN1() public {\nVAR2.transfer(VAR3, 1000000000000000000);\n}\n}",
        "label": false,
        "name": "0xf3ac6c6a88de9cafd1fcd418b01da0184b442ea6.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ninterface CON3 {\n}\ninterface CON4 {\n}\ninterface CON5 {\n}\ninterface CON6 {\n}\ncontract CON7 {\naddress public VAR1;\nmodifier FUN1() {\nrequire(msg.sender == getAddress(\"admin\"),\"Permission Denied\");\n_;\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint;\nusing SafeMath for uint256;\nbytes32 VAR2 = 0x0000000000000000000000000000000000000000000000000000000000000000;\naddress VAR3; mapping (address => bytes32) VAR4; bool public VAR5;\n}\ncontract CON9 is CON8 {\nfunction FUN2(uint VAR6) public payable {\nif (msg.value > 0) {FUN3(msg.sender);}\nif (VAR6 > 0) {FUN4(VAR6);}\n}\nfunction FUN3(address VAR7) public payable {\nCON3 VAR8 = CON3(VAR3);\nif (VAR4[VAR7] == VAR2) {\nrequire(msg.sender == VAR7, \"Creating CDP for others is not permitted at the moment.\");\nVAR4[msg.sender] = VAR8.open();\n}\nCON5 VAR9 = CON5(getAddress(\"weth\"));\nVAR9.deposit.value(msg.value)(); uint VAR10 = pethPEReth(msg.value);\nVAR8.join(VAR10); VAR8.lock(VAR4[VAR7], VAR10);\n}\nfunction FUN4(uint VAR6) public {\nrequire(!VAR5, \"Operation Disabled\");\nCON3 VAR8 = CON3(VAR3);\nVAR8.draw(VAR4[msg.sender], VAR6);\nCON1 VAR11 = CON1(getAddress(\"dai\"));\nVAR11.transfer(msg.sender, VAR6);\n}\n}\ncontract CON10 is CON9 {\nfunction FUN5(uint VAR12, uint VAR13) public payable {\nif (VAR12 > 0) {FUN6(VAR12, msg.sender);}\nif (VAR13 > 0) {FUN7(VAR13);}\n}\nfunction FUN6(uint VAR12, address VAR7) public payable {\naddress VAR14 = getAddress(\"dai\");\naddress VAR15 = getAddress(\"mkr\");\naddress VAR16 = getAddress(\"eth\");\nCON1 VAR11 = CON1(VAR14);\nCON1 VAR17 = CON1(VAR15);\nuint VAR18 = VAR17.balanceOf(address(this)); VAR11.transferFrom(msg.sender, address(this), VAR12); CON3 VAR8 = CON3(VAR3);\nVAR8.wipe(VAR4[VAR7], VAR12); uint VAR19 = VAR18 - VAR17.balanceOf(address(this));\nif (msg.value > 0) { FUN8(VAR16, VAR15, VAR19, msg.value);\n} else { VAR17.transferFrom(msg.sender, address(this), VAR19); }\n}\nfunction FUN7(uint VAR13) public {\nrequire(!VAR5, \"Operation Disabled\");\nuint VAR20 = pethPEReth(VAR13);\nCON3 VAR8 = CON3(VAR3);\nVAR8.free(VAR4[msg.sender], VAR20); VAR8.exit(VAR20); CON5 VAR9 = CON5(getAddress(\"weth\"));\nVAR9.withdraw(VAR13); msg.sender.transfer(VAR13);\n}\nfunction FUN8(address VAR16,address VAR15,uint VAR19,uint VAR21) internal\n{\nCON6 VAR22 = CON6(getAddress(\"InstaKyber\"));\nuint VAR23;\n(, VAR23) = VAR22.getExpectedPrice(VAR16, VAR15, VAR21);\nuint VAR24 = VAR22.executeTrade.value(VAR21)(VAR16, VAR15, VAR21, VAR23, VAR19);\nrequire(VAR19 == VAR24, \"ETH not sufficient to cover the MKR fees.\");\nif (address(this).balance > 0) {\nmsg.sender.transfer(address(this).balance);\n}\n}\n}\ncontract CON11 is CON10 {\nfunction FUN9(address VAR25) public {\nrequire(VAR25 != 0, \"Invalid Address.\");\nCON3 VAR8 = CON3(VAR3);\nVAR8.give(VAR4[msg.sender], VAR25);\nVAR4[msg.sender] = VAR2;\n}\nfunction FUN10() public {\nCON1 VAR9 = CON1(getAddress(\"weth\"));\nVAR9.approve(VAR3, 2**256 - 1);\nCON1 VAR26 = CON1(getAddress(\"peth\"));\nVAR26.approve(VAR3, 2**256 - 1);\nCON1 VAR17 = CON1(getAddress(\"mkr\"));\nVAR17.approve(VAR3, 2**256 - 1);\nCON1 VAR11 = CON1(getAddress(\"dai\"));\nVAR11.approve(VAR3, 2**256 - 1);\n}\n}\ncontract CON12 is CON11 {\nconstructor(address VAR27) public {\nVAR1 = VAR27;\nVAR3 = getAddress(\"cdp\");\nFUN10();\n}\nfunction () public payable {}\nfunction FUN12(bool VAR28) public FUN1 {\nVAR5 = VAR28;\n}\nfunction FUN13(uint VAR29) public FUN1 {\nCON1 VAR17 = CON1(getAddress(\"mkr\"));\nVAR17.transfer(msg.sender, VAR29);\n}\n}",
        "label": false,
        "name": "0xe1076fc995b3d299a2957eb0035049e8666b412e.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR3 = true;\n}\nfunction FUN8() FUN1 FUN6 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) public VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 public VAR6;\nfunction FUN9(address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR8) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN14(VAR10, VAR7, VAR8);\nFUN15(VAR10, msg.sender, VAR5[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN12(address VAR9, uint256 VAR11) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR9, uint256 VAR12) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN14(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\nfunction FUN15(address VAR13, address VAR9, uint256 VAR8) internal {\nrequire(VAR9 != address(0));\nrequire(VAR13 != address(0));\nVAR5[VAR13][VAR9] = VAR8;\n}\n}\ncontract CON5 is CON4, CON2 {\nfunction FUN9(address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10, address VAR7, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN10(address VAR9, uint256 VAR8) public FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR8);\n}\nfunction FUN12(address VAR9, uint VAR11) public FUN5 returns (bool VAR14) {\nreturn super.FUN12(VAR9, VAR11);\n}\nfunction FUN13(address VAR9, uint VAR12) public FUN5 returns (bool VAR14) {\nreturn super.FUN13(VAR9, VAR12);\n}\n}\ncontract CON6 is CON1 {\nCON7 public VAR15;\nuint256 constant public VAR16 = 18;\nuint256 public VAR6 = 100000000 * (10 ** uint256(VAR16));\nconstructor () public {\nVAR15 = FUN16();\nVAR15.FUN8();\n}\nfunction FUN16() internal returns (CON7) {\nreturn new CON7();\n}\nfunction FUN17() external FUN1 {\nVAR15.FUN8();\n}\nfunction FUN18() external FUN1 {\nVAR15.FUN7();\n}\nfunction FUN9(address VAR7, uint256 VAR8) external FUN1 returns (bool VAR17) {\nuint256 VAR18 = VAR8 * (10 ** uint256(VAR16));\nreturn VAR15.FUN9(VAR7, VAR18);\n}\n}\ncontract CON7 is CON5 {\nstring constant public VAR19 = \"Marvelous Business Transaction Coin\";\nstring constant public VAR20 = \"MBTC\";\nuint8 constant public VAR21 = 18;\nuint256 constant VAR22 = 10 ** uint256(VAR21);\nuint256 constant VAR23 = 100000000 * VAR22;\nconstructor () public {\nVAR3 = true;\nVAR6 = VAR23;\nVAR4[msg.sender] = VAR23;\n}\n}",
        "label": false,
        "name": "0x634ca6a844a172c053b3fdee8827c449f849fb16.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4, uint256 VAR5) public FUN10 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN19(msg.sender);\n}\nmodifier FUN16() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN17(address VAR10) public FUN16 {\nFUN19(VAR10);\n}\nfunction FUN18() public {\nFUN20(msg.sender);\n}\nfunction FUN19(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN20(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON6 is CON5 {\nbool private VAR13;\nconstructor () internal {\nVAR13 = false;\n}\nmodifier FUN21() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN22() {\nrequire(VAR13);\n_;\n}\nfunction FUN23() public FUN16 FUN21 {\nVAR13 = true;\n}\nfunction FUN24() public FUN16 FUN22 {\nVAR13 = false;\n}\n}\ncontract CON7 is CON2, CON6 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN21 returns (bool VAR14) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN21 returns (bool VAR14) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON8 is CON2 {\nfunction FUN25(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN26(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON9 is CON4, CON7, CON8 {\nstring public VAR15;\nstring public VAR16;\nuint256 public VAR17;\nconstructor() public {\nVAR15 = \"CMDX\";\nVAR16 = \"CMDX\";\nVAR17 = 18;\n}\n}",
        "label": false,
        "name": "0x63bcfa2aaf618662b76e58eae4ee410f933b47ac.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON1{\nusing SafeMath for uint256;\nCON2 public VAR3;\nuint256 public VAR4;\nuint256 public VAR5;\nuint256 public VAR6 = 1000;\nuint256 public VAR7;\nuint256 public VAR8;\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\nuint256 VAR13;\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\nbool VAR17 = false;\nuint256 VAR18 = 75 days;\nmapping(address=>bool) VAR19;\nfunction CON3(uint256 VAR20, address VAR21, address VAR22) public\n{\nrequire(VAR21 != 0x0);\nrequire(VAR20 >=now);\nVAR4 = VAR20;\nVAR5 = VAR4 + VAR18;\nrequire(VAR5 >= VAR4);\nVAR1 = VAR21;\nVAR9 = 32500000 * 10 ** 18;\nVAR12 = 30;\nVAR13 = 25;\nVAR14 = 20;\nVAR13 = 10;\nVAR16 = 5;\nVAR10 = 7000000 * 10 ** 18;\nVAR11 = 3000000 * 10 ** 18;\nVAR3 = CON2(VAR22);\n}\nfunction () public payable {\nFUN4(msg.sender);\n}\nfunction FUN4(address VAR23) public payable {\nrequire(VAR23 != 0x0);\nrequire(VAR17 == false);\nrequire(VAR19[VAR23] == true);\nrequire(FUN6());\nrequire(VAR8<VAR9);\nuint256 VAR24 = msg.value;\nuint256 VAR25 = VAR24.mul(VAR6);\nuint256 VAR26 = determineBonus(VAR25);\nVAR25 = VAR25.add(VAR26);\nVAR7 = VAR7.add(VAR24);\nVAR3.transfer(VAR23,VAR25);\nVAR8 = VAR8.add(VAR25);\nFUN5();\n}\nfunction FUN5() internal {\nVAR1.transfer(msg.value);\n}\nfunction FUN6() internal constant returns (bool) {\nbool VAR27 = now >= VAR4 && now <= VAR5;\nbool VAR28 = msg.value != 0;\nreturn VAR27 && VAR28;\n}\nfunction FUN7() public constant returns (bool) {\nreturn now > VAR5;\n}\nfunction FUN8(uint256 VAR29) public FUN1{\nVAR5 = VAR29;\n}\nfunction FUN9(uint256 VAR30) public FUN1{\nVAR4 = VAR30;\n}\nfunction FUN10(uint256 VAR31) public FUN1 {\nVAR6 = VAR31;\n}\nfunction FUN11() public FUN1 {\nVAR17 = true;\n}\nfunction FUN12() public FUN1 {\nVAR17 = false;\n}\nfunction FUN13(address VAR32) public FUN1\n{\nVAR19[VAR32]= true;\n}\nfunction FUN14(address VAR32) public FUN1\n{\nVAR19[VAR32]= false;\n}\nfunction FUN15() public FUN1\n{\nuint VAR33 = VAR3.balanceOf(address(this));\nVAR3.transfer(VAR1,VAR33);\n}\nfunction FUN16(address VAR34) public FUN1\n{\nrequire(FUN7());\nuint VAR33 = VAR3.balanceOf(address(this));\nVAR3.transfer(VAR34,VAR33);\n}\n}",
        "label": false,
        "name": "0x630692af992c84d59a77990587b15d8b330e084b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nfunction CON4() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nfunction CON5() public {\nVAR4 = \"WSC\";\nVAR5 = \"WienerSportCoin\";\nVAR6 = 18;\nVAR7 = 10000000000000000000000000;\nVAR8[0xDeDb2bc188C593421C27a78D54fcAd3ed6b214B1] = VAR7;\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7 - VAR8[address(0)];\n}\nfunction FUN5(address VAR10) public constant returns (uint VAR11) {\nreturn VAR8[VAR10];\n}\nfunction FUN6(address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[VAR16] = safeSub(VAR8[VAR16], VAR13);\nVAR9[VAR16][msg.sender] = safeSub(VAR9[VAR16][msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR15) public constant returns (uint VAR17) {\nreturn VAR9[VAR10][VAR15];\n}\nfunction FUN10(address VAR15, uint VAR13, bytes VAR18) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nCON3(VAR15).receiveApproval(msg.sender, VAR13, this, VAR18);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN12(address VAR19, uint VAR13) public FUN1 returns (bool VAR14) {\nreturn CON2(VAR19).FUN6(VAR1, VAR13);\n}\n}",
        "label": false,
        "name": "0x2774803bcb0368001b9641860ad509dfc0d62642.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 9900000000000000000000000000;\nVAR6 = 9900000000000000000000000000;\nVAR3 = \"FZend Blockchain\";\nVAR4 = \"FZB\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4e065fbcf13688317a1d6c40b722601e732ba636.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath\nfor uint;\nmapping(address => uint) public VAR1;\nmapping(address => uint) public VAR2;\nmapping(address => uint) public VAR3;\naddress public VAR4 = 0xf76775E4C97fe43cf42a41b45d3D1A2e283Ec43A;\naddress public VAR5 = 0xeC2325073AE9F288b3dF22b3b55E68BB3fD9bCB5;\nuint VAR6 = 7;\nuint public VAR7 = 1;\nuint public VAR8 = 1 hours;\nuint public VAR9 = 375;\nuint public VAR10 = 400;\nuint public VAR11 = 450;\nuint public VAR12 = 500;\nuint public VAR13 = 500 ether;\nuint public VAR14 = 2000 ether;\nuint public VAR15 = 4000 ether;\nuint public VAR16 = 0;\nuint public VAR17 = 0;\nmodifier FUN1() {\nrequire(VAR1[msg.sender] > 0, \"Deposit not found\");\n_;\n}\nmodifier FUN2() {\nrequire(now >= VAR2[msg.sender].add(VAR8), \"Too fast VAR18 request\");\n_;\n}\nfunction FUN3() FUN1 FUN2 internal {\nif ((VAR1[msg.sender].mul(2)) <= VAR3[msg.sender]) {\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\n} else {\nuint VAR18 = payoutAmount();\nVAR2[msg.sender] = now;\nVAR3[msg.sender] += VAR18;\nmsg.sender.transfer(VAR18);\n}\n}\nfunction FUN4() private {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR16 += 1;\n}\nif (VAR1[msg.sender] > 0 && now > VAR2[msg.sender].add(VAR8)) {\nFUN3();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR4.transfer(msg.value.mul(VAR6).div(100));\nuint VAR19 = msg.value.mul(VAR7).div(100);\nVAR17 += VAR19;\nVAR5.transfer(VAR19);\n} else {\nFUN3();\n}\n}\nfunction FUN5() FUN1 private {\nuint VAR20 = VAR1[msg.sender].sub(VAR3[msg.sender]).sub(VAR1[msg.sender].mul(VAR6).div(100));\nrequire(VAR1[msg.sender] > VAR20, 'You have already repaid your deposit');\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR20);\n}\nfunction() external payable {\nif (msg.value == 0.00000525 ether) {\nFUN5();\n} else {\nFUN4();\n}\n}\n}",
        "label": false,
        "name": "0x6a16055015bce7d67c80030b383bdd89ab565dbc.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 > 0);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR4 != address(0));\nuint256 VAR7 = VAR3[VAR6][msg.sender];\nVAR2[VAR6] = VAR2[VAR6].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nVAR3[VAR6][msg.sender] = VAR7.sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR8) public constant returns (uint256 VAR9) {\nreturn VAR2[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR10] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR3[VAR8][VAR10];\n}\n}\ncontract CON3 is CON2 {\nstring public VAR12 = \"SPN Token\";\nstring public VAR13 = \"SPN\";\nuint public VAR14 = 18;\nuint public constant VAR15 = 200000000e18;\naddress public constant VAR16 = 0xDDD4b9Dc94Eb41969E37EB64baf3C0E1cd959c29;\nfunction CON3() public {\nVAR2[msg.sender] = VAR15;\nVAR1 = VAR15;\nFUN1(VAR16, VAR15);\n}\n}",
        "label": false,
        "name": "0x67bc56caad630dc1719b14a540adc8e9968325c3.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor () internal {\nFUN8(msg.sender);\n}\nmodifier FUN5() {\nrequire(isWhitelistAdmin(msg.sender));\n_;\n}\nfunction FUN6(address VAR4) public FUN5 {\nFUN8(VAR4);\n}\nfunction FUN7() public {\nFUN9(msg.sender);\n}\nfunction FUN8(address VAR4) internal {\nVAR3.add(VAR4);\n}\nfunction FUN9(address VAR4) internal {\nVAR3.remove(VAR4);\n}\n}\ncontract CON3 is CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR5;\nmodifier FUN10() {\nrequire(isWhitelisted(msg.sender));\n_;\n}\nfunction FUN11(address VAR4) public FUN5 {\nFUN14(VAR4);\n}\nfunction FUN12(address VAR4) public FUN5 {\nFUN15(VAR4);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR4) internal {\nVAR5.add(VAR4);\n}\nfunction FUN15(address VAR4) internal {\nVAR5.remove(VAR4);\n}\n}\ncontract CON4 is CON1, CON3 {\nconstructor ()\nCON3() public {\n}\nfunction FUN16(address VAR6) public FUN5 {\nif (!isWhitelisted(VAR6)) {\nFUN11(VAR6);\n}\n}\nfunction FUN17(address VAR4) public FUN1 {\nrequire(VAR4 != msg.sender, \"Use renounceWhitelistAdmin\");\nFUN9(VAR4);\n}\n}",
        "label": false,
        "name": "0x0000000fdf9eb269b38e39e058f45d7d0ddb60f9.sol"
    },
    {
        "source": "{\"ERC20.sol\":{\"content\":\"\\npragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        require(value== 0 || _allowed[msg.sender][spender] == 0);\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract ERC20Burnable is ERC20 {\\n    \\n    function burn(uint256 value) public {\\n        _burn(msg.sender, value);\\n    }\\n\\n    \\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    \\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    \\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    \\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\n\\n\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\n \\ncontract Token is ERC20, ERC20Detailed, ERC20Burnable {\\n    uint8 public constant DECIMALS = 18;\\n    // uint256 public constant INIT_SUPPLY = 10000000000 * (10 ** uint256(DECIMALS));\\n     \\n    // address private constant ADDR_TOKEN_SWAP = address(0x1234);\\n    // address private constant ADDR_OPERATION = address(0x1234);\\n    // address private constant ADDR_REWARD = address(0x1234);\\n    // address private constant ADDR_TEAM = address(0x1234);\\n    // address private constant ADDR_PARTNER = address(0x1234);\\n    \\n    // 2019.06.01 ~ 2021.12.01.\\n    uint[31] private TIME_TABLE = [ 1559347200,\\n        1561939200, 1564617600, 1567296000, 1569888000, 1572566400, 1575158400, \\n        1577836800, 1580515200, 1583020800, 1585699200, 1588291200, 1590969600, \\n        1593561600, 1596240000, 1598918400, 1601510400, 1604188800, 1606780800,\\n        1609459200, 1612137600, 1614556800, 1617235200, 1619827200, 1622505600, \\n        1625097600, 1627776000, 1630454400, 1633046400, 1635724800, 1638316800];\\n        \\n    \\n    // event Mint(address indexed to, uint256 amount);\\n    // event FininshedMint();\\n\\n    struct TimeMint {\\n        address beneficiary;\\n        uint256 releaseTime;\\n        uint256 value;\\n    }\\n    \\n    TimeMint[] timeMintList;\\n\\n    address owner;\\n    bool mintingAvail = true;\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n    \\n    modifier canMint() {\\n        require(mintingAvail);\\n        _;\\n    }\\n\\n    \\n    constructor () public ERC20Detailed(\\\"HAMA token\\\", \\\"HAMA\\\", DECIMALS) {\\n        \\n        // All tokens will provide by insertTimeMintTimeTable\\n        // _mint(msg.sender, INITIAL_SUPPLY);\\n        owner = msg.sender;\\n        // _initMintScheuld();\\n    }\\n    \\n    \\n    // function _initMintScheuld() internal{\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[0], 1500000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[2], 200000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[3], 100000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[4], 300000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[5], 100000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[6], 300000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[7], 100000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[8], 300000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[9], 100000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[10], 300000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[11], 100000000);\\n        // insertTimeMint(ADDR_TOKEN_SWAP, TIME_TABLE[12], 100000000);\\n        \\n        // for (uint i=0; i\\u003c10; i+=3) {\\n        //     insertTimeMint(ADDR_OPERATION, TIME_TABLE[i], 375000000);\\n        // }\\n        \\n        // insertTimeMint(ADDR_REWARD, TIME_TABLE[0], 3000000000);\\n        \\n        // for (uint i=7; i\\u003c25; i++) {\\n        //     insertTimeMint(ADDR_TEAM, TIME_TABLE[i], 38920000);\\n        // }\\n        \\n        // for (uint i=0; i\\u003c25; i+=3) {\\n        //     insertTimeMint(ADDR_PARTNER, TIME_TABLE[i], 162500000);\\n        // }\\n    // }\\n\\n    \\n    function getTimeTimeLength() view public returns(uint256) {\\n        return timeMintList.length;\\n    }\\n\\n    \\n    function getTimeTimeMint(uint index) view public returns(address, uint256, uint256) {\\n        return (timeMintList[index].beneficiary, timeMintList[index].releaseTime, timeMintList[index].value);\\n    }\\n\\n    \\n    function insertTimeMintTimeTable(address _beneficiary, uint256 index, uint256 _value) onlyOwner canMint public returns (bool){\\n        require(_beneficiary != address(0));\\n        require(index \\u003e= 0 \\u0026\\u0026 index \\u003c TIME_TABLE.length, \\\"insertTimeMint: index out of range\\\");\\n        return insertTimeMint(_beneficiary, TIME_TABLE[index], _value);\\n    }\\n    \\n    \\n    function insertTimeMint(address _beneficiary, uint256 _releaseTime, uint256 _value) onlyOwner canMint public returns (bool){\\n        require(_beneficiary != address(0));\\n        require(_releaseTime \\u003e block.timestamp, \\\"TokenTimelock: release time is before current time\\\");\\n        TimeMint memory item = TimeMint({\\n            beneficiary: _beneficiary,\\n            releaseTime: _releaseTime,\\n            value: _value\\n        });\\n        timeMintList.push(item);\\n        return true;\\n    }\\n    \\n    \\n    function removeTimeMint(uint index) onlyOwner canMint public returns (bool){\\n        require(index \\u003e= 0 \\u0026\\u0026 index \\u003c timeMintList.length, \\\"removeTimeMint: index out of range.\\\");\\n        timeMintList[index] = timeMintList[timeMintList.length-1];\\n        delete timeMintList[timeMintList.length-1];\\n        timeMintList.length--;\\n        return true;\\n    }\\n    \\n \\n    function releaseTimeMintToken() onlyOwner canMint public returns (bool) {\\n        require(timeMintList.length \\u003e 0);\\n        uint i = 0;\\n        while (i \\u003c timeMintList.length) {\\n            if (block.timestamp \\u003e= timeMintList[i].releaseTime) {           // 0. if True\\n                if (_mintForTime(timeMintList[i])) {                        // 1. Mining according to timeMintList[i].\\n                    timeMintList[i] = timeMintList[timeMintList.length-1];  // 2.  Note: timeMintList[timeMintList.length-1] is timeMintList[i] NOW !!\\n                    delete timeMintList[timeMintList.length-1];\\n                    timeMintList.length--;\\n                    continue;   // To solve the problem.\\n                }\\n            }\\n            i++;    // 3. BUT we skipped the check of timeMintList[i](i.e. timeMintList[timeMintList.length-1]) with `i++`, \\n        }\\n    }\\n    \\n    function _mintForTime(TimeMint memory item) onlyOwner canMint private returns (bool) {\\n        require(block.timestamp \\u003e= item.releaseTime, \\\"TokenTimelock: current time is before release time\\\");\\n        _mint(item.beneficiary, item.value);\\n        // emit Mint(item.beneficiary, item.value);\\n        return true;\\n    }\\n    \\n    \\n    function finishMinting() onlyOwner canMint public returns (bool) {\\n        mintingAvail = false;\\n        // emit FininshedMint();\\n        return true;\\n    }\\n\\n}\"}}",
        "label": false,
        "name": "0xb0035b4edb8b2c907531fdcb204ffb52c4b4d8ed.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() public payable { }\nfunction FUN7() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN8(address VAR4) FUN1 public {\nselfdestruct(VAR4);\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON3 {\nstruct Monster {\nuint64 VAR5;\nuint8 VAR6;\nuint16 VAR7;\nuint16 VAR8;\n}\nCON4 public VAR9 = CON4(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\nuint8 public constant VAR10 = 4;\nuint8 public constant VAR11 = 8;\nuint8 public constant VAR12 = 12;\nuint public constant VAR13 = 3;\nuint16 public VAR14 = 10;\nuint public VAR15 = 4;\nuint64 public VAR16 = 8 minutes;\nuint public VAR17 = 0.04 ether;\nuint public VAR18 = 0.16 ether;\nuint public VAR19;\nuint VAR20;\nmapping(uint => Monster) public VAR21;\nmapping(uint => uint) public VAR22;\nmapping(uint => uint) public VAR23;\nfunction FUN9() public payable {}\nfunction FUN10(uint VAR24) FUN3 FUN15 external payable {\nuint VAR25;\naddress VAR1;\n(,,, VAR25, VAR1,,) = VAR9.getHeroDetails(VAR24);\nrequire(msg.sender == VAR1);\nuint VAR26 = (VAR25 / (32 ** 12)) % 32 + 1;\nuint VAR27 = (VAR25 / (32 ** 8)) % 32 + 1;\nMonster memory VAR28 = VAR21[VAR24];\nuint VAR29 = VAR28.VAR6;\nuint VAR30 = VAR22[VAR24];\nbool VAR31;\nif (VAR29 == 0) {\nrequire(msg.value >= VAR17);\nVAR19 += VAR17;\nVAR21[VAR24] = Monster(uint64(now), 1, VAR14, VAR14);\nVAR28 = VAR21[VAR24];\nVAR22[VAR24] = VAR26;\nVAR30 = VAR26;\nif (msg.value > VAR17) {\nmsg.sender.transfer(msg.value - VAR17);\n}\n} else {\nrequire(VAR30 > 0);\nVAR31 = now > VAR28.VAR5 + VAR16 * 2 ||\n(VAR28.VAR8 == VAR28.VAR7 && now > VAR28.VAR5 + VAR16);\nif (VAR31) {\nuint VAR32 = VAR17 - VAR23[VAR24];\nif (VAR32 > 0) {\nVAR18 += VAR32;\nVAR19 -= VAR32;\nVAR23[VAR24] += VAR32;\n}\nassert(VAR32 <= VAR17);\n}\nmsg.sender.transfer(msg.value);\n}\nif (!VAR31) {\nFUN13(VAR24, VAR25, VAR27, VAR30);\n}\n}\nfunction FUN11(address VAR33) FUN1 external {\nVAR9 = CON4(VAR33);\n}\nfunction FUN12(uint VAR34) FUN1 external {\nVAR17 = VAR34;\n}\nfunction FUN13(uint VAR24, uint VAR35, uint VAR36, uint VAR37) internal {\nMonster storage VAR28 = VAR21[VAR24];\nuint8 VAR29 = VAR28.VAR6;\nuint VAR38;\n(VAR38,,,,) = VAR9.getHeroPower(VAR35, VAR13);\nuint VAR39;\nuint VAR40;\nif (now > VAR28.VAR5 + VAR16) {\nVAR39 = VAR29 + VAR15;\n} else {\nif (VAR29 >= 2) {\nVAR39 = FUN14(VAR29 / 2);\n}\n}\nif (VAR39 >= VAR37) {\nVAR22[VAR24] = 0;\nuint VAR32 = VAR17 - VAR23[VAR24];\nif (VAR32 > 0) {\nVAR18 += VAR32;\nVAR19 -= VAR32;\nVAR23[VAR24] += VAR32;\n}\nassert(VAR32 <= VAR17);\n} else {\nVAR22[VAR24] -= VAR39;\nif (now > VAR28.VAR5 + VAR16) {\nVAR29++;\nVAR21[VAR24] = Monster(uint64(VAR28.VAR5 + VAR16),VAR29, VAR29 * VAR14, VAR29 * VAR14);\nVAR28 = VAR21[VAR24];\n}\nVAR40 = (VAR36 * 1e9 + VAR38 * 1e9 / (10 * (1 + FUN14(5)))) / tx.gasprice;\nbool VAR41 = VAR40 >= VAR28.VAR8;\nif (VAR41) {\nuint VAR42;\nuint8 VAR43 = VAR29 + 1;\nVAR21[VAR24] = Monster(uint64(now), VAR43, VAR43 * VAR14, VAR43 * VAR14);\nVAR28 = VAR21[VAR24];\nif (VAR29 == VAR10) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR11) {\nVAR42 = VAR17 / 2;\nVAR23[VAR24] += VAR42;\nVAR19 -= VAR42;\n} else if (VAR29 == VAR12) {\nVAR42 = VAR18 / 2;\nVAR18 -= VAR42;\n}\nmsg.sender.transfer(VAR42);\n} else {\nVAR28.VAR8 -= uint8(VAR40);\n}\n}\n}\nfunction FUN14(uint VAR44) private returns (uint) {\nVAR20 = uint(keccak256(VAR20,block.blockhash(block.number - 1),block.coinbase,block.difficulty));\nreturn VAR20 % VAR44;\n}\nmodifier FUN15() {\naddress VAR45 = msg.sender;\nuint VAR46;\nassembly { VAR46 := extcodesize(VAR45) }\nrequire(VAR46 == 0);\n_;\n}\n}",
        "label": false,
        "name": "0x06ea256d8a2112aff4f700407e254bae8921811d.sol"
    },
    {
        "source": "contract MultiAsset {\r\n    function owner(bytes32 _symbol) constant returns(address);\r\n    function isCreated(bytes32 _symbol) constant returns(bool);\r\n    function totalSupply(bytes32 _symbol) constant returns(uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\r\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\r\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\r\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\r\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\r\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\r\n}\r\n\r\ncontract OpenDollar {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approve(address indexed from, address indexed spender, uint value);\r\n\r\n    MultiAsset public multiAsset;\r\n    bytes32 public symbol;\r\n\r\n    function init(address _multiAsset, bytes32 _symbol) returns(bool) {\r\n        MultiAsset ma = MultiAsset(_multiAsset);\r\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\r\n            return false;\r\n        }\r\n        multiAsset = ma;\r\n        symbol = _symbol;\r\n        return true;\r\n    }\r\n\r\n    modifier onlyMultiAsset() {\r\n        if (msg.sender == address(multiAsset)) {\r\n            _\r\n        }\r\n    }\r\n\r\n    function totalSupply() constant returns(uint) {\r\n        return multiAsset.totalSupply(symbol);\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns(uint) {\r\n        return multiAsset.balanceOf(_owner, symbol);\r\n    }\r\n\r\n    function allowance(address _from, address _spender) constant returns(uint) {\r\n        return multiAsset.allowance(_from, _spender, symbol);\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns(bool) {\r\n        return transferWithReference(_to, _value, \"\");\r\n    }\r\n\r\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\r\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\r\n        return transferToICAPWithReference(_icap, _value, \"\");\r\n    }\r\n\r\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\n        return transferFromWithReference(_from, _to, _value, \"\");\r\n    }\r\n\r\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\r\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\r\n        return transferFromToICAPWithReference(_from, _icap, _value, \"\");\r\n    }\r\n\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns(bool) {\r\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setCosignerAddress(address _cosigner) returns(bool) {\r\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\r\n        Approve(_from, _spender, _value);\r\n    }\r\n\r\n    function sendToOwner() returns(bool) {\r\n        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\r\n    }\r\n}",
        "label": false,
        "name": "0x9ce63a4e69de34844e340fc541d82db9506287bc.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nuint256 public VAR13;\nuint256 public VAR14;\nconstructor (uint256 VAR15) public {\nrequire(VAR15 > 0);\nVAR13 = VAR15;\n}\nfunction FUN18(address VAR4, uint256 VAR5) public FUN13 returns (bool) {\nrequire(VAR14.add(VAR5) <= VAR13);\nVAR14 = VAR14.add(VAR5);\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON3, CON5 {\nstring public constant VAR16 = \"TESSST\";\nstring public constant VAR17 = \"TESSST\";\nuint8 public constant VAR18 = 18;\nstruct FreezeParams {\nuint256 VAR19;\nuint256 VAR5;\nbool VAR20;\n}\nmapping (address => FreezeParams) private VAR21;\nconstructor () public CON5(5400000000 * 1e18) {\n}\nfunction FUN19(address VAR22, uint256 VAR23, uint256 VAR24, bool VAR25) public FUN13 returns (bool) {\nrequire(now < VAR24);\nFUN20(VAR22, VAR23, VAR24, VAR25);\nFUN18(VAR22, VAR23);\nreturn true;\n}\nfunction FUN20(address VAR4, uint256 VAR5, uint256 VAR26, bool VAR20) private {\nFreezeParams memory VAR27;\nVAR27 = VAR21[VAR4];\nif (VAR27.VAR19 == 0) {\nVAR27.VAR19 = VAR26;\nVAR27.VAR20 = VAR20;\n}\nVAR27.VAR5 = VAR27.VAR5.add(VAR5);\nVAR21[VAR4] = VAR27;\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(getAvailableBalance(msg.sender) >= VAR5);\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(getAvailableBalance(VAR7) >= VAR5);\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN11(uint256 VAR5) public {\nrequire(getAvailableBalance(msg.sender) >= VAR5);\nsuper.FUN11(VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nrequire(getAvailableBalance(VAR7) >= VAR5);\nsuper.FUN12(VAR7, VAR5);\n}\nfunction FUN21(address VAR28, uint256 VAR23, string memory VAR29) public returns (bool VAR30) {\nFUN2(VAR28, VAR23);\nCON7(VAR28).approvalFallback(msg.sender,VAR23,address(this),VAR29);\nreturn true;\n}\n}\ncontract CON7 {\n}",
        "label": false,
        "name": "0xbfc6b4e71af9d1117bcda8ce839d50cbff298b52.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping(address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring constant public VAR11 = \"Korean Won\";\nstring constant public VAR12 = \"KRWT\";\nuint8 constant public VAR13 = 8;\nuint public VAR1 = 100000000000 * 10**uint(VAR13);\nfunction CON5() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0xcdebfbcc7fdbd97209f1be6c12db5858a29769de.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) public VAR3;\nmodifier FUN5( address VAR4 )\n{\nrequire(VAR4 != address(0x0));\nrequire(VAR4 != address(this));\n_;\n}\nmodifier FUN6 {\nrequire(msg.sender == VAR35() || VAR3[msg.sender]);\n_;\n}\nfunction FUN7(address VAR5) public FUN1 FUN5(VAR5){\nrequire(!VAR3[VAR5]);\nVAR3[VAR5] = true;\n}\nfunction FUN8(address VAR5) public FUN1 FUN5(VAR5){\nrequire(VAR3[VAR5]);\nVAR3[VAR5] = false;\n}\n}\ninterface CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\nuint256 private VAR8;\nfunction FUN9(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR10 <= VAR6[msg.sender]);\nrequire(VAR9 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR11, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = VAR10;\nreturn true;\n}\nfunction FUN11(address VAR12,address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR10 <= VAR6[VAR12]);\nrequire(VAR10 <= VAR7[VAR12][msg.sender]);\nrequire(VAR9 != address(0));\nVAR6[VAR12] = VAR6[VAR12].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR10);\nreturn true;\n}\nfunction FUN12(address VAR11,uint256 VAR13)\npublic\nreturns (bool)\n{\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = (VAR7[msg.sender][VAR11].add(VAR13));\nreturn true;\n}\nfunction FUN13(address VAR11,uint256 VAR14)\npublic\nreturns (bool)\n{\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = (VAR7[msg.sender][VAR11].sub(VAR14));\nreturn true;\n}\nfunction FUN14(address VAR15, uint256 VAR16) internal {\nrequire(VAR15 != 0);\nVAR8 = VAR8.add(VAR16);\nVAR6[VAR15] = VAR6[VAR15].add(VAR16);\n}\nfunction FUN15(address VAR15, uint256 VAR16) internal {\nrequire(VAR15 != 0);\nrequire(VAR16 <= VAR6[VAR15]);\nVAR8 = VAR8.sub(VAR16);\nVAR6[VAR15] = VAR6[VAR15].sub(VAR16);\n}\nfunction FUN16(address VAR15, uint256 VAR16) internal {\nrequire(VAR16 <= VAR7[VAR15][msg.sender]);\nVAR7[VAR15][msg.sender] = VAR7[VAR15][msg.sender].sub(VAR16);\nFUN15(VAR15, VAR16);\n}\n}\ncontract CON5 is CON4 {\nfunction FUN17(uint256 VAR10) public {\nFUN15(msg.sender, VAR10);\n}\nfunction FUN18(address VAR12, uint256 VAR10) public {\nFUN16(VAR12, VAR10);\n}\nfunction FUN15(address VAR17, uint256 VAR10) internal {\nsuper.FUN15(VAR17, VAR10);\n}\n}\ncontract CON6 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor() public {\nVAR18.add(msg.sender);\n}\nmodifier FUN19() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN20(address VAR15) public FUN19 {\nVAR18.add(VAR15);\n}\nfunction FUN21() public {\nVAR18.remove(msg.sender);\n}\nfunction FUN22(address VAR15) internal {\nVAR18.remove(VAR15);\n}\n}\ncontract CON7 is CON4, CON6 {\nbool private VAR19 = false;\nmodifier FUN23() {\nrequire(!VAR19);\n_;\n}\nfunction FUN24(address VAR9,uint256 VAR16)\npublic\nFUN19\nFUN23\nreturns (bool)\n{\nFUN14(VAR9, VAR16);\nreturn true;\n}\nfunction FUN25()\npublic\nFUN19\nFUN23\nreturns (bool)\n{\nVAR19 = true;\nreturn true;\n}\n}\ncontract CON8 is CON2 {\nbool public VAR20;\nmapping (address => bool) public VAR21;\nmodifier FUN26( address VAR22 ) {\nrequire(!VAR20);\nrequire(!VAR21[msg.sender] && !VAR21[VAR22]);\n_;\n}\nmodifier FUN27( address VAR23, address VAR22 ) {\nrequire(!VAR20);\nrequire(!VAR21[msg.sender] && !VAR21[VAR23] && !VAR21[VAR22]);\n_;\n}\nfunction FUN28(address VAR24, bool VAR25) public FUN6 FUN5(VAR24) {\nrequire(VAR21[VAR24] != VAR25);\nVAR21[VAR24] = VAR25;\n}\nfunction FUN29(bool VAR25) public FUN6 {\nrequire(VAR20 != VAR25);\nVAR20 = VAR25;\n}\n}\ncontract CON9 is CON5, CON7, CON8\n{\nstring public constant VAR26 = \"Cryptonium\";\nstring public constant VAR27 = \"CRN\";\nuint8 public constant VAR28 = 18;\nconstructor( address VAR29, uint VAR30 ) public\n{\nFUN14(VAR29, VAR30);\nFUN7(VAR29);\n}\nfunction FUN9(address VAR22, uint VAR31) public FUN5(VAR22) FUN26(VAR22) returns (bool)\n{\nreturn super.FUN9(VAR22, VAR31);\n}\nfunction FUN11(address VAR23, address VAR22, uint VAR31) public FUN5(VAR22) FUN27(VAR23, VAR22) returns (bool)\n{\nreturn super.FUN11(VAR23, VAR22, VAR31);\n}\nfunction FUN10(address VAR32, uint256 VAR31) public FUN5(VAR32) FUN26(VAR32) returns (bool)\n{\nreturn super.FUN10(VAR32, VAR31);\n}\nfunction FUN12( address VAR32, uint256 VAR33 ) public FUN5(VAR32) FUN26(VAR32) returns (bool)\n{\nreturn super.FUN12(VAR32, VAR33);\n}\nfunction FUN13(address VAR32, uint256 VAR34) public FUN5(VAR32) FUN26(VAR32) returns (bool)\n{\nreturn super.FUN13(VAR32, VAR34);\n}\n}\ncontract CON10 {\naddress public VAR35;\nuint public VAR36;\nconstructor() public {\nVAR35 = msg.sender;\n}\nmodifier FUN30() {\nif (msg.sender == VAR35) _;\n}\nfunction FUN31(uint VAR37) public FUN30 {\nVAR36 = VAR37;\n}\nfunction FUN32(address VAR38) public FUN30 {\nCON10 VAR39 = CON10(VAR38);\nVAR39.FUN31(VAR36);\n}\n}",
        "label": false,
        "name": "0xb1a804f02559c91c12ba3e3f76934141e4ecd137.sol"
    },
    {
        "source": "contract Exchange():\r\n    def setup(token_addr: address): modifying\r\n\r\nNewExchange: event({token: indexed(address), exchange: indexed(address)})\r\n\r\nexchangeTemplate: public(address)\r\ntokenCount: public(uint256)\r\ntoken_to_exchange: address[address]\r\nexchange_to_token: address[address]\r\nid_to_token: address[uint256]\r\n\r\n@public\r\ndef initializeFactory(template: address):\r\n    assert self.exchangeTemplate == ZERO_ADDRESS\r\n    assert template != ZERO_ADDRESS\r\n    self.exchangeTemplate = template\r\n\r\n@public\r\ndef createExchange(token: address) -> address:\r\n    assert token != ZERO_ADDRESS\r\n    assert self.exchangeTemplate != ZERO_ADDRESS\r\n    assert self.token_to_exchange[token] == ZERO_ADDRESS\r\n    exchange: address = create_with_code_of(self.exchangeTemplate)\r\n    Exchange(exchange).setup(token)\r\n    self.token_to_exchange[token] = exchange\r\n    self.exchange_to_token[exchange] = token\r\n    token_id: uint256 = self.tokenCount + 1\r\n    self.tokenCount = token_id\r\n    self.id_to_token[token_id] = token\r\n    log.NewExchange(token, exchange)\r\n    return exchange\r\n\r\n@public\r\n@constant\r\ndef getExchange(token: address) -> address:\r\n    return self.token_to_exchange[token]\r\n\r\n@public\r\n@constant\r\ndef getToken(exchange: address) -> address:\r\n    return self.exchange_to_token[exchange]\r\n\r\n@public\r\n@constant\r\ndef getTokenWithId(token_id: uint256) -> address:\r\n    return self.id_to_token[token_id]",
        "label": false,
        "name": "0xc0a47dfe034b400b47bdad5fecda2621de6c4d95.sol"
    },
    {
        "source": "# Author: S\u00c3\u00b6ren Steiger, github.com/ssteiger\r\n# License: MIT\r\n\r\n# EVENTS:\r\nNewSolutionFound: event({_addressOfWinner: indexed(address), _solution: uint256})\r\nBountyTransferred: event({_to: indexed(address), _amount: wei_value})\r\nBountyIncreased: event({_amount: wei_value})\r\nCompetitionTimeExtended: event({_to: uint256})\r\n\r\n\r\n# STATE VARIABLES:\r\nowner: public(address)\r\n\r\nx1: public(uint256)\r\nx2: public(uint256)\r\nx3: public(uint256)\r\nx4: public(uint256)\r\n\r\nbestSolution: public(uint256)\r\naddressOfWinner: public(address)\r\n\r\ndurationInBlocks: public(uint256)\r\ncompetitionEnd: public(uint256)\r\nclaimPeriodeLength: public(uint256)\r\n\r\n\r\n# METHODS:\r\n@public\r\ndef __init__(_durationInBlocks: uint256):\r\n    self.owner = msg.sender\r\n    self.bestSolution = 0\r\n    self.durationInBlocks = _durationInBlocks\r\n    self.competitionEnd = block.number + _durationInBlocks\r\n    self.addressOfWinner = ZERO_ADDRESS\r\n    # set claim periode to three days\r\n    # assuming an average blocktime of 14 seconds -> 86400/14\r\n    self.claimPeriodeLength = 6172\r\n\r\n\r\n@public\r\n@payable\r\ndef __default__():\r\n    # return any funds sent to the contract address directly\r\n    send(msg.sender, msg.value)\r\n\r\n\r\n@private\r\ndef _calculateNewSolution(_x1: uint256, _x2: uint256, _x3: uint256, _x4: uint256) -> uint256:\r\n    # check new parameters against constraints\r\n    assert _x1 >= 40\r\n    assert _x2 <= 615\r\n    assert _x3 < 200 and _x3 < 400\r\n    assert (3 * _x1) + (2 * _x3) >= 200\r\n    assert (3 * _x2) - (2 * _x3 * _x4) <= 400\r\n    assert _x1 + _x2 >= 120\r\n    assert _x1 > 0 and _x2 > 0 and _x3 > 0\r\n    assert _x4 == 0 or _x4 == 1\r\n    assert _x1 + _x2 * _x3 <= 200000\r\n    assert _x1 + _x2 * _x3 <= 4000\r\n    # calculate and return new solution\r\n    return (4 * _x1) + (3 * _x2) - (1000 * _x4)\r\n\r\n\r\n@public\r\ndef submitSolution(_x1: uint256, _x2: uint256, _x3: uint256, _x4: uint256) -> uint256:\r\n    newSolution: uint256\r\n    newSolution = self._calculateNewSolution(_x1, _x2, _x3, _x4)\r\n    assert newSolution > self.bestSolution\r\n    # save the solution and it's values\r\n    self.x1 = _x1\r\n    self.x2 = _x2\r\n    self.x3 = _x3\r\n    self.x4 = _x4\r\n    self.bestSolution = newSolution\r\n    self.addressOfWinner = msg.sender\r\n    log.NewSolutionFound(msg.sender, newSolution)\r\n    return newSolution\r\n\r\n\r\n@public\r\ndef claimBounty():\r\n    assert block.number > self.competitionEnd\r\n    if (self.addressOfWinner == ZERO_ADDRESS):\r\n        # no solution was found -> extend duration of competition\r\n        self.competitionEnd = block.number + self.durationInBlocks\r\n    else:\r\n        assert block.number < (self.competitionEnd + self.claimPeriodeLength)\r\n        assert msg.sender == self.addressOfWinner\r\n        send(self.addressOfWinner, self.balance)\r\n        # extend duration of competition\r\n        self.competitionEnd = block.number + self.durationInBlocks\r\n        log.BountyTransferred(self.addressOfWinner, self.balance)\r\n\r\n\r\n@public\r\n@payable\r\ndef topUpBounty():\r\n    log.BountyIncreased(msg.value)\r\n\r\n\r\n@public\r\ndef extendCompetition():\r\n    # only if no valid solution has been submitted\r\n    assert self.addressOfWinner == ZERO_ADDRESS\r\n    assert block.number > (self.competitionEnd + self.claimPeriodeLength)\r\n    # extend duration of competition\r\n    self.competitionEnd = block.number + self.durationInBlocks\r\n    # reset winner address\r\n    self.addressOfWinner = ZERO_ADDRESS\r\n    log.CompetitionTimeExtended(self.competitionEnd)",
        "label": false,
        "name": "0xe75fa140f7c05077e05ffa0a9db227e32c80d5da.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\naddress payable public VAR3;\nbool public VAR4;\nuint VAR5;\nuint VAR6;\nuint VAR7;\nuint8 constant VAR8 = 64;\nmapping(address => userAccount) public VAR9;\nmapping (uint => address payable) public VAR10;\nmapping (uint => uint) public VAR11;\nstruct userAccount {\nuint[] VAR12;\nuint[3][] VAR13;\nuint VAR14;\n}\nconstructor() public {\nVAR4 = true;\nVAR5 = 10;\nVAR6 = 10;\nVAR7 = 5;\nVAR3 = msg.sender;\n}\nfunction FUN5(uint VAR15, uint VAR16) public payable {\nrequire(msg.value >= 10000000000000000);\nuint VAR17 = msg.value.div(VAR7);\nuint VAR18 = msg.value-VAR17;\naddress payable VAR19 = VAR10[VAR16];\nrequire(VAR19 != address(0));\nVAR19.transfer(VAR18);\nVAR3.transfer(VAR17);\n}\nfunction FUN6(uint VAR15, uint VAR16, string memory VAR20) public payable {\nbytes memory VAR21 = bytes(VAR20);\nrequire(msg.value >= 10000000000000000);\nrequire(VAR21.length <= VAR8, \"Too long\");\nuint VAR17 = msg.value.div(VAR7);\naddress payable VAR22;\nuint VAR23;\nif (VAR11[VAR16] != 0) {\nVAR22 = VAR10[VAR11[VAR16]];\nVAR23 = msg.value.div(5);\n}\nuint VAR18 = msg.value - VAR17 - VAR23;\naddress payable VAR24 = VAR10[VAR16];\nrequire(VAR24 != address(0));\nVAR24.transfer(VAR18);\nVAR22.transfer(VAR23);\nVAR3.transfer(VAR17);\n}\nfunction FUN7(uint VAR15, uint VAR16) public payable {\nrequire(msg.value >= 10000000000000000);\nuint VAR17 = msg.value.div(VAR6);\nuint VAR18 = msg.value-VAR17;\naddress payable VAR19 = VAR10[VAR16];\nrequire(VAR19 != address(0));\nVAR19.transfer(VAR18);\nVAR3.transfer(VAR17);\n}\nfunction FUN8(uint VAR15, uint VAR16, uint VAR25) public payable {\nrequire(msg.value >= 10000000000000000);\nrequire(VAR25 > 0 && VAR15 > 0);\nuint VAR17 = msg.value.div(VAR6);\nuint VAR18 = msg.value-VAR17;\naddress payable VAR24 = VAR10[VAR16];\nrequire(VAR24 != address(0));\nVAR24.transfer(VAR18);\nVAR3.transfer(VAR17);\nVAR9[msg.sender].VAR13.push([VAR16,VAR25, msg.value]);\n}\nfunction FUN9(uint VAR15, uint VAR26, uint VAR16) public payable {\nrequire(msg.value >= 10000000000000000);\nuint VAR17 = msg.value.div(VAR6);\nif(VAR4){\nVAR17 = 0;\n}\naddress payable VAR22;\nuint VAR23;\nif (VAR11[VAR16] != 0) {\nVAR22 = VAR10[VAR11[VAR16]];\nVAR23 = msg.value.div(5);\n}\nuint VAR18 = msg.value- VAR17 - VAR23;\naddress payable VAR24 = VAR10[VAR16];\nrequire(VAR24 != address(0));\nVAR24.transfer(VAR18);\nVAR22.transfer(VAR23);\nVAR3.transfer(VAR17);\nVAR9[msg.sender].VAR12.push(VAR26);\n}\nfunction FUN10(uint VAR15, uint VAR27, uint VAR16) public payable {\nrequire(msg.value >= 10000000000000000);\nrequire(VAR27 > 0 && VAR15 > 0);\nuint VAR17 = msg.value.div(VAR6);\nif(VAR4){\nVAR17 = 0;\n}\nuint VAR23;\naddress payable VAR22;\nif (VAR11[VAR16] != 0) {\nVAR22 = VAR10[VAR11[VAR16]];\nVAR23 = msg.value.div(5);\n}\nuint VAR18 = msg.value- VAR17-VAR23;\naddress payable VAR24 = VAR10[VAR16];\nrequire(VAR24 != address(0));\nVAR24.transfer(VAR18);\nVAR22.transfer(VAR23);\nVAR3.transfer(VAR17);\n}\nfunction FUN11(uint VAR15) public payable {\nrequire(msg.value >= 10000000000000000);\nVAR3.transfer(msg.value);\n}\nfunction FUN12(uint VAR15, uint VAR16, uint VAR28) public payable {\nrequire(msg.value >= 10000000000000000);\nuint VAR17 = msg.value.div(VAR5);\nif(VAR4){\nVAR17 = 0;\n}\nuint VAR18 = msg.value - VAR17;\naddress payable VAR24 = VAR10[VAR16];\nrequire(VAR24 != address(0));\nVAR24.transfer(VAR18);\nVAR3.transfer(VAR17);\n}\nfunction FUN13(uint VAR16, address payable VAR24) public FUN1 {\nVAR10[VAR16] = VAR24;\n}\nfunction FUN14(uint VAR16, uint VAR29) public FUN1 {\nVAR11[VAR16] = VAR29;\n}\nfunction FUN15(bool VAR30, uint VAR31, uint VAR32, uint VAR33) public FUN1 {\nVAR4 = VAR30;\nVAR5 = VAR31;\nVAR6 = VAR32;\nVAR7 = VAR33;\n}\n}",
        "label": false,
        "name": "0x538cc4af284ba376ad5bad0d364fbc9fb302546a.sol"
    },
    {
        "source": "contract CON1\n{\nusing SafeMath for *;\naddress public VAR1;\nmapping(uint256 => mapping(uint256 => uint256)) VAR2;\nbool public VAR3 = false;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(VAR3);\n_;\n}\nmodifier FUN2() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN4() public FUN2 FUN3 {\nVAR3 = true;\n}\nfunction FUN5() public FUN1 FUN3 {\nVAR3 = false;\n}\nfunction FUN6(uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) FUN3\npublic returns (bool) {\nrequire(VAR4 > 0);\nrequire(VAR5 > 0);\nrequire(VAR6 >= 0);\nrequire(VAR7 > 0);\nrequire(VAR2[VAR4][VAR5] <= 0);\nrequire(VAR7 <= 1000000);\nuint256 VAR8 = uint256(keccak256(abi.encodePacked((block.timestamp).add(block.difficulty).add(VAR4).add(VAR5).add(VAR6)))) % VAR7;\nVAR2[VAR4][VAR5] = VAR8;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x79bde2574d61f2bdbfe4c333a594fbba3c99e122.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN17 to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN18 from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR13 = \"Cremanon Token\"; string public constant VAR14 = \"CRT\"; uint8 public constant VAR15 = 18; uint256 public constant VAR16 = 100 * 10000 * 10000 * (10 ** uint256(VAR15));\nconstructor() public {\nsuper.FUN7(msg.VAR8, VAR16);\nVAR12 = msg.VAR8;\n}\naddress public VAR12;\nmodifier FUN11() {\nrequire(msg.VAR8 == VAR12, \"Not owner\");\n_;\n}\nfunction FUN12() public FUN11 {\nVAR12 = address(0);\n}\nfunction FUN13(address VAR17) public FUN11 {\nFUN14(VAR17);\n}\nfunction FUN14(address VAR17) internal {\nrequire(VAR17 != address(0), \"Already owner\");\nVAR12 = VAR17;\n}\naddress public VAR18;\nfunction FUN15(address VAR19) public FUN11 {\nrequire(VAR19 != address(0), \"Invalid Address\");\nVAR18 = VAR19;\n}\nmodifier FUN16() {\nrequire(msg.VAR8 == VAR18, \"Not crc\");\n_;\n}\nfunction FUN17(address VAR20,uint256 VAR21)\npublic FUN16\nreturns (bool)\n{\nsuper.FUN7(VAR20, VAR21);\nreturn true;\n}\nfunction FUN18(address VAR22, uint256 VAR23) public FUN16 returns (bool) {\nrequire(VAR23 <= super.balanceOf(VAR22), \"Balance is too small.\");\nsuper.FUN8(VAR22, VAR23);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xf6e46bc5cc050476c8ab0a82519f3623b5b7bfc5.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nstring public VAR1; string public VAR2; uint8 public VAR3 = 18; uint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nfunction CON2(uint256 VAR7, string VAR8, string VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint256 VAR12) internal {\nrequire(VAR11 != 0x0);\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public {\nFUN1(msg.sender, VAR11, VAR12);\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14){\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public returns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes VAR16) public returns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, this, VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x01003e4f6351c25dec19007f8f0adf1e9fe68bec.sol"
    },
    {
        "source": "contract CON1{\nstring public VAR1; string public VAR2; uint8 public VAR3 = 18; uint256 public VAR4;\nmapping (address => uint256) public VAR5;\nfunction CON1(uint256 VAR6,address VAR7, string VAR8, string VAR9) public{\nVAR4 = VAR6 * 10 ** uint256(VAR3); VAR5[VAR7] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, uint256 VAR11) public{\nVAR5[msg.sender] -= VAR11;\nVAR5[VAR10] += VAR11;\n}\n}",
        "label": false,
        "name": "0xd6107c04f9045c6b0d54615e09d7adfdb4c1c3d8.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"BRNS\";\nVAR5 = \"Bryansky token\";\nVAR6 = 2;\nVAR7 = 1000000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x96c33394853a989a02e83a085ccbf46a976b0fcf.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\nusing Dictionary for Dictionary.Data;\nenum PaymentState {OPEN, COMPLETED, CANCELLED}\nstruct Payment {\nuint VAR1;\nuint VAR2;\nuint VAR3;\naddress VAR4;\nuint VAR5;\naddress payable VAR6;\naddress payable VAR7;\nbytes VAR8;\nPaymentState VAR9;\n}\nCON2 VAR10;\nstruct RetrieveFundsRequest {\nuint VAR11;\naddress VAR6;\naddress VAR7;\nstring VAR12;\n}\nmapping(address => Dictionary.Data) VAR13;\nmapping(address => Dictionary.Data) VAR14;\nmapping(uint => Payment) VAR15;\naddress payable VAR16;\nuint VAR17;\nuint VAR18;\nmapping(address => mapping(address => uint)) public VAR19;\nbool VAR20;\nbool VAR21;\naddress constant VAR22 = 0x1C56346CD2A2Bf3202F771f50d3D14a367B48070;\nbytes32 constant VAR23 = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;\nstring private constant VAR24 = \"RetrieveFundsRequest(uint256 VAR11,address VAR6,address VAR7,string VAR12)\";\nstring private constant VAR25 = \"EIP712Domain(string VAR32,string version,uint256 VAR29,address VAR22,bytes32 VAR23)\";\nbytes32 private constant VAR26 = keccak256(abi.encodePacked(VAR25));\nbytes32 private constant VAR27 = keccak256(abi.encodePacked(VAR24));\nbytes32 private VAR28;\nuint256 VAR29;\nconstructor(uint256 VAR30) public {\nVAR16 = msg.VAR6;\nVAR17 = 0.001 ether;\nVAR18 = 0.005 ether;\nVAR20 = true;\nVAR21 = true;\nVAR29 = VAR30;\nVAR28 = keccak256(\nabi.encode(VAR26,keccak256(\"Etherclear\"),keccak256(\"1\"),VAR29,VAR22,VAR23)\n);\n}\nmodifier FUN1 {\nrequire(msg.VAR6 == VAR16,\"Only the contract VAR16 is allowed to use this function.\");\n_;\n}\nfunction FUN2(address VAR31, string memory VAR32)\npublic\nFUN1\n{\nVAR10 = CON2(VAR31);\nVAR10.setName(VAR32);\n}\nfunction FUN3(address VAR4) external FUN1 {\nuint VAR33 = VAR19[VAR4][VAR16];\nVAR19[VAR4][VAR16] = 0;\nif (VAR4 == address(0)) {\nVAR16.transfer(VAR33);\n} else {\nrequire(CON1(VAR4).transfer(VAR16, VAR33),\"Could not successfully withdraw token\");\n}\n}\nfunction FUN4(uint VAR34) external FUN1 {\nVAR17 = VAR34;\n}\nfunction FUN5(uint VAR34) external FUN1 {\nVAR18 = VAR34;\n}\nfunction FUN6(bool VAR35) public FUN1 {\nVAR21 = !VAR35;\n}\nfunction FUN7(bool VAR35) public FUN1 {\nVAR20 = !VAR35;\n}\nfunction FUN8(uint VAR11) external {\nPayment memory VAR36 = VAR15[VAR11];\nrequire(VAR36.VAR6 == msg.VAR6,\"Payment VAR6 does not match message VAR6.\");\nrequire(VAR36.VAR9 == PaymentState.OPEN,\"Payment must be open to cancel.\");\nVAR36.VAR3 = now;\nVAR36.VAR9 = PaymentState.CANCELLED;\ndelete VAR15[VAR11];\nVAR13[VAR36.VAR7].remove(VAR11);\nVAR14[VAR36.VAR6].remove(VAR11);\nif (VAR36.VAR4 == address(0)) {\nVAR19[address(0)][VAR36.VAR6] = SafeMath.sub(VAR19[address(0)][VAR36.VAR6],VAR36.VAR5);\nVAR36.VAR6.transfer(VAR36.VAR5);\n} else {\nFUN10(VAR36.VAR4, VAR36.VAR6, VAR36.VAR6, VAR36.VAR5);\n}\n}\nfunction FUN9(address VAR4,address VAR37,uint VAR38,uint VAR39) internal {\nrequire(VAR4 != address(0));\nrequire(\nCON1(VAR4).transferFrom(VAR37,address(this),SafeMath.add(VAR38, VAR39))\n);\nVAR19[VAR4][VAR37] = SafeMath.add(VAR19[VAR4][msg.VAR6],VAR38);\nVAR19[VAR4][VAR16] = SafeMath.add(VAR19[VAR4][VAR16], VAR39);\n}\nfunction FUN10(address VAR4,address VAR40,address VAR41,uint VAR42) internal {\nrequire(VAR4 != address(0));\nrequire(CON1(VAR4).transfer(VAR41, VAR42));\nVAR19[VAR4][VAR40] = SafeMath.sub(VAR19[VAR4][VAR40], VAR42);\n}\nfunction FUN11(uint VAR42,address payable VAR7,uint VAR1,bytes calldata VAR8) external payable {\nreturn FUN12(address(0),VAR42,VAR7,VAR1,VAR8);\n}\nfunction FUN12(address VAR4,uint VAR42,address payable VAR7,uint VAR1,bytes memory VAR8) public payable {\nrequire(VAR20, \"The create payments functionality is currently disabled\");\nuint VAR43 = uint(SafeMath.mul(VAR18, VAR42) / (1 ether));\nif (VAR4 == address(0)) {\nrequire(\nmsg.value >= (SafeMath.add(SafeMath.add(VAR42, VAR17),VAR43)),\n\"Message value is not enough to cover VAR42 and fees\"\n);\n} else {\nrequire(msg.value >= VAR17,\"Message value is not enough to cover base fee\");\n}\nDictionary.Data storage VAR44 = VAR14[msg.VAR6];\nDictionary.Data storage VAR45 = VAR13[VAR7];\nuint VAR11 = getPaymentId(VAR7, VAR8);\nrequire(VAR15[VAR11].VAR6 == address(0),\"Payment ID must be unique. Use a different VAR12 hash.\");\nbytes memory VAR46 = \"\\x20\";\nVAR44.set(VAR11, VAR46);\nVAR45.set(VAR11, VAR46);\nPayment memory VAR36 = Payment(VAR1,now,0,VAR4,VAR42,msg.VAR6,VAR7,VAR8,PaymentState.OPEN);\nVAR15[VAR11] = VAR36;\nif (VAR4 == address(0)) {\nVAR19[address(0)][msg.VAR6] = SafeMath.add(VAR19[address(0)][msg.VAR6],VAR42);\nVAR19[address(0)][VAR16] = SafeMath.add(VAR19[address(0)][VAR16],SafeMath.sub(msg.value, VAR42));\n} else {\nVAR19[address(0)][VAR16] = SafeMath.add(VAR19[address(0)][VAR16],msg.value);\nFUN9(VAR4, msg.VAR6, VAR42, VAR43);\n}\n}\nfunction FUN13(uint256 VAR11,address VAR6,address VAR7,string memory VAR12,bytes32 VAR47,bytes32 VAR48,uint8 VAR49) public {\nRetrieveFundsRequest memory VAR50 = RetrieveFundsRequest(VAR11,VAR6,VAR7,VAR12);\naddress VAR51 = ecrecover(hashRetrieveFundsRequest(VAR50),VAR49,VAR47,VAR48);\nrequire(VAR7 == VAR51,\"The message VAR7 must be the same as the VAR51 of the message\");\nPayment memory VAR36 = VAR15[VAR11];\nrequire(VAR36.VAR7 == VAR7,\"The payment's VAR7 must be the same as VAR51 of the message\");\nFUN15(VAR36, VAR11, VAR12);\n}\nfunction FUN14(uint VAR11, string memory VAR52) public {\nPayment memory VAR36 = VAR15[VAR11];\nrequire(VAR36.VAR7 == msg.VAR6,\"Message VAR6 must match payment recipient\");\nFUN15(VAR36, VAR11, VAR52);\n}\nfunction FUN15(Payment memory VAR36, uint VAR11, string memory VAR52)\nprivate\n{\nrequire(VAR21, \"The retrieve funds functionality is currently VAR35.\");\nrequire(VAR36.VAR9 == PaymentState.OPEN,\"Payment must be open to retrieve funds\");\nbytes memory VAR53 = abi.encodePacked(\nkeccak256(abi.encodePacked(VAR52, VAR36.VAR7))\n);\nrequire(sliceUint(VAR53) == sliceUint(VAR36.VAR8),\"Passphrase is not correct\");\nrequire((VAR36.VAR2 + VAR36.VAR1) > now,\"Hold time has already expired\");\nVAR36.VAR3 = now;\nVAR36.VAR9 = PaymentState.COMPLETED;\ndelete VAR15[VAR11];\nVAR13[VAR36.VAR7].remove(VAR11);\nVAR14[VAR36.VAR6].remove(VAR11);\nif (VAR36.VAR4 == address(0)) {\nVAR36.VAR7.transfer(VAR36.VAR5);\nVAR19[address(0)][VAR36.VAR6] = SafeMath.sub(VAR19[address(0)][VAR36.VAR6],VAR36.VAR5);\n} else {\nFUN10(VAR36.VAR4, VAR36.VAR6, VAR36.VAR7, VAR36.VAR5);\n}\n}\n}",
        "label": false,
        "name": "0x7f5a8e08a693ea75d6ee87de54886ec013f31e11.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nfunction FUN1(address VAR2) public FUN3\n{\nVAR1 = VAR2;\n}\nfunction CON1() public\n{\nVAR1 = msg.sender;\n}\nfunction FUN2() public FUN3\n{\nselfdestruct(VAR1);\n}\nmodifier FUN3(){\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1{\nstring public constant VAR3 = \"EtherealTipJar\";\nstring public constant VAR4 = \"A\";\nstring public constant VAR5 = \"'The universe never did make sense; I suspect it was built on government contract.' -Robert A. Heinlein\";\nfunction () payable public {\n}\nfunction FUN5(address VAR6, uint256 VAR7) public FUN3{\nrequire(this.balance >= VAR7);\nif(VAR7 > 0)\n{\nVAR6.transfer(VAR7);\n}\n}\n}",
        "label": false,
        "name": "0x678042580304a7f32dd03b027d90083818dc16a1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbool public VAR1;\naddress public VAR2;\nmapping(address => bool) public VAR3;\nmapping(address => bool) public VAR4;\nmodifier FUN1 {\nif(!VAR1) {\nrequire(VAR3[msg.sender]);\n}\n_;\n}\nmodifier FUN2 {\nrequire(!VAR4[msg.sender]);\n_;\n}\nmodifier FUN3\n{\nrequire(VAR2 == msg.sender);\n_;\n}\nconstructor()\npublic\n{\nVAR1 = false;\nVAR2 = msg.sender;\n}\nfunction FUN4(address VAR5, bool VAR6)\nexternal\nFUN3\n{\nrequire(VAR2 != VAR5);\nVAR4[VAR5] = VAR6;\n}\nfunction FUN5(address VAR5, bool VAR6)\nexternal\nFUN3\n{\nVAR3[VAR5] = VAR6;\n}\n}\ncontract CON3 is CON1, CON2 {\nstring public constant VAR7 = \"YGGDRASH\";\nstring public constant VAR8 = \"YEED\";\nuint8 public constant VAR9 = 18;\nbool public VAR10;\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR11;\nmapping(address => mapping(address => uint256)) internal VAR12;\nuint256 internal VAR13;\nmodifier FUN6 {\nrequire(VAR10);\n_;\n}\nconstructor(uint256 VAR14)\npublic\n{\nrequire(VAR14 != 0);\nVAR13 = VAR14;\nVAR11[msg.sender] = VAR14;\n}\nfunction FUN7(address VAR15, uint256 VAR16)\npublic\nFUN1\nFUN2\nreturns (bool) {\nrequire(VAR15 != address(0));\nrequire(VAR11[msg.sender] >= VAR16);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR16);\nVAR11[VAR15] = VAR11[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN8(address VAR17, address VAR15, uint256 VAR16)\npublic\nFUN1\nFUN2\nreturns (bool VAR18) {\nrequire(!VAR4[VAR17]);\nrequire(VAR11[VAR17] >= VAR16);\nrequire(VAR12[VAR17][msg.sender] >= VAR16);\nVAR11[VAR17] = VAR11[VAR17].sub(VAR16);\nVAR11[VAR15] = VAR11[VAR15].add(VAR16);\nVAR12[VAR17][msg.sender] = VAR12[VAR17][msg.sender].sub(VAR16);\nreturn true;\n}\nfunction FUN9(address VAR19, uint256 VAR16)\npublic\nFUN2\nreturns (bool) {\nVAR12[msg.sender][VAR19] = VAR16;\nreturn true;\n}\nfunction FUN10(address VAR20, uint256 VAR21)\npublic\nFUN2\nreturns (bool) {\nVAR12[msg.sender][VAR20] = (VAR12[msg.sender][VAR20].add(VAR21));\nreturn true;\n}\nfunction FUN11(address VAR20, uint256 VAR22)\npublic\nFUN2\nreturns (bool) {\nuint256 VAR23 = VAR12[msg.sender][VAR20];\nif (VAR22 > VAR23) {\nVAR12[msg.sender][VAR20] = 0;\n} else {\nVAR12[msg.sender][VAR20] = VAR23.sub(VAR22);\n}\nreturn true;\n}\nfunction FUN12(uint256 VAR24)\npublic\nFUN6\nFUN3\n{\nrequire(VAR11[msg.sender] >= VAR24);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR24);\nVAR13 = VAR13.sub(VAR24);\n}\nfunction FUN13(bool VAR25)\nexternal\nFUN6\nFUN3\n{\nVAR1 = VAR25;\n}\nfunction FUN14(bool VAR26)\npublic\nFUN3\n{\nVAR10 = VAR26;\n}\nfunction FUN15(address VAR27)\npublic\nFUN6\nFUN3\nreturns (bool VAR18) {\nrequire(VAR27 != VAR2);\nVAR11[VAR2] = VAR11[VAR2].add(VAR11[VAR27]);\nVAR11[VAR27] = 0;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xca2796f9f61dc7b238aab043971e49c6164df375.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 VAR19 the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 VAR20 the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: mint VAR20 the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn VAR19 the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 VAR19 the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 VAR20 the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 {\naddress private VAR13;\nmapping(address => bool) public VAR14;\nconstructor() public {\nVAR13 = msg.VAR8;\nFUN13(msg.VAR8);\n}\nmodifier FUN11() {\nrequire(VAR14[msg.VAR8]);\n_;\n}\nmodifier FUN12() {\nrequire(msg.VAR8 == VAR13);\n_;\n}\nfunction FUN13(address VAR15) public FUN12 {\nrequire(VAR15 != address(0));\nVAR14[VAR15] = true;\n}\nfunction FUN14(address VAR15) public FUN12 {\nrequire(VAR15 != address(0));\nVAR14[VAR15] = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring public constant VAR16 = \"Constant Stablecoin\";\nstring public constant VAR17 = \"CONST\";\nuint public constant VAR18 = 2;\nfunction FUN15(address VAR19,address VAR20,uint VAR7,bytes32 VAR21)\npublic\nFUN11\n{\nFUN6(VAR19, VAR20, VAR7);\n}\nfunction FUN16(address VAR22,uint VAR7,bytes32 VAR21)\npublic\nFUN11\n{\nFUN7(VAR22, VAR7);\n}\nfunction FUN17(address VAR23,uint VAR7,bytes32 VAR21)\npublic\nFUN11\n{\nFUN8(VAR23, VAR7);\n}\n}",
        "label": false,
        "name": "0x067707c7dcf49d92e3791f1cfbcdf8d25d1997f9.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) private VAR1;\nmapping(address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nrequire(VAR11 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR11);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor() public {\nFUN11(msg.sender);\n}\nmodifier FUN8() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN9(address VAR10) public FUN8 {\nFUN11(VAR10);\n}\nfunction FUN10() public {\nFUN12(msg.sender);\n}\nfunction FUN11(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN12(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON4 is CON3 {\nbool private VAR13 = false;\nmodifier FUN13() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN14() {\nrequire(VAR13);\n_;\n}\nfunction FUN15() public FUN8 FUN13 {\nVAR13 = true;\n}\nfunction FUN16() public FUN8 FUN14 {\nVAR13 = false;\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN13 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN13 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN13 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN13 returns (bool VAR14) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN13 returns (bool VAR14) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON6 is CON2 {\nfunction FUN17(uint256 VAR15) public {\nFUN7(msg.sender, VAR15);\n}\n}\ncontract CON7 is CON5, CON6 {\nstring public constant VAR16 = \"Boombit Token\";\nstring public constant VAR17 = \"BM\";\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 10000000000 * (10 ** uint256(VAR18));\nconstructor() public {\nFUN6(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0x8a04295ed8176279cc372ab8f42b4d59eba99077.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nuint256 constant private VAR2 = 2**256 - 1;\nmapping (address => mapping (address => uint256)) public VAR3;\nstring public VAR4 = \"Love\";\nuint8 public VAR5 = 0;\nstring public VAR6 = \"LOVE\";\nconstructor() public {\nVAR1 = VAR2;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool VAR9) {\nreturn true;\n}\nfunction FUN2(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9) {\nuint256 VAR11 = VAR3[VAR10][msg.sender];\nif (VAR11 < VAR2) {\nVAR3[VAR10][msg.sender] -= VAR8;\n}\nreturn true;\n}\nfunction FUN3(address VAR12, uint256 VAR8) public returns (bool VAR9) {\nVAR3[msg.sender][VAR12] = VAR8;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x5a276aeb77bcfdac8ac6f31bbc7416ae1a85eef2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nfunction CON1() public {\nVAR1 = msg.sender;\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1 || msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != address(0));\nVAR1 = VAR3;\n}\n}\ncontract CON2 {\n}\ncontract CON3{\nuint public VAR4;\n}\ncontract CON4 {\n}\ncontract CON5 is CON3, CON2, CON1{\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nuint public VAR8;\nuint public VAR4;\nbool public VAR9;\nmapping(address => uint) VAR10;\nmapping (address => mapping (address => uint)) VAR11;\nmodifier FUN3() {\nrequire(msg.sender == VAR1 || msg.sender == VAR2 || VAR9==false);\n_;\n}\nfunction CON5() public{\nVAR9 = true;\nVAR8 = 50000000000000;\nVAR4 = VAR8;\nVAR10[msg.sender] = VAR8; VAR5 = 'Hyde & Co. Token'; VAR6 = 'CON5'; VAR7 = 6; }\nfunction FUN4() public FUN1 {\nVAR9 = false;\n}\nfunction FUN5(uint256 VAR12) public FUN1 returns (bool){\nVAR10[msg.sender] = sub(VAR10[msg.sender], VAR12) ;\nVAR4 = sub(VAR4, VAR12);\nreturn true;\n}\nfunction FUN6(address VAR13, uint VAR12) public FUN3 returns (bool) {\nuint VAR14 = VAR10[msg.sender];\nrequire((VAR12 > 0) && (VAR12 <= VAR14));\nVAR10[msg.sender] = sub(VAR10[msg.sender], VAR12);\nVAR10[VAR13] = add(VAR10[VAR13], VAR12);\nreturn true;\n}\nfunction FUN7(address VAR15, address VAR13, uint VAR12) public FUN3 returns (bool) {\nuint VAR16 = VAR11[VAR15][msg.sender];\nuint VAR14 = VAR10[VAR15];\nrequire(VAR12 <= VAR16 && VAR12 <= VAR14 && VAR12 > 0);\nVAR10[VAR13] = add(VAR10[VAR13], VAR12);\nVAR10[VAR15] = sub(VAR10[VAR15], VAR12);\nVAR11[VAR15][msg.sender] = sub(VAR16, VAR12);\nreturn true;\n}\nfunction FUN8(address VAR17) public constant returns (uint VAR18) {\nreturn VAR10[VAR17];\n}\nfunction FUN9(address VAR19, uint VAR12) public returns (bool) {\nVAR11[msg.sender][VAR19] = VAR12;\nreturn true;\n}\nfunction FUN10(address VAR19, uint256 VAR12, bytes VAR20) public {\nCON4 VAR21 = CON4(VAR19);\nif (FUN9(VAR19, VAR12)) {\nVAR21.receiveApproval(msg.sender, VAR12, this, VAR20);\n}\n}\nfunction FUN11(address VAR17, address VAR19) public constant returns (uint VAR22) {\nreturn VAR11[VAR17][VAR19];\n}\n}",
        "label": false,
        "name": "0xc4796a5bfc6fa56ea42b5e7c7889abcf724c44fd.sol"
    },
    {
        "source": "contract CON1 {\nmapping(uint => Token) public VAR1;\naddress public VAR2;\naddress public VAR3;\nstruct Token {\nstring VAR4;\nuint256 VAR5;\nuint256 VAR6;\nuint256 VAR7;\nuint256 VAR8;\nuint VAR9;\n}\nfunction CON1() {\nVAR3 = msg.VAR2;\nVAR2 = msg.VAR2;\n}\nfunction FUN1(uint VAR10) internal constant returns (Token) {\nreturn VAR1[VAR10];\n}\nfunction FUN2(uint VAR10) constant returns (uint256) {\nreturn VAR1[VAR10].VAR5;\n}\nfunction FUN3(uint VAR10) constant returns (uint256) {\nreturn VAR1[VAR10].VAR6;\n}\nfunction FUN4(uint VAR10) constant returns (uint256) {\nreturn VAR1[VAR10].VAR7;\n}\nfunction FUN5(uint VAR10) constant returns (uint256) {\nreturn VAR1[VAR10].VAR8;\n}\nfunction FUN6(uint VAR10) constant returns (uint) {\nreturn VAR1[VAR10].VAR9;\n}\nfunction FUN7(uint VAR11, string VAR12, uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8) external {\nrequire(msg.VAR2==VAR2);\nVAR1[VAR11] = Token(VAR12, VAR5, VAR6, VAR7, VAR8, VAR9.number);\n}\nfunction FUN8(uint VAR11) {\nrequire(msg.VAR2==VAR3);\ndelete VAR1[VAR11];\n}\nfunction FUN9(address VAR13){\nrequire(msg.VAR2==VAR3);\nVAR3 = VAR13;\n}\nfunction FUN10(address VAR14){\nrequire(msg.VAR2==VAR3);\nVAR2 = VAR14;\n}\nfunction FUN11(address VAR15, uint VAR16, bytes VAR17) external returns (bytes32 VAR18) {\nrequire(msg.VAR2==VAR3);\nrequire(VAR15.call.value(VAR16)(VAR17));\nreturn 0;\n}\nfunction() payable {\n}\nfunction FUN13(uint VAR11) external payable {\nuint256 VAR19 = VAR1[0].VAR6 * 35;\nrequire(msg.value >= VAR19);\nVAR2.transfer(msg.value);\n}\nfunction FUN14() external payable {\nrequire(msg.value >= 0);\nVAR2.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x8055d0504666e2b6942beb8d6014c964658ca591.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\nuint256 public VAR2;\nmapping (bytes32 => bool) public VAR3;\nCON1 public constant VAR4 = CON1(0x448a5065aeBB8E423F0896E6c5D525C040f59af3);\nCON2 public constant VAR5 = CON2(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\nconstructor(uint256 VAR6) public {\nVAR1 = msg.sender;\nVAR2 = VAR6;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1, \"risky-biz: you are not Mariano!\");\n_;\n}\nfunction FUN2(uint256 VAR7) external returns (bool) {\nbytes32 VAR8 = bytes32(VAR7);\n(address lad, , uint art, ) = VAR4.cups(VAR8);\nrequire(msg.sender == lad, \"risky-biz: sender is not cdp owner\");\nrequire(art >= VAR2, \"risky-biz: not enough debt in cdp\");\nrequire(!VAR4.safe(VAR8), \"risky-biz: cdp is not unsafe\");\nrequire(!VAR3[VAR8], \"risky-biz: this cdp has already played\");\nVAR3[VAR8] = true;\nreturn VAR5.transfer(msg.sender, VAR5.balanceOf(address(this)));\n}\nfunction FUN3(uint256 VAR6) external FUN1 {\nVAR2 = VAR6;\n}\nfunction FUN4() external FUN1 returns (bool) {\nuint VAR9 = VAR5.balanceOf(address(this));\nreturn VAR5.transfer(msg.sender, VAR9);\n}\n}",
        "label": false,
        "name": "0x7441cce7039cb7b8f6ff6f4ba5850cd655b12ba2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"CAPITAL\";\nstring public VAR16 = \"CALL\";\nuint8 public VAR17 = 18;\n}",
        "label": false,
        "name": "0x2c02c801a3324b371ad285c64af372ff1e23f460.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"ETHP\";\nstring public constant VAR2 = \"Ethereum Plus\";\nuint8 public constant VAR3 = 18;\nuint256 VAR4 = 10000000000000000000000000;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nthrow;\n}\n_;\n}\nfunction CON2() {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2() constant returns (uint256 FUN2) {\nFUN2 = VAR4;\n}\nfunction FUN3(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR6[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR11) returns (bool VAR12) {\nif (VAR6[msg.sender] >= VAR11&& VAR11 > 0&& VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR13,address VAR10,uint256 VAR11) returns (bool VAR12) {\nif (VAR6[VAR13] >= VAR11&& VAR7[VAR13][msg.sender] >= VAR11&& VAR11 > 0&& VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[VAR13] -= VAR11;\nVAR7[VAR13][msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR14, uint256 VAR11) returns (bool VAR12) {\nVAR7[msg.sender][VAR14] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR8, address VAR14) constant returns (uint256 VAR15) {\nreturn VAR7[VAR8][VAR14];\n}\n}",
        "label": false,
        "name": "0x047055f35cb837e838dde0202b7b1a5a75757835.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xbcf319c45230477211a44ac51e4064ca697eef4b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR10) public FUN11 {\nFUN14(VAR10);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR10) internal {\nVAR18.add(VAR10);\n}\nfunction FUN15(address VAR10) internal {\nVAR18.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN16(address VAR4, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON2 {\nfunction FUN17(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN18(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON7 is CON2, CON3, CON5, CON6 {\nconstructor(string memory VAR15,string memory VAR16,uint8 VAR17)\nCON6()\nCON5()\nCON3(VAR15, VAR16, VAR17)\nCON2()\npublic\n{}\n}",
        "label": false,
        "name": "0xebcd0ea69b0f2b9bb23021348e9e31517340073f.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nuint256 VAR7 = VAR5[VAR6][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR5[VAR6][msg.sender] = VAR7.sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR4) public returns (bool) {\nrequire((VAR4 == 0) || (VAR5[msg.sender][VAR8] == 0));\nVAR5[msg.sender][VAR8] = VAR4;\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR9;\nconstructor () public {\nVAR9 = msg.sender;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR9);\n_;\n}\nfunction FUN5(address VAR10) public FUN4 {\nrequire(VAR10 != address(0));\nVAR9 = VAR10;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR11 = false;\nmodifier FUN6() {\nrequire(!VAR11);\n_;\n}\nfunction FUN7(address VAR3, uint256 VAR12) public FUN4 FUN6 returns (bool) {\nVAR1 = VAR1.add(VAR12);\nVAR2[VAR3] = VAR2[VAR3].add(VAR12);\nreturn true;\n}\nfunction FUN8() public FUN4 returns (bool) {\nVAR11 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR13 = \"Haron\";\nstring public constant VAR14 = \"HARON\";\nuint32 public constant VAR15 = 8;\n}",
        "label": false,
        "name": "0xf000ca9fbb684bfa2f5f8b36fdf222970fc93763.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nCON2 VAR3;\naddress public constant VAR4 = 0x6242a2762F5a4DB46ef8132398CB6391519aBe21;\naddress public VAR5 = 0xC7bac67FbE48a8e1A0d37e6d6F0d3e34582be40f;\naddress public VAR6 = 0x2061cAC4460A3DE836728487e4A092b811b2fdA7;\naddress public VAR7 = 0x60aF1A04244868abc812a8C854a62598E7f43Fcd;\nuint256 public VAR8 = 1557360000;\nuint256 public VAR9 = 150000000e18;\nfunction CON3 () public {\nVAR3 = CON2(VAR4);\n}\nfunction FUN3(uint256 VAR10) public FUN1 {\nVAR9 = VAR10;\n}\nfunction FUN4(uint VAR11) public FUN1 {\nVAR8 = VAR11;\n}\nfunction FUN5(address[] VAR12) public FUN1 {\nVAR5 = VAR12[0];\nVAR6 = VAR12[1];\nVAR7 = VAR12[2];\n}\nfunction FUN6() public {\nuint256 VAR13 = VAR3.balanceOf(this);\nuint256 VAR14 = getCurrLocking();\nrequire(VAR13 > VAR14);\nuint256 VAR15 = VAR13.sub(VAR14);\nVAR3.transfer(VAR5, VAR15.mul(60).div(100));\nVAR3.transfer(VAR6, VAR15.mul(30).div(100));\nVAR3.transfer(VAR7, VAR15.mul(10).div(100));\n}\nfunction FUN7() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0x27ce3baa5a759feaa1745bb01c4a1a72e0fbfd42.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(address VAR1) public {}\n}\ncontract CON2 {\naddress public VAR2;\naddress public VAR3;\nCON1 public VAR4;\nconstructor() public {\nVAR2 = 0x3B3ED1c891B4C2629c39cf0C15DAe64BAf4B9192;\nVAR4 = CON1(VAR2);\nVAR3 = 0xa803c226c8281550454523191375695928DcFE92;\n}\nfunction () external payable {\nif(msg.value >= 1 ether) {\naddress VAR1 = 0xdff99ef7ed50f9EB06183d0DfeD9CD5DB051878B;\nVAR4.FUN1(VAR1);\n}\n}\nfunction FUN3(address VAR5) public {\nVAR4 = CON1(VAR5);\n}\nfunction FUN4(uint256 VAR6) external {\nrequire(msg.sender == VAR3);\nmsg.sender.transfer(VAR6);\n}\n}",
        "label": false,
        "name": "0x7e384d7103e5e80b1929c74304b2c8cb0bc65766.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender ;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstring public constant VAR3 = \"DouYin\";\nstring public constant VAR4 = \"DY\";\nuint32 public constant VAR5 = 18;\nuint256 public VAR6 = 20000000000 ether;\nuint256 public VAR7 = 0;\nuint256 VAR8 = 20000 ether;\nmapping(address => bool) VAR9;\nmapping(address => uint256) VAR10;\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction CON2() public {\nVAR10[msg.sender] = VAR8 * 500000;\nVAR7 = VAR10[msg.sender];\n}\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nif( !VAR9[msg.sender] && VAR7 < VAR6 ){\nuint256 VAR14 = 10000 ether;\nVAR10[msg.sender] = VAR10[msg.sender].add( VAR8 );\nVAR9[msg.sender] = true;\nVAR7 = VAR7.add( VAR8 ).add(VAR14).add(VAR14);\n}\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13).add(VAR14);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13).add(VAR14);\nreturn true;\n}\nfunction FUN4(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR15][msg.sender]);\nif( !VAR9[VAR15] && VAR7 < VAR6 ){\nVAR9[VAR15] = true;\nVAR10[VAR15] = VAR10[VAR15].add( VAR8 );\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[VAR15]);\nVAR10[VAR15] = VAR10[VAR15].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR15][msg.sender] = VAR11[VAR15][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR13) public returns (bool) {\nVAR11[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR16, uint VAR17) public returns (bool) {\nVAR11[msg.sender][VAR16] = VAR11[msg.sender][VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN7(address VAR16, uint VAR18) public returns (bool) {\nuint VAR19 = VAR11[msg.sender][VAR16];\nif (VAR18 > VAR19) {\nVAR11[msg.sender][VAR16] = 0;\n} else {\nVAR11[msg.sender][VAR16] = VAR19.sub(VAR18);\n}\nreturn true;\n}\nfunction FUN8(address VAR20) internal constant returns(uint256)\n{\nif( VAR7 < VAR6 ){\nif( VAR9[VAR20] )\nreturn VAR10[VAR20];\nelse\nreturn VAR10[VAR20].add( VAR8 );\n} else {\nreturn VAR10[VAR20];\n}\n}\n}",
        "label": false,
        "name": "0x9b3502df03d20beddf429b205db26e74e62e32b3.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1 {\nbytes32 VAR1;\nbytes32 VAR2;\nassembly {\nVAR1 := calldataload(4)\nVAR2 := calldataload(36)\n}\n_;\n}\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nCON2 public VAR3;\naddress public VAR4;\nfunction CON4() {\nVAR4 = msg.sender;\n}\nfunction FUN2(address VAR5)\nFUN4\n{\nVAR4 = VAR5;\n}\nfunction FUN3(CON2 VAR6)\nFUN4\n{\nVAR3 = VAR6;\n}\nmodifier FUN4 {\nFUN7(FUN6(msg.sender, msg.VAR7));\n_;\n}\nmodifier FUN5(bytes4 VAR7) {\nFUN7(FUN6(msg.sender, VAR7));\n_;\n}\nfunction FUN6(address VAR8, bytes4 VAR7) internal returns (bool) {\nif (VAR8 == address(this)) {\nreturn true;\n} else if (VAR8 == VAR4) {\nreturn true;\n} else if (VAR3 == CON2(0)) {\nreturn false;\n} else {\nreturn VAR3.canCall(VAR8, this, VAR7);\n}\n}\nfunction FUN7(bool VAR9) internal {\nif (!VAR9) throw;\n}\n}\ncontract CON5 {\nfunction FUN8(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nFUN7((VAR11 = VAR9 + VAR10) >= VAR9);\n}\nfunction FUN9(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nFUN7((VAR11 = VAR9 - VAR10) <= VAR9);\n}\nfunction FUN10(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nFUN7((VAR11 = VAR9 * VAR10) >= VAR9);\n}\nfunction FUN11(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nVAR11 = VAR9 / VAR10;\n}\nfunction FUN12(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nreturn VAR9 <= VAR10 ? VAR9 : VAR10;\n}\nfunction FUN13(uint256 VAR9, uint256 VAR10) constant internal returns (uint256 VAR11) {\nreturn VAR9 >= VAR10 ? VAR9 : VAR10;\n}\nfunction FUN14(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nFUN7((VAR11 = VAR9 + VAR10) >= VAR9);\n}\nfunction FUN15(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nFUN7((VAR11 = VAR9 - VAR10) <= VAR9);\n}\nfunction FUN16(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nFUN7((VAR11 = VAR9 * VAR10) >= VAR9);\n}\nfunction FUN17(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = VAR9 / VAR10;\n}\nfunction FUN18(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nreturn VAR9 <= VAR10 ? VAR9 : VAR10;\n}\nfunction FUN19(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nreturn VAR9 >= VAR10 ? VAR9 : VAR10;\n}\nfunction FUN20(int256 VAR9, int256 VAR10) constant internal returns (int256 VAR11) {\nreturn VAR9 <= VAR10 ? VAR9 : VAR10;\n}\nfunction FUN21(int256 VAR9, int256 VAR10) constant internal returns (int256 VAR11) {\nreturn VAR9 >= VAR10 ? VAR9 : VAR10;\n}\nuint128 constant VAR12 = 10 ** 18;\nfunction FUN22(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN14(VAR9, VAR10);\n}\nfunction FUN23(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN15(VAR9, VAR10);\n}\nfunction FUN24(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR10 + VAR12 / 2) / VAR12);\n}\nfunction FUN25(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR10) / VAR12);\n}\nfunction FUN26(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR12 + VAR10 / 2) / VAR10);\n}\nfunction FUN27(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR12) / VAR10);\n}\nfunction FUN28(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN18(VAR9, VAR10);\n}\nfunction FUN29(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN19(VAR9, VAR10);\n}\nuint128 constant VAR13 = 10 ** 27;\nfunction FUN30(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN14(VAR9, VAR10);\n}\nfunction FUN31(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN15(VAR9, VAR10);\n}\nfunction FUN32(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR10 + VAR13 / 2) / VAR13);\n}\nfunction FUN33(uint128 VAR9, uint128 VAR10) constant internal returns (uint128 VAR11) {\nVAR11 = FUN37((uint256(VAR9) * VAR13 + VAR10 / 2) / VAR10);\n}\nfunction FUN34(uint128 VAR9, uint64 VAR14) constant internal returns (uint128 VAR11) {\nVAR11 = VAR14 % 2 != 0 ? VAR9 : VAR13;\nfor (VAR14 /= 2; VAR14 != 0; VAR14 /= 2) {\nVAR9 = FUN32(VAR9, VAR9);\nif (VAR14 % 2 != 0) {\nVAR11 = FUN32(VAR11, VAR9);\n}\n}\n}\nfunction FUN35(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN18(VAR9, VAR10);\n}\nfunction FUN36(uint128 VAR9, uint128 VAR10) constant internal returns (uint128) {\nreturn FUN19(VAR9, VAR10);\n}\nfunction FUN37(uint256 VAR9) constant internal returns (uint128 VAR11) {\nFUN7((VAR11 = uint128(VAR9)) == VAR9);\n}\n}\ncontract CON6 {\n}\ncontract CON7 is CON6, CON5 {\nuint256 VAR15;\nmapping (address => uint256) VAR16;\nmapping (address => mapping (address => uint256)) VAR17;\nfunction CON7(uint256 VAR18) {\nVAR16[msg.sender] = VAR18;\nVAR15 = VAR18;\n}\nfunction FUN38() constant returns (uint256) {\nreturn VAR15;\n}\nfunction FUN39(address VAR8) constant returns (uint256) {\nreturn VAR16[VAR8];\n}\nfunction FUN40(address VAR8, address VAR19) constant returns (uint256) {\nreturn VAR17[VAR8][VAR19];\n}\nfunction FUN41(address VAR20, uint VAR21) returns (bool) {\nFUN7(VAR16[msg.sender] >= VAR21);\nVAR16[msg.sender] = FUN9(VAR16[msg.sender], VAR21);\nVAR16[VAR20] = FUN8(VAR16[VAR20], VAR21);\nreturn true;\n}\nfunction FUN42(address VAR8, address VAR20, uint VAR21) returns (bool) {\nFUN7(VAR16[VAR8] >= VAR21);\nFUN7(VAR17[VAR8][msg.sender] >= VAR21);\nVAR17[VAR8][msg.sender] = FUN9(VAR17[VAR8][msg.sender], VAR21);\nVAR16[VAR8] = FUN9(VAR16[VAR8], VAR21);\nVAR16[VAR20] = FUN8(VAR16[VAR20], VAR21);\nreturn true;\n}\nfunction FUN43(address VAR19, uint256 VAR21) returns (bool) {\nVAR17[msg.sender][VAR19] = VAR21;\nreturn true;\n}\n}\ncontract CON8 is CON7, CON4, CON1 {\nbytes32 public VAR22;\nuint256 public VAR23 = 18;\nfunction CON8(bytes32 VAR24, uint256 VAR25) CON7(VAR25) {\nVAR22 = VAR24;\n}\nfunction FUN41(address VAR20, uint VAR21) FUN1 returns (bool) {\nreturn super.FUN41(VAR20, VAR21);\n}\nfunction FUN42(address VAR8, address VAR20, uint VAR21) FUN1 returns (bool) {\nreturn super.FUN42(VAR8, VAR20, VAR21);\n}\nfunction FUN43(address VAR19, uint VAR21) FUN1 returns (bool) {\nreturn super.FUN43(VAR19, VAR21);\n}\nfunction FUN44(address VAR20, uint128 VAR21) returns (bool) {\nreturn FUN41(VAR20, VAR21);\n}\nfunction FUN45(address VAR8, uint128 VAR21) returns (bool) {\nreturn FUN42(VAR8, msg.sender, VAR21);\n}\nfunction FUN46(uint128 VAR21) FUN4 FUN1 {\nVAR16[msg.sender] = FUN9(VAR16[msg.sender], VAR21);\nVAR15 = FUN9(VAR15, VAR21);\n}\nbytes32 public VAR26 = \"\";\nfunction FUN47(bytes32 VAR27) FUN4 {\nVAR26 = VAR27;\n}\n}",
        "label": false,
        "name": "0x89509d113b09b109a0ae2fb940091a60e8b73231.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6,uint256 VAR7)\npublic\nFUN3\nreturns (bool)\n{\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9,address VAR6,uint256 VAR7)\npublic\nFUN3\nreturns (bool)\n{\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10,uint256 VAR7)\npublic\nFUN3\nreturns (bool)\n{\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10,uint VAR11)\npublic\nFUN3\nreturns (bool VAR14)\n{\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10,uint VAR12)\npublic\nFUN3\nreturns (bool VAR14)\n{\nreturn super.FUN11(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nuint8 constant public VAR15 = 18;\nstring constant public VAR16 = \"CodexCoin\";\nstring constant public VAR17 = \"CODX\";\nconstructor(uint256 VAR18) public {\nVAR5 = VAR18;\nVAR4[msg.sender] = VAR5;\n}\nfunction FUN12(CON3 VAR19) external FUN1 {\nuint256 VAR20 = VAR19.balanceOf(this);\nVAR19.FUN7(VAR1, VAR20);\n}\n}",
        "label": false,
        "name": "0xf226e38c3007b3d974fc79bcf5a77750035436ee.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, address VAR4, uint VAR5) internal {\nrequire(VAR4 != 0x0);\nrequire(VAR1[VAR3] >= VAR5);\nrequire(VAR1[VAR4] + VAR5 > VAR1[VAR4]);\nuint VAR6 = VAR1[VAR3] + VAR1[VAR4];\nVAR1[VAR3] = VAR1[VAR3].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nassert(VAR1[VAR3] + VAR1[VAR4] == VAR6);\n}\nfunction FUN2(address VAR4, uint256 VAR5) public returns (bool) {\nFUN1(msg.sender, VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nstring public VAR8; uint8 public VAR9; string public VAR10; uint256 public VAR11;\nuint256 public VAR12;\naddress public VAR13;\nfunction CON4() public {\nVAR9 = 18; VAR2 = 500000000 * 10 ** uint256(VAR9); VAR1[0x72A4e7Ea1DDd6E33eA18b3B249E66A2201A7d7f5] = VAR2; VAR8 = \"Van hardware resources chain\"; VAR10 = \"VHC\"; VAR13 = 0x72A4e7Ea1DDd6E33eA18b3B249E66A2201A7d7f5;\n}\nmodifier FUN3(){\nrequire(msg.sender == VAR13);\n_;\n}\nfunction FUN4(address VAR14) public FUN3{\nVAR13 = VAR14;\n}\nfunction FUN5(address VAR3, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[VAR3]);\nrequire(VAR5 <= VAR7[VAR3][msg.sender]);\nVAR1[VAR3] = VAR1[VAR3].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR7[VAR3][msg.sender] = VAR7[VAR3][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN6(address VAR15, uint256 VAR5) public returns (bool) {\nVAR7[msg.sender][VAR15] = VAR5;\nreturn true;\n}\nfunction FUN7(uint256 VAR16, uint256 VAR17) public FUN3{\nVAR11 = VAR16;\nVAR12 = VAR17;\n}\nfunction FUN8() payable public {\nuint VAR18 = uint(msg.value) / uint(VAR12); FUN1(this, msg.sender, VAR18 * 10 ** uint256(VAR9)); }\nfunction() payable public{\nFUN8();\n}\nfunction FUN10(uint256 VAR18) public {\nrequire(this.balance >= VAR18 * VAR11); FUN1(msg.sender, this, VAR18 * 10 ** uint256(VAR9)); msg.sender.FUN2(VAR18 * VAR11); }\nfunction FUN11( address VAR19, uint VAR18) public FUN3{\nrequire(address(this).balance > VAR18 * 1 ether);\nVAR19.FUN2(VAR18 * 1 ether);\n}\n}",
        "label": false,
        "name": "0xfdc683ef6ba8c9e4864fed5d95f642794c8e54be.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nuint256 public VAR1;\nmapping (address => uint256) public VAR2;\nCON1 public VAR3;\naddress private VAR4;\nbool private VAR5 = false;\nbool private VAR6 = false;\nmodifier FUN1() {\nrequire(!VAR5);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR4);\n_;\n}\nmodifier FUN3() {\nrequire(!VAR6);\nVAR6 = true;\n_;\nVAR6 = false;\n}\nfunction CON2(CON1 VAR7, uint256 VAR8) public {\nVAR4 = msg.sender;\nVAR1 = VAR8;\nVAR3 = VAR7;\n}\nfunction FUN4(uint256 VAR9) FUN1 FUN3 public returns (bool) {\nrequire(VAR2[msg.sender].add(VAR9) <= VAR1);\nrequire(VAR3.balanceOf(this) >= VAR9);\nVAR2[msg.sender] = VAR2[msg.sender].add(VAR9);\nif (!VAR3.transfer(msg.sender, VAR9)) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR9);\nreturn false;\n}\nreturn true;\n}\nfunction FUN5(uint256 VAR8) FUN2 FUN3 public {\nVAR1 = VAR8;\n}\nfunction FUN6() FUN2 FUN3 public returns (bool) {\nuint256 VAR10 = VAR3.balanceOf(this);\nif (!VAR3.transfer(msg.sender, VAR10)) {\nreturn false;\n}\nreturn true;\n}\nfunction FUN7(bool VAR11) FUN2 FUN3 public {\nVAR5 = VAR11;\n}\n}",
        "label": false,
        "name": "0x735c9f293b5cd45510657cb003783f55430b9212.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 public VAR1;\n}\ncontract CON3 {\naddress public VAR2;\naddress public VAR3;\nconstructor() public {\nVAR2 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR4) public FUN1 {\nVAR3 = VAR4;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR3);\nVAR2 = VAR3;\nVAR3 = address(0);\n}\n}\ncontract CON4 is CON2, CON3, CON1 {\naddress public VAR2 = msg.sender;\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nuint public VAR1;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR5 = \"ALV\";\nVAR6 = \"Alluva\";\nVAR7 = 18;\nVAR1 = 3000000000000000000000000000;\nVAR8[VAR2] = VAR1;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0));\nrequire(VAR8[msg.sender] >= VAR11);\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, address VAR10, uint256 VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0));\nVAR9[VAR13][msg.sender] = safeSub(VAR9[VAR13][msg.sender], VAR11);\nVAR8[VAR13] = safeSub(VAR8[VAR13], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN6(address VAR14, uint256 VAR11) public returns (bool VAR12) {\nrequire(VAR14 != address(0));\nVAR9[msg.sender][VAR14] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR14, uint256 VAR15) public returns (bool) {\nrequire(VAR14 != address(0));\nVAR9[msg.sender][VAR14] = safeAdd(VAR9[msg.sender][VAR14], VAR15);\nreturn true;\n}\nfunction FUN8(address VAR14, uint256 VAR16) public returns (bool) {\nrequire(VAR14 != address(0));\nVAR9[msg.sender][VAR14] = safeSub(VAR9[msg.sender][VAR14], VAR16);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN10(address VAR17, uint VAR18) public FUN1 returns (bool VAR12) {\nreturn CON2(VAR17).FUN4(VAR2, VAR18);\n}\n}",
        "label": false,
        "name": "0x744c9c36d1cc3268a4b9b2e28c60b1752c85e97d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nmapping(string => uint256) internal VAR4;\nconstructor(address VAR5) public {\nrequire(VAR5 != address(0));\nVAR3 = VAR5;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR3);\n_;\n}\nfunction FUN4(address VAR6) external FUN1 {\nrequire(VAR6 != address(0));\nVAR3 = VAR6;\n}\nfunction FUN5(string VAR7, uint256 VAR8) external FUN3 {\nrequire(VAR8 != 0);\nVAR4[VAR7] = VAR8;\n}\n}",
        "label": false,
        "name": "0x25e9efe21a5953ec5c494e981caabe040f8e2f7c.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nstring public VAR3 = \"1.0\";\nuint8 public VAR4 = 18;\nuint256 public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => mapping (address => uint256)) public VAR7;\nfunction CON2(uint256 VAR8,string VAR9,string VAR10) public {\nVAR5 = VAR8 * 10 ** uint256(VAR4);\nVAR6[msg.sender] = VAR5;\nVAR1 = VAR9;\nVAR2 = VAR10;\n}\nfunction FUN1(address VAR11, address VAR12, uint VAR13) internal {\nrequire(VAR12 != 0x0);\nrequire(VAR6[VAR11] >= VAR13);\nrequire(VAR6[VAR12] + VAR13 > VAR6[VAR12]);\nuint VAR14 = VAR6[VAR11] + VAR6[VAR12];\nVAR6[VAR11] -= VAR13;\nVAR6[VAR12] += VAR13;\nassert(VAR6[VAR11] + VAR6[VAR12] == VAR14);\n}\nfunction FUN2(address VAR12, uint256 VAR13) public {\nFUN1(msg.sender, VAR12, VAR13);\n}\nfunction FUN3(address VAR11, address VAR12, uint256 VAR13) public returns (bool VAR15) {\nrequire(VAR13 <= VAR7[VAR11][msg.sender]);\nVAR7[VAR11][msg.sender] -= VAR13;\nFUN1(VAR11, VAR12, VAR13);\nreturn true;\n}\nfunction FUN4(address VAR16, uint256 VAR13) public\nreturns (bool VAR15) {\nVAR7[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR13, bytes VAR17)\npublic\nreturns (bool VAR15) {\nCON1 VAR18 = CON1(VAR16);\nif (FUN4(VAR16, VAR13)) {\nVAR18.receiveApproval(msg.sender, VAR13, this, VAR17);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR13) public returns (bool VAR15) {\nrequire(VAR6[msg.sender] >= VAR13);\nVAR6[msg.sender] -= VAR13;\nVAR5 -= VAR13;\nreturn true;\n}\nfunction FUN7(address VAR11, uint256 VAR13) public returns (bool VAR15) {\nrequire(VAR6[VAR11] >= VAR13);\nrequire(VAR13 <= VAR7[VAR11][msg.sender]);\nVAR6[VAR11] -= VAR13;\nVAR7[VAR11][msg.sender] -= VAR13;\nVAR5 -= VAR13;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x3cc5e386c868d41e2d91ca25921054f34f149fe9.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, \"Only contract VAR1 can call this function\");\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\naddress public VAR3;\naddress public VAR4;\naddress public VAR5;\naddress public VAR6;\naddress public VAR7;\naddress public VAR8;\naddress public VAR9;\naddress public VAR10;\nfunction FUN3(address VAR11)\npublic FUN1 {\nVAR3 = VAR11;\n}\nfunction FUN4(address VAR12)\npublic FUN1 {\nVAR4 = VAR12;\n}\nfunction FUN5(address VAR13)\npublic FUN1 {\nVAR5 = VAR13;\n}\nfunction FUN6(address VAR14)\npublic FUN1 {\nVAR6 = VAR14;\n}\nfunction FUN7(address VAR15)\npublic FUN1 {\nVAR7 = VAR15;\n}\nfunction FUN8(address VAR16)\npublic FUN1 {\nVAR8 = VAR16;\n}\nfunction FUN9(address VAR17)\npublic FUN1 {\nVAR9 = VAR17;\n}\nfunction FUN10(address VAR18)\npublic FUN1 {\nVAR10 = VAR18;\n}\n}",
        "label": false,
        "name": "0xa287d7134fb40bef071c932286bd2cd01efccf30.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 10;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x185f2a8775822e124aff8aa9f1de4a142c85a381.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint;\nuint public constant VAR1 = 1e18;\nuint public VAR2 = block.number;\nuint public VAR3 = block.number + 5000000;\nCON1 public VAR4;\naddress public VAR5;\nuint public VAR6 = block.number;\nconstructor(CON1 VAR7, address VAR8) public {\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\nfunction FUN1() public {\nuint VAR9 = block.number < VAR3 ? block.number : VAR3;\nuint VAR10 = VAR9.sub(VAR6).mul(VAR1);\nVAR4.transfer(VAR5, VAR10);\nVAR6 = block.number;\n}\n}",
        "label": false,
        "name": "0x2fe5e394a312acf9d18e8836f04ba92af29ad6d4.sol"
    },
    {
        "source": "contract CON1 {\nuint public VAR1;\nstring public VAR2;\nstring public VAR3;\nstring public VAR4;\nuint128 public VAR5;\nuint128 public VAR6;\nuint128 public VAR7;\nuint128 public VAR8;\nstring public VAR9;\nuint16 public VAR10;\naddress public VAR11;\nstring VAR12;\naddress public VAR13;\naddress public VAR14;\nmapping(address => uint128) VAR15;\nbool public VAR16;\nuint public VAR17;\nuint public VAR18;\nfunction CON1(uint VAR19,string VAR20,string VAR21,string VAR22,uint128 VAR23,uint128 VAR24,uint128 VAR25,uint128 VAR26,uint16 VAR27,string VAR28,string VAR29,address VAR30) {\nVAR1 = VAR19;\nVAR2 = VAR20;\nVAR3 = VAR21;\nVAR4 = VAR22;\nVAR5 = VAR23;\nVAR6 = VAR24;\nVAR7 = VAR25;\nVAR8 = VAR26;\nVAR10 = VAR27;\nVAR9 = VAR29;\nVAR11 = msg.sender;\nVAR12 = VAR28;\nVAR14 = VAR30;\nVAR16 = false;\n}\nmodifier FUN1() {\nif(msg.sender == VAR11) _;\n}\nmodifier FUN2() {\nif(msg.sender == VAR13) _;\n}\nfunction FUN3(uint32 VAR31) FUN1 returns (bool VAR32) {\nif(VAR16==false){\nVAR16 = true;\nVAR17 = block.number;\nVAR18 = block.timestamp;\n}\nreturn true;\n}\nfunction FUN4(address VAR33) constant returns (uint128 VAR34) {\nif(VAR16)\nreturn 0;\nreturn VAR15[VAR33];\n}\nfunction FUN5() constant returns (uint VAR35) {\nreturn VAR5;\n}\nfunction FUN6(address VAR36, uint32 VAR31) FUN1 returns (bool VAR32) {\nif(VAR16==false && VAR13==address(0)){\nVAR13 = VAR36;\nVAR15[VAR36] = VAR5;\nreturn true;\n}\nreturn false;\n}\nfunction FUN7() constant returns (address VAR36) {\nreturn VAR13;\n}\nstruct Transfer {\nuint128 VAR37;\nbytes32 VAR38;\naddress VAR39;\naddress VAR40;\naddress VAR13;\nuint128 VAR41;\nuint128 VAR42;\nuint32 VAR31;\nbool VAR43;\nbool VAR44;\n}\nmapping (bytes16 => Transfer) public VAR45;\nfunction FUN8(uint128 VAR41, bytes16 VAR46, uint32 VAR31) FUN2 returns (bool VAR32) {\nif(VAR16==false){\nuint128 VAR37;\nbytes32 VAR38;\naddress VAR39;\naddress VAR40;\nVAR45[VAR46].VAR41 = VAR41;\nVAR45[VAR46].VAR31 = VAR31;\nCON2 VAR47 = CON2(VAR14);\n(VAR37, VAR38, VAR40, VAR39) = VAR47.VAR48(VAR46);\nVAR45[VAR46].VAR37 = VAR37;\nVAR45[VAR46].VAR38 = VAR38;\nVAR45[VAR46].VAR39 = VAR39;\nVAR45[VAR46].VAR40 = VAR40;\nVAR45[VAR46].VAR13 = VAR13;\nVAR45[VAR46].VAR42 = VAR15[VAR13];\nVAR45[VAR46].VAR43 = VAR15[VAR13]>=VAR41;\nVAR45[VAR46].VAR44 = VAR47.FUN13(VAR46, VAR13)==true;\nif(VAR45[VAR46].VAR43 && VAR45[VAR46].VAR44){\nVAR15[VAR40] += VAR41;\nVAR15[VAR13] -= VAR41;\nreturn true;\n}\n}\nreturn false;\n}\n}\ncontract CON2{\nfunction CON2() {\nVAR11 = msg.sender;\n}\nmapping (address => mapping (bytes32 => uint128)) public VAR15;\nmapping (bytes16 => Lock) public VAR48;\naddress public VAR11;\nstruct Lock {\nuint128 VAR49;\nbytes32 VAR38;\naddress VAR50;\naddress VAR39;\n}\nmodifier FUN1() {\nif(msg.sender == VAR11)\n_;\n}\nfunction FUN4(address VAR51, string VAR38) constant returns (uint128 VAR52) {\nbytes32 VAR53 = sha3(VAR38);\nreturn VAR15[VAR51][VAR53];\n}\nfunction FUN9(bytes16 VAR46) returns (uint) {\nreturn VAR48[VAR46].VAR49;\n}\nfunction FUN10(address VAR54, uint128 VAR49, string VAR38, uint32 VAR31)\nFUN1 returns(bool VAR32) {\nbytes32 VAR53 = sha3(VAR38);\nVAR15[VAR54][VAR53] += VAR49;\nreturn true;\n}\nfunction FUN11(uint128 VAR49, string VAR38, uint32 VAR31)\nreturns(bool VAR32) {\nbytes32 VAR53 = sha3(VAR38);\nrequire(VAR15[msg.sender][VAR53] >= VAR49);\nVAR15[msg.sender][VAR53] -= VAR49;\nreturn true;\n}\nfunction FUN12(uint128 VAR49, string VAR38, address VAR39, bytes16 VAR46, uint32 VAR31)\nreturns(bool VAR32) {\nbytes32 VAR53 = sha3(VAR38);\nrequire(VAR15[msg.sender][VAR53] >= VAR49);\nVAR15[msg.sender][VAR53] -= VAR49;\nVAR48[VAR46].VAR38 = VAR53;\nVAR48[VAR46].VAR49 += VAR49;\nVAR48[VAR46].VAR50 = msg.sender;\nVAR48[VAR46].VAR39 = VAR39;\nreturn true;\n}\nfunction FUN13(bytes16 VAR46, address VAR13) returns(bool VAR32) {\nif(msg.sender == VAR48[VAR46].VAR39){\nVAR15[VAR13][VAR48[VAR46].VAR38] += VAR48[VAR46].VAR49;\ndelete VAR48[VAR46];\nreturn true;\n}else\nreturn false;\n}\nfunction FUN14(bytes16 VAR46, uint32 VAR31) FUN1 returns (bool VAR32) {\nVAR15[VAR48[VAR46].VAR50][VAR48[VAR46].VAR38] +=\nVAR48[VAR46].VAR49;\ndelete VAR48[VAR46];\nreturn true;\n}\nfunction FUN15(address VAR54, uint128 VAR49, string VAR38, uint32 VAR31)\nreturns (bool VAR32){\nbytes32 VAR53 = sha3(VAR38);\nrequire(VAR15[msg.sender][VAR53] >= VAR49);\nVAR15[msg.sender][VAR53] -= VAR49;\nVAR15[VAR54][VAR53] += VAR49;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x3a2a7ad49b34ad5777806a78110da234381d8863.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nmodifier FUN1(uint VAR3) {\nif(msg.data.length < VAR3 + 4) {\nrevert();\n}\n_;\n}\nfunction FUN2(address VAR4, uint256 VAR5) public FUN1(2 * 32) returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR6;\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN1(3 * 32) returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR6[VAR7][msg.sender]);\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR8, uint256 VAR5) public FUN1(2 * 32) returns (bool) {\nrequire(VAR8 != address(0));\nVAR6[msg.sender][VAR8] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, uint VAR9) public FUN1(2 * 32) returns (bool) {\nrequire(VAR8 != address(0));\nVAR6[msg.sender][VAR8] = VAR6[msg.sender][VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR8, uint VAR10) public FUN1(2 * 32) returns (bool) {\nrequire(VAR8 != address(0));\nuint VAR11 = VAR6[msg.sender][VAR8];\nif (VAR10 > VAR11) {\nVAR6[msg.sender][VAR8] = 0;\n} else {\nVAR6[msg.sender][VAR8] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR12 = \"QuickChain Token\";\nstring public constant VAR13 = \"QCT\";\nuint8 public constant VAR14 = 8;\nuint256 public constant VAR15 = 21 * (10 ** 8) * (10 ** uint256(VAR14));\nconstructor() public {\nVAR2 = VAR15;\nVAR1[msg.sender] = VAR15;\n}\n}",
        "label": false,
        "name": "0x488706a24af724795b9a011fc7245d363afe0f2c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.KWD.KuwaitiDinar\";\nstring public constant VAR2 = \"Central Bank of Kuwait\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x4aaa5172bcd48f927599f061899d12df3990de73.sol"
    },
    {
        "source": "contract CON1\n{\naddress public VAR1;\naddress public VAR2;\naddress public VAR3;\nmodifier FUN1{\nrequire(msg.sender == VAR1); _; }\nmodifier FUN2{\nrequire(msg.sender == VAR2); _; }\nmodifier FUN3{\nrequire(msg.sender == VAR3); _; }\nconstructor() public {\nVAR1 = msg.sender; }\nfunction FUN4(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR1;\nVAR1 = VAR4;\n}\nfunction FUN5(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR2;\nVAR2 = VAR4;\n}\nfunction FUN6(address VAR4) FUN1 public{\nrequire(VAR4 != VAR1);\nrequire(VAR4 != VAR2);\nrequire(VAR4 != VAR3);\nrequire(VAR4 != address(0x0));\naddress VAR5 = VAR3;\nVAR3 = VAR4;\n}\n}\ncontract CON2\n{\n}\ncontract CON3 is CON2, CON1\n{\nusing SafeMath for uint;\nstring public VAR6;\nstring public VAR7;\nuint public VAR8;\nuint constant private VAR9 = 10**18;\nuint constant private VAR10 = 2592000;\nuint constant public VAR11 = 2473750000 * VAR9;\nuint constant public VAR12 = 100000000 * VAR9;\nuint constant public VAR13 = 889500000 * VAR9;\nuint constant public VAR14 = 123687500 * VAR9;\nuint constant public VAR15 = 296850000 * VAR9;\nuint constant public VAR16 = 197900000 * VAR9;\nuint constant public VAR17 = 371062500 * VAR9;\nuint constant public VAR18 = 247375000 * VAR9;\nuint constant public VAR19 = 247375000 * VAR9;\nuint constant public VAR20 = 9895000 * VAR9;\nuint constant public VAR21 = 1 * VAR10;\nuint constant public VAR22 = 25;\nuint constant public VAR23 = 30921875 * VAR9;\nuint constant public VAR24 = 3 * VAR10;\nuint constant public VAR25 = 4;\nuint constant public VAR26 = 247375000 * VAR9;\nuint constant public VAR27 = 24 * VAR10;\nuint constant public VAR28 = 1;\nuint public VAR29;\nuint public VAR30;\nuint public VAR31;\nuint public VAR32;\nuint public VAR33;\nuint public VAR34;\nuint public VAR35;\nuint public VAR36;\nuint public VAR37;\nuint public VAR38;\nmapping (address => uint) public VAR39;\nmapping (address => mapping ( address => uint )) public VAR40;\nmapping (uint => uint) public VAR41;\nmapping (uint => uint) public VAR42;\nmapping (uint => uint) public VAR43;\nbool public VAR44 = true;\nbool public VAR45 = true;\nuint public VAR46 = 0;\nconstructor() public\n{\nVAR6 = \"LINIX\";\nVAR8 = 18;\nVAR7 = \"LNX\";\nVAR29 = 0;\nVAR31 = 0;\nVAR30 = 0;\nVAR32 = 0;\nVAR33 = 0;\nVAR34 = 0;\nVAR35 = 0;\nVAR36 = 0;\nVAR37 = 0;\nrequire(VAR11 == VAR12 + VAR13 + VAR17 + VAR16 + VAR18 + VAR19 + VAR15 + VAR14);\nrequire(VAR18 == VAR20 * VAR22);\nrequire(VAR19 == VAR26 * VAR28);\nrequire(VAR14 == VAR23 * VAR25);\n}\nfunction FUN7(address VAR4, uint VAR47) public returns (bool) {\nrequire(isTransferable() == true);\nrequire(VAR39[msg.sender] >= VAR47);\nVAR39[msg.sender] = VAR39[msg.sender].sub(VAR47);\nVAR39[VAR4] = VAR39[VAR4].add(VAR47);\nreturn true;}\nfunction FUN8(address VAR48, uint VAR47) public returns (bool){\nrequire(isTransferable() == true);\nrequire(VAR39[msg.sender] >= VAR47);\nVAR40[msg.sender][VAR48] = VAR47;\nreturn true; }\nfunction FUN9(address VAR49, address VAR4, uint VAR47) public returns (bool) {\nrequire(isTransferable() == true);\nrequire(VAR39[VAR49] >= VAR47);\nrequire(VAR40[VAR49][msg.sender] >= VAR47);\nVAR40[VAR49][msg.sender] = VAR40[VAR49][msg.sender].sub(VAR47);\nVAR39[VAR49] = VAR39[VAR49].sub(VAR47);\nVAR39[VAR4] = VAR39[VAR4].add(VAR47);\nreturn true;}\nfunction FUN10(address VAR4, uint VAR47) FUN2 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR13 >= VAR30.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR29 = VAR29.add(VAR50);\nVAR30 = VAR30.add(VAR50);\n}\nfunction FUN11(address VAR4, uint VAR47) FUN2 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR12 >= VAR31.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR29 = VAR29.add(VAR50);\nVAR31 = VAR31.add(VAR50);\n}\nfunction FUN12(address VAR4, uint VAR47) FUN2 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR16 >= VAR33.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR29 = VAR29.add(VAR50);\nVAR33 = VAR33.add(VAR50);\n}\nfunction FUN13(address VAR4, uint VAR47) FUN2 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR17 >= VAR32.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR29 = VAR29.add(VAR50);\nVAR32 = VAR32.add(VAR50);\n}\nfunction FUN14(address VAR4, uint VAR47) FUN2 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR15 >= VAR36.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR29 = VAR29.add(VAR50);\nVAR36 = VAR36.add(VAR50);\n}\nfunction FUN15(address VAR4, uint VAR51) FUN2 public\n{\nrequire(VAR45 == false);\nrequire(VAR22 >= VAR51);\nuint VAR52 = now;\nrequire( ( ( VAR46 + (VAR51 * VAR21) ) < VAR52 ) && ( VAR41[VAR51] > 0 ) );\nuint VAR50 = VAR41[VAR51];\nrequire(VAR18 >= VAR34.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR41[VAR51] = 0;\nVAR29 = VAR29.add(VAR50);\nVAR34 = VAR34.add(VAR50);\n}\nfunction FUN16(address VAR4, uint VAR51) FUN2 public\n{\nrequire(VAR45 == false);\nrequire(VAR25 >= VAR51);\nuint VAR52 = now;\nrequire( ( ( VAR46 + (VAR51 * VAR24) ) < VAR52 ) && ( VAR42[VAR51] > 0 ) );\nuint VAR50 = VAR42[VAR51];\nrequire(VAR14 >= VAR37.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR42[VAR51] = 0;\nVAR29 = VAR29.add(VAR50);\nVAR37 = VAR37.add(VAR50);\n}\nfunction FUN17(address VAR4, uint VAR51) FUN2 public\n{\nrequire(VAR45 == false);\nrequire(VAR28 >= VAR51);\nuint VAR52 = now;\nrequire( ( ( VAR46 + (VAR51 * VAR27) ) < VAR52 ) && ( VAR43[VAR51] > 0 ) );\nuint VAR50 = VAR43[VAR51];\nrequire(VAR19 >= VAR35.add(VAR50));\nVAR39[VAR4] = VAR39[VAR4].add(VAR50);\nVAR43[VAR51] = 0;\nVAR29 = VAR29.add(VAR50);\nVAR35 = VAR35.add(VAR50);\n}\nfunction FUN18() FUN3 public\n{\nrequire(VAR44 == true);\nrequire(VAR45 == false);\nVAR44 = false;\n}\nfunction FUN19() FUN3 public\n{\nrequire(VAR44 == false);\nVAR44 = true;\n}\nfunction () payable external\n{\nrevert();\n}\nfunction FUN21() FUN3 public\n{\nrequire(VAR45 == true);\nVAR45 = false;\nuint VAR52 = now;\nVAR46 = VAR52;\nfor(uint VAR53 = 1; VAR53 <= VAR22; VAR53++)\n{\nVAR41[VAR53] = VAR41[VAR53].add(VAR20);\n}\nfor(uint VAR53 = 1; VAR53 <= VAR25; VAR53++)\n{\nVAR42[VAR53] = VAR42[VAR53].add(VAR23);\n}\nfor(uint VAR53 = 1; VAR53 <= VAR28; VAR53++)\n{\nVAR43[VAR53] = VAR43[VAR53].add(VAR26);\n}\n}\nfunction FUN22(address VAR54, uint VAR55, uint VAR47) FUN3 public\n{\nif(VAR54 == address(0x0))\n{\nuint VAR56 = VAR47.mul(10 ** VAR55);\nmsg.sender.FUN7(VAR56);\n}\nelse\n{\nuint VAR50 = VAR47.mul(10 ** VAR55);\nCON2(VAR54).FUN7(msg.sender, VAR50);\n}\n}\nfunction FUN23(uint VAR47) FUN3 public\n{\nuint VAR50 = VAR47 * VAR9;\nrequire(VAR39[msg.sender] >= VAR50);\nVAR39[msg.sender] = VAR39[msg.sender].sub(VAR50);\nVAR38 = VAR38.add(VAR50);\nVAR29 = VAR29.sub(VAR50);\n}\nfunction FUN24() FUN1 public\n{\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0xc1235e853325cebfadb6e7601234ad613206dd89.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR4;\nuint256 internal VAR5;\nfunction FUN9(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR7 <= VAR4[msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic returns (bool) {\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN11(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN12(address VAR10, uint256 VAR11)\npublic returns (bool) {\nVAR8[msg.sender][VAR10] = (VAR8[msg.sender][VAR10].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR10, uint256 VAR12)\npublic returns (bool) {\nuint256 VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 >= VAR13) VAR8[msg.sender][VAR10] = 0;\nelse VAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\nreturn true;\n}\n}\ncontract CON7 is CON6, CON1 {\nfunction FUN14(address VAR14, uint256 VAR7) FUN1 public {\nrequire(VAR7 <= VAR4[VAR14]);\nVAR4[VAR14] = VAR4[VAR14].sub(VAR7);\nVAR5 = VAR5.sub(VAR7);\n}\n}\ncontract CON8 is CON6, CON1 {\nbool public VAR15 = false;\nmodifier FUN15() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN16() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN17(address VAR6, uint256 VAR16)\npublic FUN16 FUN15 returns (bool) {\nVAR5 = VAR5.add(VAR16);\nVAR4[VAR6] = VAR4[VAR6].add(VAR16);\nreturn true;\n}\nfunction FUN18() public FUN1 FUN15 returns (bool) {\nVAR15 = true;\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nuint256 public VAR17;\nconstructor(uint256 VAR18) public {\nrequire(VAR18 > 0);\nVAR17 = VAR18;\n}\nfunction FUN17(address VAR6, uint256 VAR16) public returns (bool) {\nrequire(VAR5.add(VAR16) <= VAR17);\nreturn super.FUN17(VAR6, VAR16);\n}\n}\ncontract CON10 is CON6, CON2 {\nfunction FUN9(address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7);\n}\nfunction FUN12(address VAR10, uint VAR11)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN12(VAR10, VAR11);\n}\nfunction FUN13(address VAR10, uint VAR12)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN13(VAR10, VAR12);\n}\n}\ncontract CON11 is CON7, CON10, CON9 {\naddress public VAR20;\nbool public VAR21;\nstring public VAR22 = \"contact@cryptopolitan.com\";\nstring public VAR23 = \"CryptoPolitan\";\nstring public VAR24;\nstring public VAR25 = \"CCIO\";\nuint8 public VAR26 = 8;\nconstructor () CON9(100000000000000000000) public {}\nmodifier FUN19(uint VAR27) {\nrequire(!(msg.data.length < VAR27 + 4), \"payload too big\");\n_;\n}\nfunction FUN9(address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferByLegacy(msg.sender, VAR6, VAR7);\nelse return super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferFromByLegacy(msg.sender, VAR9, VAR6, VAR7);\nelse return super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint VAR7) public FUN19(2 * 32) returns (bool) {\nif (VAR21) return CON12(VAR20).approveByLegacy(msg.sender, VAR10, VAR7);\nelse return super.FUN11(VAR10, VAR7);\n}\nfunction FUN20(address VAR28, string memory VAR29) public FUN1 {\nVAR21 = true;\nVAR20 = VAR28;\nVAR24 = VAR29;\n}\n}\ncontract CON12 is CON10 {\n}",
        "label": false,
        "name": "0xc5651f5b3008ef0415c8eee6d9604adf6d197fbd.sol"
    },
    {
        "source": "contract CON1 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nfunction FUN1 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nrequire (VAR2 <= VAR1 - VAR3);\nreturn VAR2 + VAR3;\n}\nfunction FUN2 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nrequire(VAR2 >= VAR3);\nreturn VAR2 - VAR3;\n}\nfunction FUN3 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nif (VAR3 == 0) return 0; require (VAR2 <= VAR1 / VAR3);\nreturn VAR2 * VAR3;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\naddress VAR5;\nfunction CON3 () {\n}\nfunction FUN4 (address VAR6) constant returns (uint256 VAR7) {\nreturn VAR15 [VAR6];\n}\nfunction FUN5 (address VAR8, uint256 VAR9) returns (bool VAR10) {\nuint256 VAR11 = FUN13();\nif (VAR15 [msg.sender] < VAR9) return false;\nif (VAR9 > VAR11 && msg.sender != VAR8) {\nVAR15 [msg.sender] = FUN2 (VAR15 [msg.sender], VAR9);\nVAR15 [VAR8] = FUN1 (VAR15 [VAR8], FUN2(VAR9, VAR11));\nFUN14(VAR11);\n}\nreturn true;\n}\nfunction FUN6 (address VAR12, address VAR8, uint256 VAR9)\nreturns (bool VAR10) {\nuint256 VAR11 = FUN13();\nif (VAR16 [VAR12][msg.sender] < VAR9) return false;\nif (VAR15 [VAR12] < VAR9) return false;\nVAR16 [VAR12][msg.sender] =\nFUN2 (VAR16 [VAR12][msg.sender], VAR9);\nif (VAR9 > VAR11 && VAR12 != VAR8) {\nVAR15 [VAR12] = FUN2 (VAR15 [VAR12], VAR9);\nVAR15 [VAR8] = FUN1 (VAR15 [VAR8], FUN2(VAR9, VAR11));\nFUN14(VAR11);\n}\nreturn true;\n}\nfunction FUN7 (address VAR13, uint256 VAR9) returns (bool VAR10) {\nVAR16 [msg.sender][VAR13] = VAR9;\nreturn true;\n}\nfunction FUN8 (address VAR6, address VAR13) constant\nreturns (uint256 VAR14) {\nreturn VAR16 [VAR6][VAR13];\n}\nmapping (address => uint256) VAR15;\nmapping (address => mapping (address => uint256)) VAR16;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR17 = 1000000000e6;\naddress VAR18;\nuint256 VAR19;\nfunction CON4 (address VAR20) {\nVAR19 = VAR17;\nVAR15 [msg.sender] = VAR17;\nVAR18 = msg.sender;\nVAR5 = VAR20;\n}\nfunction FUN9 () constant returns (string) {\nreturn \"BCP\";\n}\nfunction FUN10 () constant returns (string) {\nreturn \"BCP\";\n}\nfunction FUN11 () constant returns (uint8) {\nreturn 6;\n}\nfunction FUN12 () constant returns (uint256 VAR21) {\nreturn VAR19;\n}\nfunction FUN5 (address VAR8, uint256 VAR9) returns (bool VAR10) {\nreturn CON3.FUN5 (VAR8, VAR9);\n}\nfunction FUN6 (address VAR12, address VAR8, uint256 VAR9)\nreturns (bool VAR10) {\nreturn CON3.FUN6 (VAR12, VAR8, VAR9);\n}\nfunction FUN13 () constant returns (uint256) {\nreturn FUN1(FUN3(VAR19, 5)/1e11, 25000);\n}\nfunction FUN14(uint256 VAR11) internal returns (bool) {\nuint256 VAR22 = VAR11/2;\nuint256 VAR23 = FUN2(VAR11, VAR22);\nVAR15 [VAR5] = FUN1 (VAR15 [VAR5], VAR23);\nVAR19 = FUN2 (VAR19, VAR22);\nreturn true;\n}\nfunction FUN7 (address VAR13, uint256 VAR24, uint256 VAR25)\nreturns (bool VAR10) {\nif (FUN8 (msg.sender, VAR13) == VAR24)\nreturn FUN7 (VAR13, VAR25);\nelse return false;\n}\nfunction FUN15 (uint256 VAR9) returns (bool VAR10) {\nif (VAR9 > VAR15 [msg.sender]) return false;\nelse if (VAR9 > 0) {\nVAR15 [msg.sender] = FUN2 (VAR15 [msg.sender], VAR9);\nVAR19 = FUN2 (VAR19, VAR9);\nreturn true;\n} else return true;\n}\nfunction FUN16 (address VAR26) {\nrequire (msg.sender == VAR18);\nVAR18 = VAR26;\n}\nfunction FUN17 (address VAR27) {\nrequire (msg.sender == VAR18);\nVAR5 = VAR27;\n}\n}",
        "label": false,
        "name": "0x1664e5b86af9bba5c125c21dfd0cae7e6a46a733.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2{\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1657f87c1bcfe3eed668dc3969d549350a5cefca.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender == VAR1) _;\n}\nfunction FUN2(uint VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) public FUN1 {\nCON1 VAR5 = CON1(VAR4);\nVAR5.FUN2(VAR2);\n}\n}",
        "label": false,
        "name": "0x1fac0ec15ce07d3f19613955c3a028e432f1a618.sol"
    },
    {
        "source": "contract CON1{\nmapping (address => uint256) public VAR1;\nmapping (address => uint256) public VAR2;\nmapping (address => uint256) public VAR3;\naddress VAR4 = 0xE22Dcbd53690764462522Bb09Af5fbE2F1ee4f2B;\naddress VAR5 = 0x8d07A25b37AA62898cb7B796cA710A8D2FAD98b4;\nfunction FUN1(address VAR6) public payable {\nrequire(msg.value >= 0.1 ether);\nif(getProfit(msg.sender) > 0){\nuint256 VAR7 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nuint256 VAR8 = msg.value;\nuint256 VAR9 = SafeMath.div(VAR8, 20);\nif(VAR6 != msg.sender && VAR6 != 0x1 && VAR6 != VAR4 && VAR6 != VAR5){\nVAR3[VAR6] = SafeMath.add(VAR3[VAR6], VAR9);\n}\nVAR3[VAR4] = SafeMath.add(VAR3[VAR4], VAR9);\nVAR3[VAR5] = SafeMath.add(VAR3[VAR5], VAR9);\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR8);\nVAR2[msg.sender] = now;\n}\nfunction FUN2() public {\nuint256 VAR7 = getProfit(msg.sender);\nVAR2[msg.sender] = now;\nuint256 VAR10 = VAR1[msg.sender];\nuint256 VAR11 = SafeMath.div(VAR10, 5);\nVAR10 = SafeMath.sub(VAR10, VAR11);\nuint256 VAR12 = SafeMath.add(VAR10, VAR7);\nrequire(VAR12 > 0);\nVAR1[msg.sender] = 0;\nmsg.sender.transfer(VAR12);\n}\nfunction FUN3() public{\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR7);\n}\nfunction FUN4() public {\nuint256 VAR7 = getProfit(msg.sender);\nrequire(VAR7 > 0);\nVAR2[msg.sender] = now;\nVAR1[msg.sender] = SafeMath.add(VAR1[msg.sender], VAR7);\n}\nfunction FUN5() public {\nrequire(VAR3[msg.sender] > 0);\nuint256 VAR9 = VAR3[msg.sender];\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR9);\n}\n}",
        "label": false,
        "name": "0xf4f52fe42631a43e3973283ce275959b6cbb103a.sol"
    },
    {
        "source": "contract CON1 {\nuint32 internal VAR1 = 1526896800;\nuint32 internal VAR2 = 1534672800;\nuint256 internal constant VAR3 = 1513072800; uint256 internal constant VAR4 = 1515751200; uint256 internal constant VAR5 = 1516442400; uint256 internal constant VAR6 = 1519120800;\nstruct AddressTokenAllocation {\naddress VAR7;\nuint256 VAR8;\nuint256 VAR9;\n}\nAddressTokenAllocation internal VAR10 = AddressTokenAllocation(0x43C5FB6b419E6dF1a021B9Ad205A18369c19F57F, 100e6, 0);\nAddressTokenAllocation internal VAR11 = AddressTokenAllocation(0x0635c57CD62dA489f05c3dC755bAF1B148FeEdb0, 550e6, 0);\nAddressTokenAllocation internal VAR12 = AddressTokenAllocation(0xae46bae68D0a884812bD20A241b6707F313Cb03a, 20e6, VAR2);\nAddressTokenAllocation internal VAR13 = AddressTokenAllocation(0xfe472389F3311e5ea19B4Cd2c9945b6D64732F13, 20e6, VAR2);\nAddressTokenAllocation internal VAR14 = AddressTokenAllocation(0xE37dfF409AF16B7358Fae98D2223459b17be0B0B, 20e6, VAR2);\nAddressTokenAllocation internal VAR15 = AddressTokenAllocation(0x39482f4cd374D0deDD68b93eB7F3fc29ae7105db, 10e6, VAR2);\nAddressTokenAllocation internal VAR16 = AddressTokenAllocation(0x03736d5B560fE0784b0F5c2D0eA76A7F15E5b99e, 5e6, VAR2);\nAddressTokenAllocation internal VAR17 = AddressTokenAllocation(0xD21726226c32570Ab88E12A9ac0fb2ed20BE88B9, 5e6, VAR2);\nAddressTokenAllocation internal VAR18 = AddressTokenAllocation(0xC66Cbb7Ba88F120E86920C0f85A97B2c68784755, 30e6, VAR1);\nAddressTokenAllocation internal VAR19 = AddressTokenAllocation(0x24ce108d1975f79B57c6790B9d4D91fC20DEaf2d, 6e6, 0);\nAddressTokenAllocation internal VAR20 = AddressTokenAllocation(0x0125c6Be773bd90C0747012f051b15692Cd6Df31, 5e6, 0);\nAddressTokenAllocation internal VAR21 = AddressTokenAllocation(0xFCF0589B6fa8A3f262C4B0350215f6f0ed2F630D, 5e6, 0);\nAddressTokenAllocation internal VAR22 = AddressTokenAllocation(0x0D016B233e305f889BC5E8A0fd6A5f99B07F8ece, 4e6, 0);\nAddressTokenAllocation internal VAR23 = AddressTokenAllocation(0x68433cFb33A7Fdbfa74Ea5ECad0Bc8b1D97d82E9, 19e6, 0);\nAddressTokenAllocation internal VAR24 = AddressTokenAllocation(0xd620A688adA6c7833F0edF48a45F3e39480149A6, 4e6, 0);\nAddressTokenAllocation internal VAR25 = AddressTokenAllocation(0x8C393F520f75ec0F3e14d87d67E95adE4E8b16B1, 100e6, 0);\nAddressTokenAllocation internal VAR26 = AddressTokenAllocation(0x6F842b971F0076C4eEA83b051523d76F098Ffa52, 96e6, 0);\nAddressTokenAllocation internal VAR27 = AddressTokenAllocation(0xcaA48d91D49f5363B2974bb4B2DBB36F0852cf83, 1e6, 0);\nuint256 public VAR28 = 3333;\n}\ncontract CON2 {\naddress public VAR29;\nfunction CON2() public {\nVAR29 = msg.VAR65;\n}\nmodifier FUN1() {\nrequire(msg.VAR65 == VAR29);\n_;\n}\nfunction FUN2(address VAR30) FUN1 public {\nrequire(VAR30 != address(0));\nrequire(VAR30 != VAR29);\nVAR29 = VAR30;\n}\n}\ncontract CON3 is CON2, CON1 {\nstring public VAR31 = 'Token 0.1';\nstring public VAR32 = 'Taklimakan';\nstring public VAR33 = 'TKLN';\nuint8 public VAR34 = 18;\nmapping (address => uint256) private VAR35; mapping (address => uint256) private VAR36; mapping (address => uint256) private VAR37; mapping (address => uint) private VAR38;\nmapping (address => mapping (address => uint256)) private VAR39;\nmapping (address => mapping (address => bool)) private VAR40;\nuint256 public VAR41 = 0;\nbool public VAR42 = true;\nfunction CON3() public {\nVAR29 = msg.VAR65;\nFUN12(VAR10);\nFUN12(VAR11);\nFUN12(VAR12);\nFUN12(VAR13);\nFUN12(VAR14);\nFUN12(VAR15);\nFUN12(VAR16);\nFUN12(VAR17);\nFUN12(VAR18);\nFUN12(VAR19);\nFUN12(VAR20);\nFUN12(VAR21);\nFUN12(VAR22);\nFUN12(VAR23);\nFUN12(VAR24);\nFUN12(VAR25);\nFUN12(VAR26);\nFUN12(VAR27);\n}\nmodifier FUN3 {\nrequire(VAR42);\n_;\n}\nmodifier FUN4(uint VAR43) {\nassert(msg.data.length >= VAR43 + 4);\n_;\n}\nfunction FUN5(address VAR44) external FUN1 {\nFUN7(VAR11, VAR44);\n}\nfunction FUN6(address VAR45) external FUN1 {\nFUN7(VAR10, VAR45);\n}\nfunction FUN7(AddressTokenAllocation VAR46, address VAR44) internal {\nuint VAR47 = VAR34;\nuint VAR48 = 10**VAR47;\nuint VAR8 = VAR46.VAR8 * VAR48;\nVAR39[VAR46.VAR7][VAR44] = VAR8;\n}\nfunction FUN8(address VAR49) public constant returns (uint256 VAR50) {\nreturn VAR35[VAR49];\n}\nfunction FUN9(address VAR49) public constant returns (uint256 VAR50) {\nreturn VAR35[VAR49] - VAR36[VAR49] - VAR37[VAR49];\n}\nfunction FUN10(address VAR51, address VAR52) public constant returns (uint256 VAR53) {\nreturn VAR39[VAR51][VAR52];\n}\nfunction FUN11(address VAR54, uint256 VAR55) public FUN3 FUN4(2*32) returns (bool VAR56) {\nFUN20(msg.VAR65);\nrequire(FUN9(msg.VAR65) >= VAR55);\nVAR35[msg.VAR65] -= VAR55;\nif (VAR38[msg.VAR65] > 0) {\nFUN19(msg.VAR65, VAR54, VAR38[msg.VAR65], VAR55);\n}\nVAR35[VAR54] += VAR55;\nreturn true;\n}\nfunction FUN12(AddressTokenAllocation VAR46) internal {\nVAR38[VAR46.VAR7] = VAR46.VAR9;\nuint VAR47 = VAR34;\nuint VAR48 = 10**VAR47;\nuint VAR57 = VAR46.VAR8 * VAR48;\nVAR35[VAR46.VAR7] += VAR57;\nVAR41 += VAR57;\n}\nfunction FUN13(address VAR52, uint256 VAR55) public FUN4(2*32) returns (bool VAR56) {\nrequire(VAR55 == 0 || VAR40[msg.VAR65][VAR52] == false);\nVAR39[msg.VAR65][VAR52] = VAR55;\nVAR40[msg.VAR65][VAR52] = false;\nreturn true;\n}\nfunction FUN13(address VAR52, uint256 VAR58, uint256 VAR55) public FUN4(3*32) returns (bool VAR56) {\nrequire(VAR39[msg.VAR65][VAR52] == VAR58);\nVAR39[msg.VAR65][VAR52] = VAR55;\nreturn true;\n}\nfunction FUN14(address VAR59, address VAR54, uint256 VAR55) public FUN3 FUN4(3*32) returns (bool VAR56) {\nFUN20(VAR59);\nrequire(FUN9(VAR59) >= VAR55);\nrequire(VAR55 <= VAR39[VAR59][msg.VAR65]);\nVAR35[VAR59] -= VAR55;\nVAR35[VAR54] += VAR55;\nVAR39[VAR59][msg.VAR65] -= VAR55;\nif (VAR38[VAR59] > 0) {\nFUN19(VAR59, VAR54, VAR38[VAR59], VAR55);\n}\nVAR40[VAR59][msg.VAR65] = true;\nreturn true;\n}\nfunction() public {\n}\nfunction FUN16(bool VAR60) external FUN1 {\nVAR42 = VAR60;\n}\nfunction FUN17() external FUN1 {\nuint VAR61 = VAR35[VAR10.VAR7];\nVAR41 -= VAR61;\nVAR35[VAR10.VAR7] = 0;\n}\nfunction FUN18() external FUN1 {\nuint VAR61 = VAR35[VAR11.VAR7];\nVAR41 -= VAR61;\nVAR35[VAR11.VAR7] = 0;\n}\nfunction FUN19(address VAR59, address VAR62, uint256 VAR63, uint256 VAR64) internal {\nif (CON1.VAR1 == VAR63) {\nVAR36[VAR62] += VAR64;\n} else if (CON1.VAR2 == VAR63) {\nVAR37[VAR62] += VAR64;\n}\n}\nfunction FUN20(address VAR65) internal {\nif (CON1.VAR1 < now) {\nVAR36[VAR65] = 0;\n}\nif (CON1.VAR2 < now) {\nVAR37[VAR65] = 0;\n}\n}\n}",
        "label": false,
        "name": "0x0675daa94725a528b05a3a88635c03ea964bfa7e.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2{\nbool private VAR3;\nconstructor () internal {\nVAR3 = false;\n}\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON4{\nusing SafeMath for uint256;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6 = 18;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nconstructor(uint256 VAR10,string memory VAR11,string memory VAR12) public {\nVAR7 = VAR10 * 10 ** uint256(VAR6); VAR8[msg.sender] = VAR7; VAR4 = VAR11; VAR5 = VAR12; }\nfunction FUN9(address VAR13, address VAR14, uint VAR15) internal {\nrequire(VAR14 != address(0x0));\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15);\nVAR8[VAR14] = VAR8[VAR14].add(VAR15);\n}\nfunction FUN10(address VAR14, uint256 VAR15) public returns (bool VAR16) {\nFUN9(msg.sender, VAR14, VAR15);\nreturn true;\n}\nfunction FUN11(address VAR13, address VAR14, uint256 VAR15) public returns (bool VAR16) {\nVAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR15);\nFUN9(VAR13, VAR14, VAR15);\nreturn true;\n}\nfunction FUN12(address VAR17, uint256 VAR15) public\nreturns (bool VAR16) {\nVAR9[msg.sender][VAR17] = VAR15;\nreturn true;\n}\nfunction FUN13(address VAR17, uint256 VAR15, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON1 VAR19 = CON1(VAR17);\nif (FUN12(VAR17, VAR15)) {\nVAR19.receiveApproval(msg.sender, VAR15, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN14(uint256 VAR15) public returns (bool VAR16) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR15); VAR7 = VAR7.sub(VAR15);\nreturn true;\n}\nfunction FUN15(address VAR13, uint256 VAR15) public returns (bool VAR16) {\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15); VAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR15); VAR7 = VAR7.sub(VAR15);\nreturn true;\n}\n}\ncontract CON5 is CON4, CON2,CON3{\nmapping (address => bool) public VAR20;\nmapping(address => uint256) public VAR21;\nconstructor() CON4(21000000,\"AaronTestCoin\",\"ATC\") public {\n}\nfunction FUN16(address VAR22) FUN1 public {\nVAR20[VAR22] = true;\n}\nfunction FUN17(address VAR22) FUN1 public{\nVAR20[VAR22] = false;\n}\nfunction FUN18(address VAR22, uint256 VAR23) FUN1 public{\nrequire(VAR23 > now);\nVAR21[VAR22] = VAR23;\n}\nfunction FUN19(address VAR22) FUN1 public{\nVAR21[VAR22] = 0;\n}\nfunction FUN20(string memory VAR24) public FUN1 {\nVAR4 = VAR24;\n}\nfunction FUN21(string memory VAR25) public FUN1{\nVAR5 = VAR25;\n}\nfunction FUN9(address VAR13, address VAR14, uint VAR15) internal FUN5 {\nrequire(VAR14 != address(0x0));\nrequire(!VAR20[VAR13]);\nrequire(!VAR20[VAR14]);\nrequire(!isAccountLocked(VAR13));\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15);\nVAR8[VAR14] = VAR8[VAR14].add(VAR15);\n}\n}",
        "label": false,
        "name": "0x4ad8d58919732154af6dd7f11bfd402e76b8b6b6.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 12;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(12); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6e5a43db10b04701385a34afb670e404bc7ea597.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x0f6007fea958b4986ab3c1b51b91882544b96d12.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nstring public VAR6; uint8 public VAR7; string public VAR8;\nfunction CON4() public {\nVAR7 = 18;\nVAR2 = 10000000000 * 10 ** uint(VAR7);\nVAR1[msg.sender] = VAR2;\nVAR6 = \"My Wish Chain\";\nVAR8 = \"Wish\";\n}\nfunction FUN2(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR5[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR9][msg.sender] = VAR5[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR10, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR4;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x741a9f61a25eb40f1372cede2b5d180fb894a830.sol"
    },
    {
        "source": "contract CON1 {\nenum Direction {NotApplicable, Forwards, Backwards, Invalid}\n}\ncontract CON2 is CON1 {\nstruct Entity {\nbool VAR1;\naddress VAR2;\naddress VAR3;\nbytes32 VAR4; mapping (address => mapping (bytes32 => Connection)) VAR5;\n}\nstruct Connection {\nbool VAR1;\nbytes32 VAR4; Direction VAR6;\nuint VAR7; }\nmapping (address => Entity) public VAR8;\nmapping (address => address) public VAR9;\nuint256 public VAR10 = 0;\nfunction CON2() public {}\nfunction () external {\nrevert();\n}\nfunction FUN2() external returns (address VAR11) {\nVAR11 = msg.sender;\nassert(VAR9[msg.sender] == address(0));\nFUN12(VAR11, msg.sender);\nVAR9[msg.sender] = VAR11;\n}\nfunction FUN3(address VAR12,bytes32 VAR13,Direction VAR14)\nexternal returns (address VAR11)\n{\nVAR11 = msg.sender;\nassert(VAR9[msg.sender] == address(0));\nFUN12(VAR11, msg.sender);\nVAR9[msg.sender] = VAR11;\nFUN11(VAR11, VAR12, VAR13, VAR14);\n}\nfunction FUN4() external returns (address VAR11) {\nVAR11 = FUN13();\nFUN12(VAR11, msg.sender);\n}\nfunction FUN5(address VAR12,bytes32 VAR13,Direction VAR14)\nexternal returns (address VAR11)\n{\nVAR11 = FUN13();\nFUN12(VAR11, msg.sender);\nFUN11(VAR11, VAR12, VAR13, VAR14);\n}\nfunction FUN6(address VAR15, bool VAR16, bytes32 VAR17) external {\naddress VAR18 = FUN15(VAR15);\nEntity storage VAR19 = VAR8[VAR18];\nVAR19.VAR1 = VAR16;\nVAR19.VAR4 = VAR17;\n}\nfunction FUN7(address VAR15, address VAR20) external {\naddress VAR18 = FUN15(VAR15);\nVAR8[VAR18].VAR2 = VAR20;\n}\nfunction FUN8(address VAR15) external {\naddress VAR18 = resolveEntityAddress(VAR15);\nFUN14(VAR15, VAR18);\nEntity storage VAR19 = VAR8[VAR18];\nrequire(VAR19.VAR2 == msg.sender);\nif (isUser(VAR18)) { assert(VAR9[msg.sender] == address(0) ||VAR9[msg.sender] == VAR18);\nVAR9[msg.sender] = VAR18;\n}\naddress VAR21 = VAR19.VAR3;\nVAR19.VAR3 = VAR19.VAR2;\nVAR19.VAR2 = address(0);\n}\nfunction FUN9(address VAR15,address VAR12,bytes32 VAR13,Direction VAR14,bool VAR16,bytes32 VAR17,uint VAR22)\nexternal\n{\naddress VAR18 = FUN15(VAR15);\naddress VAR23 = resolveEntityAddress(VAR12);\nFUN14(VAR12, VAR23);\nEntity storage VAR19 = VAR8[VAR18];\nConnection storage VAR24 = VAR19.VAR5[VAR23][VAR13];\nVAR24.VAR1 = VAR16;\nVAR24.VAR6 = VAR14;\nVAR24.VAR4 = VAR17;\nVAR24.VAR7 = VAR22;\n}\nfunction FUN10(address VAR15, address VAR12, bytes32 VAR13) external {\naddress VAR18 = FUN15(VAR15);\naddress VAR23 = resolveEntityAddress(VAR12);\nFUN14(VAR12,VAR23);\nEntity storage VAR19 = VAR8[VAR18];\ndelete VAR19.VAR5[VAR23][VAR13];\n}\nfunction FUN11(address VAR15,address VAR12,bytes32 VAR13,Direction VAR14)\npublic\n{\naddress VAR18 = FUN15(VAR15);\naddress VAR25 = resolveEntityAddress(VAR12);\nFUN14(VAR12, VAR25);\nEntity storage VAR19 = VAR8[VAR18];\nassert(!VAR19.VAR5[VAR25][VAR13].VAR1);\nConnection storage VAR24 = VAR19.VAR5[VAR25][VAR13];\nVAR24.VAR1 = true;\nVAR24.VAR6 = VAR14;\n}\nfunction FUN12(address VAR26, address VAR27) internal {\nrequire(!VAR8[VAR26].VAR1); Entity storage VAR19 = VAR8[VAR26];\nVAR19.VAR1 = true;\nVAR19.VAR3 = VAR27;\n}\nfunction FUN13() internal returns (address VAR28) {\nVAR28 = address(keccak256(safeAdd(VAR10,block.number)));\nVAR10 = safeAdd(VAR10,1);\n}\nfunction FUN14(address VAR15, address VAR29) internal {\nif (VAR15 != VAR29)\n}\nfunction FUN15(address VAR26) internal returns (address VAR11) {\nVAR11 = resolveEntityAddress(VAR26);\nFUN14(VAR26, VAR11);\nrequire(VAR8[VAR11].VAR3 == msg.sender);\n}\n}",
        "label": false,
        "name": "0x75d884981d814d676b4b6930038ee9887129b639.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nstring private VAR3 = \"Bitcharge Coin\";\nstring private VAR4 = \"BCC\";\nuint8 private VAR5 = 18;\nuint256 private VAR6 = 3000000000 ether;\nconstructor () public {\nVAR1[msg.sender] = VAR6;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR8);\nFUN6(VAR10, VAR7, VAR8);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR11) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR2[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR12) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR2[msg.sender][VAR9].sub(VAR12);\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0));\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\n}\n}",
        "label": false,
        "name": "0xf3db7146fac029cc363ffd20cd16449ee382445e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON4 is CON2, CON1 {\n}\ncontract CON5 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nfunction FUN3(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 > 0);\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR6;\nfunction FUN4(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 > 0);\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[VAR7]);\nrequire(VAR5 <= VAR6[VAR7][msg.sender]);\nVAR3[VAR7] = VAR3[VAR7].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN5(address VAR8, uint256 VAR5) public returns (bool) {\nrequire(VAR5 > 0);\nVAR6[msg.sender][VAR8] = VAR5;\nreturn true;\n}\nfunction FUN6(address VAR8, uint VAR9) public returns (bool) {\nrequire(VAR9 > 0);\nVAR6[msg.sender][VAR8] = VAR6[msg.sender][VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN7(address VAR8, uint VAR10) public returns (bool) {\nrequire(VAR10 > 0);\nuint VAR11 = VAR6[msg.sender][VAR8];\nif (VAR10 > VAR11) {\nVAR6[msg.sender][VAR8] = 0;\n} else {\nVAR6[msg.sender][VAR8] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON7 is CON3 {\nbool public VAR12 = false;\nmodifier FUN8() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN9() {\nrequire(VAR12);\n_;\n}\nfunction FUN10() FUN1 FUN8 public {\nVAR12 = true;\n}\nfunction FUN11() FUN1 FUN9 public {\nVAR12 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR4,uint256 VAR5)\npublic\nFUN8\nreturns (bool)\n{\nreturn super.FUN3(VAR4, VAR5);\n}\nfunction FUN4(address VAR7,address VAR4,uint256 VAR5)\npublic\nFUN8\nreturns (bool)\n{\nreturn super.FUN4(VAR7, VAR4, VAR5);\n}\nfunction FUN5(address VAR8,uint256 VAR5)\npublic\nFUN8\nreturns (bool)\n{\nreturn super.FUN5(VAR8, VAR5);\n}\nfunction FUN6(address VAR8,uint VAR9)\npublic\nFUN8\nreturns (bool VAR13)\n{\nreturn super.FUN6(VAR8, VAR9);\n}\nfunction FUN7(address VAR8,uint VAR10)\npublic\nFUN8\nreturns (bool VAR13)\n{\nreturn super.FUN7(VAR8, VAR10);\n}\n}\ncontract CON9 is CON8 {\nstring public constant VAR14 = \"Sustainy Keys\";\nstring public constant VAR15 = \"SKEYS\";\nuint256 public VAR16;\nuint256 public constant VAR17 = 21000000;\nconstructor(address VAR18) public {\nVAR16 = VAR17;\nVAR3[VAR18] = VAR17;\n}\n}",
        "label": false,
        "name": "0xe70553c0833f6564f552f04d86925877be3ba29b.sol"
    },
    {
        "source": "contract CON1 {\nbool private VAR1;\nbool private VAR2;\nmodifier FUN1() {\nrequire(VAR2 || isConstructor() || !VAR1, \"Contract instance has already been initialized\");\nbool VAR3 = !VAR2;\nif (VAR3) {\nVAR2 = true;\nVAR1 = true;\n}\n_;\nif (VAR3) {\nVAR2 = false;\n}\n}\nuint256[50] private VAR4;\n}\ncontract CON2 is CON1 {\naddress private VAR5;\nfunction FUN2(address VAR6) public FUN1 {\nVAR5 = VAR6;\n}\nmodifier FUN3() {\nrequire(isOwner());\n_;\n}\nfunction FUN4() public FUN3 {\nVAR5 = address(0);\n}\nfunction FUN5(address VAR7) public FUN3 {\nFUN6(VAR7);\n}\nfunction FUN6(address VAR7) internal {\nrequire(VAR7 != address(0));\nVAR5 = VAR7;\n}\nuint256[50] private VAR4;\n}\ncontract CON3 {\n}\ncontract CON4 {\nCON3 public VAR8;\nuint256 public VAR9;\nstruct Data {\nstring VAR10;\nstring VAR11;\n}\nmapping (string => address) VAR12;\nmapping (address => Data) public VAR13;\nmapping (address => bool) public VAR14;\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN2(CON3 VAR15,address VAR5)\npublic FUN1\n{\nVAR8 = VAR15;\nVAR9 = 100000000000000000000;\nVAR14[VAR5] = true;\nCON2.FUN2(VAR5);\n}\nmodifier FUN7() {\nrequire(VAR14[msg.VAR6] == true,\"The VAR6 is not VAR14 to register a username\");\n_;\n}\nfunction FUN8(address VAR16, bool VAR17) external FUN3 {\nrequire(VAR16 != msg.VAR6, \"You can not manage your role\");\nVAR14[VAR16] = VAR17;\n}\nfunction FUN9(address VAR18,string memory VAR19,string memory VAR20)\ninternal\n{\n_requireBalance(VAR18);\n_requireUsernameValid(VAR19);\nrequire(isUsernameAvailable(VAR19), \"The VAR10 was already taken\");\nVAR8.transferFrom(VAR18, address(this), VAR9);\nVAR8.burn(VAR9);\nVAR12[VAR19] = VAR18;\nData storage VAR21 = VAR13[VAR18];\ndelete VAR12[VAR21.VAR10];\nVAR21.VAR10 = VAR19;\nbytes memory VAR11 = bytes(VAR20);\nif (VAR11.length > 0) {\nVAR21.VAR11 = VAR20;\n}\n}\nfunction FUN10(address VAR18,string calldata VAR19,string calldata VAR20)\nexternal\nFUN7\n{\nFUN9(VAR18, VAR19, VAR20);\n}\nfunction FUN11(string calldata VAR20) external {\nrequire(userExists(msg.VAR6), \"The VAR13 does not exist\");\nVAR13[msg.VAR6].VAR11 = VAR20;\n}\n}",
        "label": false,
        "name": "0x894b883905bfee2cc448880f1b59f4a762e67566.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR3 = VAR3.add(VAR14);\nVAR4[VAR5] = VAR4[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON1 {\nbool public VAR15 = false;\nmodifier FUN11() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN12() {\nrequire(VAR15);\n_;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR15 = true;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR15 = false;\n}\n}\ncontract CON8 is CON5, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN11 returns (bool VAR16) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN11 returns (bool VAR16) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON9 is CON8, CON6 {\nstring public constant VAR17 = \"BITCOIN FUTURE FROM DESK DELTA ONE\";\nstring public constant VAR18 = \"BTC\";\nuint8 public constant VAR19 = 18;\n}\n// JEROME STRIKES BACK MOTHERFUCKERS",
        "label": false,
        "name": "0x7bf6bf4041e0dfec8cdbe56a087804e5ed6d2f9e.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ninterface CON3 {\n}\ncontract CON4 is CON2 {\nmapping (address => TokenState) internal VAR1;\nCON3 public VAR2;\naddress internal VAR3;\nenum TokenState {UNKNOWN, SHIT, FAKE}\nconstructor() public {\nVAR3 = msg.sender;\n}\nfunction FUN1(CON1 VAR4) external {\nVAR2.test(address(VAR4));\n}\nfunction FUN2(CON3 VAR5) external {\nrequire(msg.sender == VAR3);\nVAR2 = VAR5;\n}\nfunction FUN3(CON1 VAR4, bool VAR6) external {\nrequire(msg.sender == address(VAR2));\nTokenState VAR7 = VAR6 ? TokenState.SHIT : TokenState.FAKE;\nVAR1[address(VAR4)] = VAR7;\n}\n}",
        "label": false,
        "name": "0xc7c06ac46f2b66e00960944882f9c35eec54bba0.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR1;\nmapping (address => mapping (address => uint256)) internal VAR2;\nuint256 internal VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring private VAR11;\nstring private VAR12;\nuint8 internal VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 {\naddress private VAR17;\nconstructor () internal {\nVAR17 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR17 = address(0);\n}\nfunction FUN12(address VAR18) public FUN10 {\nFUN13(VAR18);\n}\nfunction FUN13(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON5 is CON4, CON1 {\nCON1 internal VAR19;\naddress internal VAR20;\nfunction FUN14 (address VAR6, uint256 VAR5)\nexternal FUN10 returns (bool VAR21) {\nVAR19.FUN2(VAR6, VAR5);\nVAR21 = true;\n}\nfunction FUN15 (address VAR7, address VAR4, uint256 VAR5) external FUN10 returns (bool) {\nreturn FUN17(VAR7, VAR4, VAR5);\n}\nfunction FUN16 (address VAR22)\nexternal FUN10 returns (bool VAR21) {\nVAR20 = VAR22;\nVAR19 = CON1(VAR20);\nVAR21 = true;\n}\nfunction FUN17 (address VAR7, address VAR4, uint256 VAR5) internal returns (bool) {\nreturn VAR19.FUN3(VAR7, VAR4, VAR5);\n}\n}\ncontract CON6 is CON3, CON5 {\nuint256 private VAR23 = 100000000000 * 10**uint(18);\nuint256 internal VAR24 = 100000000 * 10**uint(18);\nuint256 internal VAR25 = 500000000 * 10**uint(18);\nuint internal VAR26 = 60 * 60 * 24;\nuint internal VAR27 = VAR26 * 182;\nuint internal VAR28 = VAR26 * 365;\nuint internal VAR29 = 1000;\nuint internal VAR30 = VAR28 + VAR27;\nuint256 internal VAR31 = 2;\nuint256 internal VAR32 = 7;\nuint256 internal VAR33 = 13;\nuint256 private VAR34 = 50;\naddress internal VAR35;\nfunction FUN18() external returns (bool) {\nuint256 VAR36 = VAR47[msg.sender].VAR40;\nrequire(VAR36 > 0, \"You have not staked any tokens.\");\nVAR47[msg.sender].VAR40 = 0;\nVAR47[msg.sender].VAR41 = block.timestamp;\nFUN17(address(this), msg.sender, VAR36);\nreturn true;\n}\nfunction FUN19() external returns (bool) {\nuint256 VAR36 = VAR47[msg.sender].VAR40;\nrequire(VAR36 > 0, \"You have not staked any tokens.\");\nrequire(_holdAgeTimestamp(msg.sender) >= VAR47[msg.sender].VAR45,\"You need VAR4 stake for the minimum time of 1000 seconds.\");\nuint256 VAR37 = tridentReward(msg.sender);\nrequire(VAR37 > 0, \"Your reward is currently zero. Nothing VAR4 collect.\");\nVAR47[msg.sender].VAR40 = 0;\nVAR47[msg.sender].VAR41 = block.timestamp;\nVAR47[msg.sender].VAR42 = 0;\nVAR47[msg.sender].VAR43 = 0;\nVAR47[msg.sender].VAR44 = 0;\nVAR47[msg.sender].VAR45 = VAR26;\nVAR47[msg.sender].VAR46 = VAR28 + VAR27;\nFUN17(address(this), msg.sender, VAR36);\nuint256 VAR38 = VAR37.mul(VAR34).div(100);\nFUN7(VAR35, VAR38);\nFUN7(msg.sender, VAR37);\nreturn true;\n}\nfunction FUN20 (address VAR39) external FUN10 {\nVAR35 = VAR39;\n}\nstruct TransferInStake {\nuint256 VAR40;\nuint256 VAR41;\nuint256 VAR42;\nuint256 VAR43;\nuint256 VAR44;\nuint VAR45;\nuint VAR46;\n}\nmapping(address => TransferInStake) internal VAR47;\nmodifier FUN21() {\nrequire(VAR3 < VAR23,\"This operation would take the total supply over the maximum supply.\");\n_;\n}\nfunction FUN22(uint256 VAR45,uint256 VAR46,uint256 VAR48,uint256 VAR49,uint256 VAR50,uint256 VAR42,uint256 VAR43,uint256 VAR44,uint256 VAR51)\nexternal FUN10 returns (bool VAR21) {\nVAR24 = VAR48 * 10**uint(18);\nVAR25 = VAR49 * 10**uint(18);\nVAR29 = VAR45;\nVAR30 = VAR46;\nVAR31 = VAR42;\nVAR32 = VAR43;\nVAR33 = VAR44;\nVAR34 = VAR50;\nVAR23 = VAR51 * 10**uint(18);\nVAR21 = true;\n}\n}\ncontract CON7 is CON2 {\nfunction FUN23(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN24(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON8 is CON6, CON7 {\nuint8 private constant VAR52 = 18;\nuint256 private constant VAR53 = 0;\naddress private VAR54 = address(this);\nconstructor (string memory VAR14, string memory VAR15, address VAR22, address VAR39)\npublic CON3(VAR14, VAR15, VAR52) {\nVAR20 = VAR22;\nVAR19 = CON1(VAR20);\nVAR13 = VAR52;\nVAR35 = VAR39;\nFUN7(msg.sender, VAR53);\n}\nfunction() external payable {\nrevert();\n}\nfunction FUN26() external FUN10 {\nif (msg.sender == owner()) selfdestruct(msg.sender);\n}\nfunction FUN27 () external FUN21 returns (string memory VAR55) {\nuint256 VAR56 = VAR19.allowance(msg.sender, VAR54);\nrequire(VAR56 > 0, \"No allowance has been set.\");\nrequire(VAR56 <= VAR25, \"The allowance has been set too high.\");\nuint256 VAR57 = VAR19.balanceOf(msg.sender);\nrequire(VAR57 >= VAR56);\nrequire(VAR47[msg.sender].VAR40 == 0,\"You are already staking. Cancel your stake (sacrificing reward), or collect your reward and send again.\");\nrequire(VAR57 >= VAR56,\"The sending VAR10 balance is lower than the requested VAR5.\");\nrequire(VAR56 >= VAR24,\"There is a minimum stake amount set.\");\nuint256 VAR58 = VAR19.balanceOf(VAR54);\nFUN17(msg.sender, VAR54, VAR56);\nVAR47[msg.sender].VAR40 = VAR56;\nVAR47[msg.sender].VAR41 = block.timestamp;\nVAR47[msg.sender].VAR42 = VAR31;\nVAR47[msg.sender].VAR43 = VAR32;\nVAR47[msg.sender].VAR44 = VAR33;\nVAR47[msg.sender].VAR45 = VAR29;\nVAR47[msg.sender].VAR46 = VAR30;\nVAR19.FUN2(VAR54, VAR58.add(VAR56));\nreturn \"Vault deposit complete, thank you.\";\n}\n}",
        "label": false,
        "name": "0x9ecc1e438655e1dd724283f9bd3ded379cb6ca37.sol"
    },
    {
        "source": "contract CON1{\nbool public VAR1 = true;\nuint public VAR2;\nuint public VAR3;\nuint public VAR4 = 50000000000000000; address public VAR5 = msg.sender;\naddress public VAR6;\nfunction FUN1() {\nVAR6 = msg.sender;\n}\nfunction FUN2(){\nif(VAR6 != msg.sender)\nthrow;\nVAR3 += 1;\nif(VAR2 - VAR3 < 1)\nVAR1=true;\n}\nfunction FUN3(uint VAR7){\nif (!VAR5.send(VAR7))\nthrow;\n}\nfunction () {\nVAR2 += (msg.value / VAR4);\nif(VAR2 - VAR3 < 1){\nVAR1=true;\n} else {\nVAR1=false;\n}\n}\n}",
        "label": false,
        "name": "0x0c7b8eedd028f3730e7b0f3dc032e916302f09b4.sol"
    },
    {
        "source": "{\"Phase.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\n    // Phaselabs ERC20+ contract.\\r\\n\\r\\ncontract Phase {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    address private Phaselabs;\\r\\n    string public symbol;\\r\\n    string public  name;\\r\\n    uint public decimals;\\r\\n    uint _totalSupply;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    \\r\\n    constructor() public {\\r\\n        symbol = \\\"psx\\\";\\r\\n        name = \\\"PHASE\\\";\\r\\n        decimals = 18;\\r\\n        Phaselabs = msg.sender;\\r\\n        _totalSupply = 1000000000 * 10**uint(decimals);\\r\\n        _balances[Phaselabs] = _totalSupply;\\r\\n        emit Transfer(address(0), Phaselabs, _totalSupply);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // Returns total token supply.    \\r\\n\\r\\n    function totalSupply() public view returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Returns the balance of the specified address.\\r\\n\\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        return _balances[owner];\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Returns the amount of tokens that an owner allowed to a spender.\\r\\n\\r\\n    function allowance(address owner, address spender) public view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Increase the amount of tokens that an owner allowed to a spender.\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Decrease the amount of tokens that an owner allowed to a spender.\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Transfer token function.\\r\\n\\r\\n    function transfer(address to, uint256 value) public returns (bool) {\\r\\n        _transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Allow someone to spend some tokens in your behalf.\\r\\n\\r\\n    function approve(address spender, uint256 value) public returns (bool) {\\r\\n        require(msg.sender != spender);\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Function for attempts to send tokens that are approved from an owner to a spender.\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\r\\n        _transfer(from, to, value);\\r\\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Contract will accept ether.\\r\\n    \\r\\n    function () external payable {\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Withdraw ether.\\r\\n    \\r\\n    function WithdrawEther(uint256 amount) public{\\r\\n\\t\\trequire(msg.sender == Phaselabs);\\r\\n\\t\\tmsg.sender.transfer(amount);\\r\\n\\t}\\r\\n\\t\\r\\n\\r\\n    // Safety checks for token transfer.\\t\\r\\n\\t\\r\\n    function _transfer(address from, address to, uint256 value) internal {\\r\\n        require(from != address(0));\\r\\n        require(to != address(0));\\r\\n        require(to != address(this));\\r\\n        require(value != 0);\\r\\n        _balances[to] = _balances[to].add(value);\\r\\n        _balances[from] = _balances[from].sub(value);\\r\\n        emit Transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    // Safety checks for the approve function.\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        require(owner != address(0));\\r\\n        require(spender != address(0));\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\"}}",
        "label": false,
        "name": "0xc30affb2fdaf999bdd7ea205875b3fcad3da8d51.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON1 {\nbytes4 private constant VAR1 = 0x01ffc9a7;\nmapping(bytes4 => bool) private VAR2;\nconstructor () internal {\nFUN1(VAR1);\n}\nfunction FUN1(bytes4 VAR3) internal {\nrequire(VAR3 != 0xffffffff);\nVAR2[VAR3] = true;\n}\n}\ncontract CON5 is CON4, CON2 {\nusing SafeMath for uint256;\nusing Address for address;\nbytes4 private constant VAR4 = 0x150b7a02;\nmapping (uint256 => address) private VAR5;\nmapping (uint256 => address) private VAR6;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => bool)) private VAR8;\nbytes4 private constant VAR9 = 0x80ac58cd;\nconstructor () public {\nFUN1(VAR9);\n}\nfunction FUN2(address VAR10, uint256 VAR11) public {\naddress VAR12 = ownerOf(VAR11);\nrequire(VAR10 != VAR12);\nrequire(msg.sender == VAR12 || isApprovedForAll(VAR12, msg.sender));\nVAR6[VAR11] = VAR10;\n}\nfunction FUN3(address VAR10, bool VAR13) public {\nrequire(VAR10 != msg.sender);\nVAR8[msg.sender][VAR10] = VAR13;\n}\nfunction FUN4(address VAR14, address VAR10, uint256 VAR11) public {\nrequire(_isApprovedOrOwner(msg.sender, VAR11));\nFUN8(VAR14, VAR10, VAR11);\n}\nfunction FUN5(address VAR14, address VAR10, uint256 VAR11) public {\nFUN5(VAR14, VAR10, VAR11, \"\");\n}\nfunction FUN5(address VAR14, address VAR10, uint256 VAR11, bytes memory VAR15) public {\nFUN4(VAR14, VAR10, VAR11);\nrequire(FUN9(VAR14, VAR10, VAR11, VAR15));\n}\nfunction FUN6(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nrequire(!_exists(VAR11));\nVAR5[VAR11] = VAR10;\nVAR7[VAR10] = VAR7[VAR10].add(1);\n}\nfunction FUN7(address VAR12, uint256 VAR11) internal {\nrequire(ownerOf(VAR11) == VAR12);\nFUN10(VAR11);\nVAR7[VAR12] = VAR7[VAR12].sub(1);\nVAR5[VAR11] = address(0);\n}\nfunction FUN7(uint256 VAR11) internal {\nFUN7(ownerOf(VAR11), VAR11);\n}\nfunction FUN8(address VAR14, address VAR10, uint256 VAR11) internal {\nrequire(ownerOf(VAR11) == VAR14);\nrequire(VAR10 != address(0));\nFUN10(VAR11);\nVAR7[VAR14] = VAR7[VAR14].sub(1);\nVAR7[VAR10] = VAR7[VAR10].add(1);\nVAR5[VAR11] = VAR10;\n}\nfunction FUN9(address VAR14, address VAR10, uint256 VAR11, bytes memory VAR15)\ninternal returns (bool)\n{\nif (!VAR10.isContract()) {\nreturn true;\n}\nbytes4 VAR16 = CON3(VAR10).onERC721Received(msg.sender, VAR14, VAR11, VAR15);\nreturn (VAR16 == VAR4);\n}\nfunction FUN10(uint256 VAR11) private {\nif (VAR6[VAR11] != address(0)) {\nVAR6[VAR11] = address(0);\n}\n}\n}\ncontract CON6 is CON2 {\n}\ncontract CON7 is CON4, CON5, CON6 {\nstring private VAR17;\nstring private VAR18;\nmapping(uint256 => string) private VAR19;\nstring VAR20;\nbytes4 private constant VAR21 = 0x5b5e139f;\nconstructor (string memory VAR22, string memory VAR23) public {\nVAR17 = VAR22;\nVAR18 = VAR23;\nFUN1(VAR21);\n}\nfunction FUN11(uint256 VAR11, string memory VAR24) internal {\nVAR20 = VAR24;\n}\nfunction FUN7(address VAR12, uint256 VAR11) internal {\nsuper.FUN7(VAR12, VAR11);\nif (bytes(VAR19[VAR11]).length != 0) {\ndelete VAR19[VAR11];\n}\n}\n}\ncontract CON8 {\naddress private VAR25;\nconstructor () internal {\nVAR25 = msg.sender;\n}\nmodifier FUN12() {\nrequire(isOwner());\n_;\n}\nfunction FUN13() public FUN12 {\nVAR25 = address(0);\n}\nfunction FUN14(address VAR26) public FUN12 {\nFUN15(VAR26);\n}\nfunction FUN15(address VAR26) internal {\nrequire(VAR26 != address(0));\nVAR25 = VAR26;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN16(address VAR10, uint256 VAR11, string memory VAR27) public FUN12 returns (bool) {\nFUN6(VAR10, VAR11);\nreturn true;\n}\n}\ncontract CON10 is CON5, CON8 {\nfunction FUN17(uint256 VAR11) public FUN12 {\nFUN7(VAR11);\n}\n}\ncontract CON11 is CON5, CON7, CON8, CON9, CON10 {\nconstructor() CON7(\"C-SCORE\", \"\") public\n{\nFUN11(0, \"https: }\n}",
        "label": false,
        "name": "0xdb52872d1ba9218b32243de5a0c381d97984f4d3.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring constant public VAR1 = \"ERC20\";\nstring constant public VAR2 = \"Moneda Token\";\nstring constant public VAR3 = \"MND\";\nuint8 constant public VAR4 = 18;\nuint256 private VAR5 = 400000000e18; uint256 constant public VAR6 = 20000000e18; uint256 constant public VAR7 = 250000000e18; uint256 constant public VAR8 = 80000000e18; uint256 constant public VAR9 = 40000000e18; uint256 constant public VAR10 = 10000000e18;\nuint256 public VAR11 = 1525132799; uint256 public VAR12 = 1526342400; uint256 public VAR13 = 1531699199;\nuint256 constant public VAR14 = 1532822400; uint256 constant public VAR15 = 1563148800;\naddress public VAR16;\naddress public VAR17;\naddress public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => mapping (address => uint256)) internal VAR21;\nfunction CON1(address VAR22, address VAR23, address VAR24) public {\nVAR16 = VAR22;\nVAR17 = VAR23;\nVAR18 = VAR24;\nVAR20[VAR16] = VAR5; }\nfunction FUN1(address VAR25, uint256 VAR26) public returns (bool) {\nrequire(now >= VAR14); require(VAR26 > 0);\nif (msg.sender == VAR16 || msg.sender == VAR17)\nrequire(now >= VAR15);\nVAR20[msg.sender] = VAR20[msg.sender].sub(VAR26);\nVAR20[VAR25] = VAR20[VAR25].add(VAR26);\nreturn true;\n}\nfunction FUN2(address VAR27, address VAR25, uint256 VAR26) public returns (bool) {\nrequire(VAR26 > 0);\nrequire(VAR25 != address(0));\nrequire(VAR26 <= VAR20[VAR27]);\nrequire(VAR26 <= VAR21[VAR27][msg.sender]);\nif (now < VAR13) require(VAR27 == VAR16);\nif (msg.sender == VAR16 || msg.sender == VAR17)\nrequire(now >= VAR15);\nVAR20[VAR27] = VAR20[VAR27].sub(VAR26);\nVAR20[VAR25] = VAR20[VAR25].add(VAR26);\nVAR21[VAR27][msg.sender] = VAR21[VAR27][msg.sender].sub(VAR26);\nreturn true;\n}\nfunction FUN3(address VAR28, uint256 VAR26) public returns (bool) {\nrequire((VAR26 == 0) || (VAR21[msg.sender][VAR28] == 0));\nVAR21[msg.sender][VAR28] = VAR26;\nreturn true;\n}\nfunction FUN4() public {\nrequire(!VAR19 && now > VAR13);\nuint256 VAR29 = VAR9.add(VAR8);\nuint256 VAR30 = VAR20[VAR16].sub(VAR29);\nVAR20[VAR16] = VAR9;\nVAR20[VAR17] = VAR8;\nVAR20[VAR18] = VAR10;\nVAR5 = VAR5.sub(VAR30);\nVAR19 = true;\n}\n}",
        "label": false,
        "name": "0x7c6f0f0bb581e479f72c31abb6a89013cbba5b7a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmodifier FUN1() { if (msg.sender != VAR1) return; _; }\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR2) FUN1 public {\naddress VAR3 = VAR1;\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR4;\n}\ncontract CON3 is CON1 {\nuint256 constant public VAR5 = 880000000 ether;\nuint256 constant public VAR6 = 1533081600; uint256 constant public VAR7 = 30 days;\nuint256 constant public VAR8 = 176000000 ether;\nuint256 public VAR9 = 0;\nbool public VAR10 = false;\nCON2 constant public VAR11 = CON2(0xAAD54C9f27B876D2538455DdA69207279fF673a5);\nfunction CON3() public {\n}\nfunction FUN3() FUN1 public {\nVAR10 = true;\nrequire(VAR11.transferFrom(VAR1, this, VAR5));\n}\nfunction FUN4() FUN1 public {\nrequire(VAR10);\nrequire(now > VAR6);\nuint256 VAR12 = (now - VAR6) / VAR7 + 1;\nrequire(VAR12 > VAR9);\nuint256 VAR13 = (VAR12 - VAR9) * VAR8;\nVAR9 = VAR12;\nuint256 VAR14 = VAR11.balanceOf(this);\nuint256 VAR15 = VAR13 > VAR14 ? VAR14 : VAR13;\nrequire(VAR11.transfer(VAR1, VAR15));\n}\n}",
        "label": false,
        "name": "0xdcc982c9ead246c52dc073bc545e259f243e27f7.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nfunction CON3() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nstring public constant VAR3 = \"Marginless Token\";\nstring public constant VAR4 = \"MRS\";\nuint8 public constant VAR5 = 18;\nmapping (address => uint256) private VAR6;\nmapping (address => mapping (address => uint256)) internal VAR7;\nbool public VAR8 = false;\nuint256 private VAR9;\nmodifier FUN3() {\nrequire(VAR8);\n_;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[msg.sender]);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[VAR12]);\nrequire(VAR11 <= VAR7[VAR12][msg.sender]);\nVAR6[VAR12] = VAR6[VAR12].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR11) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR14) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR7[msg.sender][VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR13, uint VAR15) public returns (bool) {\nuint VAR16 = VAR7[msg.sender][VAR13];\nif (VAR15 > VAR16) {\nVAR7[msg.sender][VAR13] = 0;\n} else {\nVAR7[msg.sender][VAR13] = VAR16.sub(VAR15);\n}\nreturn true;\n}\nmodifier FUN9() {\nrequire(!VAR8);\n_;\n}\nfunction FUN10(address VAR10, uint256 VAR17) public FUN1 FUN9 returns (bool) {\nVAR9 = VAR9.add(VAR17);\nVAR6[VAR10] = VAR6[VAR10].add(VAR17);\nreturn true;\n}\nfunction FUN11() public FUN1 FUN9 returns (bool) {\nVAR8 = true;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9165b1ed40c097073a7d15ad3ef49e3c5b132588.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nfunction FUN1 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nassert (VAR2 <= VAR1 - VAR3);\nreturn VAR2 + VAR3;\n}\nfunction FUN2 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nassert (VAR2 >= VAR3);\nreturn VAR2 - VAR3;\n}\nfunction FUN3 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nif (VAR3 == 0) return 0; assert (VAR2 <= VAR1 / VAR3);\nreturn VAR2 * VAR3;\n}\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () {\n}\nfunction FUN4 (address VAR5) constant returns (uint256 VAR6) {\nreturn VAR13 [VAR5];\n}\nfunction FUN5 (address VAR7, uint256 VAR8) returns (bool VAR9) {\nif (VAR13 [msg.sender] < VAR8) return false;\nif (VAR8 > 0 && msg.sender != VAR7) {\nVAR13 [msg.sender] = FUN2 (VAR13 [msg.sender], VAR8);\nVAR13 [VAR7] = FUN1 (VAR13 [VAR7], VAR8);\n}\nreturn true;\n}\nfunction FUN6 (address VAR10, address VAR7, uint256 VAR8)\nreturns (bool VAR9) {\nif (VAR14 [VAR10][msg.sender] < VAR8) return false;\nif (VAR13 [VAR10] < VAR8) return false;\nVAR14 [VAR10][msg.sender] =\nFUN2 (VAR14 [VAR10][msg.sender], VAR8);\nif (VAR8 > 0 && VAR10 != VAR7) {\nVAR13 [VAR10] = FUN2 (VAR13 [VAR10], VAR8);\nVAR13 [VAR7] = FUN1 (VAR13 [VAR7], VAR8);\n}\nreturn true;\n}\nfunction FUN7 (address VAR11, uint256 VAR8) returns (bool VAR9) {\nVAR14 [msg.sender][VAR11] = VAR8;\nreturn true;\n}\nfunction FUN8 (address VAR5, address VAR11) constant\nreturns (uint256 VAR12) {\nreturn VAR14 [VAR5][VAR11];\n}\nmapping (address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) private VAR14;\n}\ncontract CON4 is CON3 {\naddress private VAR15;\nuint256 VAR16;\nbool VAR17 = false;\nfunction CON4 (uint256 VAR18) {\nVAR15 = msg.sender;\nVAR16 = VAR18;\nVAR13 [msg.sender] = VAR18;\n}\nfunction FUN9 () constant returns (uint256 VAR19) {\nreturn VAR16;\n}\nfunction FUN10 () constant returns (string VAR20) {\nreturn \"Connectius Token\";\n}\nfunction FUN11 () constant returns (string VAR20) {\nreturn \"CNTT\";\n}\nfunction FUN12 () constant returns (uint8 VAR20) {\nreturn 18;\n}\nfunction FUN5 (address VAR7, uint256 VAR8) returns (bool VAR9) {\nif (VAR17) return false;\nelse return CON3.FUN5 (VAR7, VAR8);\n}\nfunction FUN6 (address VAR10, address VAR7, uint256 VAR8)\nreturns (bool VAR9) {\nif (VAR17) return false;\nelse return CON3.FUN6 (VAR10, VAR7, VAR8);\n}\nfunction FUN7 (address VAR11, uint256 VAR21, uint256 VAR22)\nreturns (bool VAR9) {\nif (FUN8 (msg.sender, VAR11) == VAR21)\nreturn FUN7 (VAR11, VAR22);\nelse return false;\n}\nfunction FUN13 (uint256 VAR8) returns (bool VAR9) {\nif (VAR8 > VAR13 [msg.sender]) return false;\nelse if (VAR8 > 0) {\nVAR13 [msg.sender] = FUN2 (VAR13 [msg.sender], VAR8);\nVAR16 = FUN2 (VAR16, VAR8);\nreturn true;\n} else return true;\n}\nfunction FUN14 (address VAR23) {\nrequire (msg.sender == VAR15);\nVAR15 = VAR23;\n}\nfunction FUN15 () {\nrequire (msg.sender == VAR15);\nif (!VAR17) {\nVAR17 = true;\nFreeze ();\n}\n}\nfunction FUN16 () {\nrequire (msg.sender == VAR15);\nif (VAR17) {\nVAR17 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0xc6e46f253fbc5bb91a30e0c1f78bd9067e495bef.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor() public {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4,uint256 VAR5)\npublic\nFUN10\nreturns (bool)\n{\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nfunction FUN16(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN17(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON6 is CON5, CON4 {\nstring public constant VAR12 = \"SWORLD COIN\";\nstring public constant VAR13 = \"SWC\";\nuint8 public constant VAR14 = 18;\nuint256 public constant VAR15 = 5000000000 * (10 ** uint256(VAR14));\nconstructor(address VAR16) public {\nFUN7(VAR16, VAR15);\n}\n}",
        "label": false,
        "name": "0x13565ed69a6997dada0cc0e2087f08504626d9db.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1; address public VAR2;\nfunction CON1() public {\nVAR1 = msg.sender;\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3) external FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\nfunction FUN4(address VAR4) external FUN1 {\nrequire(VAR4 != address(0));\nVAR1 = VAR4;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nCON2 internal VAR5;\naddress public VAR6;\nfunction CON3() public {\nVAR5 = CON2(VAR1);\n}\nfunction FUN5(address VAR7) public FUN1 {\nVAR5 = CON2(VAR7);\nVAR6 = VAR7;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN6(uint VAR8, uint VAR9) internal {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nuint VAR11 = VAR5.getUInt(keccak256(VAR10, \"bonus\"));\nuint VAR12 = VAR5.getUInt(keccak256(msg.sender, \"balance\"));\nuint VAR13 = VAR12 + VAR11;\nVAR5.setUInt(keccak256(msg.sender, \"balance\"), VAR13);\nVAR5.setUInt(keccak256(VAR10, \"bonus\"), 0);\nif (VAR11 > 0) {\n}\n}\nfunction FUN7(address VAR14, uint VAR15) public FUN1 {\nuint VAR16 = VAR5.getUInt(keccak256(VAR14, \"promoAllowance\"));\nVAR16 += VAR15;\nVAR5.setUInt(keccak256(VAR14, \"promoAllowance\"), VAR16);\n}\nfunction FUN8() public {\nuint VAR12 = VAR5.getUInt(keccak256(msg.sender, \"balance\"));\nVAR5.FUN8(msg.sender);\n}\nfunction FUN9 (uint VAR8, uint VAR9, uint VAR17) internal {\nuint VAR18 = msg.value * VAR17 / 100;\nuint VAR19 = msg.value - VAR18;\nuint VAR20 = VAR5.getUInt(\"neighbourRewardPercentage\");\nuint VAR21 = VAR19 - (VAR19 * VAR20 * 8 / 100);\nFUN12(VAR18);\nFUN13(VAR8, VAR9, VAR21);\nFUN10(VAR8, VAR9, VAR19, VAR20);\n}\nfunction FUN10 (uint VAR8, uint VAR9, uint VAR19, uint VAR20) internal {\nuint VAR22 = VAR19 * VAR20 / 100;\naddress VAR23 = VAR5.getAdd(keccak256(keccak256(VAR8-1, \":\", VAR9-1), \"owner\"));\naddress VAR24 = VAR5.getAdd(keccak256(keccak256(VAR8-1, \":\", VAR9), \"owner\"));\naddress VAR25 = VAR5.getAdd(keccak256(keccak256(VAR8-1, \":\", VAR9+1), \"owner\"));\naddress VAR26 = VAR5.getAdd(keccak256(keccak256(VAR8, \":\", VAR9-1), \"owner\"));\naddress VAR27 = VAR5.getAdd(keccak256(keccak256(VAR8, \":\", VAR9+1), \"owner\"));\naddress VAR28 = VAR5.getAdd(keccak256(keccak256(VAR8+1, \":\", VAR9-1), \"owner\"));\naddress VAR29 = VAR5.getAdd(keccak256(keccak256(VAR8+1, \":\", VAR9), \"owner\"));\naddress VAR30 = VAR5.getAdd(keccak256(keccak256(VAR8+1, \":\", VAR9+1), \"owner\"));\nVAR23 != address(0) ? FUN11(VAR23, VAR22) : FUN11(VAR2, VAR22);\nVAR24 != address(0) ? FUN11(VAR24, VAR22) : FUN11(VAR2, VAR22);\nVAR25 != address(0) ? FUN11(VAR25, VAR22) : FUN11(VAR2, VAR22);\nVAR26 != address(0) ? FUN11(VAR26, VAR22) : FUN11(VAR2, VAR22);\nVAR27 != address(0) ? FUN11(VAR27, VAR22) : FUN11(VAR2, VAR22);\nVAR28 != address(0) ? FUN11(VAR28, VAR22) : FUN11(VAR2, VAR22);\nVAR29 != address(0) ? FUN11(VAR29, VAR22) : FUN11(VAR2, VAR22);\nVAR30 != address(0) ? FUN11(VAR30, VAR22) : FUN11(VAR2, VAR22);\n}\nfunction FUN11(address VAR31, uint VAR32) internal {\nuint VAR12 = VAR5.getUInt(keccak256(VAR31, \"balance\"));\nVAR12 += VAR32;\nVAR5.setUInt(keccak256(VAR31, \"balance\"), VAR12);\n}\nfunction FUN12 (uint VAR18) internal {\nuint VAR33 = VAR5.getUInt(keccak256(VAR1, \"balance\"));\nVAR33 += VAR18;\nVAR5.setUInt(keccak256(VAR1, \"balance\"), VAR33);\n}\nfunction FUN13 (uint VAR8, uint VAR9, uint VAR34) internal {\nuint VAR35;\nbytes32 VAR10 = getKey(VAR8, VAR9);\naddress VAR36 = VAR5.getAdd(keccak256(VAR10, \"owner\"));\nif (VAR36 == address(0)) {\nVAR35 = VAR5.getUInt(keccak256(VAR1, \"balance\"));\nVAR35 += VAR34;\nVAR5.setUInt(keccak256(VAR1, \"balance\"), VAR35);\n} else {\nVAR35 = VAR5.getUInt(keccak256(VAR36, \"balance\"));\nVAR35 += VAR34;\nVAR5.setUInt(keccak256(VAR36, \"balance\"), VAR35);\n}\n}\n}\ncontract CON5 is CON4 {\nfunction FUN14(uint VAR8,uint VAR9,bytes32 VAR37,bytes32 VAR38,bytes32 VAR39,bytes32 VAR40) public payable {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nuint VAR41 = VAR5.getUInt(\"initialPrice\");\naddress VAR36 = VAR5.getAdd(keccak256(VAR10, \"owner\"));\nuint VAR15 = VAR5.getUInt(keccak256(msg.sender, \"promoAllowance\"));\nrequire(msg.value >= VAR41 || VAR15 > 0);\nrequire(VAR36 == address(0));\nuint VAR17 = VAR5.getUInt(\"buyOutFeePercentage\");\nif (msg.value >= VAR41) {\nFUN9(VAR8, VAR9, VAR17);\nVAR5.setUInt(keccak256(VAR10, \"price\"), msg.value);\n} else {\nVAR15--;\nVAR5.setUInt(keccak256(msg.sender, \"promoAllowance\"), VAR15);\nVAR5.setUInt(keccak256(VAR10, \"price\"), VAR41);\n}\nVAR5.setBytes32(keccak256(VAR10, \"name\"), VAR37);\nVAR5.setBytes32(keccak256(VAR10, \"description\"), VAR38);\nVAR5.setBytes32(keccak256(VAR10, \"url\"), VAR39);\nVAR5.setBytes32(keccak256(VAR10, \"imageURL\"), VAR40);\nVAR5.setAdd(keccak256(VAR10, \"owner\"), msg.sender);\nuint VAR42 = VAR5.getUInt(\"blockCount\");\nFUN6(VAR8, VAR9);\nVAR42++;\nVAR5.setUInt(\"blockCount\", VAR42);\nVAR6.transfer(msg.value);\n}\nfunction FUN15(uint VAR8, uint VAR9, uint VAR43) public {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nuint VAR44 = VAR5.getUInt(keccak256(VAR10, \"price\"));\nrequire(VAR5.getAdd(keccak256(VAR10, \"owner\")) == msg.sender);\nrequire(VAR43 < VAR44 * 2);\nVAR5.setUInt(keccak256(VAR10, \"forSale\"), VAR43);\n}\nfunction FUN16(uint VAR8, uint VAR9) public {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nrequire(VAR5.getAdd(keccak256(VAR10, \"owner\")) == msg.sender);\nVAR5.setUInt(keccak256(VAR10, \"forSale\"), 0);\n}\nfunction FUN17(uint VAR8,uint VAR9,bytes32 VAR37,bytes32 VAR38,bytes32 VAR39,bytes32 VAR40) public payable {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nuint VAR43 = VAR5.getUInt(keccak256(VAR10, \"price\"));\nuint VAR45 = VAR5.getUInt(keccak256(VAR10, \"forSale\"));\naddress VAR36 = VAR5.getAdd(keccak256(VAR10, \"owner\"));\nrequire(VAR36 != address(0));\nrequire((VAR45 > 0 && msg.value >= VAR45) || msg.value >= VAR43 * 2);\nuint VAR17 = VAR5.getUInt(\"buyOutFeePercentage\");\nFUN9(VAR8, VAR9, VAR17);\nVAR5.setUInt(keccak256(VAR10, \"price\"), msg.value);\nVAR5.setBytes32(keccak256(VAR10, \"name\"), VAR37);\nVAR5.setBytes32(keccak256(VAR10, \"description\"), VAR38);\nVAR5.setBytes32(keccak256(VAR10, \"url\"), VAR39);\nVAR5.setBytes32(keccak256(VAR10, \"imageURL\"), VAR40);\nVAR5.setAdd(keccak256(VAR10, \"owner\"), msg.sender);\nVAR5.setUInt(keccak256(VAR10, \"forSale\"), 0);\nVAR5.setUInt(keccak256(VAR10, \"pricePerDay\"), 0);\nFUN6(VAR8, VAR9);\nVAR6.transfer(msg.value);\n}\nfunction FUN18(uint VAR8,uint VAR9,bytes32 VAR37,bytes32 VAR38,bytes32 VAR39,bytes32 VAR40) public {\nbytes32 VAR10 = getKey(VAR8, VAR9);\naddress VAR36 = VAR5.getAdd(keccak256(VAR10, \"owner\"));\nrequire(msg.sender == VAR36);\nVAR5.setBytes32(keccak256(VAR10, \"name\"), VAR37);\nVAR5.setBytes32(keccak256(VAR10, \"description\"), VAR38);\nVAR5.setBytes32(keccak256(VAR10, \"url\"), VAR39);\nVAR5.setBytes32(keccak256(VAR10, \"imageURL\"), VAR40);\n}\nfunction FUN19(uint VAR8,uint VAR9,uint VAR11) public FUN1 {\nbytes32 VAR10 = getKey(VAR8, VAR9);\nuint VAR46 = VAR5.getUInt(keccak256(VAR2, \"balance\"));\nrequire(VAR46 >= VAR11);\nVAR5.setUInt(keccak256(VAR10, \"bonus\"), VAR11);\n}\n}\ncontract CON6 is CON5 {\nfunction FUN20(uint VAR43) public FUN1 {\nVAR5.setUInt(\"initialPrice\", VAR43);\n}\nfunction FUN21(uint VAR17) public FUN1 {\nVAR5.setUInt(\"buyOutFeePercentage\", VAR17);\n}\nfunction FUN22(uint VAR47) public FUN1 {\nVAR5.setUInt(\"neighbourRewardPercentage\", VAR47);\n}\n}",
        "label": false,
        "name": "0x8ab45f8d56b9ecdf69603cec6ab8b863d5b56413.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"LENS\";\nVAR5 = \"LENS Platform\";\nVAR6 = 8;\nVAR7 = 30000000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nrequire(VAR10 != address(0x0));\nrequire(VAR8[msg.sender] >= VAR11);\nrequire(VAR8[VAR10] + VAR11 >= VAR8[VAR10]);\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x13cb835c47782dad075ce7faa1f8439b548b712d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nuint public VAR3;\nfunction FUN3(uint VAR4) FUN1 {\nVAR3 = VAR4;\n}\nfunction FUN4(address VAR5) FUN1 {\nCON2 VAR6 = CON2(VAR5);\nVAR6.FUN3(VAR3);\n}\n}",
        "label": false,
        "name": "0xb0c3b59ea7a89f889475de65bc23b08fd94eaac0.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN8(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN8(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN8(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN8(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\n}\ncontract CON3 is CON2 {\nstring private constant VAR12 = \"MularPay\";\nstring private constant VAR13 = \"MP\";\nuint8 private constant VAR14 = 18;\nconstructor (address VAR15) public {\nFUN7(VAR15, 1000000000 * 1 ether);\n}\n}",
        "label": false,
        "name": "0x4a48a334906f1a323628ee3eec33e8cce7bd2cfc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() internal{\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, 'you are not the VAR1 of this contract');\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0), 'must provide valid address for new VAR1');\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON3 {\nCON2 VAR3;\nconstructor(address VAR4) public{\nVAR3 = CON2(VAR4);\n}\nfunction() external payable{}\nfunction FUN4(address[] memory VAR5, uint256[] memory VAR6) public {\nuint256 VAR7 = 0;\nuint256 VAR8 = 0;\nfor (VAR8; VAR8 < VAR5.length; VAR8++) {\nVAR3.transferFrom(msg.sender, VAR5[VAR8], VAR6[VAR8]);\nVAR7 += VAR6[VAR8];\n}\n}\nfunction FUN5(CON2 VAR9, address VAR10, uint256 VAR11) public FUN1 {\nassert(VAR9.transfer(VAR10, VAR11));\n}\n}",
        "label": false,
        "name": "0xa61a8751204c9fefaa2c7f458e0f611c017b5c76.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nusing SafeMath for uint256;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13].add(VAR14) > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12].add(VAR7[VAR13]);\nVAR7[VAR12] = VAR7[VAR12].sub(VAR14);\nVAR7[VAR13] = VAR7[VAR13].add(VAR14);\nassert(VAR7[VAR12].add(VAR7[VAR13]) == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14);\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] = VAR7[msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR8[VAR12][msg.sender] = VAR8[VAR12][msg.sender].sub(VAR14); VAR6 = VAR6.sub(VAR14);\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nusing SafeMath for uint256;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13].add(VAR14) >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] = VAR7[VAR12].sub(VAR14); VAR7[VAR13] = VAR7[VAR13].add(VAR14);\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] = VAR7[VAR23].add(VAR24);\nVAR6 = VAR6.add(VAR24);\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value.div(VAR21); FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(address(this).balance >= VAR28.mul(VAR20)); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xb4b70873f4e356304fce6d1de597b29cd2194b79.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: mint to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR13;\nstring private VAR14;\nuint8 private VAR15;\nconstructor (string memory VAR16, string memory VAR17, uint8 VAR18) public {\nVAR13 = VAR16;\nVAR14 = VAR17;\nVAR15 = VAR18;\n}\n}\ncontract CON4 is CON2, CON3 {\nconstructor () public CON3(\"INDAH TOKEN\", \"IND\", 18) {\nFUN7(msg.VAR8, 1000000000 * (10 ** uint256(VAR18())));\n}\n}",
        "label": false,
        "name": "0x3e9057b739b005c577cefd45e9a77cf969ec845c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 4;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR20;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR20[VAR12]); require(!VAR20[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN9(address VAR21, uint256 VAR22) FUN1 public {\nVAR7[VAR21] += VAR22;\nVAR6 += VAR22;\n}\nfunction FUN10(address VAR21, bool VAR23) FUN1 public {\nVAR20[VAR21] = VAR23;\n}\n}",
        "label": false,
        "name": "0x6c8b614aa370f8677cc173b3417b66c60ddef3ef.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x88ec8b9a435d4d1c4ccf8cc14370c60d8346662e.sol"
    },
    {
        "source": "contract CON1{\nfunction(){\n}\n}",
        "label": false,
        "name": "0x7222af88c86620651a5594204d1f5305b1a5671f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 1000000000000000000000000000;\nVAR6 = 1000000000000000000000000000;\nVAR3 = \"A love-xcoin\";\nVAR4 = \"AXC\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb7a263d56605648ad054d4dc1aea24f244d7ba96.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\naddress public VAR3;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR2 || msg.sender == VAR1);\n_;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR3);\n_;\n}\nfunction FUN5(address VAR4) external FUN1 {\nrequire(VAR4 != address(0));\nVAR1 = VAR4;\n}\nfunction FUN6(address VAR5) external FUN1 {\nrequire(VAR5 != address(0));\nVAR2 = VAR5;\n}\nfunction FUN7(address VAR6) external FUN1 {\nrequire(VAR6 != address(0));\nVAR3 = VAR6;\n}\nfunction FUN8() external FUN1 {\nselfdestruct(VAR1);\n}\n}\ncontract CON2 is CON1 {\nbool public VAR7 = false;\nmodifier FUN9() {\nrequire(!VAR7);\n_;\n}\nmodifier FUN10 {\nrequire(VAR7);\n_;\n}\nfunction FUN11() external FUN3 FUN9 {\nVAR7 = true;\n}\nfunction FUN12() external FUN1 FUN10 {\nVAR7 = false;\n}\n}\ncontract CON3 is CON2 {\nstruct Card {\nuint8 VAR8;\nuint64 VAR9;\naddress VAR10;\nuint16 VAR11;\nuint8 VAR12;\n}\nstruct SaleInfo {\nuint128 VAR13;\nuint128 VAR14;\n}\n}\ncontract CON4 is CON3 {\nCard[] public VAR15;\nmapping (uint8 => mapping (uint64 => uint256)) private VAR16;\nmapping (uint8 => mapping (address => uint256)) private VAR17;\nmapping (uint256 => uint128) public VAR18;\nmapping (uint256 => address) public VAR19;\nmapping (address => uint256) internal VAR20;\nfunction FUN13(address VAR21, address VAR22, uint256 VAR23) internal FUN9 {\nVAR20[VAR22]++;\nVAR19[VAR23] = VAR22;\nif (VAR21 != address(0)) {\nVAR20[VAR21]--;\n}\n}\nfunction FUN14(uint256 VAR23) internal {\nVAR18[VAR23] = uint128(now); }\nfunction FUN15(uint256 VAR24,uint256 VAR25,address VAR26,address VAR27)\ninternal\nFUN9\nreturns (uint256)\n{\nuint8 VAR28 = uint8(VAR24);\nrequire(VAR24 == uint256(VAR28));\nuint64 VAR29 = uint64(VAR25);\nrequire(VAR25 == uint256(VAR29));\nuint16 VAR11 = 0;\nif (VAR27 != address(0)) {\nVAR11 = 1;\n}\nCard memory VAR30 = Card({VAR8: VAR28,VAR9: VAR29,VAR10: VAR27,VAR11: VAR11,VAR12: 0});\nuint256 VAR31 = VAR15.push(VAR30) - 1;\nVAR16[VAR28][VAR29] = VAR31;\nif (VAR27 != address(0)) {\nVAR17[VAR28][VAR27] = VAR31;\nFUN14(VAR31);\n}\nFUN13(0, VAR26, VAR31);\nreturn VAR31;\n}\n}\ncontract CON5 is CON4 {\nfunction CON5() public {\nVAR1 = msg.sender;\nVAR2 = msg.sender;\nVAR3 = msg.sender;\nFUN15(0, 0, address(0), address(0));\n}\nfunction() external payable {\nFallbackEtherReceived(msg.sender, msg.value);\n}\naddress public VAR32;\nmodifier FUN17() {\nrequire(msg.sender == VAR32);\n_;\n}\nmapping (uint256 => SaleInfo) public VAR33;\nmapping (uint256 => uint256) public VAR34;\nuint256 public VAR35;\nmapping (address => uint256) public VAR36;\nuint256 public VAR37;\nmapping (uint256 => string) public VAR38;\nfunction FUN18(uint256 VAR23, string VAR39) external FUN17 {\nVAR38[VAR23] = VAR39;\n}\nfunction FUN19(address VAR40) external FUN1 {\nVAR32 = VAR40;\n}\nfunction FUN20(address VAR21, address VAR22, uint256 VAR23) external FUN17 {\nFUN13(VAR21, VAR22, VAR23);\n}\nfunction FUN21(uint256 VAR24, uint256 VAR25, address VAR26, address VAR27) external FUN17 returns (uint256) {\nreturn FUN15(VAR24, VAR25, VAR26, VAR27);\n}\nfunction FUN22(uint256 VAR23, uint256 VAR41) external FUN17 {\nVAR33[VAR23] = SaleInfo(uint128(now), uint128(VAR41)); }\nfunction FUN23(uint256 VAR23, address VAR42) external FUN17 {\nCard storage VAR43 = VAR15[VAR23];\nif (VAR43.VAR10 == address(0)) {\nFUN14(VAR23);\n}\nVAR43.VAR10 = VAR42;\nVAR43.VAR11 += 1;\n}\nfunction FUN24(uint256 VAR23, uint8 VAR44) external FUN17 {\nuint8 VAR45 = uint8(VAR44);\nrequire(VAR44 == uint256(VAR45));\nCard storage VAR43 = VAR15[VAR23];\nVAR43.VAR12 = VAR45;\n}\nfunction FUN25(uint256 VAR23) external FUN17 {\nCard storage VAR43 = VAR15[VAR23];\naddress VAR46 = VAR43.VAR10;\nrequire(VAR46 != address(0));\nuint256 VAR47 = VAR34[VAR23];\nrequire(VAR47 > 0);\nVAR34[VAR23] = 0;\nVAR35 -= VAR47;\nVAR46.transfer(VAR47);\n}\nfunction FUN26(uint256 VAR23) external payable FUN17 {\nVAR34[VAR23] += msg.value;\nVAR35 += msg.value;\n}\nfunction FUN27(address VAR48) external payable FUN17 {\nVAR36[VAR48] += msg.value;\nVAR37 += msg.value;\n}\nfunction FUN28() external payable FUN17 {\n}\nfunction FUN29(address VAR22) external FUN4 {\nuint256 VAR49 = netContractBalance();\nif (VAR22 == address(0)) {\nVAR3.transfer(VAR49);\n} else {\nVAR22.transfer(VAR49);\n}\n}\nfunction FUN30() external FUN9 {\nuint256 VAR50 = VAR36[msg.sender];\nrequire(VAR50 > 0);\nVAR36[msg.sender] = 0;\nVAR37 -= VAR50;\nmsg.sender.transfer(VAR50);\n}\n}",
        "label": false,
        "name": "0xf953990d2d8388bfca220141fad56e74d66184ac.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"futurechain\";\nstring public constant VAR2 = \"AFCC\";\nuint8 public constant VAR3 = 8;\nuint public VAR4 = 1000000000 * 10 ** 8 ;\naddress public VAR5; uint256 VAR6;\naddress public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR7);\n_;\n}\nconstructor() public\n{\nVAR5 = msg.sender;\nVAR8[VAR5] = VAR4;\n}\nfunction FUN3(address VAR10) external FUN1\n{\nVAR7 = VAR10;\n}\nfunction FUN4( address VAR11, address VAR12, uint256 VAR13 )public returns (bool VAR14) {\nrequire( VAR12 != 0x0);\nrequire(VAR8[VAR11] >= VAR13 && VAR9[VAR11][msg.sender] >= VAR13 && VAR13 >= 0);\nVAR8[VAR11] = (VAR8[VAR11]).sub(VAR13);\nVAR9[VAR11][msg.sender] = (VAR9[VAR11][msg.sender]).sub(VAR13);\nVAR8[VAR12] = (VAR8[VAR12]).add(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR13)public returns (bool VAR14) {\nrequire( VAR15 != 0x0);\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR13)public returns (bool VAR14) {\nrequire( VAR12 != 0x0);\nrequire(VAR8[msg.sender] >= VAR13 && VAR13 >= 0);\nVAR8[msg.sender] = (VAR8[msg.sender]).sub(VAR13);\nVAR8[VAR12] = (VAR8[VAR12]).add(VAR13);\nreturn true;\n}\nfunction FUN7(address VAR11,address VAR12,uint256 VAR13) external FUN2 returns(bool VAR14) {\nrequire( VAR12 != 0x0);\nrequire (VAR8[VAR11] >= VAR13 && VAR13 > 0);\nVAR8[VAR11] = (VAR8[VAR11]).sub(VAR13);\nVAR8[VAR12] = (VAR8[VAR12]).add(VAR13);\nreturn true;\n}\nfunction FUN8(address VAR16)public FUN1\n{\nrequire( VAR16 != 0x0);\nVAR8[VAR16] = (VAR8[VAR16]).add(VAR8[VAR5]);\nVAR8[VAR5] = 0;\nVAR5 = VAR16;\n}\n}",
        "label": false,
        "name": "0x49504a1633c10303da2d20c4e8c9c65314104968.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 public VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.data.length>=(2*32)+4);\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nrequire(VAR4==0||VAR5[msg.sender][VAR7]==0);\nrequire(msg.data.length>=(2*32)+4);\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR11;\nstring public VAR12;\nuint8 public VAR13;\nuint256 public VAR14=2;\nuint256 public VAR15 = 10;\nuint256 public VAR16 =90;\naddress public VAR17;\naddress public VAR18;\nuint256 public VAR19;\nuint256 public VAR20;\nconstructor(string VAR21, string VAR22, uint8 VAR23, uint256 VAR24,address VAR25,address VAR26) public {\nVAR11 = VAR21;\nVAR12 = VAR22;\nVAR13 = VAR23;\nVAR2 = VAR24;\nVAR17=VAR25;\nVAR18=VAR26;\nVAR19 = VAR2.mul(VAR15).div(10 ** VAR14);\nVAR20= VAR2.mul(VAR16).div(10 ** VAR14);\nVAR1[VAR25]=VAR19;\nVAR1[VAR26]=VAR20;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction() public payable{\nrevert();\n}\n}",
        "label": false,
        "name": "0x4f9b4f02853259d45a53b1a920b95879c48ee1f3.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) internal VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[VAR6]);\nrequire(VAR5 <= VAR3[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nVAR3[VAR6][msg.sender] = VAR3[VAR6][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR7] = VAR5;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR3[msg.sender][VAR7] = VAR3[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR3[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR3[msg.sender][VAR7] = 0;\n} else {\nVAR3[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON3 {\naddress public VAR11;\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7(address VAR12) public FUN6 {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON4 is CON3 {\nbool public VAR13 = true;\nbool public VAR14 = false;\naddress public VAR15;\nmodifier FUN8() {\nif(VAR13) {\nif(!VAR14) {\nrequire(msg.sender == VAR15 || msg.sender == VAR11);\n} else {\nrevert();\n}\n}\n_;\n}\nfunction FUN9(bool VAR16, bool VAR17) FUN6 public {\nrequire(!(VAR16 == false && VAR17 == true));\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN8 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public FUN8 returns (bool) {\nreturn super.FUN2(VAR6, VAR4, VAR5);\n}\nfunction FUN3(address VAR7, uint256 VAR5) public FUN8 returns (bool) {\nreturn super.FUN3(VAR7, VAR5);\n}\nfunction FUN4(address VAR7, uint VAR8) public FUN8 returns (bool VAR18) {\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7, uint VAR9) public FUN8 returns (bool VAR18) {\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON6 is CON5 {\nstring public constant VAR19 = \"Bangka Token\";\nstring public constant VAR20 = \"BGT\";\nuint8 public constant VAR21 = 18;\nmodifier FUN10( address VAR22 )\n{\nrequire(VAR22 != address(0x0));\nrequire(VAR22 != address(this));\n_;\n}\nconstructor ( address VAR23, address VAR24, uint VAR25 ) public\n{\nVAR15 = VAR23;\nVAR11 = VAR24;\nVAR1 = VAR25;\nVAR2[VAR24] = VAR25;\n}\nfunction FUN1(address VAR4, uint VAR5) FUN10(VAR4) public returns (bool)\n{\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN2(address VAR6, address VAR4, uint VAR5) FUN10(VAR4) public returns (bool)\n{\nreturn super.FUN2(VAR6, VAR4, VAR5);\n}\nfunction FUN11(uint VAR5) public returns (bool)\n{\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR1 = VAR1.sub(VAR5);\nreturn true;\n}\nfunction FUN12(address VAR6, uint256 VAR5) public returns (bool)\n{\nassert( FUN2( VAR6, msg.sender, VAR5 ) );\nreturn FUN11(VAR5);\n}\nfunction FUN13( CON1 VAR26, uint VAR27 ) FUN6 public {\nVAR26.FUN1( VAR11, VAR27 );\n}\nfunction FUN14(address VAR28) FUN6 public {\nVAR15 = VAR28;\n}\n}",
        "label": false,
        "name": "0xe3e5ccc9c8ee95ddbeb08daa7c5001b88c0d632a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 400000000 * (10 ** uint256(VAR18));\nconstructor () public CON3(\"NOIZ\", \"NOIZ\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0x36151737b45017234e9570cf9a1cac97138953c2.sol"
    },
    {
        "source": "contract CON1 { }\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\nmapping (address => uint) public VAR5;\nmapping (address => mapping (address => uint)) public VAR6;\nfunction CON2() {\nVAR4 = 10000000000000;\nVAR5[msg.sender] = VAR4; VAR1 = 'DracShares'; VAR2 = 'CON2'; VAR3 = 6;\n}\nfunction FUN1() returns(uint){\nreturn VAR4 ;\n}\nfunction FUN2(address VAR7, uint256 VAR8)\nreturns (bool VAR9) {\nif (VAR5[msg.sender] >= VAR8 && VAR8 > 0) {\nVAR5[msg.sender] -= VAR8;\nVAR5[VAR7] += VAR8;\nreturn true;\n} else return false;\n}\nfunction FUN3(address VAR10,uint256 VAR8,bytes VAR11)\nreturns (bool VAR9) {\nVAR6[msg.sender][VAR10] = VAR8;\nCON1 VAR12 = CON1(VAR10);\nVAR12.receiveApproval(msg.sender, VAR8, this, VAR11);\nreturn true;\n}\nfunction FUN4(address VAR10, uint256 VAR8) returns (bool VAR9) {\nVAR6[msg.sender][VAR10] = VAR8;\nreturn true;\n}\nfunction FUN5(address VAR13,address VAR7,uint256 VAR8)\nreturns (bool VAR9) {\nif (VAR5[VAR13] >= VAR8 && VAR6[VAR13][msg.sender] >= VAR8 && VAR8 > 0) {\nVAR5[VAR7] += VAR8;\nVAR5[VAR13] -= VAR8;\nVAR6[VAR13][msg.sender] -= VAR8;\nreturn true;\n} else return false;\n}\nfunction () {\nthrow; }\n}",
        "label": false,
        "name": "0x44fb2663d37e36e4a2b4b865d9ec832e5da6a016.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nuint constant internal VAR4 = 14 days;\nuint64 public VAR5 = 0;\nfunction FUN3(address VAR6) FUN1 external returns (bool VAR7) {\nrequire(VAR6 != address(0));\nVAR3 = VAR6;\nreturn true;\n}\nfunction FUN4() FUN6 external returns (bool VAR7) {\nrequire(VAR5 == 0);\nVAR5 = uint64(now + VAR4);\nreturn true;\n}\nmodifier FUN5() {\nrequire(now > VAR5);\n_;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR3);\n_;\n}\n}\ncontract CON3 {\nuint256 public VAR8;\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR9;\nfunction FUN7(address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR10 != address(0));\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR11);\nVAR9[VAR10] = VAR9[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR9[VAR12];\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) VAR14;\nfunction FUN9(address VAR15, address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR10 != address(0));\nuint256 VAR16 = VAR14[VAR15][msg.sender];\nVAR9[VAR15] = VAR9[VAR15].sub(VAR11);\nVAR9[VAR10] = VAR9[VAR10].add(VAR11);\nVAR14[VAR15][msg.sender] = VAR16.sub(VAR11);\nreturn true;\n}\nfunction FUN10(address VAR17, uint256 VAR11) public returns (bool) {\nVAR14[msg.sender][VAR17] = VAR11;\nreturn true;\n}\nfunction FUN11(address VAR12, address VAR17) public constant returns (uint256 VAR18) {\nreturn VAR14[VAR12][VAR17];\n}\nfunction FUN12 (address VAR17, uint VAR19)\nreturns (bool VAR7) {\nVAR14[msg.sender][VAR17] = VAR14[msg.sender][VAR17].add(VAR19);\nreturn true;\n}\nfunction FUN13 (address VAR17, uint VAR20)\nreturns (bool VAR7) {\nuint VAR21 = VAR14[msg.sender][VAR17];\nif (VAR20 > VAR21) {\nVAR14[msg.sender][VAR17] = 0;\n} else {\nVAR14[msg.sender][VAR17] = VAR21.sub(VAR20);\n}\nreturn true;\n}\n}\ncontract CON7 {\nuint32 public VAR22;\nuint256 public VAR23;\n}\ncontract CON8 is CON6, CON1 {\nusing SafeMath for uint256;\nuint32 public VAR24;\naddress public VAR25 = address(0);\naddress public VAR26 = address(0);\nuint256 public VAR27;\nfunction FUN14(address VAR28) FUN1 external {\nrequire(VAR28 != address(0));\nVAR25 = VAR28;\n}\nfunction FUN15(address VAR29, uint32 VAR30)\nFUN19 FUN18 external\n{\nrequire((VAR29 != address(0)) && (VAR30 != 0));\nCON7 VAR31 = CON7(VAR29);\nrequire(VAR31.VAR22() == VAR30);\nrequire(VAR31.VAR23() == VAR8);\nVAR26 = VAR29;\n}\nfunction FUN16(uint256 VAR32) FUN17 external {\nrequire(VAR32 > 0);\nuint256 VAR13 = VAR9[msg.sender];\nrequire(VAR13 > 0);\nVAR9[msg.sender] = VAR13.sub(VAR32);\nVAR8 = VAR8.sub(VAR32);\nVAR27 = VAR27.add(VAR32);\nCON7 VAR31 = CON7(VAR26);\nVAR31.upgradeFrom(msg.sender, VAR32);\n}\nmodifier FUN17() {\nrequire(VAR26 != address(0));\n_;\n}\nmodifier FUN18() {\nrequire(VAR26 == address(0));\n_;\n}\nmodifier FUN19() {\nrequire(msg.sender == VAR25);\n_;\n}\n}\ncontract CON9 {\nmapping (address => uint) VAR33;\nfunction FUN20(address VAR34, uint256 VAR35) internal returns (bool VAR7) {\nif ((VAR34 != address(0)) && (VAR35 > 0)) {\nuint256 VAR36 = VAR33[VAR34];\nuint256 VAR37 = VAR36 + VAR35;\nif (VAR37 > VAR36) {\nVAR33[VAR34] = VAR37;\nreturn true;\n}\n}\nreturn false;\n}\nfunction FUN21() public returns (bool VAR7) {\nuint256 VAR35 = VAR33[msg.sender];\nrequire(VAR35 > 0);\nVAR33[msg.sender] = 0;\nmsg.sender.FUN7(VAR35);\nreturn true;\n}\n}\ncontract CON10 is CON8, CON2, CON9 {\nusing SafeMath for uint256;\nstring public constant VAR38 = \"Savior Token\";\nstring public constant VAR39 = \"SAVI\";\nuint8 public constant VAR40 = 18;\naddress public VAR41;\nuint256 constant internal VAR42 = 100000000 * (10 ** uint256(VAR40));\nuint256 constant internal VAR43 = 10000000 * (10 ** uint256(VAR40));\nenum Phases {PreStart, PreIcoA, PreIcoB, PreIcoC, MainIcoA, MainIcoB, MainIcoC, AfterIco}\nuint64 constant internal VAR44 = 72 hours;\nuint64 constant internal VAR45 = 240 hours;\nuint64 constant internal VAR46 = 408 hours;\nuint64 constant internal VAR47 = 168 hours;\nuint64 constant internal VAR48 = 168 hours;\nuint64 constant internal VAR49 = 1104 hours;\nuint64 constant internal VAR50 = 720 hours;\nuint64 constant internal VAR51 = 1440 hours;\nuint64 constant internal VAR52 = 30 days;\nuint256 constant internal VAR53 = 140;\nuint256 constant internal VAR54 = 10;\nuint256 constant internal VAR55 = 10;\nuint256 constant internal VAR56 = VAR53 + VAR54 + VAR55;\nuint256 constant internal VAR57 = 130;\nuint256 constant internal VAR58 = 10;\nuint256 constant internal VAR59 = 10;\nuint256 constant internal VAR60 = VAR57 + VAR58 + VAR59;\nuint256 constant internal VAR61 = 120;\nuint256 constant internal VAR62 = 10;\nuint256 constant internal VAR63 = 10;\nuint256 constant internal VAR64 = VAR61 + VAR62 + VAR63;\nuint256 constant internal VAR65 = 110;\nuint256 constant internal VAR66 = 10;\nuint256 constant internal VAR67 = 10;\nuint256 constant internal VAR68 = VAR65 + VAR66 + VAR67;\nuint256 constant internal VAR69 = 105;\nuint256 constant internal VAR70 = 10;\nuint256 constant internal VAR71 = 10;\nuint256 constant internal VAR72 = VAR69 + VAR70 + VAR71;\nuint256 constant internal VAR73 = 100;\nuint256 constant internal VAR74 = 10;\nuint256 constant internal VAR75 = 10;\nuint256 constant internal VAR76 = VAR73 + VAR74 + VAR75;\nstruct Rates {\nuint256 VAR77;\nuint256 VAR78;\nuint256 VAR79;\nuint256 VAR80;\n}\nPhases public VAR81 = Phases.PreStart;\nuint64 public VAR82; uint64 public VAR83; uint64 public VAR84; uint64 public VAR85;\nuint256 public VAR86;\nfunction CON10(uint64 VAR87) payable {\nrequire(VAR87 > now);\nVAR82 = VAR87;\nVAR83 = VAR82 + VAR50;\nVAR84 = VAR83 + VAR51;\n}\nfunction () payable external {\nFUN24();\n}\nfunction FUN23(address VAR88, uint256 VAR89) FUN1 external returns (bool VAR7) {\nrequire(VAR88 != address(0));\nVAR41 = VAR88;\nuint256 VAR90 = VAR89 * 10**18;\nVAR9[VAR41] = VAR9[VAR41].add(VAR90);\nVAR8 = VAR8.add(VAR90);\nreturn true;\n}\nfunction FUN24() payable FUN30 FUN5 public returns (bool VAR7) {\nrequire(msg.VAR32 > 0);\nrequire(now >= VAR82);\nuint256 VAR91 = msg.VAR32;\nFUN26();\nif (VAR81 != Phases.AfterIco || VAR91 < (0.01 * 10**18)) {\nRates memory VAR92 = FUN28();\nuint256 VAR93 = VAR91.mul(VAR92.VAR80);\nuint256 VAR94 = VAR8.add(VAR93);\nVAR8 = VAR94;\nVAR9[msg.sender] = VAR9[msg.sender].add(VAR91.mul(VAR92.VAR77));\nVAR9[VAR1] = VAR9[VAR1].add(VAR91.mul(VAR92.VAR78));\nVAR9[VAR41] = VAR9[VAR41].add(VAR91.mul(VAR92.VAR79));\nVAR86 = VAR86.add(VAR91);\n} else {\nFUN20(VAR1, VAR91);\n}\nreturn true;\n}\nfunction FUN25() FUN1 external {\nVAR1.FUN7(this.VAR13);\n}\nfunction FUN26() internal {\nif (now >= VAR84) {\nif (VAR81 != Phases.AfterIco) {\nVAR81 = Phases.AfterIco;\n}\n} else if (now >= VAR83 + VAR47 + VAR48) {\nif (VAR81 != Phases.MainIcoC) {\nVAR81 = Phases.MainIcoC;\n}\n} else if (now >= VAR83 + VAR47 ) {\nif (VAR81 != Phases.MainIcoB) {\nVAR81 = Phases.MainIcoB;\n}\n} else if (now >= VAR83 ) {\nif (VAR81 != Phases.MainIcoA) {\nVAR81 = Phases.MainIcoA;\n}\n} else if (now >= VAR82 + VAR44 + VAR45) {\nif (VAR81 != Phases.PreIcoC) {\nVAR81 = Phases.PreIcoC;\n}\n} else if (now >= VAR82 + VAR44 ) {\nif (VAR81 != Phases.PreIcoB) {\nVAR81 = Phases.PreIcoB;\n}\n} else if (now >= VAR82 ) {\nif (VAR81 != Phases.PreIcoA) {\nVAR81 = Phases.PreIcoA;\n}\n} else if (VAR81 == Phases.PreStart) {\nFUN27();\nVAR81 = Phases.PreIcoA;\n}\n}\nfunction FUN27() internal {\nif (VAR41 == address(0)) {\nVAR41 = VAR1;\n}\nif (VAR25 == address(0)) {\nVAR25 = VAR1;\n}\nif (VAR3 == address(0)) {\nVAR3 = VAR1;\n}\n}\nfunction FUN28() internal returns (Rates VAR92) {\nif (VAR81 == Phases.PreIcoA) {\nVAR92.VAR77 = VAR53;\nVAR92.VAR78 = VAR54;\nVAR92.VAR79 = VAR55;\nVAR92.VAR80 = VAR56;\n} else if (VAR81 == Phases.PreIcoB) {\nVAR92.VAR77 = VAR57;\nVAR92.VAR78 = VAR58;\nVAR92.VAR79 = VAR59;\nVAR92.VAR80 = VAR60;\n} else if (VAR81 == Phases.PreIcoC) {\nVAR92.VAR77 = VAR61;\nVAR92.VAR78 = VAR62;\nVAR92.VAR79 = VAR63;\nVAR92.VAR80 = VAR64;\n} else if (VAR81 == Phases.MainIcoA) {\nVAR92.VAR77 = VAR65;\nVAR92.VAR78 = VAR66;\nVAR92.VAR79 = VAR67;\nVAR92.VAR80 = VAR68;\n} else if (VAR81 == Phases.MainIcoB) {\nVAR92.VAR77 = VAR69;\nVAR92.VAR78 = VAR70;\nVAR92.VAR79 = VAR71;\nVAR92.VAR80 = VAR72;\n} else {\nVAR92.VAR77 = VAR73;\nVAR92.VAR78 = VAR74;\nVAR92.VAR79 = VAR75;\nVAR92.VAR80 = VAR76;\n}\nreturn VAR92;\n}\nfunction FUN7(address VAR10, uint256 VAR11)\nFUN5 FUN31 public returns (bool VAR7)\n{\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN9(address VAR15, address VAR10, uint256 VAR11)\nFUN5 FUN31 public returns (bool VAR7)\n{\nreturn super.FUN9(VAR15, VAR10, VAR11);\n}\nfunction FUN10(address VAR17, uint256 VAR11)\nFUN5 FUN31 public returns (bool VAR7)\n{\nrequire((VAR11 == 0) || (VAR14[msg.sender][VAR17] == 0));\nreturn super.FUN10(VAR17, VAR11);\n}\nfunction FUN12(address VAR17, uint VAR19)\nFUN5 FUN31 public returns (bool VAR7)\n{\nreturn super.FUN12(VAR17, VAR19);\n}\nfunction FUN13(address VAR17, uint VAR20)\nFUN5 FUN31 public returns (bool VAR7)\n{\nreturn super.FUN13(VAR17, VAR20);\n}\nfunction FUN21() FUN5 public returns (bool VAR7) {\nreturn super.FUN21();\n}\nmodifier FUN29() {\nrequire(VAR81 == Phases.AfterIco);\n_;\n}\nmodifier FUN30() {\nrequire(VAR81 != Phases.AfterIco);\n_;\n}\nmodifier FUN31() {\nrequire((msg.sender != VAR1) || (VAR81 == Phases.AfterIco));\n_;\n}\nmodifier FUN32() {\nrequire(now > VAR85);\n_;\n}\n}",
        "label": false,
        "name": "0xb110e378ea8b83dd52d1c5a810a5dcf99bbc96ae.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbytes4 constant VAR1 = 0x01; bytes4 constant VAR2 = 0x02; bytes4 constant VAR3 = 0x04; bytes4 constant VAR4 = 0x08; bytes4 constant VAR5 = 0x10;\n}\ncontract CON3 {\nmapping (bytes12 => address) VAR6;\nmodifier FUN1(bytes12 VAR7) {\nif (VAR6[VAR7] != 0) {\nthrow;\n}\n_;\n}\nmodifier FUN2(bytes12 VAR7) {\nif (VAR6[VAR7] == 0) {\nthrow;\n}\n_;\n}\nfunction FUN3(bytes12 VAR7) external FUN1(VAR7) {\nVAR6[VAR7] = msg.sender;\n}\nfunction FUN4(bytes12 VAR7) external constant FUN2(VAR7) returns (CON1 VAR8) {\nVAR8 = CON1(VAR6[VAR7]);\n}\n}\ncontract CON4 is CON1, CON2 {\nstruct BlobInfo {\nbytes4 VAR9; uint32 VAR10; uint32 VAR11; address VAR12; }\nmapping (bytes20 => BlobInfo) VAR13;\nmapping (bytes20 => mapping (uint => bytes32)) VAR14;\nmapping (bytes20 => mapping (address => bool)) VAR15;\nbytes12 VAR7;\nmodifier FUN5(bytes20 VAR16) {\nBlobInfo VAR17 = VAR13[VAR16];\nif (VAR17.VAR11 == 0 || VAR17.VAR11 == uint32(-1)) {\nthrow;\n}\n_;\n}\nmodifier FUN6(bytes20 VAR16) {\nif (VAR13[VAR16].VAR12 != msg.sender) {\nthrow;\n}\n_;\n}\nmodifier FUN7(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR1 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN8(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR2 != 0) {\nthrow;\n}\n_;\n}\nmodifier FUN9(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR3 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN10(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR4 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN11(bytes20 VAR16, address VAR18) {\nif (!VAR15[VAR16][VAR18]) {\nthrow;\n}\n_;\n}\nmodifier FUN12(bytes20 VAR16) {\nif (VAR13[VAR16].VAR10 == 1) {\nthrow;\n}\n_;\n}\nmodifier FUN13(bytes20 VAR16, uint VAR19) {\nif (VAR19 >= VAR13[VAR16].VAR10) {\nthrow;\n}\n_;\n}\nfunction CON4(CON3 VAR20) {\nVAR7 = bytes12(keccak256(this, block.blockhash(block.number - 1)));\nVAR20.FUN3(VAR7);\n}\nfunction FUN14(bytes4 VAR9, bytes VAR21) external returns (bytes20 VAR16) {\nVAR16 = bytes20(keccak256(msg.sender, block.blockhash(block.number - 1)));\nwhile (VAR13[VAR16].VAR11 != 0) {\nVAR16 = bytes20(keccak256(VAR16));\n}\nVAR13[VAR16] = BlobInfo({VAR9: VAR9,VAR10: 1,VAR11: uint32(block.number),VAR12: (VAR9 & VAR5 != 0) ? 0 : msg.sender,});\n}\nfunction FUN15(bytes32 VAR22, bytes VAR21) external returns (bytes20 VAR16) {\nVAR16 = bytes20(keccak256(msg.sender, VAR22));\nif (VAR13[VAR16].VAR11 != 0) {\nthrow;\n}\nVAR13[VAR16] = BlobInfo({\nVAR9: bytes4(VAR22),\nVAR10: 1,\nVAR11: uint32(block.number),\nVAR12: (bytes4(VAR22) & VAR5 != 0) ? 0 : msg.sender,\n});\n}\nfunction FUN16(bytes20 VAR16, uint VAR23) internal {\nbytes32 VAR24 = VAR14[VAR16][VAR23 / 8];\nVAR24 &= ~bytes32(uint32(-1) * 2**((VAR23 % 8) * 32));\nVAR24 |= bytes32(uint32(block.number) * 2**((VAR23 % 8) * 32));\nVAR14[VAR16][VAR23 / 8] = VAR24;\n}\nfunction FUN17(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) returns (uint VAR19) {\nVAR19 = VAR13[VAR16].VAR10++;\nFUN16(VAR16, VAR19 - 1);\n}\nfunction FUN18(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) {\nBlobInfo VAR17 = VAR13[VAR16];\nuint VAR19 = VAR17.VAR10 - 1;\nif (VAR19 == 0) {\nVAR17.VAR11 = uint32(block.number);\n}\nelse {\nFUN16(VAR16, VAR19 - 1);\n}\n}\nfunction FUN19(bytes20 VAR16) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) FUN12(VAR16) {\nuint VAR19 = --VAR13[VAR16].VAR10;\nif (VAR19 % 8 == 1) {\ndelete VAR14[VAR16][VAR19 / 8];\n}\n}\nfunction FUN20(bytes20 VAR16) internal {\nuint VAR25 = (VAR13[VAR16].VAR10 + 6) / 8;\nfor (uint VAR26 = 0; VAR26 < VAR25; VAR26++) {\ndelete VAR14[VAR16][VAR26];\n}\n}\nfunction FUN21(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) {\nFUN20(VAR16);\nBlobInfo VAR17 = VAR13[VAR16];\nVAR17.VAR10 = 1;\nVAR17.VAR11 = uint32(block.number);\n}\nfunction FUN22(bytes20 VAR16) external FUN6(VAR16) FUN9(VAR16) {\nFUN20(VAR16);\nVAR13[VAR16] = BlobInfo({VAR9: 0,VAR10: 0,VAR11: uint32(-1),VAR12: 0,});\n}\nfunction FUN23(bytes20 VAR16) external FUN10(VAR16) {\nVAR15[VAR16][msg.sender] = true;\n}\nfunction FUN24(bytes20 VAR16) external FUN11(VAR16, msg.sender) {\nVAR15[VAR16][msg.sender] = false;\n}\nfunction FUN25(bytes20 VAR16, address VAR18) external FUN6(VAR16) FUN10(VAR16) FUN11(VAR16, VAR18) {\nVAR13[VAR16].VAR12 = VAR18;\nVAR15[VAR16][VAR18] = false;\n}\nfunction FUN26(bytes20 VAR16) external FUN6(VAR16) FUN10(VAR16) {\ndelete VAR13[VAR16].VAR12;\n}\nfunction FUN27(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR1;\n}\nfunction FUN28(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 |= VAR2;\n}\nfunction FUN29(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR3;\n}\nfunction FUN30(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR4;\n}\nfunction FUN31() external constant returns (bytes12) {\nreturn VAR7;\n}\nfunction FUN32(bytes20 VAR16) external constant returns (bool FUN5) {\nBlobInfo VAR17 = VAR13[VAR16];\nFUN5 = VAR17.VAR11 != 0 && VAR17.VAR11 != uint32(-1);\n}\nfunction FUN33(bytes20 VAR16, uint VAR19) internal returns (uint VAR11) {\nif (VAR19 == 0) {\nVAR11 = VAR13[VAR16].VAR11;\n}\nelse {\nbytes32 VAR24 = VAR14[VAR16][(VAR19 - 1) / 8];\nVAR11 = uint32(uint256(VAR24) / 2**(((VAR19 - 1) % 8) * 32));\n}\n}\nfunction FUN34(bytes20 VAR16) internal returns (uint[] VAR27) {\nuint VAR10 = VAR13[VAR16].VAR10;\nVAR27 = new uint[](VAR10);\nfor (uint VAR19 = 0; VAR19 < VAR10; VAR19++) {\nVAR27[VAR19] = FUN33(VAR16, VAR19);\n}\n}\nfunction FUN35(bytes20 VAR16) external constant FUN5(VAR16) returns (bytes4 VAR9, address VAR12, uint VAR10, uint[] VAR27) {\nBlobInfo VAR17 = VAR13[VAR16];\nVAR9 = VAR17.VAR9;\nVAR12 = VAR17.VAR12;\nVAR10 = VAR17.VAR10;\nVAR27 = FUN34(VAR16);\n}\nfunction FUN36(bytes20 VAR16) external constant FUN5(VAR16) returns (bytes4 VAR9) {\nVAR9 = VAR13[VAR16].VAR9;\n}\nfunction FUN37(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR28) {\nVAR28 = VAR13[VAR16].VAR9 & VAR1 != 0;\n}\nfunction FUN38(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR29) {\nVAR29 = VAR13[VAR16].VAR9 & VAR2 != 0;\n}\nfunction FUN39(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR30) {\nVAR30 = VAR13[VAR16].VAR9 & VAR3 != 0;\n}\nfunction FUN40(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR31) {\nVAR31 = VAR13[VAR16].VAR9 & VAR4 != 0;\n}\nfunction FUN41(bytes20 VAR16) external constant FUN5(VAR16) returns (address VAR12) {\nVAR12 = VAR13[VAR16].VAR12;\n}\nfunction FUN42(bytes20 VAR16) external constant FUN5(VAR16) returns (uint VAR10) {\nVAR10 = VAR13[VAR16].VAR10;\n}\nfunction FUN43(bytes20 VAR16, uint VAR19) external constant FUN13(VAR16, VAR19) returns (uint VAR11) {\nVAR11 = FUN33(VAR16, VAR19);\n}\nfunction FUN44(bytes20 VAR16) external constant FUN5(VAR16) returns (uint[] VAR27) {\nVAR27 = FUN34(VAR16);\n}\n}",
        "label": false,
        "name": "0xe70e90fdd2b9d3e27bdd56ef249ee1d408f40be2.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN12(address VAR16) public FUN11 {\nFUN14(VAR16);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR16) internal {\nVAR18.add(VAR16);\n}\nfunction FUN15(address VAR16) internal {\nVAR18.remove(VAR16);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR19;\nconstructor () internal {\nVAR19 = false;\n}\nmodifier FUN16() {\nrequire(!VAR19);\n_;\n}\nmodifier FUN17() {\nrequire(VAR19);\n_;\n}\nfunction FUN18() public FUN11 FUN16 {\nVAR19 = true;\n}\nfunction FUN19() public FUN11 FUN17 {\nVAR19 = false;\n}\n}\ncontract CON6 is CON3, CON5 {\nfunction FUN1(address VAR10, uint256 VAR11) public FUN16 returns (bool) {\nreturn super.FUN1(VAR10, VAR11);\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public FUN16 returns (bool) {\nreturn super.FUN3(VAR13, VAR10, VAR11);\n}\nfunction FUN2(address VAR12, uint256 VAR11) public FUN16 returns (bool) {\nreturn super.FUN2(VAR12, VAR11);\n}\nfunction FUN4(address VAR12, uint VAR14) public FUN16 returns (bool VAR20) {\nreturn super.FUN4(VAR12, VAR14);\n}\nfunction FUN5(address VAR12, uint VAR15) public FUN16 returns (bool VAR20) {\nreturn super.FUN5(VAR12, VAR15);\n}\n}\ncontract CON7 {\naddress private VAR21;\nconstructor () internal {\nVAR21 = msg.sender;\n}\nmodifier FUN20() {\nrequire(isOwner());\n_;\n}\nfunction FUN21() public FUN20 {\nVAR21 = address(0);\n}\nfunction FUN22(address VAR22) public FUN20 {\nFUN23(VAR22);\n}\nfunction FUN23(address VAR22) internal {\nrequire(VAR22 != address(0));\nVAR21 = VAR22;\n}\n}\ncontract CON8 is CON2, CON6, CON7 {\nuint256 constant public VAR23 = 1 * 10 ** 9;\nbool private VAR24 = false;\nconstructor (string memory VAR4, string memory VAR5)\nCON2(VAR4, VAR5, 18)\npublic {\nuint256 VAR25 = VAR23 * 10 ** uint256(VAR6());\nFUN7(msg.sender, VAR25);\n}\nfunction FUN24(address VAR26, address VAR27, address VAR28)\npublic\nFUN20 {\nrequire(VAR24 == false);\nrequire(VAR26 != address(0x0));\nrequire(VAR27 != address(0x0));\nrequire(VAR28 != address(0x0));\nFUN6(msg.sender, VAR26, (totalSupply().mul(10)).div(100));\nFUN6(msg.sender, VAR27, (totalSupply().mul(17)).div(100));\nFUN6(msg.sender, VAR28, (totalSupply().mul(10)).div(100));\nVAR24 = true;\n}\n}",
        "label": false,
        "name": "0x06652f356e52681c07d1338bd13b2d80820a9286.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2;\nmodifier FUN1() {\nif (msg.sender == VAR1) _;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(uint VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) public FUN1 {\nCON1 VAR5 = CON1(VAR4);\nVAR5.FUN2(VAR2);\n}\n}",
        "label": false,
        "name": "0x074736cd0dca7e6824a1bf5e34a415d2b2edebe3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 100000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"FETCH.AI\";\nstring constant public VAR14 = \"FET\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16, uint256 VAR17) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR17 > 0) {\nVAR6 [VAR16] = safeAdd (VAR6 [VAR16], VAR17);\nVAR11 = safeAdd (VAR11, VAR17);\nreturn true;\n}\nreturn false;\n}\nfunction FUN6(address VAR18) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR18;\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN8 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN9(address VAR19, address VAR20, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR19 != address(this));\nCON3 VAR21 = CON3(VAR19);\nVAR21.FUN1(VAR20, VAR2);\n}\nfunction FUN10(address VAR22, bool VAR23) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR22);\nVAR10[VAR22] = VAR23;\n}\n}",
        "label": false,
        "name": "0xd8b5bc0773ac589e11fc8c21abcc8441951fd4c7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: mint to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR13;\nstring private VAR14;\nuint8 private VAR15;\nconstructor (string memory VAR16, string memory VAR17, uint8 VAR18) public {\nVAR13 = VAR16;\nVAR14 = VAR17;\nVAR15 = VAR18;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint private VAR19 = 2450e24;\nconstructor () public CON3(\"RecruitCoin\", \"GRT\", 18) {\nFUN7(msg.VAR8, VAR19);\n}\n}",
        "label": false,
        "name": "0x26fb7f1ec05f731678f894b1ef4e2c2110dfccb2.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\naddress public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,uint8 VAR11,string memory VAR12) public {\nVAR6[msg.sender] = VAR9; VAR4 = VAR9; VAR1 = VAR10; VAR2 = VAR12; VAR3 = VAR11; VAR5 = msg.sender;\n}\nfunction FUN1(address VAR13, uint256 VAR14) public {\nrequire(VAR13 != address(0), \"Cannot use zero address\");\nrequire(VAR14 > 0, \"Cannot use zero value\");\nrequire (VAR6[msg.sender] >= VAR14, \"Balance not enough\"); require (VAR6[VAR13] + VAR14 >= VAR6[VAR13], \"Overflow\" ); VAR6[msg.sender] = SafeMath.safeSub(VAR6[msg.sender], VAR14); VAR6[VAR13] = SafeMath.safeAdd(VAR6[VAR13], VAR14); }\nfunction FUN2(address VAR15, uint256 VAR14) public\nreturns (bool VAR16) {\nrequire (VAR14 > 0, \"Cannot use zero\");\nVAR8[msg.sender][VAR15] = VAR14;\nreturn true;\n}\nfunction FUN3(address VAR17, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR13 != address(0), \"Cannot use zero address\");\nrequire(VAR14 > 0, \"Cannot use zero value\");\nrequire( VAR6[VAR17] >= VAR14, \"Balance not enough\" );\nrequire( VAR6[VAR13] + VAR14 > VAR6[VAR13], \"Cannot overflows\" );\nrequire( VAR14 <= VAR8[VAR17][msg.sender], \"Cannot over allowance\" );\nVAR6[VAR17] = SafeMath.safeSub(VAR6[VAR17], VAR14); VAR6[VAR13] = SafeMath.safeAdd(VAR6[VAR13], VAR14); VAR8[VAR17][msg.sender] = SafeMath.safeSub(VAR8[VAR17][msg.sender], VAR14);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe916fd53f37c7279450857fa6d4bcae124cf94e1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public constant VAR4 = \"Metha\";\nstring public constant VAR5 = \"METH\";\nuint8 public constant VAR6 = 18; uint public VAR7 = 0;\nuint public constant VAR8 = 100;\nmapping(address => uint) VAR9;\nmapping(address => mapping(address => uint)) VAR10;\nconstructor () public {\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7;\n}\nfunction FUN5() payable public {\nuint VAR11 = msg.value * VAR8;\nVAR9[msg.sender] = VAR9[msg.sender].add(VAR11); VAR7 = VAR7.add(VAR11);\n}\nfunction () payable public {\nFUN5();\n}\nfunction FUN7(uint VAR12) public\nFUN9(1 * 32)\nreturns (bool VAR13) {\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR7 = VAR7.sub(VAR12);\nmsg.sender.FUN10(VAR12 / VAR8); return true;\n}\nfunction FUN8(address VAR14) public constant returns (uint VAR15) {\nreturn VAR9[VAR14];\n}\nmodifier FUN9(uint VAR16) {\nassert(msg.VAR21.length >= VAR16 + 4);\n_;\n}\nfunction FUN10(address VAR17, uint VAR11) public\nFUN9(2 * 32)\nreturns (bool VAR13) {\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR11);\nVAR9[VAR17] = VAR9[VAR17].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR18, uint VAR11) public\nFUN9(2 * 32)\nreturns (bool VAR13) {\nVAR10[msg.sender][VAR18] = VAR11;\nreturn true;\n}\nfunction FUN12(address VAR19, address VAR17, uint VAR11) public\nFUN9(3 * 32)\nreturns (bool VAR13) {\nVAR9[VAR19] = VAR9[VAR19].sub(VAR11);\nVAR10[VAR19][msg.sender] = VAR10[VAR19][msg.sender].sub(VAR11);\nVAR9[VAR17] = VAR9[VAR17].add(VAR11);\nreturn true;\n}\nfunction FUN13(address VAR14, address VAR18) public constant\nreturns (uint VAR20) {\nreturn VAR10[VAR14][VAR18];\n}\nfunction FUN14(address VAR18, uint VAR11, bytes VAR21) public\nFUN9(3 * 32)\nreturns (bool VAR13) {\nVAR10[msg.sender][VAR18] = VAR11;\nCON2(VAR18).receiveApproval(msg.sender, VAR11, this, VAR21);\nreturn true;\n}\nfunction FUN15(address VAR22, uint VAR11) public FUN1 returns (bool VAR13) {\nreturn CON1(VAR22).FUN10(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x364aa6b380cb4f9cee6711326d6b33a81ce1998c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xad36d35d550a0156bfe5588d25fed99fe6f1a4f1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nfunction FUN10(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN11(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON4 {\naddress private VAR11;\nconstructor () internal {\nVAR11 = msg.sender;\n}\nmodifier FUN12() {\nrequire(isOwner());\n_;\n}\nfunction FUN13() public FUN12 {\nVAR11 = address(0);\n}\nfunction FUN14(address VAR12) public FUN12 {\nFUN15(VAR12);\n}\nfunction FUN15(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON5 is CON2, CON3, CON4 {\nstring public VAR13;\nstring public VAR14;\nuint8 public constant VAR15 = 18;\nuint256 public VAR16;\nconstructor(string memory VAR17, string memory VAR18, uint256 VAR19)\npublic {\nVAR13 = VAR17;\nVAR14 = VAR18;\nVAR16 = VAR19;\n}\nfunction FUN16(address VAR20, uint256 VAR21) public FUN12 returns (bool) {\nif (VAR16 > 0)\nrequire(totalSupply().add(VAR21) <= VAR16);\nFUN7(VAR20, VAR21);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb8c93d2a53d13df07ccc403901d9798c4da9c53b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4, uint256 VAR5) public FUN10 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nfunction FUN16(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN17(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON6 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON7 is CON4, CON5, CON6 {\nstring private VAR12 = \"JungCoin\";\nstring private VAR13 = \"JCN\";\nuint8 private VAR14 = 10;\nuint256 private VAR18 = 5000000000;\naddress VAR10 = msg.sender;\nconstructor()\nCON6(VAR12, VAR13, VAR14)\nCON5()\nCON4()\npublic {\nuint256 VAR19 = VAR18 * 10 ** uint(VAR14);\nFUN7(VAR10, VAR19);\n}\n}",
        "label": false,
        "name": "0x44972c03e999ee0763e21f94f64db9683d964bbd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nstring public VAR13; uint8 public VAR14; string public VAR15; string public VAR16 = 'H1.0';\nstruct UserHistory{\naddress VAR17; string VAR18; string VAR19; }\nmapping (uint256 => UserHistory) private VAR20;\nuint256 private VAR21;\nconstructor() public {\nVAR2 = 3850000000 * 1 ether;\nVAR1[msg.sender] = VAR2;\nVAR13 = \"Gentrion\"; VAR14 = 18; VAR15 = \"GENT\"; }\nfunction FUN10 (address VAR22, string memory VAR23, string memory VAR24, uint256 VAR25) FUN6 public {\nif (FUN1(VAR22, VAR25)) {\nVAR20[VAR21] = UserHistory(VAR22, VAR23, VAR24);\nVAR21++;\n}\n}\n}",
        "label": false,
        "name": "0x0e5d3380806f947b151fc3c9ba8946453fada97a.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1 { require(msg.sender == VAR2); _; }\nfunction FUN2(address VAR1) FUN1 public { VAR2 = VAR1; }\naddress public VAR2 = msg.sender;\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nstring public constant VAR3 = \"CanYaCoin\";\nstring public constant VAR4 = \"CAN\";\nuint256 public constant VAR5 = 6;\nuint256 public constant VAR6 = 100000000 * (10 ** VAR5);\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3() {\nVAR7[msg.sender] = VAR6;\n}\nfunction FUN3() constant returns (uint256) {\nreturn VAR6;\n}\nfunction FUN4(address VAR9, uint256 VAR10) public returns (bool) {\nif (VAR7[msg.sender] >= VAR10) {\nVAR7[msg.sender] -= VAR10;\nVAR7[VAR9] += VAR10;\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR11, address VAR9, uint256 VAR10) public returns (bool) {\nif (VAR7[VAR11] >= VAR10 && VAR8[VAR11][msg.sender] >= VAR10) {\nVAR7[VAR11] -= VAR10;\nVAR8[VAR11][msg.sender] -= VAR10;\nVAR7[VAR9] += VAR10;\nreturn true;\n}\nreturn false;\n}\nfunction FUN6(address VAR12) constant public returns (uint256) {\nreturn VAR7[VAR12];\n}\nfunction FUN7(address VAR13, uint256 VAR10) public returns (bool) {\nVAR8[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN8(address VAR12, address VAR13) constant public returns (uint256 VAR14) {\nreturn VAR8[VAR12][VAR13];\n}\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nCON3 public VAR15;\naddress public VAR16;\naddress public VAR17;\naddress public VAR18;\naddress public constant VAR19 = 0x000000000000000000000000000000000000dEaD;\nuint256 public constant VAR20 = 30;\nuint256 public constant VAR21 = 30;\nuint256 public constant VAR22 = 10;\nuint256 public constant VAR23 = 30;\nfunction CON4 (address VAR24,address VAR25,address VAR26,address VAR27) public {\nrequire(VAR24 != 0);\nrequire(VAR25 != 0);\nrequire(VAR26 != 0);\nrequire(VAR27 != 0);\nVAR15 = CON3(VAR24);\nVAR16 = VAR25;\nVAR17 = VAR26;\nVAR18 = VAR27;\n}\nfunction FUN9 (uint256 VAR28) public FUN1 {\nrequire(VAR28 != 0);\nrequire(VAR15.FUN8(VAR2, this) >= VAR28);\nuint256 VAR29 = VAR28 / 100;\nuint256 VAR30 = VAR29.mul(VAR20);\nuint256 VAR31 = VAR29.mul(VAR21);\nuint256 VAR32 = VAR29.mul(VAR22);\nuint256 VAR33 = VAR29.mul(VAR23);\nrequire(VAR30.add(VAR31).add(VAR32).add(VAR33)<= VAR28);\nrequire(VAR15.FUN5(VAR2, VAR16, VAR30));\nrequire(VAR15.FUN5(VAR2, VAR17, VAR31));\nrequire(VAR15.FUN5(VAR2, VAR18, VAR32));\nrequire(VAR15.FUN5(VAR2, VAR19, VAR33));\n}\n}",
        "label": false,
        "name": "0x0ff43ec70b18de8289726e90466f7ec3e5bf0301.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xba44ffab97960f15c09913d844ced99096debde8.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nfunction CON5() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7(address VAR12) public FUN6 {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nfunction FUN8(uint256 VAR4) public FUN6 {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR2[msg.sender]);\naddress VAR13 = msg.sender;\nVAR2[VAR13] = VAR2[VAR13].sub(VAR4);\nVAR1 = VAR1.sub(VAR4);\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR14 = \"WePool\";\nstring public constant VAR15 = \"WPL\";\nuint32 public constant VAR16 = 18;\nfunction CON7() public {\nVAR1 = 200000000 * 1E18; VAR2[VAR11] = VAR1; }\n}\ncontract CON8 is CON5 {\nusing SafeMath for uint256;\nuint256 public VAR17;\nuint256 public VAR18;\nuint256 public VAR19; uint256 public VAR20;\nuint256 public VAR21;\nuint256 public VAR22; uint256 public VAR23;\naddress public VAR24; address public VAR25;\nuint256 public VAR26;\nuint256 public VAR27;\naddress[] public VAR28;\nmapping (address => uint256) public VAR29;\nCON7 public VAR30;\nmodifier FUN9() {\nrequire(now > (VAR26 + 30 days));\n_;\n}\nfunction CON8(uint256 VAR31, uint256 VAR32) public {\nrequire(VAR31 > now);\nrequire(VAR32 > VAR31 + 7 days);\nVAR27 = VAR31;\nVAR26 = VAR32;\nVAR21 = 0.1 ether;\nVAR22 = 0.00008 ether;\nVAR23 = 0.0001 ether;\nVAR17 = 200000000 * 1E18;\nVAR30 = new CON7();\nVAR18 = VAR17.mul(35).div(100);\nVAR17 = VAR17.sub(VAR18);\nVAR24 = VAR11;\nVAR25 = VAR11;\n}\nfunction FUN10(address VAR33) public FUN6 {\nrequire(VAR33 != address(0));\nVAR24 = VAR33;\n}\nfunction FUN11(address VAR34) public FUN6 {\nrequire(VAR34 != address(0));\nVAR25 = VAR34;\n}\nfunction FUN12(uint256 VAR35) public FUN6 {\nrequire(VAR35 > 0);\nVAR22 = VAR35;\n}\nfunction FUN13(uint256 VAR35) public FUN6 {\nrequire(VAR35 > 0);\nVAR23 = VAR35;\n}\nfunction FUN14(uint256 VAR36) public FUN6 {\nrequire(now < VAR27);\nrequire(VAR36 > now);\nrequire(VAR26 > VAR36 + 7 days);\nVAR27 = VAR36;\n}\nfunction FUN15(uint256 VAR36) public FUN6 {\nrequire(now < VAR26);\nrequire(VAR36 > now);\nrequire(VAR36 > VAR27 + 7 days);\nVAR26 = VAR36;\n}\nfunction FUN16() public FUN6 FUN9 {\nVAR30.FUN8(VAR30.balanceOf(this));\n}\nfunction FUN17() public FUN6 FUN9 {\nVAR24.FUN1(this.balance);\n}\nfunction FUN18() public FUN6 FUN9 {\nrequire(VAR18 > 0);\nuint256 VAR37 = VAR18;\nVAR18 = 0;\nVAR30.FUN1(VAR25, VAR37);\n}\nfunction() public payable {\nFUN20();\n}\nfunction FUN20() public payable {\naddress VAR38 = msg.sender;\nuint256 VAR39 = msg.value;\nrequire(VAR39 >= VAR21);\nuint256 VAR40;\nuint256 VAR41;\nuint256 VAR42; uint256 VAR43;\nif (now > VAR27 && now < (VAR27 + 7 days)) {\nVAR40 = VAR22;\n} else if (now > VAR26 && now < (VAR26 + 30 days)) {\nVAR40 = VAR23;\n}\nrequire(VAR40 > 0);\nVAR41 = (VAR39.mul(1E18)).div(VAR40);\nif (VAR19.add(VAR41) > VAR17) {\nVAR41 = VAR17.sub(VAR19);\nVAR42 = VAR41.mul(VAR40).div(1E18);\nVAR43 = VAR39.sub(VAR42);\n} else {\nVAR42 = VAR39;\n}\nif (VAR29[VAR38] == 0) {\nVAR28.push(VAR38);\nVAR29[VAR38] = VAR41;\n} else {\nVAR29[VAR38] = VAR29[VAR38].add(VAR41);\n}\nVAR19 = VAR19.add(VAR41);\nVAR20 = VAR20.add(VAR42);\nVAR30.FUN1(VAR38, VAR41);\nif (VAR43 > 0) {\nVAR38.FUN1(VAR43);\n}\n}\n}",
        "label": false,
        "name": "0xe0d62ad40082d615703913a48b9b3914f5b56d57.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ninterface CON4 {\n}\ncontract CON5 is CON4, CON1 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON3;\nstruct Disbursement {\nuint256 VAR3;\nuint256 VAR4;\n}\nCON3 public VAR5;\nuint256 public VAR6;\nmapping(address => Disbursement[]) public VAR7;\nconstructor(CON3 VAR8) public {\nrequire(VAR8 != address(0));\nVAR5 = VAR8;\n}\nfunction FUN5(address VAR9,uint256 VAR10,uint256 VAR11)\nexternal\nFUN1\n{\nrequire(block.VAR3 < VAR11);\nVAR7[VAR9].push(Disbursement(VAR11, VAR10));\nVAR6 = VAR6.add(VAR10);\n}\nfunction FUN6(address VAR9, uint256 VAR12)\nexternal\n{\nDisbursement[] storage VAR13 = VAR7[VAR9];\nrequire(VAR12 < VAR13.length);\nDisbursement memory VAR14 = VAR13[VAR12];\nrequire(VAR14.VAR3 < now && VAR14.VAR4 > 0);\ndelete VAR13[VAR12];\nVAR5.safeTransfer(VAR9, VAR14.VAR4);\n}\n}",
        "label": false,
        "name": "0xb9727ca27ea06f8b764ac4cf51bc8b206847e6d4.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() public FUN1 FUN3 {\nVAR3 = true;\n}\nfunction FUN6() public FUN1 FUN4 {\nVAR3 = false;\n}\n}\ncontract CON3 {\nbool private VAR4 = false;\nmodifier FUN7() {\nrequire(!VAR4);\nVAR4 = true;\n_;\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) public VAR5;\nfunction FUN8() public FUN7 {\nrequire(msg.sender != address(0));\nrequire(VAR5[msg.sender] > 0);\nrequire(VAR5[msg.sender] <= this.balance);\nuint256 VAR6 = VAR5[msg.sender];\nVAR5[msg.sender] = 0;\nmsg.sender.transfer(VAR6);\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nmapping (uint16 => uint256) public VAR7;\nmapping (uint16 => address) public VAR8;\nmapping (address => string) public VAR9;\nfunction FUN9(string VAR10) public FUN3 {\nrequire(msg.sender != address(0));\nrequire(bytes(VAR10).length > 0);\nVAR9[msg.sender] = VAR10;\n}\nfunction FUN10(uint16 VAR11) public FUN7 FUN3 payable {\nrequire(msg.sender != address(0));\nrequire(VAR11 >= 0 && VAR11 < 366);\naddress VAR12 = msg.sender;\naddress VAR13 = VAR8[VAR11];\nrequire(VAR12 != VAR13);\nuint256 VAR14 = msg.value;\nuint256 VAR15 = VAR7[VAR11];\nif (VAR15 == 0) {\nVAR15 = 1 finney; }\nrequire(VAR14 >= VAR15);\nuint256 VAR16 = 0;\nif (VAR14 > VAR15) {\nVAR16 = VAR14.sub(VAR15);\nVAR14 -= VAR16;\n}\nuint256 VAR17 = calculatePriceIncrease(VAR15);\nuint256 VAR18 = VAR15.add(VAR17);\nVAR7[VAR11] = VAR18;\nuint256 VAR19 = calculateOwnerCut(VAR14);\nuint256 VAR20 = VAR14.sub(VAR19);\nVAR5[VAR1] += VAR19;\nVAR8[VAR11] = VAR12;\nif (VAR13 != address(0)) {\nVAR5[VAR13] += VAR20;\n} else {\nVAR5[VAR1] += VAR20;\n}\nif (VAR16 > 0) {\nVAR12.transfer(VAR16);\n}\n}\n}",
        "label": false,
        "name": "0xb1dda9da790e6e8a644698d56f720709bae681e9.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\nconstructor(uint256 VAR2) public {\nVAR1[msg.sender] = VAR2; }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool VAR5) {\nrequire(VAR1[msg.sender] >= VAR4); require(VAR1[VAR3] + VAR4 >= VAR1[VAR3]); VAR1[msg.sender] -= VAR4; VAR1[VAR3] += VAR4; return true;\n}\n}",
        "label": false,
        "name": "0x47a6fb3c875840fa31bc1aad018705a658f618d4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\nusing SafeMath for uint256;\nstring public VAR1 = \"LuckyStrikeTokens\";\nstring public VAR2 = \"LST\";\nuint8 public VAR3 = 0;\nuint256 public VAR4;\nmapping(address => uint256) public VAR5;\nmapping(address => mapping(address => uint256)) public VAR6;\naddress public VAR7; address public VAR8;\nuint256 public VAR9; uint256 public VAR10;\nuint256 public VAR11; uint256 public VAR12; bool public VAR13 = true;\naddress VAR14; function CON3() public {\nVAR14 = msg.sender;\n}\nfunction FUN1(address VAR15) public {\nrequire(msg.sender == VAR14);\nrequire(VAR11 == 0);\nVAR10 = 4500 ether;\nVAR12 = 200 days;\nVAR8 = 0x0bBAb60c495413c870F8cABF09436BeE9fe3542F;\nVAR5[0x7E6CdeE9104f0d93fdACd550304bF36542A95bfD] = 33040000;\nVAR5[0x21F73Fc4557a396233C0786c7b4d0dDAc6237582] = 8260000;\nVAR5[0x0bBAb60c495413c870F8cABF09436BeE9fe3542F] = 26600000;\nVAR5[0x0d7e2582738de99FFFD9F10710bBF4EAbB3a1b98] = 2100000;\nVAR4 = 70000000;\nVAR7 = VAR15;\nVAR11 = block.timestamp;\n}\nfunction FUN2(uint256 VAR16) public returns (bool) {\nrequire(!VAR13);\nrequire(this.balance > 0);\nrequire(VAR4 > 0);\nuint256 VAR17 = (this.balance).mul(VAR16) / VAR4;\nVAR4 = VAR4.sub(VAR16);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR16);\nmsg.sender.FUN4(VAR17);\nreturn true;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR8);\nrequire(VAR4 == 0 && !VAR13);\nuint256 VAR18 = this.balance;\nVAR8.FUN4(VAR18);\n}\nfunction FUN4(address VAR19, uint256 VAR20) public returns (bool){\nif (VAR19 == address(this)) {\nreturn FUN2(VAR20);\n} else {\nreturn FUN5(msg.sender, VAR19, VAR20);\n}\n}\nfunction FUN5(address VAR21, address VAR19, uint256 VAR20) public returns (bool){\nrequire(!VAR13);\nrequire(VAR20 >= 0);\nrequire(msg.sender == VAR21 || VAR20 <= VAR6[VAR21][msg.sender]);\nrequire(VAR20 <= VAR5[VAR21]);\nVAR5[VAR21] = VAR5[VAR21].sub(VAR20);\nVAR5[VAR19] = VAR5[VAR19].add(VAR20);\nif (VAR21 != msg.sender) {\nVAR6[VAR21][msg.sender] = VAR6[VAR21][msg.sender].sub(VAR20);\n}\nreturn true;\n}\nfunction FUN6(address VAR22, uint256 VAR20) public returns (bool){\nrequire(VAR20 >= 0);\nVAR6[msg.sender][VAR22] = VAR20;\nreturn true;\n}\nfunction FUN7(address VAR22, uint256 VAR20, bytes VAR23) public returns (bool) {\nFUN6(VAR22, VAR20);\nCON1 VAR24 = CON1(VAR22);\nif (VAR24.receiveApproval(msg.sender, VAR20, this, VAR23)) {\nreturn true;\n}\nreturn false;\n}\nfunction FUN8(address VAR22, bytes VAR23) public returns (bool VAR25) {\nreturn FUN7(VAR22, VAR5[msg.sender], VAR23);\n}\nfunction FUN9(address VAR19, uint256 VAR20, bytes VAR23) public returns (bool VAR25){\nFUN5(msg.sender, VAR19, VAR20);\nCON2 VAR26 = CON2(VAR19);\nif (VAR26.tokenFallback(msg.sender, VAR20, VAR23)) {\nreturn true;\n}\nreturn false;\n}\nfunction FUN10(address VAR19, bytes VAR23) public returns (bool VAR25){\nreturn FUN9(VAR19, VAR5[msg.sender], VAR23);\n}\nfunction FUN11(address VAR27, uint256 VAR28, uint256 VAR29) public returns (bool) {\nrequire(VAR13);\nrequire(msg.sender == VAR7);\nVAR5[VAR27] = VAR5[VAR27].add(VAR28);\nVAR4 = VAR4.add(VAR28);\nVAR9 = VAR9.add(VAR29);\nif (VAR9 >= VAR10 || now.sub(VAR11) > VAR12) {\nVAR13 = false;\n}\nreturn true;\n}\nfunction FUN12() public payable {\n}\n}",
        "label": false,
        "name": "0x096035be1b555323969f613cd8402494b0178580.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nmapping (string => Roles.Role) private VAR1;\nstring public constant VAR2 = \"admin\";\nfunction CON1()\npublic\n{\nFUN1(msg.sender, VAR2);\n}\nfunction FUN1(address VAR3, string VAR4)\ninternal\n{\nVAR1[VAR4].add(VAR3);\n}\nfunction FUN2(address VAR3, string VAR4)\ninternal\n{\nVAR1[VAR4].remove(VAR3);\n}\nfunction FUN3(address VAR3, string VAR4)\nFUN6\npublic\n{\nFUN1(VAR3, VAR4);\n}\nfunction FUN4(address VAR3, string VAR4)\nFUN6\npublic\n{\nFUN2(VAR3, VAR4);\n}\nmodifier FUN5(string VAR4)\n{\ncheckRole(msg.sender, VAR4);\n_;\n}\nmodifier FUN6()\n{\ncheckRole(msg.sender, VAR2);\n_;\n}\n}\ncontract CON2 {\nuint256 public VAR5;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR6;\nfunction FUN7(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 <= VAR6[msg.sender]);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR8);\nVAR6[VAR7] = VAR6[VAR7].add(VAR8);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN8(uint256 VAR8) public {\nrequire(VAR8 <= VAR6[msg.sender]);\naddress VAR9 = msg.sender;\nVAR6[VAR9] = VAR6[VAR9].sub(VAR8);\nVAR5 = VAR5.sub(VAR8);\n}\n}\ncontract CON5 {\naddress public VAR10;\nfunction CON5() public {\nVAR10 = msg.sender;\n}\nmodifier FUN9() {\nrequire(msg.sender == VAR10);\n_;\n}\nfunction FUN10(address VAR11) public FUN9 {\nrequire(VAR11 != address(0));\nVAR10 = VAR11;\n}\n}\ncontract CON6 is CON2 {\n}\ncontract CON7 is CON6, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR12;\nfunction FUN11(address VAR13, address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 <= VAR6[VAR13]);\nrequire(VAR8 <= VAR12[VAR13][msg.sender]);\nVAR6[VAR13] = VAR6[VAR13].sub(VAR8);\nVAR6[VAR7] = VAR6[VAR7].add(VAR8);\nVAR12[VAR13][msg.sender] = VAR12[VAR13][msg.sender].sub(VAR8);\nreturn true;\n}\nfunction FUN12(address VAR14, uint256 VAR8) public returns (bool) {\nVAR12[msg.sender][VAR14] = VAR8;\nreturn true;\n}\nfunction FUN13(address VAR14, uint VAR15) public returns (bool) {\nVAR12[msg.sender][VAR14] = VAR12[msg.sender][VAR14].add(VAR15);\nreturn true;\n}\nfunction FUN14(address VAR14, uint VAR16) public returns (bool) {\nuint VAR17 = VAR12[msg.sender][VAR14];\nif (VAR16 > VAR17) {\nVAR12[msg.sender][VAR14] = 0;\n} else {\nVAR12[msg.sender][VAR14] = VAR17.sub(VAR16);\n}\nreturn true;\n}\n}\ncontract CON8 is CON7, CON5 {\nbool public VAR18 = false;\nmodifier FUN15() {\nrequire(!VAR18);\n_;\n}\nfunction FUN16(address VAR7, uint256 VAR19) FUN9 FUN15 public returns (bool) {\nVAR5 = VAR5.add(VAR19);\nVAR6[VAR7] = VAR6[VAR7].add(VAR19);\nreturn true;\n}\nfunction FUN17() FUN9 FUN15 public returns (bool) {\nVAR18 = true;\nreturn true;\n}\n}\ncontract CON9 is CON7, CON4, CON8, CON1 {\nstring public constant VAR20 = \"Purpose\";\nstring public constant VAR21 = \"PRPS\";\nuint8 public constant VAR22 = 18;\nstring constant public VAR23 = \"transfer\";\nfunction CON9() public {\nVAR5 = 0;\n}\nfunction FUN18(address VAR13, uint256 VAR8) external FUN5(VAR23) returns (bool) {\nrequire(VAR13 != address(0));\nrequire(VAR8 > 0);\naddress VAR24 = msg.sender;\nVAR6[VAR13] = VAR6[VAR13].sub(VAR8);\nVAR6[VAR24] = VAR6[VAR24].add(VAR8);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe40c374d8805b1dd58cdceff998a2f6920cb52fd.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint public VAR3;\n}\ncontract CON3 {\n}\ncontract CON4 is CON3, CON2, CON1 {\nstring public VAR4 = \"PayFair Token\";\nstring public VAR5 = \"PFR\";\nuint public constant VAR6 = 8;\nuint public constant VAR7 = 11e6;\nuint public constant VAR8 = 10 ** VAR6;\nCON2 public VAR9;\nmapping (address => mapping (address => uint)) VAR10;\nmapping(address => uint) VAR11;\nmodifier FUN3(uint VAR12) {\nrequire(msg.data.length >= VAR12 + 4);\n_;\n}\nconstructor (address VAR13) public {\nVAR1 = msg.sender;\nVAR9 = CON2(VAR13);\nVAR3 = convertToDecimal(VAR7);\nVAR11[VAR1] = convertToDecimal(VAR7);\n}\nfunction() external payable {\nrevert();\n}\nfunction FUN5(uint VAR14) public {\nrequire(VAR14 <= convertToDecimal(VAR9.balanceOf(msg.sender)));\nrequire(VAR14 <= convertToDecimal(VAR9.allowance(msg.sender, address(this))));\nVAR3 = safeAdd(VAR3, VAR14);\nVAR11[msg.sender] = safeAdd(VAR11[msg.sender], VAR14);\nVAR9.FUN7(msg.sender, address(0x0), VAR14);\n}\nfunction FUN6(address VAR15, uint VAR16) public FUN3(2 * 32) returns (bool VAR17) {\nVAR11[msg.sender] = safeSub(VAR11[msg.sender], VAR16);\nVAR11[VAR15] = safeAdd(VAR11[VAR15], VAR16);\nreturn true;\n}\nfunction FUN7(address VAR18, address VAR15, uint VAR16) public FUN3(2 * 32) returns (bool VAR17) {\nuint256 VAR19 = VAR10[VAR18][msg.sender];\nVAR11[VAR15] = safeAdd(VAR11[VAR15], VAR16);\nVAR11[VAR18] = safeSub(VAR11[VAR18], VAR16);\nVAR10[VAR18][msg.sender] = safeSub(VAR19, VAR16);\nreturn true;\n}\nfunction FUN8(address VAR20, uint VAR16) public returns (bool VAR17) {\nrequire ((VAR16 == 0) || (VAR10[msg.sender][VAR20] == 0));\nVAR10[msg.sender][VAR20] = VAR16;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb41422d5a1d5d5c73c229686935b40f881502785.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstring public constant VAR3 = \"QingYiYu\";\nstring public constant VAR4 = \"QYY\";\nuint32 public constant VAR5 = 18;\nuint256 public VAR6 = 7777777 * 10**18 ;\nuint256 public VAR7 = 0;\nuint256 VAR8 = 7777 * 10**18 ;\nmapping(address => bool) VAR9;\nmapping(address => uint256) VAR10;\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nif( !VAR9[msg.sender] && VAR7 < VAR6 ){\nVAR10[msg.sender] = VAR10[msg.sender].add( VAR8 );\nVAR9[msg.sender] = true;\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN4(address VAR14, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR14][msg.sender]);\nif( !VAR9[VAR14] && VAR7 < VAR6 ){\nVAR9[VAR14] = true;\nVAR10[VAR14] = VAR10[VAR14].add( VAR8 );\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[VAR14]);\nVAR10[VAR14] = VAR10[VAR14].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR14][msg.sender] = VAR11[VAR14][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR13) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR15, uint VAR16) public returns (bool) {\nVAR11[msg.sender][VAR15] = VAR11[msg.sender][VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR17) public returns (bool) {\nuint VAR18 = VAR11[msg.sender][VAR15];\nif (VAR17 > VAR18) {\nVAR11[msg.sender][VAR15] = 0;\n} else {\nVAR11[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\nfunction FUN8(address VAR19) internal constant returns(uint256)\n{\nif( VAR7 < VAR6 ){\nif( VAR9[VAR19] )\nreturn VAR10[VAR19];\nelse\nreturn VAR10[VAR19].add( VAR8 );\n} else {\nreturn VAR10[VAR19];\n}\n}\n}",
        "label": false,
        "name": "0x2135f7b247f7b9480990a0b7ec6cc3b98f2bb2dd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR11 = \"Render Payment\";\nstring public constant VAR12 = \"RPM\";\nuint8 public constant VAR13 = 18;\nfunction CON5(uint256 VAR14) public {\nVAR1[msg.sender] = VAR14;\nVAR2 = VAR14;\n}\n}",
        "label": false,
        "name": "0x9e71dab82c3a97567f0d4977e94252bdc680d0e7.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nassert(VAR2 <= VAR1);\nreturn VAR1 - VAR2;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nassert(VAR3>=VAR1 && VAR3>=VAR2);\nreturn VAR3;\n}\n}\ncontract CON2 {\naddress public VAR4;\nconstructor() public {\nVAR4 = msg.sender;\n}\nmodifier FUN3 {\nrequire(msg.sender == VAR4);\n_;\n}\nfunction FUN4(address VAR5) FUN3 public {\nif (VAR5 != address(0)) {\nVAR4 = VAR5;\n}\n}\n}\ncontract CON3 is CON1,CON2 {\nstring public VAR6;\nstring public VAR7;\nuint8 public VAR8 = 18;\nuint256 public VAR9;\nmapping (address => uint256) public VAR10;\nmapping (address => mapping (address => uint256)) public VAR11;\nmapping (address => bool) public VAR12;\nconstructor(uint256 VAR13, string VAR14, string VAR15) public {\nVAR9 = VAR13 * 10 ** uint256(VAR8);\nVAR10[msg.sender] = VAR9;\nVAR6 = VAR14;\nVAR7 = VAR15;\n}\nfunction FUN5(address VAR16, address VAR17, uint256 VAR18) internal {\nrequire(VAR17 != 0x0);\nrequire(VAR18 > 0);\nrequire(VAR10[VAR16] >= VAR18);\nrequire(VAR10[VAR17] + VAR18 > VAR10[VAR17]);\nrequire(!VAR12[VAR16]);\nrequire(!VAR12[VAR17]);\nuint VAR19 = CON1.FUN2(VAR10[VAR16] , VAR10[VAR17]);\nVAR10[VAR16] = CON1.FUN1( VAR10[VAR16] , VAR18);\nVAR10[VAR17] =CON1.FUN2(VAR10[VAR17] , VAR18);\nassert(VAR10[VAR16] + VAR10[VAR17] == VAR19);\n}\nfunction FUN6(address VAR17, uint256 VAR18) public returns (bool VAR20) {\nFUN5(msg.sender, VAR17, VAR18);\nreturn true;\n}\nfunction FUN7(address VAR16, address VAR17, uint256 VAR18) public returns (bool VAR20) {\nrequire(VAR17 != 0x0);\nrequire(VAR18 > 0);\nrequire(VAR10[VAR16] >= VAR18);\nrequire(VAR10[VAR17] + VAR18 > VAR10[VAR17]);\nrequire(!VAR12[VAR16]);\nrequire(!VAR12[VAR17]);\nrequire(VAR18 <= VAR11[VAR16][msg.sender]);\nuint VAR19 = CON1.FUN2(VAR10[VAR16] , VAR10[VAR17]);\nVAR11[VAR16][msg.sender] = CON1.FUN1(VAR11[VAR16][msg.sender] , VAR18);\nVAR10[VAR16] = CON1.FUN1( VAR10[VAR16] , VAR18);\nVAR10[VAR17] =CON1.FUN2(VAR10[VAR17] , VAR18);\nassert(VAR10[VAR16] + VAR10[VAR17] == VAR19);\nreturn true;\n}\nfunction FUN8(address VAR21, uint256 VAR18) public returns (bool VAR20) {\nrequire(VAR21 != 0x0);\nrequire(VAR18 > 0);\nrequire(VAR10[VAR21] >= VAR18);\nrequire(!VAR12[msg.sender]);\nrequire(!VAR12[VAR21]);\nVAR11[msg.sender][VAR21] = VAR18;\nreturn true;\n}\nfunction FUN9(address VAR22, bool VAR23) FUN3 public returns (bool VAR20){\nrequire(VAR22 != 0x0);\nVAR12[VAR22] = VAR23;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xeb4e2e3159994a13ee846308bce95757196b5de4.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1) {\nthrow;\n}\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3;\nmodifier FUN3 {\nif (VAR3) throw;\n_;\n}\nmodifier FUN4 {\nif (!VAR3) throw;\n_;\n}\nfunction FUN5() external FUN1 {\nVAR3 = true;\n}\nfunction FUN6() external FUN1 FUN4 {\nVAR3 = false;\n}\n}\ncontract CON3 {\nfunction FUN7() public constant returns (bool) {\nreturn true;\n}\nfunction FUN8(address VAR4) public constant returns (bool) {\nreturn true;\n}\n}\ncontract CON4 {\nfunction FUN9() public constant returns(bool) {\nreturn true;\n}\n}\ncontract CON5 {\nuint public VAR5;\n}\ncontract CON6 is CON5 {\nuint public VAR6;\n}\ncontract CON7 is CON2 {\nuint public VAR7 = 5;\nusing SafeMathLib for uint;\nCON6 public VAR8;\nCON3 public VAR9;\nCON4 public VAR10;\naddress public VAR11;\nuint public VAR12;\nuint public VAR13;\nuint public VAR14;\nuint public VAR15 = 0;\nuint public VAR16 = 0;\nuint public VAR17 = 0;\nuint public VAR18 = 0;\nuint public VAR19 = 0;\nbool public VAR20;\nbool public VAR21;\nbool public VAR22;\naddress public VAR23;\nmapping (address => uint256) public VAR24;\nmapping (address => uint256) public VAR25;\nmapping (address => bool) public VAR26;\nuint public VAR27;\nenum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\nfunction CON7(address VAR28, CON3 VAR29, address VAR30, uint VAR31, uint VAR32, uint VAR33) {\nVAR1 = msg.sender;\nVAR8 = CON6(VAR28);\nFUN25(VAR29);\nVAR11 = VAR30;\nif(VAR11 == 0) {\nthrow;\n}\nif(VAR31 == 0) {\nthrow;\n}\nVAR13 = VAR31;\nif(VAR32 == 0) {\nthrow;\n}\nVAR14 = VAR32;\nif(VAR13 >= VAR14) {\nthrow;\n}\nVAR12 = VAR33;\n}\nfunction() payable {\nthrow;\n}\nfunction FUN11(address VAR34, uint128 VAR35) FUN3 private {\nif(FUN32() == State.PreFunding) {\nif(!VAR26[VAR34]) {\nthrow;\n}\n} else if(FUN32() == State.Funding) {\n} else {\nthrow;\n}\nuint VAR36 = msg.VAR45;\nuint VAR37 = VAR9.calculatePrice(VAR36, VAR16, VAR15, msg.sender, VAR8.VAR6());\nif(VAR37 == 0) {\nthrow;\n}\nif(VAR24[VAR34] == 0) {\nVAR17++;\n}\nVAR24[VAR34] = VAR24[VAR34].plus(VAR36);\nVAR25[VAR34] = VAR25[VAR34].plus(VAR37);\nVAR16 = VAR16.plus(VAR36);\nVAR15 = VAR15.plus(VAR37);\nif(FUN36(VAR36, VAR37, VAR16, VAR15)) {\nthrow;\n}\nFUN39(VAR34, VAR37);\nif(!VAR11.send(VAR36)) throw;\n}\nfunction FUN12(address VAR34, uint VAR38, uint VAR39) public FUN1 {\nuint VAR37 = VAR38 * 10**VAR8.VAR6();\nuint VAR36 = VAR39 * VAR38;\nVAR16 = VAR16.plus(VAR36);\nVAR15 = VAR15.plus(VAR37);\nVAR24[VAR34] = VAR24[VAR34].plus(VAR36);\nVAR25[VAR34] = VAR25[VAR34].plus(VAR37);\nFUN39(VAR34, VAR37);\n}\nfunction FUN13(address VAR40, uint128 VAR35, uint8 VAR41, bytes32 VAR42, bytes32 VAR43) public payable {\nbytes32 VAR44 = sha256(VAR40);\nif (ecrecover(VAR44, VAR41, VAR42, VAR43) != VAR23) throw;\nif(VAR35 == 0) throw; FUN11(VAR40, VAR35);\n}\nfunction FUN14(address VAR40, uint128 VAR35) public payable {\nif(VAR22) throw; if(VAR35 == 0) throw; FUN11(VAR40, VAR35);\n}\nfunction FUN15(address VAR40) public payable {\nif(VAR21) throw; if(VAR22) throw; FUN11(VAR40, 0);\n}\nfunction FUN16(uint128 VAR35, uint8 VAR41, bytes32 VAR42, bytes32 VAR43) public payable {\nFUN13(msg.sender, VAR35, VAR41, VAR42, VAR43);\n}\nfunction FUN17(uint128 VAR35) public payable {\nFUN14(msg.sender, VAR35);\n}\nfunction FUN18() public payable {\nFUN15(msg.sender);\n}\nfunction FUN19() public FUN35(State.Success) FUN1 FUN3 {\nif(VAR20) {\nthrow;\n}\nif(address(VAR10) != 0) {\nVAR10.finalizeCrowdsale();\n}\nVAR20 = true;\n}\nfunction FUN20(CON4 VAR40) FUN1 {\nVAR10 = VAR40;\nif(!VAR10.FUN9()) {\nthrow;\n}\n}\nfunction FUN21(bool VAR45) FUN1 {\nVAR21 = VAR45;\n}\nfunction FUN22(bool VAR45, address VAR46) FUN1 {\nVAR22 = VAR45;\nVAR23 = VAR46;\n}\nfunction FUN23(address VAR40, bool VAR47) FUN1 {\nVAR26[VAR40] = VAR47;\n}\nfunction FUN24(uint VAR48) FUN1 {\nif(now > VAR48) {\nthrow; }\nVAR14 = VAR48;\n}\nfunction FUN25(CON3 VAR29) FUN1 {\nVAR9 = VAR29;\nif(!VAR9.FUN7()) {\nthrow;\n}\n}\nfunction FUN26(address VAR40) public FUN1 {\nif(VAR17 > VAR7) {\nthrow;\n}\nVAR11 = VAR40;\n}\nfunction FUN27() public payable FUN35(State.Failure) {\nif(msg.VAR45 == 0) throw;\nVAR18 = VAR18.plus(msg.VAR45);\n}\nfunction FUN28() public FUN35(State.Refunding) {\nuint256 VAR49 = VAR24[msg.sender];\nif (VAR49 == 0) throw;\nVAR24[msg.sender] = 0;\nVAR19 = VAR19.plus(VAR49);\nif (!msg.sender.send(VAR49)) throw;\n}\nfunction FUN29() public constant returns (bool VAR50) {\nreturn VAR16 >= VAR12;\n}\nfunction FUN30() public constant returns (bool VAR51) {\nreturn VAR10.FUN8();\n}\nfunction FUN31() public constant returns (bool VAR51) {\nreturn VAR9.FUN8(address(this));\n}\nfunction FUN32() public constant returns (State) {\nif(VAR20) return State.Finalized;\nelse if (address(VAR10) == 0) return State.Preparing;\nelse if (!VAR10.FUN8()) return State.Preparing;\nelse if (!VAR9.FUN8(address(this))) return State.Preparing;\nelse if (block.timestamp < VAR13) return State.PreFunding;\nelse if (block.timestamp <= VAR14 && !FUN37()) return State.Funding;\nelse if (FUN29()) return State.Success;\nelse if (!FUN29() && VAR16 > 0 && VAR18 >= VAR16) return State.Refunding;\nelse return State.Failure;\n}\nfunction FUN33(uint VAR52) FUN1 {\nVAR27 = VAR52;\n}\nfunction FUN34() public constant returns (bool) {\nreturn true;\n}\nmodifier FUN35(State VAR53) {\nif(FUN32() != VAR53) throw;\n_;\n}\n}\ncontract CON8 is CON7 {\naddress public VAR54;\nfunction CON8(address VAR28, CON3 VAR29, address VAR30, uint VAR31, uint VAR32, uint VAR33, address VAR55) CON7(VAR28, VAR29, VAR30, VAR31, VAR32, VAR33) CON7(VAR28, VAR29, VAR30, VAR31, VAR32, VAR33) {\nVAR54 = VAR55;\n}\nfunction FUN36(uint VAR36, uint VAR37, uint VAR56, uint VAR57) constant returns (bool VAR58) {\nif(VAR37 > FUN38()) {\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN37() public constant returns (bool) {\nreturn FUN38() == 0;\n}\nfunction FUN38() public constant returns (uint) {\nreturn VAR8.allowance(VAR1, this);\n}\nfunction FUN39(address VAR34, uint VAR37) private {\nif(!VAR8.transferFrom(VAR54, VAR34, VAR37)) throw;\n}\n}",
        "label": false,
        "name": "0x44ad644576eeebffcd9ad89728d2a6c415cf8fb5.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 8;\nuint256 public constant VAR19 = 100000000 * (10 ** uint256(VAR18));\nconstructor () public CON3(\"Cryptorg\", \"CTG\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0xc760721eb65aa6b0a634df6a008887c48813ff63.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4 =\"Next Geeration\";\nstring public VAR5 = \"NXTGEN\";\nuint8 public VAR6 = 2;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"NXTGEN\";\nVAR5 = \"NextGeneration\";\nVAR6 = 2;\nVAR7 = 100000001 * 1**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xe9dbb5f2ca1ba668d19d173e845bd1961ac4d2f5.sol"
    },
    {
        "source": "contract CON1 {\naddress internal VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1() public {\nrequire(VAR2 != VAR1);\nFUN3(VAR2);\n}\nfunction FUN3(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\nfunction FUN4() public constant returns(address) {\nreturn (VAR1);\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ninterface CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR4;\nmapping (address => mapping (address => uint256)) internal VAR5;\nuint256 internal VAR6;\nfunction FUN9(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR8 <= VAR4[msg.sender]);\nrequire(VAR7 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR8) public returns (bool) {\nVAR5[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN11(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR4[VAR10]);\nrequire(VAR8 <= VAR5[VAR10][msg.sender]);\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\nVAR5[VAR10][msg.sender] = VAR5[VAR10][msg.sender].sub(VAR8);\nreturn true;\n}\nfunction FUN12(address VAR11, uint256 VAR12) internal {\nrequire(VAR11 != 0);\nVAR6 = VAR6.add(VAR12);\nVAR4[VAR11] = VAR4[VAR11].add(VAR12);\n}\n}\ncontract CON5 is CON4, CON2 {\nfunction FUN9(address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN9(VAR7, VAR8);\n}\nfunction FUN11(address VAR10,address VAR7,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN11(VAR10, VAR7, VAR8);\n}\nfunction FUN10(address VAR9,uint256 VAR8)\npublic\nFUN5\nreturns (bool)\n{\nreturn super.FUN10(VAR9, VAR8);\n}\n}\ncontract CON6 is CON5 {\nstring public constant VAR13 = \"XBM\";\nstring public constant VAR14 = \"XBM\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 1000000000 * (10 ** uint256(VAR15));\nconstructor () public {\nVAR6 = VAR16;\nVAR4[msg.sender] = VAR16;\n}\n}",
        "label": false,
        "name": "0xec3421dcd1b712cddd409a28c008b13ad5c3c216.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"Hedger\";\nstring public constant VAR2 = \"HDR\";\nuint8 public constant VAR3 = 18;\nuint public VAR4;\naddress public VAR5; uint256 VAR6;\nmapping(address => uint) VAR7;\nmapping(address => mapping(address => uint)) VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nconstructor() public\n{\nVAR5 = msg.sender;\n}\nfunction FUN2(address VAR9, uint256 VAR10) external FUN1{\nrequire(VAR10 > 0);\nrequire( VAR9 != 0x0 && VAR10 > 0);\nVAR7[VAR9] = (VAR7[VAR9]).add(VAR10);\nVAR4 = (VAR4).add(VAR10);\n}\nfunction FUN3(uint256 VAR10) public returns (bool VAR11){\nrequire(VAR7[msg.sender] >= VAR10);\nrequire( VAR10 > 0);\nVAR7[msg.sender] = (VAR7[msg.sender]).sub(VAR10);\nVAR4 = VAR4.sub(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR13, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR10 && VAR8[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR7[VAR12] = (VAR7[VAR12]).sub(VAR10);\nVAR8[VAR12][msg.sender] = (VAR8[VAR12][msg.sender]).sub(VAR10);\nVAR7[VAR13] = (VAR7[VAR13]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR14, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR14 != 0x0);\nVAR8[msg.sender][VAR14] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nrequire(VAR7[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR7[msg.sender] = (VAR7[msg.sender]).sub(VAR10);\nVAR7[VAR13] = (VAR7[VAR13]).add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR15) external FUN1\n{\nrequire( VAR15 != 0x0);\nVAR7[VAR15] = (VAR7[VAR15]).add(VAR7[VAR5]);\nVAR7[VAR5] = 0;\nVAR5 = VAR15;\n}\n}",
        "label": false,
        "name": "0xf5a0da939f579a7b05b4c50e435a0fc4242b373f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nmapping (address => bool) public VAR9;\nconstructor() public {\nVAR7[msg.sender] = 600000000000000000000000000;\nVAR6 = 600000000000000000000000000;\nVAR3 = \"SpotChain Token\";\nVAR4 = \"GSB\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR10, uint256 VAR11) public returns (bool) {\nrequire(!VAR9[msg.sender]);\nrequire(VAR10 != address(0));\nrequire(VAR11 > 0);\nrequire(VAR7[msg.sender] >= VAR11);\nrequire(VAR7[VAR10] + VAR11 >= VAR7[VAR10]);\nuint VAR12 = VAR7[msg.sender] + VAR7[VAR10];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR11);\nVAR7[VAR10] = CON3.safeAdd(VAR7[VAR10], VAR11);\nassert(VAR7[msg.sender]+VAR7[VAR10]==VAR12);\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR11) public returns (bool VAR14) {\nrequire((VAR11 == 0) || (VAR8[msg.sender][VAR13] == 0));\nVAR8[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR15, address VAR10, uint256 VAR11) public returns (bool VAR14) {\nrequire (VAR10 != address(0));\nrequire (VAR11 > 0);\nrequire (VAR7[VAR15] >= VAR11) ;\nrequire (VAR7[VAR10] + VAR11 > VAR7[VAR10]);\nrequire (VAR11 <= VAR8[VAR15][msg.sender]);\nVAR7[VAR15] = CON3.safeSub(VAR7[VAR15], VAR11);\nVAR7[VAR10] = CON3.safeAdd(VAR7[VAR10], VAR11);\nVAR8[VAR15][msg.sender] = CON3.safeSub(VAR8[VAR15][msg.sender], VAR11);\nreturn true;\n}\nfunction FUN8(uint256 VAR11) public returns (bool VAR14) {\nrequire(VAR7[msg.sender] >= VAR11); VAR7[msg.sender] -= VAR11; VAR6 -= VAR11;\nreturn true;\n}\nfunction FUN9(address VAR15, uint256 VAR11) public returns (bool VAR14) {\nrequire(VAR7[VAR15] >= VAR11); require(VAR11 <= VAR8[VAR15][msg.sender]); VAR7[VAR15] -= VAR11; VAR8[VAR15][msg.sender] -= VAR11; VAR6 -= VAR11;\nreturn true;\n}\nfunction FUN10(address VAR16, uint256 VAR17) FUN1 public {\nVAR7[VAR16] += VAR17;\nVAR6 += VAR17;\n}\nfunction FUN11(address VAR16, bool VAR18) FUN1 public {\nVAR9[VAR16] = VAR18;\n}\n}",
        "label": false,
        "name": "0xdc0168718b22395bcf6bb8888867f3ff03ff5b98.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nstring public constant VAR1 = \"Golem Network Token\";\nstring public constant VAR2 = \"GNT\";\nuint8 public constant VAR3 = 18;\nuint256 public constant VAR4 = 1000;\nuint256 public constant VAR5 = 820000 ether * VAR4;\nuint256 public constant VAR6 = 150000 ether * VAR4;\nuint256 public VAR7;\nuint256 public VAR8;\nbool public VAR9 = true;\naddress public VAR10;\naddress public VAR11;\nCON3 VAR12;\nuint256 VAR13;\nmapping (address => uint256) VAR14;\naddress public VAR15;\nuint256 public VAR16;\nfunction CON2(address VAR17,address VAR18,uint256 VAR19,uint256 VAR20) {\nif (VAR17 == 0) throw;\nif (VAR18 == 0) throw;\nif (VAR19 <= block.number) throw;\nif (VAR20 <= VAR19) throw;\nVAR12 = new CON3(VAR17);\nVAR11 = VAR18;\nVAR10 = VAR17;\nVAR7 = VAR19;\nVAR8 = VAR20;\n}\nfunction FUN1(address VAR21, uint256 VAR22) returns (bool) {\nif (VAR9) throw;\nvar VAR23 = VAR14[msg.sender];\nif (VAR23 >= VAR22 && VAR22 > 0) {\nVAR23 -= VAR22;\nVAR14[msg.sender] = VAR23;\nVAR14[VAR21] += VAR22;\nreturn true;\n}\nreturn false;\n}\nfunction FUN2() external constant returns (uint256) {\nreturn VAR13;\n}\nfunction FUN3(address VAR24) external constant returns (uint256) {\nreturn VAR14[VAR24];\n}\nfunction FUN4(uint256 VAR22) external {\nif (VAR9) throw;\nif (VAR15 == 0) throw;\nif (VAR22 == 0) throw;\nif (VAR22 > VAR14[msg.sender]) throw;\nVAR14[msg.sender] -= VAR22;\nVAR13 -= VAR22;\nVAR16 += VAR22;\nCON1(VAR15).migrateFrom(msg.sender, VAR22);\n}\nfunction FUN5(address VAR25) external {\nif (VAR9) throw;\nif (VAR15 != 0) throw;\nif (msg.sender != VAR11) throw;\nVAR15 = VAR25;\n}\nfunction FUN6(address VAR26) external {\nif (msg.sender != VAR11) throw;\nif (VAR26 == 0) throw;\nVAR11 = VAR26;\n}\nfunction FUN7() payable external {\nif (!VAR9) throw;\nif (block.number < VAR7) throw;\nif (block.number > VAR8) throw;\nif (msg.value == 0) throw;\nif (msg.value > (VAR5 - VAR13) / VAR4)\nthrow;\nvar VAR27 = msg.value * VAR4;\nVAR13 += VAR27;\nVAR14[msg.sender] += VAR27;\n}\nfunction FUN8() external {\nif (!VAR9) throw;\nif ((block.number <= VAR8 ||VAR13 < VAR6) &&VAR13 < VAR5) throw;\nVAR9 = false;\nuint256 VAR28 = 18;\nuint256 VAR29 =\nVAR13 * VAR28 / (100 - VAR28);\nVAR13 += VAR29;\nVAR14[VAR12] += VAR29;\nif (!VAR10.send(this.balance)) throw;\n}\nfunction FUN9() external {\nif (!VAR9) throw;\nif (block.number <= VAR8) throw;\nif (VAR13 >= VAR6) throw;\nvar VAR30 = VAR14[msg.sender];\nif (VAR30 == 0) throw;\nVAR14[msg.sender] = 0;\nVAR13 -= VAR30;\nvar VAR31 = VAR30 / VAR4;\nif (!msg.sender.send(VAR31)) throw;\n}\n}\ncontract CON3 {\nuint256 constant VAR32 = 30000;\nmapping (address => uint256) VAR33;\nCON2 VAR34;\nuint256 VAR35;\nuint256 VAR36 = 0;\nfunction CON3(address VAR17) internal {\nVAR34 = CON2(msg.sender);\nVAR35 = now + 6 * 30 days;\nVAR33[VAR17] = 20000;\nVAR33[0x9d3F257827B17161a098d380822fa2614FF540c8] = 2500; VAR33[0xd7406E50b73972Fa4aa533a881af68B623Ba3F66] = 730; VAR33[0xd15356D05A7990dE7eC94304B0fD538e550c09C0] = 730;\nVAR33[0x3971D17B62b825b151760E2451F818BfB64489A7] = 730;\nVAR33[0x95e337d09f1bc67681b1cab7ed1125ea2bae5ca8] = 730;\nVAR33[0x0025C58dB686b8CEce05CB8c50C1858b63Aa396E] = 730;\nVAR33[0xB127FC62dE6ca30aAc9D551591daEDdeBB2eFD7A] = 630; VAR33[0x21AF2E2c240a71E9fB84e90d71c2B2AddE0D0e81] = 630;\nVAR33[0x682AA1C3b3E102ACB9c97B861d595F9fbfF0f1B8] = 630;\nVAR33[0x6edd429c77803606cBd6Bb501CC701a6CAD6be01] = 630;\nVAR33[0x5E455624372FE11b39464e93d41D1F6578c3D9f6] = 310; VAR33[0xB7c7EaD515Ca275d53e30B39D8EBEdb3F19dA244] = 138; VAR33[0xD513b1c3fe31F3Fe0b1E42aa8F55e903F19f1730] = 135; VAR33[0x70cac7f8E404EEFce6526823452e428b5Ab09b00] = 100; VAR33[0xe0d5861e7be0fac6c85ecde6e8bf76b046a96149] = 100;\nVAR33[0x17488694D2feE4377Ec718836bb9d4910E81D9Cf] = 100;\nVAR33[0xb481372086dEc3ca2FCCD3EB2f462c9C893Ef3C5] = 100;\nVAR33[0xFB6D91E69CD7990651f26a3aa9f8d5a89159fC92] = 70; VAR33[0xE2ABdAe2980a1447F445cb962f9c0bef1B63EE13] = 70;\nVAR33[0x729A5c0232712caAf365fDd03c39cb361Bd41b1C] = 70;\nVAR33[0x12FBD8fef4903f62e30dD79AC7F439F573E02697] = 70;\nVAR33[0x657013005e5cFAF76f75d03b465cE085d402469A] = 42; VAR33[0xD0AF9f75EA618163944585bF56aCA98204d0AB66] = 25; }\nfunction FUN10() external {\nif (now < VAR35) throw;\nif (VAR36 == 0)\nVAR36 = VAR34.FUN3(this);\nvar VAR37 = VAR33[msg.sender];\nVAR33[msg.sender] = 0;\nvar VAR38 = VAR36 * VAR37 / VAR32;\nif (!VAR34.FUN1(msg.sender, VAR38)) throw;\n}\n}",
        "label": false,
        "name": "0x4319c142f7b6cd722fc3a49289b8a22a7a51ca1e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON1, CON2{\naddress public VAR3;\nconstructor(address VAR4) public {\nVAR3 = VAR4;\n}\nmodifier FUN3(address VAR5) {\nrequire(VAR5 != 0);\n_;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR3);\n_;\n}\nuint256 VAR6;\nmapping(address => uint256) public VAR7;\nfunction FUN5(address VAR8) public FUN1 FUN3(VAR8) {\naddress VAR9 = VAR3;\nVAR3 = VAR8;\n}\nfunction FUN6(address VAR10) external FUN4 FUN3(VAR10) {\nrequire(!addressBelongsToAccount(VAR10));\nVAR6++;\nVAR7[VAR10] = VAR6;\n}\nfunction FUN7(address VAR11,address VAR12) external FUN4 FUN3(VAR11) {\nrequire(!addressBelongsToAccount(VAR11));\nVAR7[VAR11] = accountIdForAddress(VAR12);\n}\nfunction FUN8(address VAR13) external FUN4 {\ndelete VAR7[VAR13];\n}\n}",
        "label": false,
        "name": "0xa08b00eb41a452540c44e953d9ee86f86793af55.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON6 is CON2, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint256 VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint256 VAR9) public returns (bool) {\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON3 {\nusing SafeMath for uint256;\nfunction FUN1(address VAR3, uint256 VAR4, bytes VAR11) public returns (bool VAR12) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nif(isContract(VAR3)) {\nreturn FUN7(VAR3, VAR4, VAR11);\n} else {\nreturn FUN6(VAR3, VAR4);\n}\n}\nfunction FUN1(address VAR3, uint VAR4, bytes VAR11, string VAR13) public returns (bool VAR12) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nif(isContract(VAR3)) {\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nassert(VAR3.call.value(0)(bytes4(keccak256(VAR13)), msg.sender, VAR4, VAR11));\nreturn true;\n} else {\nreturn FUN6(VAR3, VAR4);\n}\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool VAR12) {\nreturn FUN1(VAR3, VAR4, new bytes(0));\n}\nfunction FUN6(address VAR3, uint VAR4) private returns (bool VAR12) {\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN7(address VAR3, uint VAR4, bytes VAR11) private returns (bool VAR12) {\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nCON4 VAR14 = CON4(VAR3);\nVAR14.tokenFallback(msg.sender, VAR4, VAR11);\nreturn true;\n}\n}\ncontract CON8 is CON7 {\nstring public VAR15;\nstring public VAR16;\nuint8 public VAR17;\nuint256 public VAR18 = 25000000;\nfunction CON8() public {\nVAR15 = \"TRUE\";\nVAR16 = \"TRUE\";\nVAR17 = 18;\nVAR2 = VAR18 * 10 ** uint256(VAR17);\nVAR1[msg.sender] = VAR2;\n}\n}",
        "label": false,
        "name": "0x6704e83fac5fc347efbdba61728e62389ab54367.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = 0x0;\n}\n}\ncontract CON3 is CON2 {\nmapping (address => bool) public VAR4;\nmodifier FUN4() {\nrequire(FUN5(msg.sender));\n_;\n}\nfunction FUN5(address VAR5) public constant returns (bool) {\nreturn (VAR4[VAR5] || VAR1 == VAR5);\n}\nfunction FUN6(address VAR5) public FUN1 {\nrequire(!VAR4[VAR5] && VAR5 != VAR1);\nVAR4[VAR5] = true;\n}\nfunction FUN7(address VAR5) public FUN1 {\nrequire(VAR4[VAR5]);\ndelete VAR4[VAR5];\n}\n}\ncontract CON4 is CON3 {\nstruct App {\naddress VAR6;\nstring VAR7;\naddress VAR8;\nuint VAR9;\nbool VAR10;\n}\nstruct Brand {\naddress VAR11;\naddress VAR6;\nstring VAR12;\nbool VAR10;\n}\nstruct Product {\naddress VAR13;\naddress VAR11;\nstring VAR14;\nstring VAR15;\nuint VAR16;\nstring VAR17;\nbool VAR10;\n}\nCON1 public VAR18;\naddress public VAR8;\nuint public VAR9;\nmapping(address => App) public VAR19;\nmapping(address => Brand) public VAR20;\nmapping(address => Product) public VAR21;\nmapping(address => mapping(address => bool)) VAR22;\nmapping(bytes32 => address) VAR23;\naddress[] public VAR24;\naddress[] public VAR25;\naddress[] public VAR26;\nfunction FUN8(address VAR27) public FUN4 {\nVAR18 = CON1(VAR27);\n}\nfunction FUN9(address VAR28, uint VAR29) public FUN4 {\nVAR8 = VAR28;\nVAR9 = VAR29;\n}\nfunction FUN10(string VAR7, address VAR28, uint VAR29) public {\nApp storage VAR30 = VAR19[msg.sender];\nrequire(VAR30.VAR6 == address(0));\nVAR19[msg.sender] = App({VAR6: msg.sender,VAR7: VAR7,VAR8: VAR28,VAR9: VAR29,VAR10: true});\nVAR24.push(msg.sender);\n}\nfunction FUN11(string VAR7, address VAR28, uint VAR29, bool VAR10) public {\nApp storage VAR30 = VAR19[msg.sender];\nrequire(msg.sender == VAR30.VAR6);\nVAR30.VAR7 = VAR7;\nVAR30.VAR8 = VAR28;\nVAR30.VAR9 = VAR29;\nVAR30.VAR10 = VAR10;\n}\nfunction FUN12(address VAR6) public constant returns (App VAR31) {\nVAR31 = VAR19[VAR6];\n}\nfunction FUN13(address VAR6) public constant returns (address VAR28, uint VAR29, bool VAR10) {\nApp storage VAR30 = VAR19[VAR6];\nVAR28 = VAR30.VAR8;\nVAR29 = VAR30.VAR9;\nVAR10 = VAR30.VAR10;\n}\nfunction FUN14() public constant returns (uint) {\nreturn VAR24.length;\n}\nfunction FUN15(address VAR11, string VAR12) public {\nApp storage VAR31 = VAR19[msg.sender];\nrequire(VAR31.VAR6 != address(0));\nBrand storage VAR32 = VAR20[VAR11];\nrequire(VAR32.VAR11 == address(0));\nVAR20[VAR11] = Brand({VAR11: VAR11,VAR6: msg.sender,VAR12: VAR12,VAR10: true});\nVAR25.push(VAR11);\n}\nfunction FUN16(address VAR11, string VAR12, bool VAR10) public {\nBrand storage VAR32 = VAR20[VAR11];\nrequire(VAR32.VAR6 == msg.sender);\nVAR32.VAR12 = VAR12;\nVAR32.VAR10 = VAR10;\n}\nfunction FUN17(address VAR11) public constant returns (Brand VAR32) {\nVAR32 = VAR20[VAR11];\n}\nfunction FUN18(address VAR11) public constant returns (address VAR6, address VAR33, bool VAR10) {\nBrand storage VAR32 = VAR20[VAR11];\nrequire(VAR32.VAR6 != address(0));\nApp storage VAR31 = VAR19[VAR32.VAR6];\nrequire(VAR31.VAR6 != address(0));\nVAR6 = VAR31.VAR6;\nVAR33 = VAR31.VAR8;\nVAR10 = VAR31.VAR10 && VAR32.VAR10;\n}\nfunction FUN19() public constant returns (uint) {\nreturn VAR25.length;\n}\nfunction FUN20(address VAR13, string VAR14, string VAR15, uint VAR16, string VAR17) public {\nBrand storage VAR32 = VAR20[msg.sender];\nrequire(VAR32.VAR11 != address(0));\nApp storage VAR31 = VAR19[VAR32.VAR6];\nrequire(VAR31.VAR6 != address(0));\nProduct storage VAR34 = VAR21[VAR13];\nrequire(VAR34.VAR13 == address(0));\nVAR21[VAR13] = Product({VAR13: VAR13,VAR11: msg.sender,VAR14: VAR14,VAR15: VAR15,VAR16: VAR16,VAR17: VAR17,VAR10: true});\nVAR26.push(VAR13);\n}\nfunction FUN21(address VAR13, string VAR14, string VAR15, uint VAR16, string VAR17, bool VAR10) public {\nProduct storage VAR34 = VAR21[VAR13];\nrequire(VAR34.VAR11 == msg.sender);\nBrand storage VAR32 = VAR20[msg.sender];\nrequire(VAR32.VAR11 == msg.sender);\nApp storage VAR31 = VAR19[VAR32.VAR6];\nVAR34.VAR14 = VAR14;\nVAR34.VAR15 = VAR15;\nVAR34.VAR16 = VAR16;\nVAR34.VAR17 = VAR17;\nVAR34.VAR10 = VAR10;\n}\nfunction FUN22(address VAR13) public constant returns (Product VAR34) {\nVAR34 = VAR21[VAR13];\n}\nfunction FUN23(address VAR13) public constant returns (address VAR11, address VAR6, address VAR33, bool VAR10) {\nProduct storage VAR34 = VAR21[VAR13];\nrequire(VAR34.VAR11 != address(0));\nBrand storage VAR32 = VAR20[VAR11];\nrequire(VAR32.VAR6 != address(0));\nApp storage VAR31 = VAR19[VAR32.VAR6];\nrequire(VAR31.VAR6 != address(0));\nVAR11 = VAR34.VAR11;\nVAR6 = VAR31.VAR6;\nVAR33 = VAR31.VAR8;\nVAR10 = VAR31.VAR10 && VAR32.VAR10 && VAR32.VAR10;\n}\nfunction FUN24() public constant returns (uint) {\nreturn VAR26.length;\n}\nfunction FUN25(address VAR35, bool VAR36) public {\nBrand storage VAR32 = VAR20[msg.sender];\nrequire(VAR32.VAR11 != address(0));\nVAR22[VAR35][msg.sender] = VAR36;\n}\nfunction FUN26(address VAR13, bytes32 VAR37) public {\nProduct storage VAR34 = VAR21[VAR13];\nrequire(VAR34.VAR11 != address(0) && VAR34.VAR10);\nBrand storage VAR32 = VAR20[VAR34.VAR11];\nrequire(VAR32.VAR11 != address(0) && VAR32.VAR10);\nApp storage VAR31 = VAR19[VAR32.VAR6];\nrequire(VAR31.VAR6 != address(0) && VAR31.VAR10);\nbool VAR38 = VAR22[msg.sender][VAR32.VAR11];\nrequire(VAR38);\nVAR23[VAR37] = VAR13;\nif (VAR31.VAR9 > 0) {\nVAR18.transferFrom(VAR32.VAR11, VAR31.VAR8, VAR31.VAR9);\n}\nif (VAR9 > 0) {\nVAR18.transferFrom(VAR32.VAR11, VAR8, VAR9);\n}\n}\nfunction FUN27(address VAR39) public constant returns (address VAR13, address VAR11, address VAR6) {\nbytes32 VAR40 = keccak256(VAR39);\nVAR13 = VAR23[VAR40];\nProduct storage VAR34 = VAR21[VAR13];\nBrand storage VAR32 = VAR20[VAR34.VAR11];\nVAR11 = VAR34.VAR11;\nVAR6 = VAR32.VAR6;\n}\n}",
        "label": false,
        "name": "0x0364a98148b7031451e79b93449b20090d79702a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3 {\nrequire(!VAR3);\n_;\n}\nfunction FUN4() public FUN1 {\nVAR3 = true;\n}\nfunction FUN5() public FUN1 {\nVAR3 = false;\n}\n}\ncontract CON4 {\nuint256 public VAR4;\n}\ncontract CON5 is CON1, CON2, CON3, CON4 {\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nuint8 public VAR8 = 1;\nmapping (address => uint256) public VAR9;\nmapping (address => uint256) public VAR10;\nmapping (address => mapping (address => uint256)) public VAR11;\nconstructor() public {\nVAR5 = \"CodePress Token\";\nVAR6 = \"CDS\";\nVAR7 = 18;\nVAR4 = 800000000 * 10 ** uint256(VAR7);\nVAR9[msg.sender] = VAR4;\n}\nfunction FUN6(address VAR12, uint256 VAR13) public FUN1 returns (bool VAR14) {\nrequire(VAR9[VAR12] >= VAR13);\nrequire(VAR13 > 0);\nVAR9[VAR12] = sub(VAR9[VAR12], VAR13);\nVAR10[VAR12] = add(VAR10[VAR12], VAR13);\nreturn true;\n}\nfunction FUN7(address VAR12, uint256 VAR13) public FUN1 returns (bool VAR14) {\nrequire(VAR10[VAR12] >= VAR13);\nrequire(VAR13 > 0);\nVAR10[VAR12] = sub(VAR10[VAR12], VAR13);\nVAR9[VAR12] = add(VAR9[VAR12], VAR13);\nreturn true;\n}\nfunction FUN8(address VAR15, uint256 VAR13) public FUN3 returns (bool VAR14) {\nrequire( VAR15 != address(0));\nrequire(VAR9[msg.sender] >= VAR13);\nrequire(VAR9[VAR15] + VAR13 >= VAR9[VAR15]);\nVAR9[msg.sender] -= VAR13;\nVAR9[VAR15] += VAR13;\nreturn true;\n}\nfunction FUN9(address VAR16, address VAR15, uint256 VAR13) FUN3 public returns (bool VAR14) {\nrequire( VAR15 != address(0));\nrequire(VAR9[VAR16] >= VAR13);\nrequire(VAR9[VAR15] + VAR13 >= VAR9[VAR15]);\nrequire(VAR11[VAR16][msg.sender] >= VAR13);\nVAR9[VAR15] += VAR13;\nVAR9[VAR16] -= VAR13;\nVAR11[VAR16][msg.sender] -= VAR13;\nreturn true;\n}\nfunction FUN10(address VAR17, uint256 VAR13) public FUN3 returns (bool VAR14) {\nrequire( VAR17 != address(0));\nrequire(VAR13 > 0);\nrequire((VAR13 == 0)||(VAR11[msg.sender][VAR17] == 0));\nVAR11[msg.sender][VAR17] = VAR13;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x73fadd839ccc9097bbcc87e1f9af56157bc47dde.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(address VAR1) constant returns (uint256 VAR2) {\nreturn 34500000000000000000;\n}\nfunction FUN2(address VAR3, uint256 VAR4) returns (bool VAR5) {\nreturn true;\n}\n}",
        "label": false,
        "name": "0x081528cdadfca02b74dae6547d04d391c9a698fb.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 private VAR18 = 10000000000e18;\nconstructor () public\nCON2(\"CryptoMarketAdsToken\", \"CMA\", 18)\n{\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0xe968ad47b1c071ea3905ef982833552a495d6213.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \"SEK.SwedishKrona\";\nstring public constant VAR2 = \"Danske Bank Certified Deposit- Danske Bank A/S-Stock price: DANSKE (CPH) Subsidiaries:Danica Pension F\u00f6rs\u00e4kringsaktiebolag (publ.)\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0xeed10fa72cccf6887680ad2a48012a155beda82b.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\nmapping (address => uint256) VAR2;\nconstructor() public { }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR4);\nVAR2[msg.sender] = sub(VAR2[msg.sender], VAR4);\nVAR2[VAR3] = add(VAR2[VAR3], VAR4);\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nstring public VAR5 = \"CED\";\nstring public VAR6 = \"CED Coin\";\nuint256 public VAR7 = 8;\nuint256 public VAR8 = 38280000*(10**8);\nuint256 public VAR9 = 1560902400;\nuint256 public VAR10 = 1560902400;\naddress public VAR11;\naddress public VAR12 = address(0x01);\nstruct FreezeStruct {\nuint256 VAR13; uint256 VAR14; bool VAR15;\n}\nFreezeStruct[] public VAR16;\nconstructor() public{\nVAR1 = 319000000*(10**8);\nVAR2[VAR12] = VAR8;\nVAR2[msg.sender] = sub(VAR1,VAR8);\nVAR11 = msg.sender;\nVAR16.push(FreezeStruct({VAR13:1560927600, VAR14:9570000*(10**8), VAR15: true}));\nVAR16.push(FreezeStruct({VAR13:1560928200, VAR14:14355000*(10**8), VAR15: true}));\nVAR16.push(FreezeStruct({VAR13:1560928800, VAR14:14355000*(10**8), VAR15: true}));\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire (now >= VAR9 || now >= VAR10);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.sender == VAR11);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN3(uint256 VAR17) public {\nrequire(msg.sender == VAR11);\nrequire(VAR17 <= VAR10);\nVAR9 = VAR17;\n}\nfunction FUN4(uint256 VAR18) public {\nrequire(msg.sender == VAR11);\nrequire(VAR18>=0 && VAR18<VAR16.length);\nrequire(now >= VAR16[VAR18].VAR13 && VAR16[VAR18].VAR15);\nrequire(VAR2[VAR12] >= VAR16[VAR18].VAR14);\nVAR2[VAR12] = sub(VAR2[VAR12], VAR16[VAR18].VAR14);\nVAR2[VAR11] = add(VAR2[VAR11], VAR16[VAR18].VAR14);\nVAR8 = sub(VAR8, VAR16[VAR18].VAR14);\nVAR16[VAR18].VAR15 = false;\n}\n}",
        "label": false,
        "name": "0x5d68c032d4341fa42c8986fcd5fe178bb50e3a0b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nstruct Admin {\nbool VAR2;\nbool VAR3;\nbytes32 VAR4;\n}\nmapping (address => Admin) VAR5;\nconstructor(address VAR6) public {\nVAR1 = VAR6;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR7, bool VAR8, bool VAR9, bytes32 VAR10) external FUN1() {\nVAR5[VAR7] = Admin(VAR8, VAR9, VAR10);\n}\nfunction FUN3(address VAR7) external FUN1() {\ndelete VAR5[VAR7];\n}\n}",
        "label": false,
        "name": "0x92b3be4b8ca3b4faaaf9d08ab9a8329465c1bdcc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\naddress public VAR3;\nfunction FUN3() public constant returns (bool) {\nreturn true;\n}\nfunction FUN4(address VAR4) public constant returns (bool) {\nreturn true;\n}\nfunction FUN5(address VAR5) public constant returns (bool) {\nreturn false;\n}\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMathLibExt for uint;\nuint public VAR6;\nmodifier FUN6() {\nif (msg.sender != address(VAR3)) throw;\n_;\n}\nfunction FUN7(address VAR7) FUN1 {\nassert(VAR7 != address(0));\nassert(VAR3 == address(0));\nVAR3 = VAR7;\n}\nfunction CON3(uint VAR8) FUN1 {\nrequire(VAR8 > 0);\nVAR6 = VAR8;\n}\nfunction FUN8(uint VAR9) FUN6 {\nVAR6 = VAR9;\n}\nfunction FUN9(uint VAR10, uint VAR11, uint VAR12, address VAR13, uint VAR14) public constant returns (uint) {\nuint VAR15 = 10 ** VAR14;\nreturn VAR10.times(VAR15) / VAR6;\n}\n}",
        "label": false,
        "name": "0x3d822467ebe1678167dbc260d981066e1384c13c.sol"
    },
    {
        "source": "contract SimpleLotto {\r\n    int public playCount = 0;\r\n    int public playCount1;\r\n    address public owner = msg.sender;\r\n    mapping (address => uint) public players;\r\n    My public aloha;\r\n\r\n  struct My {\r\n    string a;\r\n    int b;\r\n  }\r\n\r\n    modifier onlyBy(address _account) {\r\n        if (msg.sender != _account)\r\n            throw;\r\n        _\r\n    }\r\n    \r\n    function SimpleLotto() {\r\n        playCount1 = 42;\r\n    }\r\n    \r\n    event Sent(address from, address to, int amount);\r\n    \r\n    function play(address receiver, uint amount) returns (uint){\r\n        playCount++;\r\n        playCount1++;\r\n        Sent(owner, receiver, playCount);\r\n        players[receiver] += amount;\r\n        \r\n        aloha.a = \"hi\";\r\n        aloha.b = playCount1;\r\n        \r\n        return msg.value;\r\n    } \r\n\r\n    function terminate() { \r\n        if (msg.sender == owner)\r\n            suicide(owner); \r\n    }\r\n    \r\n    function terminateAlt() onlyBy(owner) { \r\n            suicide(owner); \r\n    }\r\n}",
        "label": false,
        "name": "0xb57acd47240599d0c68f14892dd05441af67e2d3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\naddress private VAR11;\nuint256 VAR12;\nbool VAR13 = false;\nfunction CON4 (uint256 VAR14) public {\nVAR11 = msg.sender;\nVAR12 = VAR14;\nVAR9 [msg.sender] = VAR14;\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN1 (VAR2, VAR3);\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN2 (VAR6, VAR2, VAR3);\n}\nfunction FUN3 (address VAR8, uint256 VAR15, uint256 VAR16)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR15)\nreturn FUN3 (VAR8, VAR16);\nelse return false;\n}\nfunction FUN4 (address VAR17) public {\nrequire (msg.sender == VAR11);\nVAR11 = VAR17;\n}\nfunction FUN5 () public {\nrequire (msg.sender == VAR11);\nif (!VAR13) {\nVAR13 = true;\nFreeze ();\n}\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR11);\nif (VAR13) {\nVAR13 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0x966889549fe7b3b950063151f6e2ad7651becdb9.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3, CON2, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\naddress public VAR8;\nmapping(address => uint) VAR9;\nmapping(address => mapping(address => uint)) VAR10;\nmapping (address => uint256) public VAR11;\nuint256 public VAR12;\nconstructor() public {\nVAR4 = \"BYS\";\nVAR5 = \"Bayesin\";\nVAR6 = 18;\nVAR7 = 2000000000 * 10 ** 18; VAR8 = 0xC92221388BA9418777454e142d4dA4513bdb81A1;\nVAR12 = 1536681600;\nVAR9[VAR8] = VAR7;\n}\nmodifier FUN4\n{\nrequire(msg.sender == VAR8);\n_;\n}\nmodifier FUN5() {\nif (now >= VAR12)\n_;\n}\nfunction FUN6(address VAR13, uint256 VAR14) public FUN4\n{\nVAR11[VAR13] = VAR14;\n}\nfunction FUN7(address VAR15, uint VAR16) public FUN5 returns (bool VAR17) {\nrequire(now > VAR11[msg.sender]);\nVAR9[msg.sender] = safeSub(VAR9[msg.sender], VAR16);\nVAR9[VAR15] = safeAdd(VAR9[VAR15], VAR16);\nreturn true;\n}\nfunction FUN8(address VAR18, uint VAR16) public returns (bool VAR17) {\nVAR10[msg.sender][VAR18] = VAR16;\nreturn true;\n}\nfunction FUN9(address VAR19, address VAR15, uint VAR16) public FUN5 returns (bool VAR17) {\nrequire(VAR16 > 0);\nrequire(block.timestamp > VAR11[VAR19]);\nVAR9[VAR19] = safeSub(VAR9[VAR19], VAR16);\nVAR10[VAR19][msg.sender] = safeSub(VAR10[VAR19][msg.sender], VAR16);\nVAR9[VAR15] = safeAdd(VAR9[VAR15], VAR16);\nreturn true;\n}\nfunction FUN10(address VAR18, uint VAR16) public returns (bool VAR17) {\nVAR10[msg.sender][VAR18] = VAR16;\nreturn true;\n}\nfunction FUN11(address VAR15, uint256 VAR20) internal {\nrequire(VAR20 > 0);\nrequire(VAR9[VAR8] - VAR20 > 0);\nVAR9[VAR8] = safeSub(VAR9[VAR8], VAR20);\nVAR9[VAR15] = safeAdd(VAR9[VAR15], VAR20);\n}\n}\ncontract CON5 is CON4 {\naddress public VAR21; uint public VAR22 = 0; uint public VAR23 = 0; uint public VAR24 = 0;\nuint public VAR25 = 0; uint public VAR26 = 0; uint public VAR27 = 0; uint public VAR28 = 0;\nuint public VAR29 = 0;\nbool public VAR30 = false;\nbool public VAR31 = false;\nuint256 public VAR32 = 0;\nuint256 public VAR33 = 0; uint256 public VAR34 = 0;\nuint256 public VAR35 = 0; uint public VAR36 = 0; uint public VAR37 = 0; uint256 public VAR38 = 0; uint public VAR39 = 0; uint public VAR40 = 0; uint public VAR41 = 0;\nmapping(address => uint256) public VAR42;\nconstructor() public {\nVAR21 = 0xC92221388BA9418777454e142d4dA4513bdb81A1; VAR22 = 3000 * 1 ether; VAR23 = 20000 * 1 ether;\nVAR24 = 7000;\nVAR30 = false;\nVAR31 = false;\nVAR33 = 0; VAR34 = 0;\nVAR35 = 40;\nVAR36 = safeMul(0, 1 ether); VAR37 = safeMul(2000, 1 ether); VAR38 = 20;\nVAR39 = safeMul(2000, 1 ether); VAR40 = safeMul(10000, 1 ether);\nVAR41 = 0;\nVAR25 = 13000; VAR26 = 1532620800;\nVAR27 = 0; VAR28 = 0;\nVAR29 = 26000000 * 10 ** 18; }\nfunction () public payable {\nrequire(!VAR31);\nrequire(msg.sender != VAR8);\nif (block.timestamp > VAR12) {\nVAR31 = true;\nrevert();\n}\nuint VAR43 = msg.value;\nuint256 VAR44 = 0;\nif (block.timestamp < VAR26) {\nif (VAR28 >= VAR29) {\nrevert();\n}\nVAR27 = safeAdd(VAR27, VAR43);\nVAR44 = safeMul(VAR43, VAR25);\nVAR28 = safeAdd(VAR28, VAR44);\n} else {\nVAR42[msg.sender] = safeAdd(VAR42[msg.sender], VAR43);\nif ((VAR33 >= VAR36) && (VAR33 < VAR37)) {\nVAR41 = VAR35;\n}else if ((VAR33 >= VAR39) && (VAR33 < VAR40)) {\nVAR41 = VAR38;\n}else {\nVAR41 = 0;\n}\nVAR33 = safeAdd(VAR33, VAR43);\nVAR44 = safeMul(VAR43, VAR24);\nVAR44 = safeAdd(VAR44,\nsafeDiv( safeMul(VAR44, VAR41), 100) );\n}\nVAR32 = safeAdd(VAR32, VAR43);\nVAR34 = safeAdd(VAR34, VAR44);\nFUN11(msg.sender, VAR44);\nif (VAR33 >= VAR22) {\nVAR30 = true;\n}\nif (VAR33 >= VAR23) {\nVAR30 = true;\nVAR31 = true;\n}\n}\nmodifier FUN13() { if ((now >= VAR12) || (VAR33 >= VAR23)) _; }\nfunction FUN14() public FUN13 {\nif (VAR33 >= VAR22) {\nVAR30 = true;\n}\nVAR31 = true;\n}\nfunction FUN15() public FUN13 {\nif (!VAR30 && VAR21 != msg.sender) {\nuint VAR43 = VAR42[msg.sender];\nif (VAR43 > 0) {\nmsg.sender.FUN7(VAR43);\nVAR42[msg.sender] = 0;\n}\n}\nif (VAR30 && VAR21 == msg.sender) {\nif (address(this).balance > 0) {\nmsg.sender.FUN7(address(this).balance);\nVAR27 = 0;\n}\n}\n}\nfunction FUN16() public {\nrequire(VAR21 == msg.sender);\nif(VAR27 > 0) {\nmsg.sender.FUN7(VAR27);\nVAR27 = 0;\n}\n}\n}",
        "label": false,
        "name": "0xe8b1b40f2d307bce891833f46eef1f69560e6926.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR16) public FUN11 {\nFUN14(VAR16);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR16) internal {\nVAR18.add(VAR16);\n}\nfunction FUN15(address VAR16) internal {\nVAR18.remove(VAR16);\n}\n}\ncontract CON5 is CON3, CON4 {\nfunction FUN16(address VAR10, uint256 VAR11) public FUN11 returns (bool) {\nFUN7(VAR10, VAR11);\nreturn true;\n}\n}\ncontract CON6 {\naddress private VAR19;\nconstructor () internal {\nVAR19 = msg.sender;\n}\nmodifier FUN17() {\nrequire(isOwner());\n_;\n}\nfunction FUN18() public FUN17 {\nVAR19 = address(0);\n}\nfunction FUN19(address VAR20) public FUN17 {\nFUN20(VAR20);\n}\nfunction FUN20(address VAR20) internal {\nrequire(VAR20 != address(0));\nVAR19 = VAR20;\n}\n}\ncontract CON7 {\n}\ncontract CON8 {\n}\ncontract CON9 is CON6 {\naddress public VAR21;\naddress public VAR22;\nmodifier FUN21(address VAR23) {\nuint VAR24;\nassembly { VAR24 := extcodesize(VAR23) }\nrequire(VAR24 > 0);\n_;\n}\nconstructor(address VAR25, address VAR26) public {\nVAR21 = VAR25;\nVAR22 = VAR26;\n}\nfunction FUN22(address VAR25) public FUN17 FUN21(VAR25) {\nrequire(VAR21 != VAR25, \"The address cannot be the same\");\naddress VAR27 = VAR21;\nVAR21 = VAR25;\n}\nfunction FUN23(address VAR26) public FUN17 FUN21(VAR26) {\nrequire(VAR22 != VAR26, \"The address cannot be the same\");\naddress VAR28 = VAR22;\nVAR22 = VAR26;\n}\n}\ncontract CON10 is CON2, CON5, CON6 {\nuint8 constant public VAR29 = 0;\nstring constant public VAR30 = \"CH0465030796\";\nCON9 public VAR31;\nconstructor(CON9 VAR32, string memory VAR1, string memory VAR2) public\nCON2(VAR1, VAR2, VAR29)\n{\nrequire(address(VAR32) != address(0), \"Uninitialized or undefined address\");\nVAR31 = VAR32;\n}\nfunction FUN1(address VAR33, uint256 VAR34) public returns (bool) {\nrequire(FUN28(msg.sender, balanceOf(msg.sender), VAR34), \"Cannot send vested amount!\");\nrequire(FUN26(msg.sender, VAR33, VAR34), \"Cannot FUN1!\");\nreturn super.FUN1(VAR33, VAR34);\n}\nfunction FUN3(address VAR35, address VAR33, uint256 VAR34) public returns (bool) {\nrequire(FUN28(VAR35, balanceOf(VAR35), VAR34), \"Cannot send vested amount!\");\nrequire(FUN26(VAR35, VAR33, VAR34), \"Cannot FUN1!\");\nreturn super.FUN3(VAR35, VAR33, VAR34);\n}\nfunction FUN24(address VAR35, address VAR33, uint256 VAR34) public returns (bool) {\nrequire(FUN27(VAR35, VAR33, VAR34), \"Not VAR42!\");\nFUN6(VAR35, VAR33, VAR34);\nreturn true;\n}\nfunction FUN25(address VAR36, uint VAR37) public returns (uint8) {\nreturn FUN29(VAR36, VAR37);\n}\nfunction FUN26(address VAR35, address VAR33, uint256 VAR34) private returns (bool) {\nuint8 VAR38 = VAR25().check(address(this), msg.sender, VAR35, VAR33, VAR34);\nreturn VAR38 == 0;\n}\nfunction FUN27(address VAR35, address VAR33, uint256 VAR34) private returns (bool) {\nuint8 VAR39 = VAR25().forceCheck(address(this), msg.sender, VAR35, VAR33, VAR34);\nreturn VAR39 == 0;\n}\nfunction FUN28(address VAR40, uint256 VAR41, uint256 VAR34) private returns (bool) {\nbool VAR42 = VAR25().checkVested(address(this), msg.sender, VAR40, VAR41, VAR34);\nreturn VAR42;\n}\nfunction FUN29(address VAR43, uint VAR37) private returns (uint8) {\nuint8 VAR44 = VAR26().check(address(this), msg.sender, VAR43, VAR37);\nreturn VAR44;\n}\n}",
        "label": false,
        "name": "0xff7a0282d23138dccb55334f1beced4b5ddffb1a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN4(uint256 VAR6) public {\nrequire(VAR6 <= VAR3[msg.sender]);\naddress VAR7 = msg.sender;\nVAR3[VAR7] = VAR3[VAR7].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON5 is CON2 {\n}\ncontract CON6 is CON5, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR9]);\nrequire(VAR6 <= VAR8[VAR9][msg.sender]);\nVAR3[VAR9] = VAR3[VAR9].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR6) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON1 {\naddress public VAR14;\nbool VAR15;\nbool public VAR16 = false;\nfunction FUN9(address VAR17) external {\nrequire(VAR17 != address(0));\nrequire(VAR15 == false);\nVAR14 = VAR17;\nVAR15 = true;\n}\nmodifier FUN10() {\nif(msg.sender != VAR14) {\nrequire(!VAR16);\n}\n_;\n}\nmodifier FUN11() {\nrequire(VAR16);\n_;\n}\nfunction FUN12() FUN1 FUN10 public {\nVAR16 = true;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR16 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\nfunction FUN6(address VAR10, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN6(VAR10, VAR6);\n}\nfunction FUN7(address VAR10, uint VAR11) public FUN10 returns (bool VAR18) {\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN8(address VAR10, uint VAR12) public FUN10 returns (bool VAR18) {\nreturn super.FUN8(VAR10, VAR12);\n}\n}\ncontract CON9 is CON6, CON1 {\nmapping (address => bool) public VAR19;\nfunction FUN14(address VAR20) public FUN1 {\nVAR19[VAR20] = true;\n}\nfunction FUN15(address VAR20) public FUN1 {\nVAR19[VAR20] = false;\n}\nmodifier FUN16(address VAR21) {\nrequire(!VAR19[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN16(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN16(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON10 is CON6, CON1 {\nmapping (address => uint) public VAR22;\nfunction FUN17(address VAR20, uint VAR23) public FUN1 {\nuint VAR24;\nVAR24 = now + (VAR23 * 1 days);\nVAR22[VAR20] = VAR24;\n}\nfunction FUN18(address VAR20) public FUN1 {\nVAR22[VAR20] = now;\n}\nmodifier FUN19(address VAR21) {\nrequire(now >= VAR22[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN19(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN19(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON11 is CON10, CON9, CON8, CON4 {\nstring public constant VAR25 = \"TTON\";\nstring public constant VAR26 = \"TTON\";\nuint public constant VAR27 = 18;\nuint public constant VAR28 = 1000000000 * (10 ** VAR27);\nconstructor() public {\nVAR4 = VAR28;\nVAR3[msg.sender] = VAR4;\n}\n}",
        "label": false,
        "name": "0xabdac5fcbb870e6d28821db3cc8f132b5c7e940d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nuint256 public VAR4;\nuint256 public VAR5;\naddress public VAR6;\nmapping(address => uint256) public VAR7;\nuint256 public VAR8;\nuint256 public VAR9;\nuint256 public VAR10;\nfunction CON3(uint256 VAR11,uint256 VAR12,uint256 VAR13,uint256 VAR14,address VAR15) public {\nrequire(VAR12 > VAR11);\nrequire(VAR13 > 0);\nrequire(VAR14 > VAR13);\nrequire(VAR15 != address(0));\nVAR4 = VAR11;\nVAR5 = VAR12;\nVAR9 = VAR13;\nVAR10 = VAR14;\nVAR6 = VAR15;\n}\nfunction () external payable {\nFUN8(msg.sender);\n}\nfunction FUN8(address VAR16) public FUN3 payable {\nrequire(VAR16 != address(0));\nrequire(validPurchase());\nuint256 VAR17 = msg.value;\nVAR8 = VAR8.add(VAR17);\nVAR7[VAR16] = VAR7[VAR16].add(VAR17);\nFUN9();\n}\nfunction FUN9() internal {\nVAR6.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x2c30840965f8fb2dc42bf4d6d530661d9f0e73c3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint private VAR17 = 1000000000e8;\nconstructor () public\nCON3(\"Decimated Token\", \"DIO\", 8)\n{\nFUN7(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0x35a5cb585d51d836922b78a9bb1f5c04635c39b6.sol"
    },
    {
        "source": "contract CON1{\nusing SafeMath for uint;\nmapping (address => uint) public VAR1;\nmapping (address => uint) public VAR2;\nuint VAR3 = 1000;\nuint VAR4 = 2000;\nuint VAR5 = 3000;\nuint VAR6 = 4000;\nuint VAR7 = 5000;\nuint VAR8 = 1 days;\nuint public VAR9;\nuint public VAR10;\nuint public VAR11;\nuint public VAR12;\nmodifier FUN1(){\nrequire(VAR1[msg.sender] > 0, \"Deposit not found\");\n_;\n}\nmodifier FUN2(){\nrequire(now >= VAR2[msg.sender].add(VAR8), \"Too fast payout request. The VAR2 of payment has not yet come\");\n_;\n}\nfunction FUN3()FUN1 FUN2 private{\nuint VAR13 = getDepositMultiplier();\nVAR2[msg.sender] = now;\nmsg.sender.transfer(VAR13);\nVAR10+=VAR13;\nVAR12 =now;\n}\nfunction FUN4() private{\nif(msg.value > 0){\nif (VAR1[msg.sender] == 0){\nVAR11+=1;\n}\nif(getDepositMultiplier() > 0 && now >= VAR2[msg.sender].add(VAR8) ){\nFUN3();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR9+=msg.value;\n}else{\nFUN3();\n}\n}\nfunction() external payable{\nrequire((VAR1[msg.sender] + msg.value) >= VAR1[msg.sender]);\nFUN4();\n}\n}",
        "label": false,
        "name": "0xdbb885c8b2b2aeb3dc6b4348d5af20bf5d9db50d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR6 != address(0));\nuint256 VAR9 = VAR5[VAR8][msg.sender];\nVAR4[VAR8] = VAR4[VAR8].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR5[VAR8][msg.sender] = VAR9.sub(VAR7);\nreturn true;\n}\nfunction FUN5(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR4[VAR10];\n}\nfunction FUN6(address VAR12, uint256 VAR7) public returns (bool) {\nVAR5[msg.sender][VAR12] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR10, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR10][VAR12];\n}\n}\ncontract CON4 is CON3, CON1 {\nstring public VAR14 = \"CreditAsia Coin\";\nstring public VAR15 = \"CAC\";\nuint public VAR16 = 18;\nuint public constant VAR17 = 10000000000e18;\nuint public constant VAR18 = 10000000000e18;\naddress public constant VAR19 = 0xbb90E8310a78f99aB776985A9B7ecDf39ace98e9;\nmapping(address => uint256) public VAR20;\nmapping(address => uint256) public VAR21;\nmapping(address => uint256) public VAR22;\nmapping(address => uint256) public VAR23;\nmodifier FUN8(address VAR24, uint256 VAR7) {\nrequire(VAR24 != address(0));\nuint256 VAR13 = VAR4[VAR24].sub(VAR7);\nuint256 VAR25 = 0;\nif (VAR20[VAR24] > 0) {\nVAR25 = VAR25.add(FUN9(VAR24));\n}\nif (VAR21[VAR24] > 0) {\nVAR25 = VAR25.add(FUN10(VAR24));\n}\nrequire(VAR13 >= VAR25);\n_;\n}\nfunction CON4() public {\nVAR4[msg.sender] = VAR17;\nVAR3 = VAR17;\nFUN3(VAR19, VAR18);\n}\nfunction FUN9(address VAR26)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR27 = VAR22[VAR26];\nuint256 VAR28 = VAR20[VAR26];\nif (now <= VAR27 + (90 * 1 days )) {return VAR28;}\nreturn 0;\n}\nfunction FUN10(address VAR29)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR30 = VAR23[VAR29];\nuint256 VAR28 = VAR21[VAR29];\nif (now <= VAR30) {return VAR28;}\nif (now <= VAR30 + 90 days) {return VAR28;}\nreturn 0;\n}\nfunction FUN11(address VAR26, uint256 VAR7, uint256 VAR31)\npublic\nFUN1\n{\nrequire(VAR26 != address(0));\nVAR20[VAR26] = VAR7;\nVAR22[VAR26] = VAR31;\n}\nfunction FUN12(address VAR29, uint256 VAR7, uint256 VAR32)\npublic\nFUN1\n{\nrequire(VAR29 != address(0));\nVAR21[VAR29] = VAR7;\nVAR23[VAR29] = VAR32;\n}\nfunction FUN3(address VAR6, uint VAR7)\npublic\nFUN8(msg.sender, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN3(VAR6, VAR7);\n}\nfunction FUN4(address VAR8, address VAR6, uint VAR7)\npublic\nFUN8(VAR8, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN4(VAR8, VAR6, VAR7);\n}\n}",
        "label": false,
        "name": "0x038651c3e304c7764a3cab885195e04de3ae271e.sol"
    },
    {
        "source": "contract ValidetherOracle {\r\n\r\n    mapping (string => address) nameToAddress;\r\n      mapping (address => string) addressToName;\r\n\r\n  address admin;\r\n\r\n  modifier onlyAdmin {\r\n     if (msg.sender != admin) throw;\r\n     _\r\n  }\r\n\r\n  \r\n  function ValidetherOracle() {\r\n    admin = msg.sender;\r\n  }\r\n\r\n  \r\n  function addInstitution(address institutionAddress, string institutionName) onlyAdmin {\r\n    nameToAddress[institutionName] = institutionAddress;\r\n    addressToName[institutionAddress] = institutionName;\r\n  }\r\n\r\n  \r\n  function getInstitutionByAddress(address institutionAddress) constant returns(string) {\r\n    return addressToName[institutionAddress];\r\n  }\r\n\r\n  \r\n  function getInstitutionByName(string institutionName) constant returns(address) {\r\n    return nameToAddress[institutionName];\r\n  }\r\n\r\n  \r\n  function setNewAdmin(address newAdmin) onlyAdmin {\r\n    admin = newAdmin;\r\n  }\r\n\r\n}",
        "label": false,
        "name": "0x6e7f987907320630b7880eecc26b17c0d9afa7b4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{\nusing SafeMath for uint256;\nstring public constant VAR1 = \"HHEM\";\nstring public constant VAR2 = \"Healthureum\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 150000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nrequire (msg.sender == VAR5);\n_;\n}\nconstructor() public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) external FUN1 {\nrequire( VAR8 <= VAR6[VAR5]);\nVAR4 = (VAR4).sub(VAR8);\nVAR6[VAR5] = VAR6[VAR5].sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10) public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x5a8b0fa9f5ca7a79fc13ed248150e051537a2ba5.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (uint => uint) VAR3;\nuint public VAR4;\nfunction FUN3(uint VAR5, uint VAR6)\nFUN1\n{\nVAR3[VAR5] = VAR6;\nif (VAR5 > VAR4) VAR4 = VAR5;\n}\nfunction FUN4(uint VAR5)\npublic\nconstant\nreturns (uint)\n{\nuint VAR7 = VAR5;\nif (VAR7 == 0) VAR7 = VAR4;\nreturn VAR3[VAR7];\n}\n}",
        "label": false,
        "name": "0x4ef405d78be762c0e5628b1b93ef6c7ead2d9385.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 80000000000000000000000000;\nVAR6 = 80000000000000000000000000;\nVAR3 = \"Convenient Rural Link\";\nVAR4 = \"CRL\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xacac2019b9c3b100ed78a61208dcb64db4a60e44.sol"
    },
    {
        "source": "contract CON1\n{\nmapping (address => uint256) public VAR1;\n}\ncontract CON2\n{\nusing SafeMath for uint256;\naddress payable public VAR2 = 0xf18ddD2Ed8d7dAe0Fc711b100Ea3b5ea0BFD0183;\nuint256 VAR3 = 1000;\nCON1 VAR4 = CON1(0x063b98a414EAA1D4a5D4fC235a22db1427199024);\nstruct InvestorData {\nuint256 VAR5;\nuint256 VAR6;\nuint256 VAR7;\n}\nmapping (address => InvestorData) VAR8;\nmodifier FUN1()\n{\nassert(msg.sender == VAR2);\n_;\n}\nfunction FUN2(uint256 VAR9) public FUN1 {\nVAR2.transfer(VAR9);\n}\nfunction FUN3(address payable VAR10) public FUN1 {\nVAR2 = VAR10;\n}\nfunction FUN4(uint256 VAR11) public FUN1 {\nVAR3 = VAR11;\n}\nfunction FUN5 (address VAR12, address VAR13, uint256 VAR9) FUN1 public\n{\nCON1(VAR12).transfer(VAR13, VAR9);\n}\nfunction() payable external\n{\nassert(msg.sender == tx.origin);\nif (msg.sender == VAR2) return;\nassert(VAR4.VAR1(msg.sender) >= VAR3 * 10**18);\nInvestorData storage VAR14 = VAR8[msg.sender];\nif (msg.value > 0)\n{\nassert(msg.value >= 2 ether || (VAR14.VAR5 != 0 && msg.value >= 0.01 ether));\nif (msg.VAR14.length == 20) {\naddress payable VAR15 = bytesToAddress(msg.VAR14);\nassert(VAR15 != msg.sender);\nVAR15.transfer(msg.value.mul(25).div(100)); VAR2.transfer(msg.value.mul(5).div(100)); } else if (msg.VAR14.length == 0) {\nVAR2.transfer(msg.value.mul(30).div(100));\n} else {\nassert(false); }\n}\nif (VAR14.VAR5 != 0) {\nuint256 VAR16 = VAR14.VAR5.mul(20).div(100).mul(block.timestamp - VAR14.VAR6).div(30 days);\nVAR14.VAR7 = VAR14.VAR7.add(VAR16);\naddress(msg.sender).transfer(VAR16);\n}\nVAR14.VAR6 = block.timestamp;\nVAR14.VAR5 = VAR14.VAR5.add(msg.value.mul(70).div(100));\n}\n}",
        "label": false,
        "name": "0x9c235ac2c33077a30593a3fd27a0087c687a80a3.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nmodifier FUN1(uint VAR4) {\nrequire(msg.data.length >= (VAR4 + 4));\n_;\n}\nfunction () public{\nrevert();\n}\nfunction FUN3(address VAR5) public constant returns (uint VAR6) {\nreturn VAR2[VAR5];\n}\nfunction FUN4(address VAR5, address VAR7) public constant returns (uint256 VAR8) {\nreturn VAR3[VAR5][VAR7];\n}\nfunction FUN5(address VAR9, uint VAR10) public FUN1(2 * 32) returns (bool VAR11) {\nFUN7(msg.sender, VAR9, VAR10);\nreturn true;\n}\nfunction FUN6(address VAR12, address VAR9, uint256 VAR10) public FUN1(3 * 32) returns (bool) {\nVAR3[VAR12][msg.sender] = VAR3[VAR12][msg.sender].sub(VAR10);\nFUN7(VAR12, VAR9, VAR10);\nreturn true;\n}\nfunction FUN7(address VAR12, address VAR9, uint256 VAR10) internal {\nrequire(VAR10 > 0);\nVAR2[VAR12] = VAR2[VAR12].sub(VAR10);\nVAR2[VAR9] = VAR2[VAR9].add(VAR10);\n}\nfunction FUN8(address VAR7, uint256 VAR10) public returns (bool) {\nrequire((VAR10 == 0) || (VAR3[msg.sender][VAR7] == 0));\nVAR3[msg.sender][VAR7] = VAR10;\nreturn true;\n}\n}\ncontract CON3 {\naddress public VAR13;\nfunction CON3() public {\nVAR13 = msg.sender;\n}\nmodifier FUN9 {\nif (msg.sender != VAR13) revert();\n_;\n}\nfunction FUN10(address VAR14) public FUN9 {\nVAR13 = VAR14;\n}\n}\ncontract CON4 is CON2, CON3{\nusing SafeMath for uint256;\nstring public VAR15 = 'IQF TOKEN';\nstring public VAR16 = 'IQF';\nuint8 public VAR17 = 8;\nuint256 public VAR1 = 10000000000000000;\nfunction CON4() public {\nVAR2[this] = VAR1;\n}\nfunction FUN11(address VAR18, uint256 VAR10) public FUN9 {\nVAR2[this] = VAR2[this].sub(VAR10);\nVAR2[VAR18] = VAR2[VAR18].add(VAR10);\n}\nfunction FUN12() public FUN9 {\nVAR1 = VAR1.sub(VAR2[this]);\nVAR2[this] = 0;\n}\n}",
        "label": false,
        "name": "0x15223c63a203731db1a2ebfe5277a55f77a453b9.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public VAR1 = \"BitandPay\";\nstring public VAR2 = \"BNP\";\nuint256 public VAR3 = 250000000;\nuint8 public VAR4 = 0;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nuint256 public VAR8 = 1513296000; uint256 public VAR9 = 1518739199;\nuint256 public VAR10 = 1428571428571400 wei;\nuint256 public VAR11;\nbool public VAR12 = false;\nuint256 VAR13;\nuint256 public VAR14 = 1000000 ether;\nmodifier FUN1() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN2() {\nrequire(VAR12);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction CON2() public {\nVAR5 = msg.sender;\nVAR6[VAR5] = 250000000;\n}\nfunction VAR3() constant public returns (uint256 VAR15) {\nreturn VAR3;\n}\nfunction FUN4(address VAR16) constant public returns (uint256 VAR17) {\nreturn VAR6[VAR16];\n}\nfunction FUN5(address VAR18, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire(VAR18 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR19);\nVAR6[VAR18] = VAR6[VAR18].add(VAR19);\nreturn true;\n}\nfunction FUN6(address VAR21, address VAR18, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire(VAR18 != address(0));\nvar VAR22 = VAR7[VAR21][msg.sender];\nVAR6[VAR21] = VAR6[VAR21].sub(VAR19);\nVAR6[VAR18] = VAR6[VAR18].add(VAR19);\nVAR7[VAR21][msg.sender] = VAR22.sub(VAR19);\nreturn true;\n}\nfunction FUN7(address VAR23, uint256 VAR19) FUN1 public returns (bool VAR20) {\nrequire((VAR19 == 0) || (VAR7[msg.sender][VAR23] == 0));\nVAR7[msg.sender][VAR23] = VAR19;\nreturn true;\n}\nfunction FUN8(address VAR24, address VAR23) constant public returns (uint256 VAR25) {\nreturn VAR7[VAR24][VAR23];\n}\nfunction FUN9 (address VAR23, uint VAR26) FUN1 public\nreturns (bool VAR20) {\nVAR7[msg.sender][VAR23] = VAR7[msg.sender][VAR23].add(VAR26);\nreturn true;\n}\nfunction FUN10 (address VAR23, uint VAR27) FUN1 public\nreturns (bool VAR20) {\nuint VAR28 = VAR7[msg.sender][VAR23];\nif (VAR27 > VAR28) {\nVAR7[msg.sender][VAR23] = 0;\n} else {\nVAR7[msg.sender][VAR23] = VAR28.sub(VAR27);\n}\nreturn true;\n}\nfunction FUN11(address VAR18, uint256 VAR29) FUN3 public returns (bool VAR20) {\nVAR3 = VAR3.add(VAR29);\nVAR6[VAR18] = VAR6[VAR18].add(VAR29);\nreturn true;\n}\nfunction () payable public {\nFUN13(msg.sender);\n}\nfunction FUN13(address VAR30) payable FUN1 public {\nrequire(FUN14());\nuint256 VAR31 = msg.value;\nuint256 VAR32 = VAR31.mul(VAR10);\nrequire(VAR6[this] > VAR32);\nVAR11 = VAR11.add(VAR31);\nVAR6[VAR30] = VAR6[VAR30].add(VAR32); VAR6[this] = VAR6[this].sub(VAR32);\n}\nfunction FUN14() internal constant returns (bool) {\nbool VAR33 = now >= VAR8 && now <= VAR9;\nbool VAR34 = msg.value != 0;\nbool VAR35 = VAR11.add(msg.value) <= VAR14;\nreturn VAR33 && VAR34 && VAR35;\n}\nfunction FUN15() public constant returns (bool) {\nbool VAR36 = VAR11 >= VAR14;\nreturn now > VAR9 || VAR36;\n}\nfunction FUN16(uint256 VAR37) FUN3 public {\nrequire(VAR37 > 0);\nVAR14 = VAR37;\n}\nfunction FUN17(uint256 VAR38) FUN3 public {\nVAR10 = VAR38;\n}\nfunction FUN18() FUN3 FUN1 public {\nVAR12 = true;\n}\nfunction FUN19() FUN3 FUN2 public {\nVAR12 = false;\n}\nfunction FUN20() FUN3 public {\nselfdestruct(VAR5);\n}\nfunction FUN21(address VAR39) FUN3 public {\nselfdestruct(VAR39);\n}\nfunction FUN22(address VAR40) FUN3 public {\nVAR5 = VAR40;\n}\nfunction FUN23(CON1 VAR41) external FUN3 {\nVAR13 = VAR41.FUN4(this);\nVAR41.FUN5(VAR5, VAR13);\nVAR13 = 0;\n}\nfunction FUN24(uint256 VAR29) FUN3 public {\nrequire(this.VAR17 >= VAR29);\nVAR5.FUN5(VAR29);\n}\nfunction FUN25(address VAR18, uint256 VAR29) FUN3 public {\nrequire(VAR18 != address(0));\nrequire(this.VAR17 >= VAR29);\nVAR18.FUN5(VAR29);\n}\n}",
        "label": false,
        "name": "0x4b2ca6b25e063d8dce5bd862f99669a67ec44c9d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nfunction FUN1(bytes32 VAR2) public payable {\nif(msg.value > 0) {\nVAR1.transfer(msg.value);\n}\n}\nfunction () public payable {\nif(msg.value > 0) {\nVAR1.transfer(msg.value);\n}\n}\n}",
        "label": false,
        "name": "0x16e98489427c86094e67b72d70743783afdd82c3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR4;\nuint256 internal VAR5;\nfunction FUN9(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR7 <= VAR4[msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic returns (bool) {\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nrequire(VAR6 != address(0));\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN11(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN12(address VAR10, uint256 VAR11)\npublic returns (bool) {\nVAR8[msg.sender][VAR10] = (VAR8[msg.sender][VAR10].add(VAR11));\nreturn true;\n}\nfunction FUN13(address VAR10, uint256 VAR12)\npublic returns (bool) {\nuint256 VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 >= VAR13) VAR8[msg.sender][VAR10] = 0;\nelse VAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\nreturn true;\n}\n}\ncontract CON7 is CON6, CON1 {\nfunction FUN14(address VAR14, uint256 VAR7) FUN1 public {\nrequire(VAR7 <= VAR4[VAR14]);\nVAR4[VAR14] = VAR4[VAR14].sub(VAR7);\nVAR5 = VAR5.sub(VAR7);\n}\n}\ncontract CON8 is CON6, CON1 {\nbool public VAR15 = false;\nmodifier FUN15() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN16() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN17(address VAR6, uint256 VAR16)\npublic FUN16 FUN15 returns (bool) {\nVAR5 = VAR5.add(VAR16);\nVAR4[VAR6] = VAR4[VAR6].add(VAR16);\nreturn true;\n}\nfunction FUN18() public FUN1 FUN15 returns (bool) {\nVAR15 = true;\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nuint256 public VAR17;\nconstructor(uint256 VAR18) public {\nrequire(VAR18 > 0);\nVAR17 = VAR18;\n}\nfunction FUN17(address VAR6, uint256 VAR16) public returns (bool) {\nrequire(VAR5.add(VAR16) <= VAR17);\nreturn super.FUN17(VAR6, VAR16);\n}\n}\ncontract CON10 is CON6, CON2 {\nfunction FUN9(address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint256 VAR7)\npublic FUN5 returns (bool) {\nreturn super.FUN11(VAR10, VAR7);\n}\nfunction FUN12(address VAR10, uint VAR11)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN12(VAR10, VAR11);\n}\nfunction FUN13(address VAR10, uint VAR12)\npublic FUN5 returns (bool VAR19) {\nreturn super.FUN13(VAR10, VAR12);\n}\n}\ncontract CON11 is CON7, CON10, CON9 {\naddress public VAR20;\nbool public VAR21;\nstring public VAR22 = \"contact@cryptocontrol.io\";\nstring public VAR23 = \"CryptoControl\";\nstring public VAR24;\nstring public VAR25 = \"CCIO\";\nuint8 public VAR26 = 8;\nconstructor () CON9(100000000000000000000) public {}\nmodifier FUN19(uint VAR27) {\nrequire(!(msg.data.length < VAR27 + 4), \"payload too big\");\n_;\n}\nfunction FUN9(address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferByLegacy(msg.sender, VAR6, VAR7);\nelse return super.FUN9(VAR6, VAR7);\n}\nfunction FUN10(address VAR9, address VAR6, uint VAR7) public FUN5 returns (bool) {\nif (VAR21) return CON12(VAR20).transferFromByLegacy(msg.sender, VAR9, VAR6, VAR7);\nelse return super.FUN10(VAR9, VAR6, VAR7);\n}\nfunction FUN11(address VAR10, uint VAR7) public FUN19(2 * 32) returns (bool) {\nif (VAR21) return CON12(VAR20).approveByLegacy(msg.sender, VAR10, VAR7);\nelse return super.FUN11(VAR10, VAR7);\n}\nfunction FUN20(address VAR28, string memory VAR29) public FUN1 {\nVAR21 = true;\nVAR20 = VAR28;\nVAR24 = VAR29;\n}\n}\ncontract CON12 is CON10 {\n}",
        "label": false,
        "name": "0x4a9e09f6d1f643ee5f3b02039843d774a224577a.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bytes32 VAR1) public {\n}\n}",
        "label": false,
        "name": "0x5b36eb873b5e91c6405407b6d508f670a7c60d4b.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR2;\nfunction CON3() {\nVAR2 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN2(address VAR3) FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint;\naddress public VAR4 = 0x0A9465529653815E61E5187517392d9C10d0f9dd;\naddress public VAR5 = 0xa7A1F840CF741B96F5A80D5856ae02F0f474251f;\nCON2 public VAR6;\nuint public VAR7 = 1521435600; uint public VAR8 = 1523854800; uint public VAR9 = 1526274000;\nuint public VAR10 = 1000000000000000000;\nuint public VAR11 = 2000000*VAR10;\nuint public VAR12 = 6000000*VAR10;\nuint public VAR13 = 8000000*VAR10;\nuint public VAR14 = 0;\nuint public VAR15 = 200000*VAR10;\nuint public VAR16 = 0;\nuint public VAR17 = 1000000000000000; uint public VAR18 = 2000000000000000; uint public VAR19 = 4000000000000000;\nfunction CON4(){\nVAR2 = msg.sender;\nVAR6 = CON2(VAR5);\n}\nfunction FUN3() constant returns (uint256) {\nreturn VAR6.balanceOf(address(this));\n}\nfunction FUN4(address VAR20) FUN1 {\nVAR5 = VAR20;\nVAR6 = CON2(VAR5);\n}\nfunction FUN5(address VAR21, uint VAR22) FUN1 returns (bool) {\nreturn VAR6.transfer(VAR21, VAR22);\n}\nfunction() payable {\nFUN7();\n}\nfunction FUN7() payable {\nrequire(now >= VAR7);\nrequire(msg.value >= 100000000000000);\nuint VAR23 = msg.value;\nuint VAR24 = 0;\nuint VAR25 = 0;\nif(now >= VAR7 && now < VAR8){\nrequire(VAR11 > VAR14);\nVAR25 = VAR23.mul(VAR10).div(VAR17);\nif(VAR25.add(VAR14) > VAR11) {\nVAR25 = VAR11.sub(VAR14);\nVAR24 = VAR23.sub(VAR25.mul(VAR17).div(VAR10));\n}\n} else if(now >= VAR8 && now < VAR9){\nrequire(VAR12 > VAR14);\nVAR25 = VAR23.mul(VAR10).div(VAR18);\nif(VAR25.add(VAR14) > VAR12) {\nVAR25 = VAR12.sub(VAR14);\nVAR24 = VAR23.sub(VAR25.mul(VAR18).div(VAR10));\n}\n} else {\nrequire(VAR13 > VAR14);\nVAR25 = VAR23.mul(VAR10).div(VAR19);\nif(VAR25.add(VAR14) > VAR13) {\nVAR25 = VAR13.sub(VAR14);\nVAR24 = VAR23.sub(VAR25.mul(VAR19).div(VAR10));\n}\n}\nVAR14 = VAR14.add(VAR25);\nif(VAR16 < VAR15 && VAR25 >= 500*VAR10){\nuint VAR26 = 0;\nif(VAR25 >= 500*VAR10 && VAR25 <1000*VAR10)\n{\nVAR26 = 20*VAR10;\n} else if ( VAR25 >= 1000*VAR10 && VAR25 <5000*VAR10 ) {\nVAR26 = 100*VAR10;\n} else if ( VAR25 >= 5000*VAR10 && VAR25 <10000*VAR10 ) {\nVAR26 = 600*VAR10;\n} else if ( VAR25 >= 10000*VAR10 ) {\nVAR26 = 1500*VAR10;\n}\nVAR26 = (VAR26 < (VAR15 - VAR16) ) ? VAR26 : (VAR15 - VAR16);\nVAR16 = VAR16.add(VAR26);\nVAR25 = VAR25.add(VAR26);\n}\nrequire(FUN3() > VAR25);\nrequire(VAR6.transfer(msg.sender, VAR25));\nif(VAR24==0){\nVAR4.transfer(msg.value);\n}else{\nVAR4.transfer(msg.value.sub(VAR24));\nmsg.sender.transfer(VAR24);\n}\n}\n}",
        "label": false,
        "name": "0x116676d386404238f54589ccdbbce1638aa8cb0d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1) {\nthrow;\n}\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\nfunction FUN3() FUN1 {\nselfdestruct(VAR1);\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 public VAR4;\nmodifier FUN4(uint256 VAR5) {\nif(msg.data.length < VAR5 + 4) {\nthrow;\n}\n_;\n}\nfunction FUN5(address VAR6, uint256 VAR7) FUN4(2 * 32) {\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN6(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR3[VAR8];\n}\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) VAR10;\nfunction FUN7(address VAR11, address VAR6, uint256 VAR7) FUN4(3 * 32) {\nvar VAR12 = VAR10[VAR11][msg.sender];\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\nVAR3[VAR11] = VAR3[VAR11].sub(VAR7);\nVAR10[VAR11][msg.sender] = VAR12.sub(VAR7);\n}\nfunction FUN8(address VAR13, uint256 VAR7) {\nif ((VAR7 != 0) && (VAR10[msg.sender][VAR13] != 0)) throw;\nVAR10[msg.sender][VAR13] = VAR7;\n}\nfunction FUN9(address VAR8, address VAR13) constant returns (uint256 VAR14) {\nreturn VAR10[VAR8][VAR13];\n}\n}\ncontract CON6 is CON5, CON1 {\nstring public constant VAR15 = \"Blockracing Share\";\nstring public constant VAR16 = \"BRS\";\nuint256 public constant VAR17 = 8;\nfunction CON6(){\nVAR1 = msg.sender;\nVAR4=13200000000000000;\nVAR3[VAR1]=VAR4;\n}\nfunction () {\nthrow;\n}\n}",
        "label": false,
        "name": "0xa85c95aba6c298535890d6f1133632220d458e9a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1 = \"StalentCoin\";\nstring public VAR2 = \"STC\";\nuint8 public VAR3 = 0;\nuint256 public VAR4 = 150000000;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xfaf8f6632a22051993baedf0451088fee63089fa.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR18.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR18.remove(VAR10);\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN18(address VAR4, uint256 VAR5) public FUN13 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON7 {\naddress private VAR19;\nconstructor () internal {\nVAR19 = msg.sender;\n}\nmodifier FUN19() {\nrequire(isOwner());\n_;\n}\nfunction FUN20() public FUN19 {\nVAR19 = address(0);\n}\nfunction FUN21(address VAR20) public FUN19 {\nFUN22(VAR20);\n}\nfunction FUN22(address VAR20) internal {\nrequire(VAR20 != address(0));\nVAR19 = VAR20;\n}\n}\ninterface CON8 {\n}\ncontract CON9 is CON2, CON4, CON6, CON3, CON7 {\nuint constant private VAR21 = 21000000000e18; string constant public VAR22 = \"QQQ Token\";\nstring constant public VAR23 = \"QQQ\";\nuint8 constant public VAR24 = 18;\naddress constant internal VAR25 = address(0);\nCON8 public VAR26;\nconstructor()\nCON2()\nCON4(VAR22, VAR23, VAR24)\nCON6()\nCON3()\nCON7()\npublic\n{\nFUN7(msg.sender, VAR21);\n}\nfunction FUN23(address VAR27) external FUN19 {\nVAR26 = CON8(VAR27);\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nbool VAR28;\nVAR28 = FUN24(msg.sender, VAR4, VAR5);\nif (VAR28) {\nFUN6(msg.sender, VAR4, VAR5);\n}\nreturn VAR28;\n}\nfunction FUN24(address VAR7, address VAR4, uint256 VAR29) private returns (bool) {\nif (address(VAR26) == VAR25) {\nreturn true;\n}\nreturn VAR26.FUN24(msg.sender, VAR7, VAR4, VAR29);\n}\n}",
        "label": false,
        "name": "0x2822f6d1b2f41f93f33d937bc7d84a8dfa4f4c21.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 6;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nfunction CON4(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] > VAR14); require (VAR7[VAR13] + VAR14 > VAR7[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\n}",
        "label": false,
        "name": "0xfdde51fdfca83be086d6da0ba303fc68db15c5f4.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nuint256 public VAR4;\nuint256 public VAR5;\naddress public VAR6;\naddress public VAR7;\nmapping(address => uint256) public VAR8;\nuint256 public VAR9;\nuint256 public VAR10;\nuint256 public VAR11;\nuint256 public VAR12;\nmapping (address => bool) public VAR13;\nfunction CON3(uint256 VAR14,uint256 VAR15,uint256 VAR16,uint256 VAR17,uint256 VAR18,address VAR19,address VAR20) public {\nrequire(VAR15 > VAR14);\nrequire(VAR16 > 0);\nrequire(VAR17 > VAR16);\nrequire(VAR20 != address(0));\nVAR4 = VAR14;\nVAR5 = VAR15;\nVAR7 = VAR19;\nVAR11 = VAR16;\nVAR12 = VAR17;\nVAR10 = VAR18;\nVAR6 = VAR20;\n}\nfunction () external payable {\nFUN8(msg.sender);\n}\nfunction FUN8(address VAR21) public FUN3 payable {\nrequire(VAR21 != address(0));\nrequire(validPurchase());\nuint256 VAR22 = msg.value;\nif (VAR22 >= VAR10) {\nrequire(VAR13[VAR21]);\n}\nVAR9 = VAR9.add(VAR22);\nVAR8[VAR21] = VAR8[VAR21].add(VAR22);\nFUN10();\n}\nfunction FUN9(address VAR23, bool VAR24) public {\nrequire(msg.sender == VAR7);\nVAR13[VAR23] = VAR24;\n}\nfunction FUN10() internal {\nVAR6.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x6b87e4542044b1a17c44d0103ee9365e010dad36.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"Street Credit\";\nstring public constant VAR2 = \"STREET\";\nuint8 public constant VAR3 = 18;\nuint public constant VAR4 = 100000000 * 10**uint(VAR3);\nmapping(address => uint) public VAR5;\nmapping(address => mapping (address => uint256)) internal VAR6;\nuint public constant VAR7 = 10 szabo;\naddress private constant VAR8 = 0xff1A7c1037CDb35CD55E4Fe5B73a26F9C673c2bc;\nfunction CON1() public {\nVAR5[VAR8] = VAR4;\n}\nfunction () public payable {\nFUN3(msg.sender);\n}\nfunction FUN2(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR5[msg.sender]);\nrequire(VAR5[msg.sender] + VAR10 >= VAR5[msg.sender]);\nVAR5[msg.sender] -= VAR10;\nVAR5[VAR9] += VAR10;\nreturn true;\n}\nfunction FUN3(address VAR11) public payable returns (bool) {\nrequire(VAR11 != address(0));\nrequire(VAR5[VAR8] > 0);\nrequire(msg.value != 0);\nuint VAR12 = msg.value / VAR7;\nVAR8.FUN2(msg.value);\nVAR5[VAR8] -= VAR12;\nVAR5[VAR11] += VAR12;\nreturn true;\n}\nfunction FUN4(address VAR13, address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR5[VAR13]);\nrequire(VAR10 <= VAR6[VAR13][msg.sender]);\nVAR5[VAR13] -= VAR10;\nVAR5[VAR9] += VAR10;\nVAR6[VAR13][msg.sender] -= VAR10;\nreturn true;\n}\nfunction FUN5(address VAR14, uint256 VAR10) public returns (bool) {\nVAR6[msg.sender][VAR14] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14, uint VAR15) public returns (bool) {\nVAR6[msg.sender][VAR14] += VAR15;\nreturn true;\n}\nfunction FUN7(address VAR14, uint VAR16) public returns (bool) {\nuint VAR17 = VAR6[msg.sender][VAR14];\nif (VAR16 > VAR17) {\nVAR6[msg.sender][VAR14] = 0;\n} else {\nVAR6[msg.sender][VAR14] = VAR17 - VAR16;\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe6b46cb05644e930862b8d4ed86260522a4ce3b9.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ninterface CON3 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6 = 18;\nuint public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nmapping (address => bool) public VAR10;\nmapping (address => uint256) public VAR11;\nconstructor(uint256 VAR12,string VAR13,string VAR14) public {\nVAR7 = VAR12 * 10 ** uint256(VAR6);\nVAR8[msg.sender] = VAR7;\nVAR5 = VAR13;\nVAR4 = VAR14;\n}\nfunction FUN7(address VAR15, address VAR16, uint VAR17) FUN3 internal {\nrequire (VAR16 != 0x0);\nrequire(!VAR10[VAR15]);\nrequire(!VAR10[VAR16]);\nuint256 VAR18 = VAR8[VAR15].sub(VAR17);\nrequire(VAR11[VAR15] == 0 || VAR18 >= VAR11[VAR15]);\nVAR8[VAR15] = VAR18;\nVAR8[VAR16] = VAR8[VAR16].add(VAR17);\n}\nfunction FUN8(address VAR16, uint256 VAR17)\npublic\nreturns (bool VAR19) {\nFUN7(msg.sender, VAR16, VAR17);\nreturn true;\n}\nfunction FUN9(address VAR15, address VAR16, uint256 VAR17)\npublic\nreturns (bool VAR19) {\nVAR9[VAR15][msg.sender] = VAR9[VAR15][msg.sender].sub(VAR17);\nFUN7(VAR15, VAR16, VAR17);\nreturn true;\n}\nfunction FUN10(address VAR20, uint256 VAR17) FUN1\npublic\nreturns (bool VAR19) {\nVAR9[msg.sender][VAR20] = VAR17;\nreturn true;\n}\nfunction FUN11(address VAR20, uint256 VAR17, bytes VAR21) FUN1\npublic\nreturns (bool VAR19) {\nCON3 VAR22 = CON3(VAR20);\nif (FUN10(VAR20, VAR17)) {\nVAR22.receiveApproval(msg.sender, VAR17, this, VAR21);\nreturn true;\n}\n}\nfunction FUN12(uint256 VAR17)\npublic\nreturns (bool VAR19) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR17);\nVAR7 = VAR7.sub(VAR17);\nreturn true;\n}\nfunction FUN13(address VAR23, bool VAR24) FUN1 public {\nVAR10[VAR23] = VAR24;\n}\nfunction FUN14(address VAR23, uint256 VAR17) FUN1 public {\nrequire(VAR17 > 0);\nVAR11[VAR23] = VAR17;\n}\nfunction FUN15(address VAR23) FUN1 public {\nVAR11[VAR23] = 0;\n}\n}",
        "label": false,
        "name": "0xcb33c7a2cff4d770fdbff7454cc58825a94f990e.sol"
    },
    {
        "source": "contract CON1{\nuint256 public VAR1=86400; uint256 public VAR2=300;\nuint256 VAR3=10000;\nuint256 VAR4=5000;\nbool public VAR5=false;\naddress public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => uint256) public VAR9;\nmapping (address => address) public VAR10;\nuint256 public VAR11;\nconstructor() public\n{\nVAR6=msg.sender;\n}\nfunction FUN1(address VAR12) public\n{\nrequire(VAR5);\nif(VAR10[msg.sender]==0 && VAR10[msg.sender]!=msg.sender)\n{\nVAR10[msg.sender]=VAR12;\n}\nuint256 VAR13=getMyPoohs();\nuint256 VAR14=SafeMath.div(VAR13,VAR1);\nVAR7[msg.sender]=SafeMath.add(VAR7[msg.sender],VAR14);\nVAR8[msg.sender]=0;\nVAR9[msg.sender]=now;\nVAR8[VAR10[msg.sender]]=SafeMath.add(VAR8[VAR10[msg.sender]],SafeMath.div(VAR13,5));\nVAR11=SafeMath.add(VAR11,SafeMath.div(VAR13,10));\n}\nfunction FUN2() public{\nrequire(VAR5);\nuint256 VAR15=getMyPoohs();\nuint256 VAR16=calculatePoohSell(VAR15);\nuint256 VAR17=devFee(VAR16);\nVAR7[msg.sender] = SafeMath.div(VAR7[msg.sender],2);\nVAR8[msg.sender]=0;\nVAR9[msg.sender]=now;\nVAR11=SafeMath.add(VAR11,VAR15);\nVAR6.transfer(VAR17);\nmsg.sender.transfer(SafeMath.sub(VAR16,VAR17));\n}\nfunction FUN3() public payable\n{\nrequire(VAR5);\nuint256 VAR18=calculatePoohBuy(msg.value,SafeMath.sub(address(this).balance,msg.value));\nVAR18=SafeMath.sub(VAR18,devFee(VAR18));\nVAR6.transfer(devFee(msg.value));\nVAR8[msg.sender]=SafeMath.add(VAR8[msg.sender],VAR18);\n}\nfunction FUN4(uint256 VAR19) public payable\n{\nrequire(VAR11==0);\nVAR5=true;\nVAR11=VAR19;\n}\nfunction FUN5() public payable\n{\nrequire(VAR5);\nrequire(msg.value==0.001 ether); VAR6.transfer(msg.value); require(VAR7[msg.sender]==0);\nVAR9[msg.sender]=now;\nVAR7[msg.sender]=VAR2;\n}\n}",
        "label": false,
        "name": "0x1054bf40be3e021e26fa5f6d627fe395a3fd3f26.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"TST\";\nstring public constant VAR2 = \"Test\";\nuint8 public constant VAR3 = 18;\nuint256 VAR4 = 100000000000000000000;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nthrow;\n}\n_;\n}\nfunction CON2() {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2() constant returns (uint256 FUN2) {\nFUN2 = VAR4;\n}\nfunction FUN3(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR6[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR11) returns (bool VAR12) {\nif (VAR6[msg.sender] >= VAR11 && VAR11 > 0 && VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR13, address VAR10, uint256 VAR11) returns (bool VAR12) {\nif (VAR6[VAR13] >= VAR11 && VAR7[VAR13][msg.sender] >= VAR11 && VAR11 > 0 && VAR6[VAR10] + VAR11 > VAR6[VAR10]) {\nVAR6[VAR13] -= VAR11;\nVAR7[VAR13][msg.sender] -= VAR11;\nVAR6[VAR10] += VAR11;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR14, uint256 VAR11) returns (bool VAR12) {\nVAR7[msg.sender][VAR14] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR8, address VAR14) constant returns (uint256 VAR15) {\nreturn VAR7[VAR8][VAR14];\n}\n}",
        "label": false,
        "name": "0x4688f0dd8fc54a3d52ec6b13135ba93488e49f13.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 VAR1;\nmodifier FUN1(bytes32 VAR2) {\nif (address(VAR1) != 0x0 && VAR1.hasRole(this, VAR2, msg.sender)) {\n_;\n}\n}\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nif (!VAR3.claimFor(this, msg.sender) && !VAR3.isOwner(this, msg.sender)) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON3 {\nmapping (address => bool) VAR4;\nfunction FUN3(address VAR5) FUN1('admin') returns(bool) {\nVAR4[VAR5] = true;\nreturn true;\n}\nfunction FUN4(address VAR5) FUN1('admin') returns(bool) {\nVAR4[VAR5] = false;\nreturn true;\n}\nfunction FUN5(address VAR5) public constant returns (bool) {\nreturn VAR4[VAR5];\n}\n}",
        "label": false,
        "name": "0x36dbc64ac3322070390eeaaff22c0d02d5b33fac.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 public VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.data.length>=(2*32)+4);\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nrequire(VAR4==0||VAR5[msg.sender][VAR7]==0);\nrequire(msg.data.length>=(2*32)+4);\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR11;\nstring public VAR12;\nuint8 public VAR13;\nuint256 public VAR14=2;\nuint256 public VAR15=70;\nuint256 public VAR16=10;\nuint256 public VAR17=10;\nuint256 public VAR18=10;\naddress public VAR19;\naddress public VAR20;\naddress public VAR21;\naddress public VAR22;\nuint256 public VAR23;\nuint256 public VAR24;\nuint256 public VAR25;\nuint256 public VAR26;\nconstructor(string VAR27,string VAR28, uint8 VAR29, uint256 VAR30,address VAR31,address VAR32,address VAR33,address VAR34) public {\nVAR11 = VAR27;\nVAR12 = VAR28;\nVAR13 = VAR29;\nVAR2 = VAR30*10**uint256(VAR29);\nVAR19=VAR31;\nVAR20=VAR32;\nVAR21=VAR33;\nVAR22=VAR34;\nVAR23=VAR2.mul(VAR15).div(10 ** VAR14);\nVAR24=VAR2.mul(VAR16).div(10 ** VAR14);\nVAR25=VAR2.mul(VAR17).div(10 ** VAR14);\nVAR26=VAR2.mul(VAR18).div(10 ** VAR14);\nVAR1[VAR31]=VAR23;\nVAR1[VAR32]=VAR24;\nVAR1[VAR33]=VAR25;\nVAR1[VAR34]=VAR26;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction() public payable{\nrevert();\n}\n}",
        "label": false,
        "name": "0x66decc2bf3ae56399d1492905c161954bf32b423.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstruct Bet {\nuint256 VAR1;\nuint256 VAR2;\nuint256 VAR3;\nbool VAR4;\n}\nmapping(address => Bet) public VAR5;\nuint256 public VAR6;\nmapping(address => uint256) private VAR7;\nuint256 public VAR8;\nuint256 constant public VAR9 = 1e18; uint256 constant private VAR10 = 100;\naddress constant private VAR11 = address(0x058a144951e062FC14f310057D2Fd9ef0Cf5095b);\nCON2 constant private VAR12 = CON2(VAR11);\naddress constant private VAR13 = address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\nstruct Shareholder {\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\n}\nuint256 constant private VAR17 = 20000e18;\nuint256 public VAR18;\nmapping(address => Shareholder) public VAR19;\nbool public VAR20 = true;\nuint256 constant private VAR21 = 10e18;\nuint256 private VAR22;\nuint256 public VAR23;\nuint256 constant private VAR24 = 1 hours;\nuint256 private VAR25;\nmodifier FUN1()\n{\nif(now - VAR25 > VAR24 && VAR18 > 0) {\nFUN13();\n}\n_;\n}\nfunction() external payable {}\nfunction FUN3(address VAR26, uint256 VAR1, bytes calldata VAR27)\nexternal\nFUN1\n{\nrequire(msg.sender == VAR11);\nif(VAR27[0] == 0) {\nFUN10(VAR26, VAR1);\n} else {\nFUN5(VAR26, VAR1, uint8(VAR27[0]));\n}\n}\nfunction FUN4(uint256 VAR1, uint256 VAR2)\nexternal\nFUN1\n{\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR1);\nFUN5(msg.sender, VAR1, VAR2);\n}\nfunction FUN5(address VAR26, uint256 VAR1, uint256 VAR2)\nprivate\n{\nrequire(VAR2 >= 1 && VAR2 <= 98);\nrequire(VAR1 >= VAR9);\nif(hasActiveBet(VAR26)) {\nFUN7(VAR26);\n}\nuint256 VAR28 = VAR28(VAR1, VAR2);\nrequire(VAR28 <= maximumProfit());\nVAR5[VAR26] = Bet(VAR1, VAR2, block.number + 1, true);\nVAR6++;\nVAR8 = VAR8.add(VAR1);\nif(VAR20) {\nFUN11(VAR26, VAR28 < VAR1 ? VAR28 : VAR1);\n}\n}\nfunction FUN6()\nexternal\nFUN1\n{\nrequire(hasActiveBet(msg.sender));\nFUN7(msg.sender);\n}\nfunction FUN7(address VAR26)\nprivate\n{\nBet storage VAR29 = VAR5[VAR26];\nrequire(VAR29.VAR3 < block.number);\nVAR29.VAR4 = false;\nif(block.number - 256 > VAR29.VAR3) {\nreturn;\n}\nuint256 VAR30 = (uint256(blockhash(VAR29.VAR3)) % 100) + 1;\nif(VAR30 <= VAR29.VAR2) {\nuint256 VAR31 = VAR29.VAR1.mul(99) / VAR29.VAR2;\nVAR7[VAR26] = VAR7[VAR26].add(VAR31);\nVAR8 = VAR8.sub(VAR31);\n} else {\n}\n}\nfunction FUN8()\nexternal\nFUN1\n{\nuint256 VAR1 = VAR7[msg.sender];\nrequire(VAR1 > 0);\nVAR7[msg.sender] = 0;\nVAR12.transfer(msg.sender, VAR1);\n}\nfunction FUN9()\nexternal\n{\nShareholder storage VAR32 = VAR19[msg.sender];\nFUN12(VAR32);\nuint256 VAR1 = VAR32.VAR15;\nrequire(VAR1 > 0);\nVAR32.VAR15 = 0;\nVAR23 = VAR23.sub(VAR1);\nmsg.sender.transfer(VAR1);\n}\nfunction FUN10(address VAR26, uint256 VAR1)\nprivate\n{\nrequire(VAR20);\nVAR8 = VAR8.add(VAR1);\nFUN11(VAR26, VAR1);\n}\nfunction FUN11(address VAR26, uint256 VAR1)\nprivate\n{\nuint256 VAR33;\nif(VAR18.add(VAR1) < VAR17) {\nVAR33 = VAR1;\n} else {\nVAR33 = VAR17.sub(VAR18);\nVAR20 = false;\n}\nShareholder storage VAR34 = VAR19[VAR26];\nShareholder storage VAR35 = VAR19[VAR13];\nFUN12(VAR34);\nFUN12(VAR35);\nVAR18 = VAR18.add(VAR33);\nVAR34.VAR14 = VAR34.VAR14.add(VAR33.mul(19) / 20);\nVAR35.VAR14 = VAR35.VAR14.add(VAR33 / 20);\n}\nfunction FUN12(Shareholder storage VAR32)\nprivate\n{\nuint256 VAR36 = VAR22.sub(VAR32.VAR16);\nVAR32.VAR16 = VAR22;\nVAR32.VAR15 = VAR32.VAR15\n.add(VAR36.mul(VAR32.VAR14) / VAR21);\n}\nfunction FUN13()\npublic\n{\nVAR25 = now;\nuint256 VAR37 = VAR12.dividendsOf(address(this), true);\nif(VAR37 > 0) {\nVAR12.withdraw();\nVAR22 = VAR22.add(VAR37.mul(VAR21) / VAR18);\nVAR23 = VAR23.add(VAR37);\n}\n}\n}\ninterface CON2 {\n}",
        "label": false,
        "name": "0x59891b95010267f7a3666dcb3221059a73e11ad1.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5\n{\nstring public VAR17 = \"Dis Token\";\nstring public VAR18 = \"DIS\";\nuint public VAR19 = 2;\nuint private constant VAR20 = 10 * 10**(6+2);\nfunction CON6()\n{\nVAR15 = msg.sender;\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\n}",
        "label": false,
        "name": "0x339f0a7ec421e751d3727be6c83492c56979b408.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1() {\n}\n}",
        "label": false,
        "name": "0xa657a8cfa71397fb360f8d95f372adfd46a57644.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nconstructor(string VAR6, string VAR7, uint8 VAR8) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\n}\ncontract CON5 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR9;\nuint256 internal VAR10;\nfunction FUN5(address VAR11, uint256 VAR12) public returns (bool) {\nrequire(VAR12 <= VAR9[msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON6 is CON3, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR13;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[VAR14]);\nrequire(VAR12 <= VAR13[VAR14][msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nVAR13[VAR14][msg.sender] = VAR13[VAR14][msg.sender].sub(VAR12);\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR12) public returns (bool) {\nVAR13[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN8(address VAR15,uint256 VAR16)\npublic\nreturns (bool)\n{\nVAR13[msg.sender][VAR15] = (VAR13[msg.sender][VAR15].add(VAR16));\nreturn true;\n}\nfunction FUN9(address VAR15,uint256 VAR17)\npublic\nreturns (bool)\n{\nuint256 VAR18 = VAR13[msg.sender][VAR15];\nif (VAR17 >= VAR18) {\nVAR13[msg.sender][VAR15] = 0;\n} else {\nVAR13[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint internal constant VAR19 = 2**256 - 1;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nuint VAR20 = VAR13[VAR14][msg.sender];\nrequire(VAR12 <= VAR9[VAR14], \"insufficient balance\");\nrequire(VAR12 <= VAR20, \"insufficient allowance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][msg.sender] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[msg.sender], \"insufficient balance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON8 is CON7, CON4, CON1 {\nbool public VAR21 = false;\nbool public VAR22 = false;\nmapping (address => bool) public VAR23;\nmodifier FUN10() {\nrequire(!VAR21);\n_;\n}\nmodifier FUN11() {\nrequire(VAR23[msg.sender]);\n_;\n}\nmodifier FUN12() {\nrequire(!VAR22);\n_;\n}\nconstructor()\npublic\nCON4(\"bZx Protocol Token\",\"BZRX\",18)\n{\nVAR23[msg.sender] = true;\n}\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN6(VAR14,VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN5(VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN13(address VAR15,address VAR14,address VAR11,uint256 VAR12)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(canTransfer(VAR15,VAR14,VAR12),\"canTransfer is false\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nuint VAR20 = VAR13[VAR14][VAR15];\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][VAR15] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN14(address VAR11,uint256 VAR24)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR10 = VAR10.add(VAR24);\nVAR9[VAR11] = VAR9[VAR11].add(VAR24);\nreturn true;\n}\nfunction FUN15()\npublic\nFUN1\nFUN10\n{\nVAR21 = true;\n}\nfunction FUN16()\npublic\nFUN1\nFUN12\n{\nVAR22 = true;\n}\nfunction FUN17(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = true;\n}\nfunction FUN18(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = false;\n}\n}\ncontract CON9 is CON1 {\nusing SafeMath for uint256;\naddress public VAR26;\nmapping (address => uint) public VAR27;\nconstructor(address VAR28)\npublic\n{\nVAR26 = VAR28;\n}\nfunction()\npublic\n{\nrevert();\n}\nfunction FUN6(address VAR14,address VAR11,uint256 VAR24)\npublic\nreturns (bool)\n{\nrequire(VAR24 <= VAR27[msg.sender], \"insufficient FUN5 allowance\");\nVAR27[msg.sender] = VAR27[msg.sender].sub(VAR24);\nreturn CON8(VAR26).FUN13(msg.sender,VAR14,VAR11,VAR24);\n}\nfunction FUN20(address VAR29,uint VAR24)\npublic\nFUN1\n{\nVAR27[VAR29] = VAR24;\n}\nfunction FUN21(address VAR28)\npublic\nFUN1\n{\nVAR26 = VAR28;\n}\nfunction FUN22(address VAR30,address VAR11,uint VAR12)\npublic\nFUN1\nreturns (bool)\n{\nuint VAR31 = CON6(VAR30).balanceOf.gas(4999)(this);\nif (VAR12 > VAR31) {\nreturn CON6(VAR30).FUN5(VAR11,VAR31);\n} else {\nreturn CON6(VAR30).FUN5(VAR11,VAR12);\n}\n}\n}",
        "label": false,
        "name": "0x88b0652919467b1e47cd1a1fd676cd1940d2fa69.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON2 is CON1 {\nbool private VAR3;\nconstructor () internal {\nVAR3 = false;\n}\nmodifier FUN6() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN7() {\nrequire(VAR3);\n_;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = true;\n}\nfunction FUN9() public FUN1 FUN7 {\nVAR3 = false;\n}\n}\ncontract CON3 {\naddress private VAR4;\nconstructor () internal {\nVAR4 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR4 = address(0);\n}\nfunction FUN12(address VAR5) public FUN10 {\nFUN13(VAR5);\n}\nfunction FUN13(address VAR5) internal {\nrequire(VAR5 != address(0));\nVAR4 = VAR5;\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public VAR6 = 0;\nuint256 public VAR7 = 375;\nuint256 public VAR8 = 0.008 ether;\nuint256 public VAR9 = 161280;\naddress public VAR10 = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\nCON5 VAR11;\nconstructor() internal {\nVAR11 = CON5(VAR10);\n}\nfunction FUN14(uint256 VAR12) external FUN10 {\nrequire(VAR12 <= 10000, 'new successful VAR33 fee must be in basis points (hundredths of a percent), not wei');\nVAR7 = VAR12;\n}\nfunction FUN15(uint256 VAR13) external FUN10 {\nVAR8 = VAR13;\n}\nfunction FUN16(uint256 VAR14) external FUN10 {\nVAR9 = VAR14;\n}\nfunction FUN17() external FUN10 {\nuint256 VAR15 = VAR6;\nVAR6 = 0;\nmsg.sender.transfer(VAR15);\n}\nfunction() external payable {\nrevert('please call the FUN19() function on the CON6 contract if you wish to open a VAR33');\n}\n}\ncontract CON5 {\nmapping (uint256 => address) public VAR16;\n}\ncontract CON6 is CON4 {\nusing SafeMath for uint256;\nstruct Bounty {\nuint256 VAR17;\nuint256 VAR18;\nuint128 VAR19;\nuint128 VAR20;\nuint128 VAR8;\nuint64 VAR21;\nuint16 VAR22;\nuint16 VAR23;\naddress VAR24;\n}\nmapping (uint256 => Bounty) public VAR25;\nuint256 public VAR26 = 0;\nmapping (uint256 => bool) public VAR27;\nfunction FUN19(uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR31, uint256 VAR32) external payable FUN6 {\nrequire(msg.value >= VAR8.mul(uint256(2)), 'the value of your VAR33 must be at least twice as large as the unsuccessful VAR33 fee');\nrequire(VAR32 <= VAR9, 'you cannot lock eth into a VAR33 for longer than the maximumLockoutDuration');\nrequire(VAR31 <= uint256(13), 'you cannot specify an invalid cooldown index');\nrequire(VAR30 <= uint256(~uint16(0)), 'you cannot specify an invalid VAR22');\nuint256 VAR19 = _computeBountyPrice(msg.value, VAR7);\nuint256 VAR21 = uint256(block.number).add(VAR32);\nBounty memory VAR33 = Bounty({VAR17: VAR28,VAR18: VAR29,VAR19: uint128(VAR19),VAR20: uint128(msg.value),VAR8: uint128(VAR8),VAR21: uint64(VAR21),VAR22: uint16(VAR30),VAR23: uint16(VAR31),VAR24: msg.sender});\nVAR25[VAR26] = VAR33;\nVAR27[VAR26] = true;\nVAR26 = VAR26.add(uint256(1));\n}\nfunction FUN20(uint256 VAR34, uint256 VAR35) external FUN6 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nrequire(msg.sender == VAR11.ownerOf(VAR35), 'you do not own the cat that you are trying to use to fulfill this VAR33');\nrequire(VAR11.VAR16(VAR35) == address(this), 'you must approve the bounties contract for this cat before you can fulfill a VAR33');\nBounty storage VAR33 = VAR25[VAR34];\nuint256 VAR36;\nuint256 VAR22;\nuint256 VAR18;\n( , , VAR36, , , , , , VAR22, VAR18) = VAR11.getKitty(VAR35);\nrequire((uint16(VAR33.VAR22) == ~uint16(0) || uint16(VAR22) == uint16(VAR33.VAR22)), 'your cat is not the correct VAR22 to fulfill this VAR33');\nrequire(VAR18 & VAR33.VAR17 == VAR33.VAR18, 'your cat does not have the correct VAR18 to fulfill this VAR33');\nrequire(uint16(VAR36) <= uint16(VAR33.VAR23), 'your cat does not have a low enough cooldown index to fulfill this VAR33');\nVAR27[VAR34] = false;\nVAR11.transferFrom(msg.sender, VAR33.VAR24, VAR35);\nuint256 VAR37 = uint256(VAR33.VAR20).sub(uint256(VAR33.VAR19));\nVAR6 = VAR6.add(VAR37);\nmsg.sender.transfer(uint256(VAR33.VAR19));\n}\nfunction FUN21(uint256 VAR34) external FUN6 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nBounty storage VAR33 = VAR25[VAR34];\nrequire(msg.sender == VAR33.VAR24, 'you cannot withdraw the funds for someone elses VAR33');\nrequire(block.number >= uint256(VAR33.VAR21), 'this VAR33 is not withdrawable until the minimum number of blocks that were originally specified have passed');\nVAR27[VAR34] = false;\nVAR6 = VAR6.add(uint256(VAR33.VAR8));\nuint256 VAR38 = uint256(VAR33.VAR20).sub(uint256(VAR33.VAR8));\nmsg.sender.transfer(VAR38);\n}\nfunction FUN22(uint256 VAR34) external FUN7 {\nrequire(VAR27[VAR34], 'this VAR33 has either already completed or has not yet begun');\nBounty storage VAR33 = VAR25[VAR34];\nrequire(msg.sender == VAR33.VAR24, 'you cannot withdraw the funds for someone elses VAR33');\nVAR27[VAR34] = false;\nmsg.sender.transfer(uint256(VAR33.VAR20));\n}\nfunction() external payable {\nrevert('please call the FUN19() function if you wish to submit funds to the contract');\n}\n}",
        "label": false,
        "name": "0xcb52e6ba959d1c9b2c56ab1696271bd874c85bfd.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR6 != address(0));\nuint256 VAR9 = VAR5[VAR8][msg.sender];\nVAR4[VAR8] = VAR4[VAR8].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR5[VAR8][msg.sender] = VAR9.sub(VAR7);\nreturn true;\n}\nfunction FUN5(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR4[VAR10];\n}\nfunction FUN6(address VAR12, uint256 VAR7) public returns (bool) {\nVAR5[msg.sender][VAR12] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR10, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR10][VAR12];\n}\n}\ncontract CON4 is CON3, CON1 {\nstring public VAR14 = \"BOX Token\";\nstring public VAR15 = \"BOX\";\nuint public VAR16 = 18;\nuint public constant VAR17 = 3000000000e18;\nuint public constant VAR18 = 900000000e18; uint public constant VAR19 = 600000000e18; uint public constant VAR20 = 450000000e18; uint public constant VAR21 = 300000000e18; uint public constant VAR22 = 750000000e18;\naddress public constant VAR23 = 0x49dE776A181603b11116E7DaB15d84BE6711D54A;\naddress public constant VAR24 = 0x8546a5a4b3BBE86Bf57fC9F5E497c770ae5D0233;\naddress public constant VAR25 = 0x9f255092008F6163395aEB35c4Dec58a1ecbdFd6;\naddress public constant VAR26 = 0xD6d64A62A7fF8F55841b0DD2c02d5052457bCA6c;\naddress public constant VAR27 = 0x55aaeC60E116086AC3a5e4fDC74b21de9B91CC53;\nmapping(address => uint256) public VAR28;\nmapping(address => uint256) public VAR29;\nmapping(address => uint256) public VAR30;\nmapping(address => uint256) public VAR31;\nmodifier FUN8(address VAR32, uint256 VAR7) {\nrequire(VAR32 != address(0));\nuint256 VAR13 = VAR4[VAR32].sub(VAR7);\nuint256 VAR33 = 0;\nif (VAR28[VAR32] > 0) {\nVAR33 = VAR33.add(FUN9(VAR32));\n}\nif (VAR29[VAR32] > 0) {\nVAR33 = VAR33.add(FUN10(VAR32));\n}\nrequire(VAR13 >= VAR33);\n_;\n}\nfunction CON4() public {\nVAR4[msg.sender] = VAR17;\nVAR3 = VAR17;\nFUN3(VAR23, VAR18);\nFUN3(VAR24, VAR19);\nFUN3(VAR25, VAR20);\nFUN3(VAR26, VAR21);\nFUN3(VAR27, VAR22);\n}\nfunction FUN9(address VAR34)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR35 = VAR30[VAR34];\nuint256 VAR36 = VAR28[VAR34];\nif (now <= VAR35 + (180 * 1 days)) {return VAR36;}\nif (now <= VAR35 + (180 * 2 days)) {return VAR36.mul(7).div(8);}\nif (now <= VAR35 + (180 * 3 days)) {return VAR36.mul(6).div(8);}\nif (now <= VAR35 + (180 * 4 days)) {return VAR36.mul(5).div(8);}\nif (now <= VAR35 + (180 * 5 days)) {return VAR36.mul(4).div(8);}\nif (now <= VAR35 + (180 * 6 days)) {return VAR36.mul(3).div(8);}\nif (now <= VAR35 + (180 * 7 days)) {return VAR36.mul(2).div(8);}\nif (now <= VAR35 + (180 * 8 days)) {return VAR36.mul(1).div(8);}\nreturn 0;\n}\nfunction FUN10(address VAR37)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR38 = VAR31[VAR37];\nuint256 VAR36 = VAR29[VAR37];\nif (now <= VAR38) {return VAR36;}\nif (now <= VAR38 + 90 days) {return VAR36.mul(2).div(3);}\nif (now <= VAR38 + 180 days) {return VAR36.mul(1).div(3);}\nreturn 0;\n}\nfunction FUN11(address VAR34, uint256 VAR7, uint256 VAR39)\npublic\nFUN1\n{\nrequire(VAR34 != address(0));\nVAR28[VAR34] = VAR7;\nVAR30[VAR34] = VAR39;\n}\nfunction FUN12(address VAR37, uint256 VAR7, uint256 VAR40)\npublic\nFUN1\n{\nrequire(VAR37 != address(0));\nVAR29[VAR37] = VAR7;\nVAR31[VAR37] = VAR40;\n}\nfunction FUN3(address VAR6, uint VAR7)\npublic\nFUN8(msg.sender, VAR7)\nreturns (bool VAR41)\n{\nreturn super.FUN3(VAR6, VAR7);\n}\nfunction FUN4(address VAR8, address VAR6, uint VAR7)\npublic\nFUN8(VAR8, VAR7)\nreturns (bool VAR41)\n{\nreturn super.FUN4(VAR8, VAR6, VAR7);\n}\n}",
        "label": false,
        "name": "0x63f584fa56e60e4d0fe8802b27c7e6e3b33e007f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON3;\nCON3 public VAR3;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nconstructor(uint256 VAR7, address VAR8, CON3 VAR9) public {\nrequire(VAR7 > 0);\nrequire(VAR8 != address(0));\nrequire(VAR9 != address(0));\nVAR5 = VAR7;\nVAR4 = VAR8;\nVAR3 = VAR9;\n}\nfunction () external payable {\nFUN6(msg.sender);\n}\nfunction FUN6(address VAR10) public payable {\nuint256 VAR11 = msg.value;\nFUN7(VAR10, VAR11);\nuint256 VAR12 = _getTokenAmount(VAR11);\nVAR6 = VAR6.add(VAR11);\nFUN10(VAR10, VAR12);\nFUN11(VAR10, VAR11);\nFUN12();\nFUN8(VAR10, VAR11);\n}\nfunction FUN7(address VAR10,uint256 VAR13)\ninternal\n{\nrequire(VAR10 != address(0));\nrequire(VAR13 != 0);\n}\nfunction FUN8(address VAR10,uint256 VAR13)\ninternal\n{\n}\nfunction FUN9(address VAR10,uint256 VAR14)\ninternal\n{\nVAR3.safeTransfer(VAR10, VAR14);\n}\nfunction FUN10(address VAR10,uint256 VAR14)\ninternal\n{\nFUN9(VAR10, VAR14);\n}\nfunction FUN11(address VAR10,uint256 VAR13)\ninternal\n{\n}\nfunction FUN12() internal {\nVAR4.FUN16(msg.value);\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nuint256 public VAR15;\nuint256 public VAR16;\nmodifier FUN13 {\nrequire(block.timestamp >= VAR15 && block.timestamp <= VAR16);\n_;\n}\nconstructor(uint256 VAR17, uint256 VAR18) public {\nrequire(VAR17 >= block.timestamp);\nrequire(VAR18 >= VAR17);\nVAR15 = VAR17;\nVAR16 = VAR18;\n}\nfunction FUN7(address VAR10,uint256 VAR13)\ninternal\nFUN13\n{\nsuper.FUN7(VAR10, VAR13);\n}\n}\ncontract CON6 is CON1, CON5 {\nusing SafeMath for uint256;\nbool public VAR19 = false;\nfunction FUN14() public FUN1 {\nrequire(!VAR19);\nrequire(hasClosed());\nFUN15();\nVAR19 = true;\n}\nfunction FUN15() internal {\n}\n}\ncontract CON7 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR20;\nuint256 internal VAR21;\nfunction FUN16(address VAR22, uint256 VAR23) public returns (bool) {\nrequire(VAR23 <= VAR20[msg.sender]);\nrequire(VAR22 != address(0));\nVAR20[msg.sender] = VAR20[msg.sender].sub(VAR23);\nVAR20[VAR22] = VAR20[VAR22].add(VAR23);\nreturn true;\n}\n}\ncontract CON8 is CON3, CON7 {\nmapping (address => mapping (address => uint256)) internal VAR24;\nfunction FUN17(address VAR25,address VAR22,uint256 VAR23)\npublic\nreturns (bool)\n{\nrequire(VAR23 <= VAR20[VAR25]);\nrequire(VAR23 <= VAR24[VAR25][msg.sender]);\nrequire(VAR22 != address(0));\nVAR20[VAR25] = VAR20[VAR25].sub(VAR23);\nVAR20[VAR22] = VAR20[VAR22].add(VAR23);\nVAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].sub(VAR23);\nreturn true;\n}\nfunction FUN18(address VAR26, uint256 VAR23) public returns (bool) {\nVAR24[msg.sender][VAR26] = VAR23;\nreturn true;\n}\nfunction FUN19(address VAR26,uint256 VAR27)\npublic\nreturns (bool)\n{\nVAR24[msg.sender][VAR26] = (VAR24[msg.sender][VAR26].add(VAR27));\nreturn true;\n}\nfunction FUN20(address VAR26,uint256 VAR28)\npublic\nreturns (bool)\n{\nuint256 VAR29 = VAR24[msg.sender][VAR26];\nif (VAR28 >= VAR29) {\nVAR24[msg.sender][VAR26] = 0;\n} else {\nVAR24[msg.sender][VAR26] = VAR29.sub(VAR28);\n}\nreturn true;\n}\n}\ncontract CON9 is CON8, CON1 {\nbool public VAR30 = false;\nmodifier FUN21() {\nrequire(!VAR30);\n_;\n}\nmodifier FUN22() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN23(address VAR22,uint256 VAR31)\npublic\nFUN22\nFUN21\nreturns (bool)\n{\nVAR21 = VAR21.add(VAR31);\nVAR20[VAR22] = VAR20[VAR22].add(VAR31);\nreturn true;\n}\nfunction FUN24() public FUN1 FUN21 returns (bool) {\nVAR30 = true;\nreturn true;\n}\n}\ncontract CON10 is CON4 {\nfunction FUN9(address VAR10,uint256 VAR14)\ninternal\n{\nrequire(CON9(address(VAR3)).FUN23(VAR10, VAR14));\n}\n}\ncontract CON11 is CON1 {\nbool public VAR32 = false;\nmodifier FUN25() {\nrequire(!VAR32);\n_;\n}\nmodifier FUN26() {\nrequire(VAR32);\n_;\n}\nfunction FUN27() public FUN1 FUN25 {\nVAR32 = true;\n}\nfunction FUN28() public FUN1 FUN26 {\nVAR32 = false;\n}\n}\ncontract CON12 {\n}\ncontract CON13 is CON8, CON11 {\nfunction FUN16(address VAR22,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN16(VAR22, VAR23);\n}\nfunction FUN17(address VAR25,address VAR22,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN17(VAR25, VAR22, VAR23);\n}\nfunction FUN18(address VAR26,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN18(VAR26, VAR23);\n}\nfunction FUN19(address VAR26,uint VAR27)\npublic\nFUN25\nreturns (bool VAR33)\n{\nreturn super.FUN19(VAR26, VAR27);\n}\nfunction FUN20(address VAR26,uint VAR28)\npublic\nFUN25\nreturns (bool VAR33)\n{\nreturn super.FUN20(VAR26, VAR28);\n}\n}\ncontract CON14 is CON13, CON9 {\nstring public constant VAR34 = \"Realty Returns Token\";\nstring public constant VAR35 = \"RRT\";\nuint8 public constant VAR36 = 18;\nconstructor() public {\nFUN27();\n}\n}\ncontract CON15 is CON1 {\nusing SafeMath for uint;\nuint256 public VAR37;\nuint256 public VAR38;\nuint256 public VAR39;\nuint256 public VAR40;\nuint256 public VAR41;\nmapping (address => uint256) public VAR42;\nCON3 public VAR43;\nconstructor\n(CON3 VAR9,uint256 VAR44,uint256 VAR45,uint256 VAR46)\npublic\n{\nrequire(VAR9 != address(0));\nVAR43 = CON3(VAR9);\nVAR37 = VAR44;\nVAR38 = VAR45;\nVAR41 = VAR46;\n}\nfunction FUN29(address VAR47, uint256 VAR48)\nexternal\nFUN1\nreturns(bool)\n{\nrequire(VAR42[VAR47] == 0 && VAR47 != address(0));\nVAR40 = VAR40.add(VAR48);\nrequire(VAR40 <= VAR41);\nVAR42[VAR47] = VAR48;\nreturn true;\n}\nfunction FUN30() external {\nrequire(VAR43 != address(0));\nassert(now >= VAR37);\nif (VAR39 == 0) {\nVAR39 = VAR43.balanceOf(this);\n}\nuint256 VAR49 = VAR42[msg.sender];\nVAR42[msg.sender] = 0;\nrequire(VAR43.FUN16(msg.sender, VAR49));\n}\nfunction FUN31() public FUN1 {\nrequire(now >= VAR38);\nuint256 VAR50 = VAR43.balanceOf(this);\nif (VAR50 > 0) {\nVAR43.FUN16(msg.sender, VAR50);\n}\nselfdestruct(VAR1);\n}\n}\ncontract CON16 is CON6, CON10, CON11 {\nuint256 constant public VAR51 = 240000000e18; uint256 constant public VAR52 = 120000000e18; uint256 constant public VAR53 = 120000000e18; uint256 constant public VAR54 = 530000000e18;\nuint256 constant public VAR55 = 190000000e18; uint256 public VAR56 = 1321580e18;\naddress public VAR57;\naddress public VAR58;\naddress public VAR59;\naddress public VAR60;\naddress public VAR61;\nuint256 public VAR62;\naddress public VAR63;\nconstructor\n(uint256 VAR17,uint256 VAR18,CON14 VAR9,uint256 VAR7,address VAR8,address VAR64,address VAR65)\npublic\nCON6()\nCON4(VAR7, VAR8, VAR9)\nCON5(VAR17, VAR18)\n{\nrequire(VAR64 != address(0));\nVAR57 = VAR64;\nVAR63 = VAR65;\nrequire(CON14(VAR3).VAR32());\n}\nfunction FUN32(uint256 VAR66) external FUN1 {\nrequire(VAR66 != 0);\nVAR5 = VAR66;\n}\nfunction FUN33(uint256 VAR67) external FUN1 {\nrequire(VAR67 != 0);\nVAR56 = VAR67;\n}\nfunction FUN34(address VAR68, uint256 VAR69)\npublic\nFUN1\n{\nrequire(VAR68 != address(0));\nrequire(VAR3.totalSupply().add(VAR69) <= VAR55);\nFUN9(VAR68, VAR69);\n}\nfunction FUN35\n(address VAR70,address VAR71,address VAR72)\npublic\nFUN1\n{\nrequire(VAR58 == address(0x0) && VAR59 == address(0x0) && VAR60 == address(0x0));\nrequire(VAR70 != address(0x0) && VAR71 != address(0x0) && VAR72 != address(0x0));\nVAR58 = VAR70;\nVAR59 = VAR71;\nVAR60 = VAR72;\n}\nfunction FUN7(address VAR10, uint256 VAR13)\ninternal\nFUN25\n{\nrequire(VAR10 != address(0));\nrequire(VAR13 >= 1 ether);\nrequire(VAR3.totalSupply() < VAR55);\n}\nfunction FUN12() internal {\nuint256 VAR73 = msg.value.div(100);\nuint256 VAR74 = msg.value.sub(VAR73);\nVAR63.FUN16(VAR73);\nVAR4.FUN16(VAR74);\n}\nfunction FUN15() internal {\nrequire(VAR58 != address(0) && VAR59 != address(0) && VAR60 != address(0));\nif (VAR55 > VAR3.totalSupply()) {\nuint256 VAR75 = VAR55.sub(VAR3.totalSupply());\nFUN9(VAR4, VAR75);\n}\nFUN9(VAR57, VAR51);\nFUN9(VAR58, VAR52);\nFUN9(VAR59, VAR53);\nFUN9(VAR60, VAR54);\nCON14(VAR3).FUN24();\nCON14(VAR3).FUN28();\nsuper.FUN15();\n}\n}",
        "label": false,
        "name": "0x22f004a328fdb5091376d8eaf83adc5bc2a33846.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 5000000000000000000000000000;\nVAR6 = 5000000000000000000000000000;\nVAR3 = \"Bundls Token\";\nVAR4 = \"BUND\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd84246471fdf41e9cb832ea36e33eb51eba56457.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nconstructor(string VAR6, string VAR7, uint8 VAR8) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\n}\ncontract CON5 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR9;\nuint256 internal VAR10;\nfunction FUN5(address VAR11, uint256 VAR12) public returns (bool) {\nrequire(VAR12 <= VAR9[msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON6 is CON3, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR13;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[VAR14]);\nrequire(VAR12 <= VAR13[VAR14][msg.sender]);\nrequire(VAR11 != address(0));\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nVAR13[VAR14][msg.sender] = VAR13[VAR14][msg.sender].sub(VAR12);\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR12) public returns (bool) {\nVAR13[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN8(address VAR15,uint256 VAR16)\npublic\nreturns (bool)\n{\nVAR13[msg.sender][VAR15] = (VAR13[msg.sender][VAR15].add(VAR16));\nreturn true;\n}\nfunction FUN9(address VAR15,uint256 VAR17)\npublic\nreturns (bool)\n{\nuint256 VAR18 = VAR13[msg.sender][VAR15];\nif (VAR17 >= VAR18) {\nVAR13[msg.sender][VAR15] = 0;\n} else {\nVAR13[msg.sender][VAR15] = VAR18.sub(VAR17);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint internal constant VAR19 = 2**256 - 1;\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nuint VAR20 = VAR13[VAR14][msg.sender];\nrequire(VAR12 <= VAR9[VAR14], \"insufficient balance\");\nrequire(VAR12 <= VAR20, \"insufficient allowance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][msg.sender] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR12 <= VAR9[msg.sender], \"insufficient balance\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nreturn true;\n}\n}\ncontract CON8 is CON7, CON4, CON1 {\nbool public VAR21 = false;\nbool public VAR22 = false;\nmapping (address => bool) public VAR23;\nmodifier FUN10() {\nrequire(!VAR21);\n_;\n}\nmodifier FUN11() {\nrequire(VAR23[msg.sender]);\n_;\n}\nmodifier FUN12() {\nrequire(!VAR22);\n_;\n}\nconstructor()\npublic\nCON4(\"bZx Protocol Token\",\"BZRX\",18)\n{\nVAR23[msg.sender] = true;\n}\nfunction FUN6(address VAR14,address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN6(VAR14,VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN5(address VAR11,uint256 VAR12)\npublic\nreturns (bool)\n{\nif (VAR22 || VAR23[msg.sender]) {\nreturn super.FUN5(VAR11,VAR12);\n}\nrevert(\"this token is locked for transfers\");\n}\nfunction FUN13(address VAR15,address VAR14,address VAR11,uint256 VAR12)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(canTransfer(VAR15,VAR14,VAR12),\"canTransfer is false\");\nrequire(VAR11 != address(0), \"token burn not allowed\");\nuint VAR20 = VAR13[VAR14][VAR15];\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR11] = VAR9[VAR11].add(VAR12);\nif (VAR20 < VAR19) {\nVAR13[VAR14][VAR15] = VAR20.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN14(address VAR11,uint256 VAR24)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nrequire(VAR11 != address(0), \"token burn not allowed\");\nVAR10 = VAR10.add(VAR24);\nVAR9[VAR11] = VAR9[VAR11].add(VAR24);\nreturn true;\n}\nfunction FUN15()\npublic\nFUN1\nFUN10\n{\nVAR21 = true;\n}\nfunction FUN16()\npublic\nFUN1\nFUN12\n{\nVAR22 = true;\n}\nfunction FUN17(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = true;\n}\nfunction FUN18(address VAR25)\npublic\nFUN1\nFUN10\n{\nVAR23[VAR25] = false;\n}\n}\ncontract CON9 is CON1 {\nusing SafeMath for uint256;\naddress public VAR26;\nmapping (address => uint) public VAR27;\nstring public VAR3 = \"bZx Protocol Token\";\nstring public VAR4 = \"BZRX\";\nuint8 public VAR5 = 18;\nconstructor(address VAR28)\npublic\n{\nVAR26 = VAR28;\n}\nfunction()\npublic\n{\nrevert();\n}\nfunction FUN6(address VAR14,address VAR11,uint256 VAR24)\npublic\nreturns (bool)\n{\nrequire(VAR24 <= VAR27[msg.sender], \"insufficient FUN5 allowance\");\nVAR27[msg.sender] = VAR27[msg.sender].sub(VAR24);\nreturn CON8(VAR26).FUN13(msg.sender,VAR14,VAR11,VAR24);\n}\nfunction FUN20(address VAR29,uint VAR24)\npublic\nFUN1\n{\nVAR27[VAR29] = VAR24;\n}\nfunction FUN21(address VAR28)\npublic\nFUN1\n{\nVAR26 = VAR28;\n}\nfunction FUN22(address VAR30,address VAR11,uint VAR12)\npublic\nFUN1\nreturns (bool)\n{\nuint VAR31 = CON6(VAR30).balanceOf.gas(4999)(this);\nif (VAR12 > VAR31) {\nreturn CON6(VAR30).FUN5(VAR11,VAR31);\n} else {\nreturn CON6(VAR30).FUN5(VAR11,VAR12);\n}\n}\n}",
        "label": false,
        "name": "0xfad784f7c60a4d3a6d05cb84049e1dba414f3edf.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\nuint256 public VAR1;\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 {\nusing SafeERC20 for CON3;\nCON3 public VAR2;\naddress public VAR3;\nuint256 public VAR4;\nfunction CON5(CON3 VAR5, address VAR6, uint256 VAR7) {\nrequire(VAR7 > now);\nVAR2 = VAR5;\nVAR3 = VAR6;\nVAR4 = VAR7;\n}\nfunction FUN1() public {\nrequire(now >= VAR4);\nuint256 VAR8 = VAR2.FUN12(this);\nrequire(VAR8 > 0);\nVAR2.safeTransfer(VAR3, VAR8);\n}\n}\ncontract CON6 {\naddress public VAR9;\nfunction CON6() {\nVAR9 = msg.sender;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR9);\n_;\n}\nfunction FUN3(address VAR10) FUN2 public {\nrequire(VAR10 != address(0));\nVAR9 = VAR10;\n}\n}\ncontract CON7 is CON6 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON3;\naddress public VAR3;\nuint256 public VAR11;\nuint256 public VAR12;\nuint256 public VAR13;\nbool public VAR14;\nmapping (address => uint256) public VAR15;\nmapping (address => bool) public VAR16;\nfunction CON7(address VAR6, uint256 VAR17, uint256 VAR18, uint256 VAR19, bool VAR20) public {\nrequire(VAR6 != address(0));\nrequire(VAR17 >= now);\nrequire(VAR19 > 0);\nrequire(VAR18 <= VAR19);\nVAR3 = VAR6;\nVAR12 = VAR17;\nVAR11 = VAR17.add(VAR18);\nVAR13 = VAR19;\nVAR14 = VAR20;\n}\nfunction FUN1(CON3 VAR2) public {\nuint256 VAR21 = FUN5(VAR2);\nrequire(VAR21 > 0);\nVAR15[VAR2] = VAR15[VAR2].add(VAR21);\nVAR2.safeTransfer(VAR3, VAR21);\n}\nfunction FUN4(CON3 VAR2) public FUN2 {\nrequire(VAR14);\nrequire(!VAR16[VAR2]);\nuint256 VAR22 = VAR2.FUN12(this);\nuint256 VAR21 = FUN5(VAR2);\nuint256 VAR23 = VAR22.sub(VAR21);\nVAR16[VAR2] = true;\nVAR2.safeTransfer(VAR9, VAR23);\n}\nfunction FUN5(CON3 VAR2) public constant returns (uint256) {\nreturn FUN6(VAR2).sub(VAR15[VAR2]);\n}\nfunction FUN6(CON3 VAR2) public constant returns (uint256) {\nuint256 VAR24 = VAR2.FUN12(this);\nuint256 VAR25 = VAR24.add(VAR15[VAR2]);\nif (now < VAR11) {\nreturn 0;\n} else if (now >= VAR12.add(VAR13) || VAR16[VAR2]) {\nreturn VAR25;\n} else {\nreturn VAR25.mul(now.sub(VAR12)).div(VAR13);\n}\n}\n}\ncontract CON8 is CON6 {\nbool public VAR26 = false;\nmodifier FUN7() {\nrequire(!VAR26);\n_;\n}\nmodifier FUN8() {\nrequire(VAR26);\n_;\n}\nfunction FUN9() FUN2 FUN7 public {\nVAR26 = true;\n}\nfunction FUN10() FUN2 FUN8 public {\nVAR26 = false;\n}\n}\ncontract CON9 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR27;\nfunction FUN11(address VAR28, uint256 VAR29) public returns (bool) {\nrequire(VAR28 != address(0));\nVAR27[msg.sender] = VAR27[msg.sender].sub(VAR29);\nVAR27[VAR28] = VAR27[VAR28].add(VAR29);\nreturn true;\n}\nfunction FUN12(address VAR30) public constant returns (uint256 VAR22) {\nreturn VAR27[VAR30];\n}\n}\ncontract CON10 is CON4, CON9 {\nmapping (address => mapping (address => uint256)) VAR31;\nfunction FUN13(address VAR32, address VAR28, uint256 VAR29) public returns (bool) {\nrequire(VAR28 != address(0));\nuint256 VAR33 = VAR31[VAR32][msg.sender];\nVAR27[VAR32] = VAR27[VAR32].sub(VAR29);\nVAR27[VAR28] = VAR27[VAR28].add(VAR29);\nVAR31[VAR32][msg.sender] = VAR33.sub(VAR29);\nreturn true;\n}\nfunction FUN14(address VAR34, uint256 VAR29) public returns (bool) {\nVAR31[msg.sender][VAR34] = VAR29;\nreturn true;\n}\nfunction FUN15(address VAR30, address VAR34) public constant returns (uint256 VAR35) {\nreturn VAR31[VAR30][VAR34];\n}\nfunction FUN16 (address VAR34, uint VAR36)\nreturns (bool VAR37) {\nVAR31[msg.sender][VAR34] = VAR31[msg.sender][VAR34].add(VAR36);\nreturn true;\n}\nfunction FUN17 (address VAR34, uint VAR38)\nreturns (bool VAR37) {\nuint VAR39 = VAR31[msg.sender][VAR34];\nif (VAR38 > VAR39) {\nVAR31[msg.sender][VAR34] = 0;\n} else {\nVAR31[msg.sender][VAR34] = VAR39.sub(VAR38);\n}\nreturn true;\n}\n}\ncontract CON11 is CON10, CON8 {\nfunction FUN11(address VAR28, uint256 VAR29) public FUN7 returns (bool) {\nreturn super.FUN11(VAR28, VAR29);\n}\nfunction FUN13(address VAR32, address VAR28, uint256 VAR29) public FUN7 returns (bool) {\nreturn super.FUN13(VAR32, VAR28, VAR29);\n}\nfunction FUN14(address VAR34, uint256 VAR29) public FUN7 returns (bool) {\nreturn super.FUN14(VAR34, VAR29);\n}\nfunction FUN16(address VAR34, uint VAR36) public FUN7 returns (bool VAR37) {\nreturn super.FUN16(VAR34, VAR36);\n}\nfunction FUN17(address VAR34, uint VAR38) public FUN7 returns (bool VAR37) {\nreturn super.FUN17(VAR34, VAR38);\n}\n}\ncontract CON12 is CON1, CON2, CON11 {\nuint256 public VAR40;\nuint256 public VAR41;\nmapping (address => uint256) public VAR42;\nfunction CON12(uint256 VAR43, uint256 VAR44) internal {\nrequire(VAR44 > VAR43);\nVAR40 = VAR43;\nVAR41 = VAR44;\n}\nmodifier FUN18(address VAR32, uint VAR29) {\nrequire(block.number >= VAR40);\nif (block.number < VAR41) {\nuint256 VAR45 = FUN19(VAR32);\nif (VAR45 > 0) {\nuint256 VAR46 = FUN12(VAR32).sub(VAR29);\nrequire(VAR46 >= VAR45);\n}\n}\n_;\n}\nfunction FUN19(address VAR28) public constant returns(uint256) {\nuint256 VAR45 = VAR42[VAR28];\nif (block.number >= VAR41) return 0;\nelse if (block.number <= VAR40) return VAR45;\nuint256 VAR47 = VAR45.div(VAR41.sub(VAR40));\nuint256 VAR15 = block.number.sub(VAR40).mul(VAR47);\nreturn VAR45.sub(VAR15);\n}\nfunction FUN11(address VAR28, uint VAR29) FUN18(msg.sender, VAR29) public returns (bool) {\nreturn super.FUN11(VAR28, VAR29);\n}\nfunction FUN13(address VAR32, address VAR28, uint VAR29) FUN18(VAR32, VAR29) public returns (bool) {\nreturn super.FUN13(VAR32, VAR28, VAR29);\n}\nmodifier FUN20() {\nrequire(!FUN21());\n_;\n}\nfunction FUN21() public constant returns(bool VAR48) {\nreturn block.number >= VAR40;\n}\nfunction FUN22(address VAR28, uint256 VAR49) public FUN2 FUN20 returns (bool VAR50) {\nVAR1 = VAR1.add(VAR49);\nVAR27[VAR28] = VAR27[VAR28].add(VAR49);\nreturn true;\n}\nfunction FUN23(address VAR28, uint256 VAR49) public FUN2 FUN20 returns (bool VAR50) {\nVAR42[VAR28] = VAR42[VAR28].add(VAR49);\nreturn FUN22(VAR28, VAR49);\n}\nfunction FUN24(address VAR28, uint256 VAR49, uint256 VAR7) public\nFUN2 FUN20 returns (CON5 VAR51) {\nCON5 VAR52 = new CON5(this, VAR28, VAR7);\nFUN22(VAR52, VAR49);\nreturn VAR52;\n}\nfunction FUN25(address VAR28, uint256 VAR49, uint256 VAR17, uint256 VAR19) public\nFUN2 FUN20 returns (CON7 VAR53) {\nCON7 VAR54 = new CON7(VAR28, VAR17, 0, VAR19, true);\nFUN22(VAR54, VAR49);\nreturn VAR54;\n}\nfunction FUN26(uint256 VAR49) public returns (bool VAR55) {\nVAR27[msg.sender] = VAR27[msg.sender].sub(VAR49);\nVAR1 = VAR1.sub(VAR49);\nreturn true;\n}\nfunction FUN27(CON7 VAR56) public {\nrequire(VAR56 != address(0));\nVAR56.FUN1(this);\n}\nfunction FUN28(CON7 VAR56) public FUN2 {\nrequire(VAR56 != address(0));\nVAR56.FUN4(this);\n}\n}\ncontract CON13 is CON12 {\nstring public constant VAR57 = \"NOKU\";\nstring public constant VAR58 = \"NOKU\";\nuint8 public constant VAR59 = 18;\nfunction CON13(uint256 VAR43, uint256 VAR44)\nCON12(VAR43, VAR44) public {\n}\n}",
        "label": false,
        "name": "0x1fc52f1abade452dd4674477d4711951700b3d27.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ncontract CON2 { }\ncontract CON3 is CON1{\nbytes32 public VAR3;\nbytes32 public VAR4;\nuint8 public VAR5 = 5;\nuint256 public VAR6;\nbool public VAR7 = false;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nmodifier FUN3 {\nassert(VAR1 == msg.sender);\n_;\n}\nmodifier FUN4 {\nassert (!VAR7);\n_;\n}\nmodifier FUN5 {\nassert(0x0 != msg.sender);\n_;\n}\nfunction CON3 () public {\nVAR6 = 15800000000000; VAR8[msg.sender] = 15800000000000; VAR3 = \"Ferrum\"; VAR4 = \"FRM\";\n}\nfunction FUN6(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != 0x0);\nrequire(VAR8[VAR10] >= VAR12);\nrequire(VAR8[VAR11] + VAR12 > VAR8[VAR11]);\nuint VAR13 = VAR8[VAR10] + VAR8[VAR11];\nVAR8[VAR10] -= VAR12;\nVAR8[VAR11] += VAR12;\nassert(VAR8[VAR10] + VAR8[VAR11] == VAR13);\n}\nfunction FUN7(address VAR11, uint256 VAR12) public {\nrequire(VAR8[msg.sender] >= VAR12); require(VAR8[VAR11] + VAR12 >= VAR8[VAR11]); VAR8[msg.sender] -= VAR12; VAR8[VAR11] += VAR12; }\nfunction FUN8(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR9[VAR10][msg.sender]); VAR9[VAR10][msg.sender] -= VAR12;\nFUN6(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN9(address VAR15, uint256 VAR12) FUN4 FUN5 public returns (bool VAR14) {\nrequire(VAR12 == 0 || VAR9[msg.sender][VAR15] == 0);\nVAR9[msg.sender][VAR15] = VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x957b9dc190c4391a1e07352df34e1ec02077f1ec.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0) && VAR2 != VAR1);\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() public FUN1 FUN3 {\nVAR3 = true;\n}\nfunction FUN6() public FUN1 FUN4 {\nVAR3 = false;\n}\n}\ncontract CON3 is CON1 {\nfunction CON3() public payable { }\nfunction FUN7() FUN1 public {\nselfdestruct(VAR1);\n}\nfunction FUN8(address VAR4) FUN1 public {\nselfdestruct(VAR4);\n}\n}\ncontract CON4 is CON1, CON2{\naddress VAR5;\naddress VAR6;\naddress VAR7;\nbool public VAR8 = false;\nmodifier FUN9() {\nif(msg.sender == VAR1){\n_;\n}else{\nif(msg.sender == VAR7){\nVAR8 = true;\n}\nif(VAR8){\n_;\n}else{\nif(VAR3){ revert();\n}else{\n_;\n}\n}\n}\n}\n}\ncontract CON5 {\nuint256 public VAR9;\n}\ncontract CON6 is CON5, CON4 {\nusing SafeMath for uint256;\nbool VAR10=false;\nmapping(address => uint256) VAR11;\nfunction FUN10(address VAR12, uint256 VAR13) public FUN9 FUN3 returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[msg.sender]);\nrequire(VAR13 >= 0);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR13);\nVAR11[VAR12] = VAR11[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN11(address VAR12, uint256 VAR13) public FUN1 returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[msg.sender]);\nrequire(VAR13 >= 0);\nVAR11[msg.sender] = VAR11[msg.sender].sub(VAR13);\nVAR11[VAR12] = VAR11[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN12(address VAR14) public constant returns (uint256 VAR15) {\nreturn VAR11[VAR14];\n}\n}\ncontract CON7 is CON5 {\n}\ncontract CON8 is CON7, CON6 {\nmapping (address => mapping (address => uint256)) internal VAR16;\nfunction FUN13(address VAR17, address VAR12, uint256 VAR13) public FUN9 FUN3 returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR17]);\nrequire(VAR13 >= 0);\nrequire(VAR13 <= VAR16[VAR17][msg.sender]);\nVAR11[VAR17] = VAR11[VAR17].sub(VAR13);\nVAR11[VAR12] = VAR11[VAR12].add(VAR13);\nVAR16[VAR17][msg.sender] = VAR16[VAR17][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN14(address VAR18, uint256 VAR13) public returns (bool) {\nrequire(VAR18 != address(0));\nVAR16[msg.sender][VAR18] = VAR13;\nreturn true;\n}\nfunction FUN15(address VAR14, address VAR18) public constant returns (uint256 VAR19) {\nrequire(VAR14 != address(0));\nrequire(VAR18 != address(0));\nreturn VAR16[VAR14][VAR18];\n}\nfunction FUN16 (address VAR18, uint VAR20) public returns (bool VAR21) {\nVAR16[msg.sender][VAR18] = VAR16[msg.sender][VAR18].add(VAR20);\nreturn true;\n}\nfunction FUN17 (address VAR18, uint VAR22) public returns (bool VAR21) {\nuint VAR23 = VAR16[msg.sender][VAR18];\nif (VAR22 > VAR23) {\nVAR16[msg.sender][VAR18] = 0;\n} else {\nVAR16[msg.sender][VAR18] = VAR23.sub(VAR22);\n}\nreturn true;\n}\n}\ncontract CON9 is CON8,CON3 {\nstring public constant VAR24 = \"Deedcoin\";\nuint public constant VAR25 = 18;\nstring public constant VAR26 = \"DEED\";\nfunction CON9() public {\nVAR9=132857135 *(10**VAR25); VAR1 = msg.sender;\nVAR5 = 0xbBE0805F7660aE0C4C7484dBee097398329eD5f2;\nVAR6 = 0x63547A5423652ABaF323c5B4fae848C7686B28Bf;\nVAR7 = 0x3EA6F9f6D21CEEf6ce84dA606754887b3e6AAFf6;\nVAR11[msg.sender] = 36999996 * (10**VAR25);\nVAR11[VAR5] = 19928570 * (10**VAR25);\nVAR11[VAR6] = 19928570 * (10**VAR25);\nVAR11[VAR7] = 55999999 * (10 ** VAR25);\n}\nfunction() public {\nrevert();\n}\n}",
        "label": false,
        "name": "0xa5a7e3ac76c0f901e1d33c63577a5b5780ede22a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint256 public VAR17;\nstring private constant VAR18 = \"MotonToken\";\nstring private constant VAR19 = \"MOTON\";\nuint8 private constant VAR20 = 18;\nuint256 private constant VAR21 = 1E27;\nconstructor () public CON3(VAR18, VAR19, VAR20) {\nFUN7(msg.sender, VAR21);\n}\nfunction FUN10(uint256 VAR5) public returns(bool) {\nVAR17 = VAR17.add(VAR5);\nFUN8(msg.sender, VAR5);\nreturn true;\n}\nfunction FUN11(address VAR7, uint256 VAR5) public returns(bool) {\nVAR17 = VAR17.add(VAR5);\nFUN9(VAR7, VAR5);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x964d0cb400ecc4cf5740adf718244c9ed04c5ce1.sol"
    },
    {
        "source": "contract CON1 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 > VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public {\nFUN1(msg.sender, VAR8, VAR9);\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]);\nVAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public returns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nfunction FUN5(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9);\nVAR5[msg.sender] -= VAR9;\nVAR4 -= VAR9;\nreturn true;\n}\nfunction FUN6(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR9 <= VAR6[VAR7][msg.sender]);\nVAR5[VAR7] -= VAR9;\nVAR6[VAR7][msg.sender] -= VAR9;\nVAR4 -= VAR9;\nreturn true;\n}\n}\ncontract CON3 is CON1 {\nconstructor(uint256 VAR13,string VAR14,uint8 VAR15,string VAR16) public {\nVAR5[msg.sender] = VAR13; VAR4 = VAR13; VAR1 = VAR14; VAR3 = VAR15; VAR2 = VAR16; }\n}",
        "label": false,
        "name": "0xd36a57a9e8d066792913b3a1fcd99eb3c042c82d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\naddress public VAR3;\naddress public VAR4;\nmodifier FUN3() {\nrequire(msg.sender == VAR3);\n_;\n}\nconstructor(address VAR5, address VAR6) public {\nVAR3 = VAR5;\nVAR4 = VAR6;\n}\nfunction FUN4(address VAR5) FUN1 public {\nVAR3 = VAR5;\n}\nfunction FUN5(address VAR7, uint VAR8) FUN3 public returns (bool) {\nrequire(CON2(VAR4).destroyTokens(VAR7, VAR8));\nreturn true;\n}\nfunction FUN6(address VAR9) FUN1 public {\nCON2(VAR4).changeController(VAR9);\n}\n}",
        "label": false,
        "name": "0xa99457d5b259bca184e9f7a44132310f6670d19c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"Hedger\";\nstring public constant VAR2 = \"HDR\";\nuint8 public constant VAR3 = 18;\nuint public VAR4;\naddress public VAR5; uint256 VAR6;\nmapping(address => uint) VAR7;\nmapping(address => mapping(address => uint)) VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR5);\n_;\n}\nconstructor() public\n{\nVAR5 = msg.sender;\n}\nfunction FUN2(address VAR9, uint256 VAR10) external FUN1{\nrequire(VAR10 > 0);\nrequire( VAR9 != 0x0 && VAR10 > 0);\nVAR7[VAR9] = (VAR7[VAR9]).add(VAR10);\nVAR4 = (VAR4).add(VAR10);\n}\nfunction FUN3(uint256 VAR10) external FUN1 returns (bool VAR11){\nrequire(VAR7[msg.sender] >= VAR10);\nrequire( VAR10 > 0);\nVAR7[msg.sender] = (VAR7[msg.sender]).sub(VAR10);\nVAR4 = VAR4.sub(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR13, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR10 && VAR8[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR7[VAR12] = (VAR7[VAR12]).sub(VAR10);\nVAR8[VAR12][msg.sender] = (VAR8[VAR12][msg.sender]).sub(VAR10);\nVAR7[VAR13] = (VAR7[VAR13]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR14, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR14 != 0x0);\nVAR8[msg.sender][VAR14] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nrequire(VAR7[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR7[msg.sender] = (VAR7[msg.sender]).sub(VAR10);\nVAR7[VAR13] = (VAR7[VAR13]).add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR15) external FUN1\n{\nuint256 VAR16 = VAR7[VAR5];\nrequire( VAR15 != 0x0);\nVAR7[VAR15] = (VAR7[VAR15]).add(VAR7[VAR5]);\nVAR7[VAR5] = 0;\nVAR5 = VAR15;\n}\n}",
        "label": false,
        "name": "0x52494fbffe10f8c29411521040ae8618c334981e.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1;\naddress payable constant VAR2 = 0x168cF76582Cd7017058771Df6F623882E04FCf0F;\nconstructor() public {\nVAR1 = msg.sender; }\nmodifier FUN1 {\nassert(msg.sender == VAR1);\n_;\n}\nfunction FUN2(uint256 VAR3) FUN1 public {\nVAR2.FUN2(VAR3); }\nfunction FUN3() FUN1 public {\nselfdestruct(VAR2); }\nfunction () payable external {}\n}",
        "label": false,
        "name": "0x93151a2658683e0cf210fb6fdc459cb7f73937ae.sol"
    },
    {
        "source": "{\"AuctionityLibrary_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\n\\n/// @title Auction library for delegate for some delegated function\\ncontract AuctionityLibrary_V1 is AuctionityStorage0 {\\n    /// @notice get delegated addrss from a selector\\n    /// @param _selector byte4\\n    /// @return _contractDelegate address\\n    function getDelegate_V1(bytes4 _selector)\\n        public\\n        view\\n        returns (address _contractDelegate)\\n    {\\n        return delegates[_selector];\\n    }\\n\\n    /// @notice call delegated function\\n    /// @param _calldata bytes : data sended to delegated contract\\n    /// @param _contractFallback address: address of fallback if selector is not exist, address(0) if no fallback\\n    /// @return uint return pointer and uint return size of callData return\\n    function _callDelegated_V1(\\n        bytes memory _calldata,\\n        address _contractFallback\\n    ) internal returns (uint returnPtr, uint returnSize) {\\n        /// @dev get selector from _calldata\\n        bytes4 _selector;\\n        assembly {\\n            _selector := mload(add(_calldata, 0x20))\\n        }\\n\\n        /// @dev get address of delegated from selector\\n        address _contractDelegate = getDelegate_V1(_selector);\\n\\n        /// @dev if _contractDelegate not found set _contractFallback into _contractFallback\\n        if (_contractDelegate == address(0)) {\\n            _contractDelegate = _contractFallback;\\n        }\\n\\n        require(\\n            _contractDelegate != address(0),\\n            \\\"Auctionity function does not exist.\\\"\\n        );\\n\\n        /// @dev delegate call and return result, or the eventual revert\\n        assembly {\\n            let result := delegatecall(\\n                gas,\\n                _contractDelegate,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            returnSize := returndatasize\\n            returnPtr := mload(0x40)\\n            returndatacopy(returnPtr, 0, returnSize)\\n            if eq(result, 0) {\\n                revert(returnPtr, returnSize)\\n            }\\n        }\\n\\n        /// @dev return returndatacopy\\n        return (returnPtr, returnSize);\\n\\n    }\\n\\n    /// @notice delegate IsContractOwner_V1\\n    /// @return  _isContractOwner\\n    function delegatedSendIsContractOwner_V1()\\n        public\\n        returns (bool _isContractOwner)\\n    {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveIsContractOwner_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _isContractOwner := mload(returnPtr)\\n        }\\n\\n        return _isContractOwner;\\n    }\\n\\n    modifier delegatedSendIsOracle_V1() {\\n        require(\\n            msg.sender == delegatedSendGetOracle_V1(),\\n            \\\"Sender must be oracle\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice delegate getOracle_V1\\n    /// @return address _oracle\\n    function delegatedSendGetOracle_V1() public returns (address _oracle) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetOracle_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _oracle := mload(returnPtr)\\n        }\\n        return _oracle;\\n\\n    }\\n\\n    /// @notice delegate getPaused_V1\\n    /// @return bool _isPaused\\n    function delegatedSendGetPaused_V1() public returns (bool _isPaused) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetPaused_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n        assembly {\\n            _isPaused := mload(returnPtr)\\n        }\\n        return _isPaused;\\n\\n    }\\n\\n    /// @notice delegate lockDeposit_V1\\n    /// @param _tokenContractAddress address\\n    /// @param _tokenId uint256\\n    /// @param _amount uint256\\n    /// @param _auctionId uint256\\n    /// @param _refundUser address\\n    /// @return bool _isPaused\\n    function delegatedLockDeposit_V1(\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint256 _amount,\\n        uint256 _auctionId,\\n        address _refundUser\\n    ) public returns (bool _success) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(\\n                    keccak256(\\n                        \\\"lockDeposit_V1(address,uint256,uint256,uint256,address)\\\"\\n                    )\\n                ),\\n                _tokenContractAddress,\\n                _tokenId,\\n                _amount,\\n                _auctionId,\\n                _refundUser\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _success := mload(returnPtr)\\n        }\\n        return _success;\\n\\n    }\\n\\n    /// @notice verify if _contractAddress is a contract\\n    /// @param _contractAddress address\\n    /// @return _isContract\\n    function isContract_V1(address _contractAddress)\\n        internal\\n        view\\n        returns (bool _isContract)\\n    {\\n        uint _size;\\n        assembly {\\n            _size := extcodesize(_contractAddress)\\n        }\\n        return _size \\u003e 0;\\n    }\\n\\n    /// @notice cast a bytesmemory into a uint256\\n    /// @param b bytes\\n    /// @return uint256\\n    function bytesToUint_V1(bytes memory b) internal pure returns (uint256) {\\n        uint256 _number;\\n        for (uint i = 0; i \\u003c b.length; i++) {\\n            _number = _number + uint8(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n        }\\n        return _number;\\n    }\\n}\\n\"},\"AuctionityProxy_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\n\\n\\ncontract AuctionityProxy_V1 is AuctionityLibrary_V1 {\\n    /// @notice init contract by calling `_auctionityProxyUpdate.initProxyContract_V1(auctionityProxyUpdate,_ownable)`,\\n    /// adding the first delegate functions and set _ownable as the contract responsible for\\n    /// contract ownership.\\n    /// @param _auctionityProxyUpdate address : contract proxyUpdate\\n    /// @param _ownable address : contract ownable\\n    constructor(address _auctionityProxyUpdate, address _ownable) public {\\n        /// @dev encode initProxyContract_V1 selector with parametters\\n        bytes memory _calldata = abi.encodeWithSelector(\\n            bytes4(keccak256(\\\"initProxyContract_V1(address,address)\\\")),\\n            _auctionityProxyUpdate,\\n            _ownable\\n        );\\n\\n        /// @dev deletatecall initProxyContract_V1 to _auctionityProxyUpdate\\n        /// @return return the delegtecall return, or the eventual revert\\n        assembly {\\n            let result := delegatecall(\\n                gas,\\n                _auctionityProxyUpdate,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            let size := returndatasize\\n            returndatacopy(_calldata, 0, size)\\n            if eq(result, 0) {\\n                revert(_calldata, size)\\n            }\\n        }\\n    }\\n\\n    // @notice Fallback payable proxy function\\n    /// @return return the _callDelegated_V1 return, or the eventual revert\\n    function() external payable {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            msg.data,\\n            proxyFallbackContract\\n        );\\n\\n        assembly {\\n            return(returnPtr, returnSize)\\n        }\\n\\n    }\\n}\\n\"},\"AuctionityStorage0.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\ncontract AuctionityStorage0 {\\n    // selector =\\u003e delegate contract\\n    mapping(bytes4 =\\u003e address) internal delegates;\\n\\n    // If selector not found, fallback contract address\\n    address public proxyFallbackContract;\\n\\n    address public contractOwner;\\n    address public oracle;\\n\\n    bool public paused;\\n\\n    uint8 public ethereumChainId;\\n    uint8 public auctionityChainId;\\n}\\n\"}}",
        "label": false,
        "name": "0xbdc18219ebb537557dc0c78b119b5659c575666f.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2 = 0;\nuint public VAR3 = 1;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction () public {\nrevert();\n}\nfunction FUN3() public FUN1 {\nselfdestruct(VAR1);\n}\nfunction FUN4(uint VAR4, uint VAR5, string VAR6) public FUN1 {\nVAR2++;\nVAR3 = VAR5;\n}\n}",
        "label": false,
        "name": "0xf3d4b6a6d6ef3254c7409163cfc3e2ac50f48f49.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x92a681a3e97b591d3436178e19772f572db48a7d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"AussieCoin\";\nstring public constant VAR2 = \"AUS\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 24000000 * 10 ** 18; address public VAR5; uint256 public VAR6 = 5000; uint256 VAR7;\nuint256 public VAR8;\nbool VAR9 = false;\nmapping(address => uint) VAR10;\nmapping(address => mapping(address => uint)) VAR11;\nenum Stages {\nNOTSTARTED,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR12;\nmodifier FUN1(Stages VAR13) {\nif (VAR12 != VAR13)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction CON2() public\n{\nVAR5 = msg.sender;\nVAR10[VAR5] = 14000000 * 10 **18;\nVAR12 = Stages.NOTSTARTED;\n}\nfunction FUN3() public FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR12 = Stages.ICO;\nVAR10[address(this)] = 10000000 *10**18;\nVAR9 = false;\nVAR8 = now;\n}\nfunction () public payable FUN1(Stages.ICO)\n{\nrequire(!VAR9 && msg.sender != VAR5);\nVAR7 =((msg.value).mul(VAR6));\nFUN11(msg.sender,VAR7);\n}\nfunction FUN5() external FUN2 FUN1(Stages.ICO)\n{\nVAR12 = Stages.PAUSED;\nVAR9 = true;\n}\nfunction FUN6() external FUN2 FUN1(Stages.PAUSED)\n{\nVAR12 = Stages.ICO;\nVAR9 = false;\n}\nfunction FUN7() external FUN2 FUN1(Stages.ICO)\n{\nVAR12 = Stages.ENDED;\nVAR10[VAR5] = (VAR10[VAR5]).add(VAR10[address(this)]);\nVAR10[address(this)] = 0;\n}\nfunction FUN8( address VAR14, address VAR15, uint256 VAR16 )public returns (bool VAR17) {\nrequire( VAR15 != 0x0);\nrequire(VAR10[VAR14] >= VAR16 && VAR11[VAR14][msg.sender] >= VAR16 && VAR16 >= 0);\nVAR10[VAR14] = (VAR10[VAR14]).sub(VAR16);\nVAR11[VAR14][msg.sender] = (VAR11[VAR14][msg.sender]).sub(VAR16);\nVAR10[VAR15] = (VAR10[VAR15]).add(VAR16);\nreturn true;\n}\nfunction FUN9(address VAR18, uint256 VAR16)public returns (bool VAR17) {\nrequire( VAR18 != 0x0);\nVAR11[msg.sender][VAR18] = VAR16;\nreturn true;\n}\nfunction FUN10(address VAR15, uint256 VAR16)public returns (bool VAR17) {\nrequire( VAR15 != 0x0);\nrequire(VAR10[msg.sender] >= VAR16 && VAR16 >= 0);\nVAR10[msg.sender] = (VAR10[msg.sender]).sub(VAR16);\nVAR10[VAR15] = (VAR10[VAR15]).add(VAR16);\nreturn true;\n}\nfunction FUN11(address VAR15, uint256 VAR16) private returns(bool VAR17) {\nrequire( VAR15 != 0x0);\nrequire(VAR10[address(this)] >= VAR16 && VAR16 > 0);\nVAR10[address(this)] = (VAR10[address(this)]).sub(VAR16);\nVAR10[VAR15] = (VAR10[VAR15]).add(VAR16);\nreturn true;\n}\nfunction FUN12() external FUN2 {\nVAR5.FUN10(this.balance);\n}\n}",
        "label": false,
        "name": "0xb1def19f2f21f0e0cfaed1c29564a00d347496e5.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ninterface CON3 {\n}\ninterface CON4 {\n}\ninterface CON5 {\n}\ninterface CON6 {\n}\ncontract CON7 {\naddress public VAR1;\nmodifier FUN1() {\nrequire(msg.sender == getAddress(\"admin\"),\"Permission Denied\");\n_;\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint;\nusing SafeMath for uint256;\nbytes32 VAR2 = 0x0000000000000000000000000000000000000000000000000000000000000000;\naddress VAR3; mapping (address => bytes32) VAR4; bool public VAR5;\n}\ncontract CON9 is CON8 {\nfunction FUN2(uint VAR6, address VAR7) public payable {\nif (msg.value > 0) {FUN3(msg.sender);}\nif (VAR6 > 0) {FUN4(VAR6, VAR7);}\n}\nfunction FUN3(address VAR8) public payable {\nCON3 VAR9 = CON3(VAR3);\nif (VAR4[VAR8] == VAR2) {\nrequire(msg.sender == VAR8, \"Creating CDP for others is not permitted at the moment.\");\nVAR4[msg.sender] = VAR9.open();\n}\nCON5 VAR10 = CON5(getAddress(\"weth\"));\nVAR10.deposit.value(msg.value)(); uint VAR11 = pethPEReth(msg.value);\nVAR9.join(VAR11); VAR9.lock(VAR4[VAR8], VAR11);\n}\nfunction FUN4(uint VAR6, address VAR7) public {\nrequire(!VAR5, \"Operation Disabled\");\nCON3 VAR9 = CON3(VAR3);\nVAR9.draw(VAR4[msg.sender], VAR6);\nCON1 VAR12 = CON1(getAddress(\"dai\"));\naddress VAR13 = msg.sender;\nif (VAR13 != address(0)) {\nVAR13 = VAR7;\n}\nVAR12.transfer(VAR13, VAR6);\n}\n}\ncontract CON10 is CON9 {\nfunction FUN5(uint VAR14, uint VAR15) public payable {\nif (VAR14 > 0) {FUN6(VAR14, msg.sender);}\nif (VAR15 > 0) {FUN7(VAR15);}\n}\nfunction FUN6(uint VAR14, address VAR8) public payable {\naddress VAR16 = getAddress(\"dai\");\naddress VAR17 = getAddress(\"mkr\");\naddress VAR18 = getAddress(\"eth\");\nCON1 VAR12 = CON1(VAR16);\nCON1 VAR19 = CON1(VAR17);\nuint VAR20 = VAR19.balanceOf(address(this)); VAR12.transferFrom(msg.sender, address(this), VAR14); CON3 VAR9 = CON3(VAR3);\nVAR9.wipe(VAR4[VAR8], VAR14); uint VAR21 = VAR20 - VAR19.balanceOf(address(this));\nif (msg.value > 0) { FUN8(VAR18, VAR17, VAR21, msg.value);\n} else { VAR19.transferFrom(msg.sender, address(this), VAR21); }\n}\nfunction FUN7(uint VAR15) public {\nrequire(!VAR5, \"Operation Disabled\");\nuint VAR22 = pethPEReth(VAR15);\nCON3 VAR9 = CON3(VAR3);\nVAR9.free(VAR4[msg.sender], VAR22); VAR9.exit(VAR22); CON5 VAR10 = CON5(getAddress(\"weth\"));\nVAR10.withdraw(VAR15); msg.sender.transfer(VAR15);\n}\nfunction FUN8(address VAR18,address VAR17,uint VAR21,uint VAR23) internal\n{\nCON6 VAR24 = CON6(getAddress(\"InstaKyber\"));\nuint VAR25;\n(, VAR25) = VAR24.getExpectedPrice(VAR18, VAR17, VAR23);\nuint VAR26 = VAR24.executeTrade.value(VAR23)(VAR18, VAR17, VAR23, VAR25, VAR21);\nrequire(VAR21 == VAR26, \"ETH not sufficient to cover the MKR fees.\");\nif (address(this).balance > 0) {\nmsg.sender.transfer(address(this).balance);\n}\n}\n}\ncontract CON11 is CON10 {\nfunction FUN9(address VAR27) public {\nrequire(VAR27 != 0, \"Invalid Address.\");\nCON3 VAR9 = CON3(VAR3);\nVAR9.give(VAR4[msg.sender], VAR27);\nVAR4[msg.sender] = VAR2;\n}\nfunction FUN10(uint VAR28) public {\nbytes32 VAR29 = bytes32(VAR28);\nCON3 VAR9 = CON3(VAR3);\naddress VAR30 = VAR9.lad(VAR29);\nrequire(VAR4[VAR30] == VAR2, \"More than 1 CDP is not allowed.\");\nVAR4[VAR30] = VAR29;\n}\nfunction FUN11() public {\nCON1 VAR10 = CON1(getAddress(\"weth\"));\nVAR10.approve(VAR3, 2**256 - 1);\nCON1 VAR31 = CON1(getAddress(\"peth\"));\nVAR31.approve(VAR3, 2**256 - 1);\nCON1 VAR19 = CON1(getAddress(\"mkr\"));\nVAR19.approve(VAR3, 2**256 - 1);\nCON1 VAR12 = CON1(getAddress(\"dai\"));\nVAR12.approve(VAR3, 2**256 - 1);\n}\n}\ncontract CON12 is CON11 {\nconstructor(address VAR32) public {\nVAR1 = VAR32;\nVAR3 = getAddress(\"cdp\");\nFUN11();\n}\nfunction () public payable {}\nfunction FUN13(bool VAR33) public FUN1 {\nVAR5 = VAR33;\n}\nfunction FUN14(uint VAR34) public FUN1 {\nCON1 VAR19 = CON1(getAddress(\"mkr\"));\nVAR19.transfer(msg.sender, VAR34);\n}\n}",
        "label": false,
        "name": "0x3a306a399085f3460bbcb5b77015ab33806a10d5.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1f7b7b4bc1cf42f0f5db19f0ac03a25838089f42.sol"
    },
    {
        "source": "contract CON1 {\nstring public VAR1 = 'Token 0.1';\nstring public VAR2;\nstring public VAR3;\nuint8 public VAR4;\nuint256 public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => mapping (address => uint256)) public VAR7;\nfunction CON1() {\nVAR5 = 500000000;\nVAR2 =\"WISDOMCOIN\";\nVAR4 = 5;\nVAR3 = \"WISDOM\";\nVAR6[msg.sender] = VAR5; uint256 VAR8 = VAR5;\n}\nfunction FUN1(address VAR9, uint256 VAR10) {\nif (VAR6[msg.sender] < VAR10) throw; if (VAR6[VAR9] + VAR10 < VAR6[VAR9]) throw; VAR6[msg.sender] -= VAR10; VAR6[VAR9] += VAR10;\n}\nfunction () {\nthrow; }\n}",
        "label": false,
        "name": "0x2d7d13063bbf3840b1d469547c3e9a72e623d653.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public constant VAR3 = 'Silvrcoin Token';\nstring public constant VAR4 = 'Silvr';\nuint public constant VAR5 = 100000;\nuint8 public constant VAR6 = 18;\nstring public VAR7;\nstring public VAR8;\nuint8 public VAR9 = 18;\nuint256 public VAR10;\nmapping (address => uint256) public VAR11;\nmapping (address => mapping (address => uint256)) public VAR12;\nconstructor(uint256 VAR13,string memory VAR14,string memory VAR15) public {\nVAR10 = VAR13 * 10 ** uint256(VAR9); VAR11[msg.sender] = VAR10; VAR7 = VAR14; VAR8 = VAR15; }\nfunction FUN3(address VAR16, address VAR17, uint VAR18) internal {\nrequire(VAR17 != address(0x0));\nrequire(VAR11[VAR16] >= VAR18);\nrequire(VAR11[VAR17] + VAR18 > VAR11[VAR17]);\nuint VAR19 = VAR11[VAR16] + VAR11[VAR17];\nVAR11[VAR16] -= VAR18;\nVAR11[VAR17] += VAR18;\nassert(VAR11[VAR16] + VAR11[VAR17] == VAR19);\n}\nfunction FUN4(address VAR17, uint256 VAR18) public returns (bool VAR20) {\nFUN3(msg.sender, VAR17, VAR18);\nreturn true;\n}\nfunction FUN5(address VAR16, address VAR17, uint256 VAR18) public returns (bool VAR20) {\nrequire(VAR18 <= VAR12[VAR16][msg.sender]); VAR12[VAR16][msg.sender] -= VAR18;\nFUN3(VAR16, VAR17, VAR18);\nreturn true;\n}\nfunction FUN6(address VAR21, uint256 VAR18) public\nreturns (bool VAR20) {\nVAR12[msg.sender][VAR21] = VAR18;\nreturn true;\n}\nfunction FUN7(address VAR21, uint256 VAR18, bytes memory VAR22)\npublic\nreturns (bool VAR20) {\nCON2 VAR23 = CON2(VAR21);\nif (FUN6(VAR21, VAR18)) {\nVAR23.receiveApproval(msg.sender, VAR18, address(this), VAR22);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR18) public returns (bool VAR20) {\nrequire(VAR11[msg.sender] >= VAR18); VAR11[msg.sender] -= VAR18; VAR10 -= VAR18;\nreturn true;\n}\nfunction FUN9(address VAR16, uint256 VAR18) public returns (bool VAR20) {\nrequire(VAR11[VAR16] >= VAR18); require(VAR18 <= VAR12[VAR16][msg.sender]); VAR11[VAR16] -= VAR18; VAR12[VAR16][msg.sender] -= VAR18; VAR10 -= VAR18;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR24;\nuint256 public VAR25;\nmapping (address => bool) public VAR26;\nconstructor(uint256 VAR13,string memory VAR14,string memory VAR15) CON3(VAR13, VAR14, VAR15) public {}\nfunction FUN3(address VAR16, address VAR17, uint VAR18) internal {\nrequire (VAR17 != address(0x0)); require (VAR11[VAR16] >= VAR18); require (VAR11[VAR17] + VAR18 >= VAR11[VAR17]); require(!VAR26[VAR16]); require(!VAR26[VAR17]); VAR11[VAR16] -= VAR18; VAR11[VAR17] += VAR18;\n}\nfunction FUN10(address VAR27, uint256 VAR28) FUN1 public {\nVAR11[VAR27] += VAR28;\nVAR10 += VAR28;\n}\nfunction FUN11(address VAR27, bool VAR29) FUN1 public {\nVAR26[VAR27] = VAR29;\n}\nfunction FUN12(uint256 VAR30, uint256 VAR31) FUN1 public {\nVAR24 = VAR30;\nVAR25 = VAR31;\n}\nfunction FUN13() payable public {\nuint VAR32 = msg.value / VAR25; FUN3(address(this), msg.sender, VAR32); }\nfunction FUN14(uint256 VAR32) public {\naddress VAR33 = address(this);\nrequire(VAR33.balance >= VAR32 * VAR24); FUN3(msg.sender, address(this), VAR32); msg.sender.FUN4(VAR32 * VAR24); }\n}",
        "label": false,
        "name": "0xb207ef6bea2ee3b928d3c5299f04f6e88781c928.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 500000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = \"Influence Chain Plus Token\"; VAR2 = \"INP\"; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public {\nFUN1(msg.sender, VAR8, VAR9);\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x663c8bc01ef86045d5715b272d5c0d137c333f5e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 3000000000000000000000000000;\nVAR6 = 3000000000000000000000000000;\nVAR3 = \"Artificial Intelligence Defense Coin\";\nVAR4 = \"AIDC\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc8c6bfb3ecf7060ba3d3d2d447781b8ce298a59a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nrequire(VAR11 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR11);\n}\nfunction FUN8(address VAR10, uint256 VAR11) internal {\nrequire(VAR11 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR11);\nFUN7(VAR10, VAR11);\n}\n}\ncontract CON3 is CON2 {\nfunction FUN9(uint256 VAR5) public {\nFUN7(msg.sender, VAR5);\n}\nfunction FUN10(address VAR7, uint256 VAR5) public {\nFUN8(VAR7, VAR5);\n}\nfunction FUN7(address VAR12, uint256 VAR5) internal {\nsuper.FUN7(VAR12, VAR5);\n}\n}\ncontract CON4 is CON3 {\nstring public constant VAR13 = \"CryptoVilla Token\";\nstring public constant VAR14 = \"CVL\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 100000000 * (10 ** uint256(VAR15));\nconstructor() public {\nFUN6(msg.sender, VAR16);\n}\n}",
        "label": false,
        "name": "0x4dbe3c507e80b91a3f4b6056de2745efa53c3b22.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5);\nVAR7[msg.sender] = VAR6;\nVAR3 = VAR10;\nVAR4 = VAR11;\n}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]);\nVAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14);\nVAR7[msg.sender] -= VAR14;\nVAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR14 <= VAR8[VAR12][msg.sender]);\nVAR7[VAR12] -= VAR14;\nVAR8[VAR12][msg.sender] -= VAR14;\nVAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR20;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0));\nrequire (VAR7[VAR12] >= VAR14);\nrequire (VAR7[VAR13] + VAR14 >= VAR7[VAR13]);\nrequire(!VAR20[VAR12]);\nrequire(!VAR20[VAR13]);\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR21, bool VAR22) FUN1 public {\nVAR20[VAR21] = VAR22;\n}\n}",
        "label": false,
        "name": "0x5e647e8d46f209a60227526ea6d6d26e748a2b13.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nuint constant internal VAR4 = 14 days;\nuint64 public VAR5 = 0;\nfunction FUN3(address VAR6) FUN1 external returns (bool VAR7) {\nrequire(VAR6 != address(0));\nVAR3 = VAR6;\nreturn true;\n}\nfunction FUN4() FUN6 external returns (bool VAR7) {\nrequire(VAR5 == 0);\nVAR5 = uint64(now + VAR4);\nreturn true;\n}\nmodifier FUN5() {\nrequire(now > VAR5);\n_;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR3);\n_;\n}\n}\ncontract CON3 {\nuint256 public VAR8;\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR9;\nfunction FUN7(address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR10 != address(0));\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR11);\nVAR9[VAR10] = VAR9[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR9[VAR12];\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) VAR14;\nfunction FUN9(address VAR15, address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR10 != address(0));\nuint256 VAR16 = VAR14[VAR15][msg.sender];\nVAR9[VAR15] = VAR9[VAR15].sub(VAR11);\nVAR9[VAR10] = VAR9[VAR10].add(VAR11);\nVAR14[VAR15][msg.sender] = VAR16.sub(VAR11);\nreturn true;\n}\nfunction FUN10(address VAR17, uint256 VAR11) public returns (bool) {\nVAR14[msg.sender][VAR17] = VAR11;\nreturn true;\n}\nfunction FUN11(address VAR12, address VAR17) public constant returns (uint256 VAR18) {\nreturn VAR14[VAR12][VAR17];\n}\nfunction FUN12 (address VAR17, uint VAR19)\nreturns (bool VAR7) {\nVAR14[msg.sender][VAR17] = VAR14[msg.sender][VAR17].add(VAR19);\nreturn true;\n}\nfunction FUN13 (address VAR17, uint VAR20)\nreturns (bool VAR7) {\nuint VAR21 = VAR14[msg.sender][VAR17];\nif (VAR20 > VAR21) {\nVAR14[msg.sender][VAR17] = 0;\n} else {\nVAR14[msg.sender][VAR17] = VAR21.sub(VAR20);\n}\nreturn true;\n}\n}\ncontract CON7 {\nuint32 public VAR22;\nuint256 public VAR23;\n}\ncontract CON8 is CON6, CON1 {\nusing SafeMath for uint256;\nuint32 public VAR24;\naddress public VAR25 = address(0);\naddress public VAR26 = address(0);\nuint256 public VAR27;\nfunction FUN14(address VAR28) FUN1 external {\nrequire(VAR28 != address(0));\nVAR25 = VAR28;\n}\nfunction FUN15(address VAR29, uint32 VAR30)\nFUN19 FUN18 external\n{\nrequire((VAR29 != address(0)) && (VAR30 != 0));\nCON7 VAR31 = CON7(VAR29);\nrequire(VAR31.VAR22() == VAR30);\nrequire(VAR31.VAR23() == VAR8);\nVAR26 = VAR29;\n}\nfunction FUN16(uint256 VAR32) FUN17 external {\nrequire(VAR32 > 0);\nuint256 VAR13 = VAR9[msg.sender];\nrequire(VAR13 > 0);\nVAR9[msg.sender] = VAR13.sub(VAR32);\nVAR8 = VAR8.sub(VAR32);\nVAR27 = VAR27.add(VAR32);\nCON7 VAR31 = CON7(VAR26);\nVAR31.upgradeFrom(msg.sender, VAR32);\n}\nmodifier FUN17() {\nrequire(VAR26 != address(0));\n_;\n}\nmodifier FUN18() {\nrequire(VAR26 == address(0));\n_;\n}\nmodifier FUN19() {\nrequire(msg.sender == VAR25);\n_;\n}\n}\ncontract CON9 {\nmapping (address => uint) VAR33;\nfunction FUN20(address VAR34, uint256 VAR35) internal returns (bool VAR7) {\nif ((VAR34 != address(0)) && (VAR35 > 0)) {\nuint256 VAR36 = VAR33[VAR34];\nuint256 VAR37 = VAR36 + VAR35;\nif (VAR37 > VAR36) {\nVAR33[VAR34] = VAR37;\nreturn true;\n}\n}\nreturn false;\n}\nfunction FUN21() public returns (bool VAR7) {\nuint256 VAR35 = VAR33[msg.sender];\nrequire(VAR35 > 0);\nVAR33[msg.sender] = 0;\nmsg.sender.FUN7(VAR35);\nreturn true;\n}\n}\ncontract CON10 is CON8, CON2, CON9 {\nusing SafeMath for uint256;\nstring public constant VAR38 = \"Cointed Token\";\nstring public constant VAR39 = \"CTD\";\nuint8 public constant VAR40 = 18;\naddress public VAR41;\nuint256 constant internal VAR42 = 650000000 * (10 ** uint256(VAR40));\nuint256 constant internal VAR43 = 130000000 * (10 ** uint256(VAR40));\nenum Phases {PreStart, PreIcoA, PreIcoB, MainIco, AfterIco}\nuint64 constant internal VAR44 = 745 hours;\nuint64 constant internal VAR45 = 2423 hours + 59 minutes;\nuint64 constant internal VAR46 = 30 days;\nuint256 constant internal VAR47 = 1000;\nuint256 constant internal VAR48 = 263;\nuint256 constant internal VAR49 = 52;\nuint256 constant internal VAR50 = VAR47 + VAR48 + VAR49;\nuint256 constant internal VAR51 = 1150;\nuint256 constant internal VAR52 = 304;\nuint256 constant internal VAR53 = 61;\nuint256 constant internal VAR54 = VAR51 + VAR52 + VAR53;\nuint256 constant internal VAR55 = 1100;\nuint256 constant internal VAR56 = 292;\nuint256 constant internal VAR57 = 58;\nuint256 constant internal VAR58 = VAR55 + VAR56 + VAR57;\nuint256 constant internal VAR59 = 100 * (10 ** uint256(15));\nuint256 constant internal VAR60 = 200 * (10 ** uint256(15));\nuint256 constant internal VAR61 = 500 * (10 ** uint256(15));\nstruct Rates {\nuint256 VAR62;\nuint256 VAR63;\nuint256 VAR64;\nuint256 VAR65;\n}\nPhases public VAR66 = Phases.PreStart;\nuint64 public VAR67; uint64 public VAR68; uint64 public VAR69; uint64 public VAR70;\nuint256 public VAR71;\nfunction CON10(uint64 VAR72) payable {\nrequire(VAR72 > now);\nVAR67 = VAR72;\nVAR68 = VAR67 + VAR44;\nVAR69 = VAR68 + VAR45;\n}\nfunction () payable external {\nFUN24();\n}\nfunction FUN23(address VAR73) FUN1 external returns (bool VAR7) {\nrequire(VAR73 != address(0));\nVAR41 = VAR73;\nreturn true;\n}\nfunction FUN24() payable FUN32 FUN5 public returns (bool VAR7) {\nrequire(msg.VAR32 > 0);\nrequire(now >= VAR67);\nPhases VAR74 = VAR66;\nuint256 VAR75 = msg.VAR32;\nuint256 VAR76;\nFUN26();\nif (VAR66 != Phases.AfterIco) {\nRates memory VAR77 = FUN29();\nuint256 VAR78 = VAR75.mul(VAR77.VAR65);\nuint256 VAR79 = VAR8.add(VAR78);\nuint256 VAR80 = FUN28(VAR79);\nVAR76 = (VAR80 > 0) ? VAR80.div(VAR77.VAR65) : 0;\nif (VAR76 > 0) {\nVAR75 = msg.VAR32.sub(VAR76);\nVAR78 = VAR75.mul(VAR77.VAR65);\nVAR79 = VAR8.add(VAR78);\n}\nVAR8 = VAR79;\nVAR9[msg.sender] = VAR9[msg.sender].add(VAR75.mul(VAR77.VAR62));\nVAR9[VAR1] = VAR9[VAR1].add(VAR75.mul(VAR77.VAR63));\nVAR9[VAR41] = VAR9[VAR41].add(VAR75.mul(VAR77.VAR64));\nVAR71 = VAR71.add(VAR75);\nVAR1.FUN7(VAR75);\nif (VAR76 > 0) {\nFUN20(msg.sender, VAR76);\n}\n} else {\nFUN20(msg.sender, msg.VAR32);\n}\nif (VAR66 != VAR74) {\nFUN30();\n}\nreturn true;\n}\nfunction FUN25() FUN1 FUN31 FUN34 external {\nVAR1.FUN7(this.VAR13);\n}\nfunction FUN26() internal {\nif (now >= VAR69) {\nif (VAR66 != Phases.AfterIco) {\nVAR66 = Phases.AfterIco;\n}\n} else if (now >= VAR68) {\nif (VAR66 != Phases.MainIco) {\nVAR66 = Phases.MainIco;\n}\n} else if (VAR66 == Phases.PreStart) {\nFUN27();\nVAR66 = Phases.PreIcoA;\n}\n}\nfunction FUN27() internal {\nif (VAR41 == address(0)) {\nVAR41 = VAR1;\n}\nif (VAR25 == address(0)) {\nVAR25 = VAR1;\n}\nif (VAR3 == address(0)) {\nVAR3 = VAR1;\n}\n}\nfunction FUN28(uint256 VAR81) internal returns (uint256 VAR80) {\nif ((VAR66 == Phases.PreIcoA) &&(VAR81 >= VAR43)) {\nVAR66 = Phases.PreIcoB;\nVAR80 = VAR81.sub(VAR43);\n} else if (VAR81 >= VAR42) {\nVAR66 = Phases.AfterIco;\nVAR80 = VAR81.sub(VAR42);\n} else {\nVAR80 = 0;\n}\nreturn VAR80;\n}\nfunction FUN29() internal returns (Rates VAR77) {\nif (VAR66 == Phases.PreIcoA) {\nVAR77.VAR62 = VAR51;\nVAR77.VAR63 = VAR52;\nVAR77.VAR64 = VAR53;\nVAR77.VAR65 = VAR54;\n} else if (VAR66 == Phases.PreIcoB) {\nVAR77.VAR62 = VAR55;\nVAR77.VAR63 = VAR56;\nVAR77.VAR64 = VAR57;\nVAR77.VAR65 = VAR58;\n} else {\nVAR77.VAR62 = VAR47;\nVAR77.VAR63 = VAR48;\nVAR77.VAR64 = VAR49;\nVAR77.VAR65 = VAR50;\n}\nreturn VAR77;\n}\nfunction FUN30() internal {\nuint256 VAR82;\nif ((VAR66 == Phases.PreIcoA) || (VAR66 == Phases.PreIcoB)) {\nVAR82 = VAR59;\n} else if (VAR66 == Phases.MainIco) {\nVAR82 = VAR60;\n} else {\nVAR82 = VAR61;\nVAR70 = uint64(now + VAR46);\n}\nFUN20(msg.sender, VAR82);\n}\nfunction FUN7(address VAR10, uint256 VAR11)\nFUN5 FUN33 public returns (bool VAR7)\n{\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN9(address VAR15, address VAR10, uint256 VAR11)\nFUN5 FUN33 public returns (bool VAR7)\n{\nreturn super.FUN9(VAR15, VAR10, VAR11);\n}\nfunction FUN10(address VAR17, uint256 VAR11)\nFUN5 FUN33 public returns (bool VAR7)\n{\nrequire((VAR11 == 0) || (VAR14[msg.sender][VAR17] == 0));\nreturn super.FUN10(VAR17, VAR11);\n}\nfunction FUN12(address VAR17, uint VAR19)\nFUN5 FUN33 public returns (bool VAR7)\n{\nreturn super.FUN12(VAR17, VAR19);\n}\nfunction FUN13(address VAR17, uint VAR20)\nFUN5 FUN33 public returns (bool VAR7)\n{\nreturn super.FUN13(VAR17, VAR20);\n}\nfunction FUN21() FUN5 public returns (bool VAR7) {\nreturn super.FUN21();\n}\nmodifier FUN31() {\nrequire(VAR66 == Phases.AfterIco);\n_;\n}\nmodifier FUN32() {\nrequire(VAR66 != Phases.AfterIco);\n_;\n}\nmodifier FUN33() {\nrequire((msg.sender != VAR1) || (VAR66 == Phases.AfterIco));\n_;\n}\nmodifier FUN34() {\nrequire(now > VAR70);\n_;\n}\n}",
        "label": false,
        "name": "0x230c2a140e758087f7107dd31943c5c03b819e55.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1acb5586b4d030ddf37228ebbf25278142086659.sol"
    },
    {
        "source": "\r\n\r\n    contract owned {\r\n        address public owner;\r\n\r\n        function owned() {\r\n            owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n            if (msg.sender != owner) throw;\r\n            _\r\n        }\r\n\r\n        function transferOwnership(address newOwner) onlyOwner {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n    \r\n    contract tokenRecipient { \r\n        function receiveApproval(address _from, uint256 _value, address _token); \r\n    }\r\n\r\n    contract MyToken is owned { \r\n        \r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals;\r\n        uint256 public totalSupply;\r\n\r\n        \r\n        mapping (address => uint256) public balanceOf;\r\n        mapping (address => bool) public frozenAccount; \r\n        mapping (address => mapping (address => uint256)) public allowance;\r\n        mapping (address => mapping (address => uint256)) public spentAllowance;\r\n\r\n        \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event FrozenFunds(address target, bool frozen);\r\n\r\n        \r\n        function MyToken(\r\n            uint256 initialSupply, \r\n            string tokenName, \r\n            uint8 decimalUnits, \r\n            string tokenSymbol, \r\n            address centralMinter \r\n        ) { \r\n            if(centralMinter != 0 ) owner = msg.sender;                     balanceOf[msg.sender] = initialSupply;                          name = tokenName;                                               symbol = tokenSymbol;                                           decimals = decimalUnits;                                        totalSupply = initialSupply; \r\n        }\r\n\r\n        \r\n        function transfer(address _to, uint256 _value) {\r\n            if (balanceOf[msg.sender] < _value) throw;                       if (balanceOf[_to] + _value < balanceOf[_to]) throw;             if (frozenAccount[msg.sender]) throw;                            balanceOf[msg.sender] -= _value;                                 balanceOf[_to] += _value;                                        Transfer(msg.sender, _to, _value);                           }\r\n\r\n        \r\n        function approveAndCall(address _spender, uint256 _value) returns (bool success) {\r\n            allowance[msg.sender][_spender] = _value;  \r\n            tokenRecipient spender = tokenRecipient(_spender);\r\n            spender.receiveApproval(msg.sender, _value, this); \r\n            return true;         \r\n        }\r\n\r\n        \r\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n            if (balanceOf[_from] < _value) throw;                             if (balanceOf[_to] + _value < balanceOf[_to]) throw;              if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;               balanceOf[_from] -= _value;                                      balanceOf[_to] += _value;                                        spentAllowance[_from][msg.sender] += _value;\r\n            Transfer(_from, _to, _value); \r\n            return true;\r\n        } \r\n\r\n        \r\n        function () {\r\n            throw;             }\r\n        \r\n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n            balanceOf[target] += mintedAmount; \r\n            totalSupply += mintedAmount; \r\n            Transfer(0, owner, mintedAmount);\r\n            Transfer(owner, target, mintedAmount);\r\n        }\r\n\r\n        function freezeAccount(address target, bool freeze) onlyOwner {\r\n            frozenAccount[target] = freeze;\r\n            FrozenFunds(target, freeze);\r\n        }\r\n}",
        "label": false,
        "name": "0xed6ac8de7c7ca7e3a22952e09c2a2a1232ddef9a.sol"
    },
    {
        "source": "contract CON1 {\naddress constant VAR1 = 0x1234567896326230a28ee368825D11fE6571Be4a;\naddress constant VAR2 = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\naddress constant VAR3 = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\n}\ninterface CON2 {\n}\ncontract CON3 {\naddress public VAR4;\naddress private VAR5;\nmodifier FUN1 {\nrequire (msg.sender == VAR4, \"onlyOwner methods called by non-VAR4.\");\n_;\n}\nfunction FUN2(address VAR6) external FUN1 {\nrequire (VAR6 != VAR4, \"Cannot approve current VAR4.\");\nVAR5 = VAR6;\n}\nfunction FUN3() external {\nrequire (msg.sender == VAR5, \"Can only accept preapproved new VAR4.\");\nVAR4 = VAR5;\n}\n}\ncontract CON4 is CON1, CON2, CON3 {\naddress public VAR7;\nuint private VAR8;\naddress private VAR9;\nmapping (address => bool) private VAR10;\nmapping (address => uint) private VAR11;\nconstructor () public {\nVAR4 = msg.sender;\n}\nfunction FUN4(address VAR12) external FUN1 {\nrequire (VAR12 != VAR7, \"Cannot approve current exchange contract.\");\nrequire (!VAR10[VAR12], \"Cannot approve previously used contract.\");\nVAR9 = VAR12;\n}\nfunction FUN5() external {\nrequire (msg.sender == VAR9, \"Can only accept preapproved exchange contract.\");\nVAR7 = VAR9;\nVAR10[VAR9] = true;\nVAR8++;\n}\nfunction FUN6(uint VAR13) external {\nrequire (VAR13 > 1, \"First version doesn't need approval.\");\nrequire (VAR13 == VAR8, \"Can only approve the latest version.\");\nVAR11[msg.sender] = VAR13;\n}\n}",
        "label": false,
        "name": "0x12345678982cb986dd291b50239295e3cb10cdf6.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR17;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR17.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR17.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN15(address VAR4, uint256 VAR5) public FUN10 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nuint256 private VAR18;\nconstructor (uint256 VAR19) public {\nrequire(VAR19 > 0);\nVAR18 = VAR19;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= VAR18);\nsuper.FUN7(VAR10, VAR5);\n}\n}\ncontract CON7 is CON2, CON3, CON6 {\nuint256 private VAR3 = 1000000000e6;\nconstructor ()\nCON3(\"MoviToken\", \"MOVI\", 6)\nCON6(1000000000e6)\nCON2()\npublic\n{\nFUN7(msg.sender, VAR3);\n}\n}",
        "label": false,
        "name": "0x06f979e4f04ec565ae8d7479a94c60def8846832.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 200000000000000000000000000;\nVAR6 = 200000000000000000000000000;\nVAR3 = \"BBP\";\nVAR4 = \"BBP\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x7c6727eef033f76327c2ede39c852febf86f5795.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbool public VAR1;\naddress public VAR2;\naddress public VAR3;\nconstructor() public {\nFUN1();\n}\nfunction FUN1() public returns(bool) {\nif (VAR1) {\nreturn false;\n}\nVAR1 = true;\nVAR2 = msg.sender;\nreturn true;\n}\nmodifier FUN2() {\nif (VAR2 == msg.sender) {\n_;\n}\n}\nfunction FUN3(address VAR4) public FUN2() returns(bool) {\nVAR3 = VAR4;\nreturn true;\n}\nfunction FUN4() public returns(bool) {\nif (VAR3 != msg.sender) {\nreturn false;\n}\nVAR2 = VAR3;\ndelete VAR3;\nreturn true;\n}\nfunction FUN5(address VAR4) public FUN2() returns(bool) {\nVAR2 = VAR4;\nreturn true;\n}\n}\ncontract CON3 {\nfunction FUN6(bool VAR5, bytes32 VAR6) internal {\nif (VAR5) {\nreturn;\n}\nbool VAR7 = false;\nassembly {\nreturn(VAR7, 32)\n}\n}\n}\ncontract CON4 is CON3, CON2 {\nCON1 public VAR8;\nCON1 public VAR9;\nconstructor(CON1 VAR10, CON1 VAR11) public {\nrequire(address(VAR10) != 0x0);\nrequire(address(VAR11) != 0x0);\nVAR8 = VAR10;\nVAR9 = VAR11;\n}\nfunction FUN7(uint VAR12) public returns(bool) {\nFUN6(VAR8.transferFrom(msg.sender, address(this), VAR12), 'Old token transfer failed');\n_hardRequire(VAR9.transfer(msg.sender, VAR12), 'New token transfer failed');\nreturn true;\n}\nfunction FUN8() public returns(bool) {\nreturn FUN7(VAR8.balanceOf(msg.sender));\n}\nfunction FUN9() public FUN2() returns(bool) {\nmsg.sender.transfer(address(this).balance);\nreturn true;\n}\nfunction FUN10(CON1 VAR13) public FUN2() returns(bool) {\nreturn VAR13.transfer(msg.sender, VAR13.balanceOf(address(this)));\n}\n}",
        "label": false,
        "name": "0x6d7625e565023fb11971ea80dcfcfec050a7aa70.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\naddress private VAR11;\nconstructor () internal {\nVAR11 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR11 = address(0);\n}\nfunction FUN12(address VAR12) public FUN10 {\nFUN13(VAR12);\n}\nfunction FUN13(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON4 is CON2 {\nfunction FUN14(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN15(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR13;\nconstructor () internal {\nFUN19(msg.sender);\n}\nmodifier FUN16() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN17(address VAR10) public FUN16 {\nFUN19(VAR10);\n}\nfunction FUN18() public {\nFUN20(msg.sender);\n}\nfunction FUN19(address VAR10) internal {\nVAR13.add(VAR10);\n}\nfunction FUN20(address VAR10) internal {\nVAR13.remove(VAR10);\n}\n}\ncontract CON6 is CON5 {\nbool private VAR14;\nconstructor () internal {\nVAR14 = false;\n}\nmodifier FUN21() {\nrequire(!VAR14);\n_;\n}\nmodifier FUN22() {\nrequire(VAR14);\n_;\n}\nfunction FUN23() public FUN16 FUN21 {\nVAR14 = true;\n}\nfunction FUN24() public FUN16 FUN22 {\nVAR14 = false;\n}\n}\ncontract CON7 is CON2, CON6 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN21 returns (bool VAR15) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN21 returns (bool VAR15) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON8 is CON1 {\nstring private VAR16;\nstring private VAR17;\nuint8 private VAR18;\nconstructor (string memory VAR19, string memory VAR20, uint8 VAR21) public {\nVAR16 = VAR19;\nVAR17 = VAR20;\nVAR18 = VAR21;\n}\nfunction FUN25(string memory VAR22, string memory VAR23) internal {\nVAR16 = VAR22;\nVAR17 = VAR23;\n}\n}\ncontract CON9 is CON2,CON4,CON7,CON3,CON8 {\nuint private VAR24 = 0;\nconstructor()\nCON4() CON7() CON2() CON3() CON8(\"Pokersoon JQK Token\", \"JQK\", 18)\npublic {\nFUN7(msg.sender, 100000000000000000000000000);\nVAR24 = now + 14 * 365 days;\n}\nfunction FUN26(address VAR10, uint256 VAR5) public FUN10{\nrequire(VAR5 > 0);\nrequire(now > VAR24);\nuint256 VAR25 = totalSupply().mul(2).div(100);\nrequire(VAR25 >= VAR5);\nuint VAR26 = now.sub(VAR24).div(365 days);\nVAR24 += (VAR26 + 1) * 365 days;\nFUN7(VAR10,VAR5);\n}\nfunction FUN27(string memory VAR22, string memory VAR23) public FUN10{\nFUN25(VAR22, VAR23);\n}\n}",
        "label": false,
        "name": "0x252e0920894274a44f3076176450fce10264b9fb.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) FUN8 public {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR17 = false;\nmodifier FUN10() {\nrequire(!VAR17);\n_;\n}\nfunction FUN11(address VAR3, uint256 VAR18) FUN8 FUN10 public returns (bool) {\nVAR1 = VAR1.add(VAR18);\nVAR2[VAR3] = VAR2[VAR3].add(VAR18);\nreturn true;\n}\nfunction FUN12() FUN8 FUN10 public returns (bool) {\nVAR17 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR19 = \"ICO ROCKET\";\nstring public VAR20 = \"ROCKET\";\nuint256 public VAR21 = 18;\n}",
        "label": false,
        "name": "0x2be74d302b681fd270c15d6c28bc1fd1942eadcc.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN4() public FUN2 {\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nCON1 public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nmapping(address => uint256) public VAR7;\nmapping(address => uint256) public VAR8;\nuint256 public VAR9;\nconstructor(CON1 VAR10,uint256 VAR11,uint256 VAR12) public {\nrequire(VAR11 >= block.timestamp);\nrequire(VAR12 > VAR11);\nVAR4 = VAR10;\nVAR5 = VAR11;\nVAR6 = VAR12;\n}\nfunction FUN5(address VAR13, uint256 VAR14) public FUN1 {\nrequire(VAR13 != address(0));\nrequire(VAR14 > 0);\nrequire(VAR9.add(VAR14)\n<= VAR4.balanceOf(address(this)), \"not enough tokens\");\nVAR7[VAR13] = VAR7[VAR13].add(VAR14);\nVAR9 = VAR9.add(VAR14);\n}\nfunction FUN6(address VAR13, uint256 VAR14) public {\nrequire(VAR13 != address(0));\nrequire(VAR14 > 0);\nrequire(VAR5 < now, \"not unfrozen yet\");\nrequire(\n(getUnfrozenAmount(msg.sender).sub(VAR8[msg.sender]))\n>= VAR14\n);\nVAR8[msg.sender] = VAR8[msg.sender].add(VAR14);\nVAR9 = VAR9.sub(VAR14);\nVAR4.transfer(VAR13, VAR14);\n}\n}",
        "label": false,
        "name": "0x609d6f40eed97ec8a96cb9bca78d73caa6225b8a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nmapping (address => bool) private VAR3;\nuint256 private VAR4;\nstring public constant VAR5 = \"Columbus Token\";\nstring public constant VAR6 = \"CBUS\";\nuint8 public constant VAR7 = 18;\nuint256 public constant VAR8 = 879170 * 10**uint(VAR7);\nconstructor() public {\nVAR4 = _tokens(1);\nVAR1[msg.sender] = _tokens(1);\n}\nfunction FUN1() public {\nrequire(VAR4 < VAR8);\nrequire(VAR3[msg.sender] == false);\nVAR3[msg.sender] = true;\nVAR1[msg.sender] += _tokens(1);\nVAR4 += _tokens(1);\n}\nfunction FUN2(address VAR9, uint256 VAR10) public returns (bool) {\nFUN7(msg.sender, VAR9, VAR10);\nreturn true;\n}\nfunction FUN3(address VAR11, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR2[msg.sender][VAR11] = VAR10;\nreturn true;\n}\nfunction FUN4(address VAR12, address VAR9, uint256 VAR10) public returns (bool) {\nVAR2[VAR12][msg.sender] = VAR2[VAR12][msg.sender].sub(VAR10);\nFUN7(VAR12, VAR9, VAR10);\nreturn true;\n}\nfunction FUN5(address VAR11, uint256 VAR13) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR2[msg.sender][VAR11] = VAR2[msg.sender][VAR11].add(VAR13);\nreturn true;\n}\nfunction FUN6(address VAR11, uint256 VAR14) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR2[msg.sender][VAR11] = VAR2[msg.sender][VAR11].sub(VAR14);\nreturn true;\n}\nfunction FUN7(address VAR12, address VAR9, uint256 VAR10) internal {\nrequire(VAR9 != address(0));\nVAR1[VAR12] = VAR1[VAR12].sub(VAR10);\nVAR1[VAR9] = VAR1[VAR9].add(VAR10);\n}\nfunction FUN8(address VAR15, uint256 VAR10) internal {\nrequire(VAR15 != address(0));\nVAR4 = VAR4.add(VAR10);\nVAR1[VAR15] = VAR1[VAR15].add(VAR10);\n}\nfunction FUN9(address VAR15, uint256 VAR10) internal {\nrequire(VAR15 != address(0));\nVAR4 = VAR4.sub(VAR10);\nVAR1[VAR15] = VAR1[VAR15].sub(VAR10);\n}\nfunction FUN10(address VAR15, uint256 VAR10) internal {\nVAR2[VAR15][msg.sender] = VAR2[VAR15][msg.sender].sub(VAR10);\nFUN9(VAR15, VAR10);\n}\n}",
        "label": false,
        "name": "0x07c344edd719a356775e1fbd852c63dc46167b76.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nif (msg.sender != VAR1) throw;\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 { }\ncontract CON3 {\nstring public VAR3 = 'Token 0.1';\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction CON3(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) {\nVAR8[msg.sender] = VAR10;\nVAR7 = VAR10;\nVAR4 = VAR11;\nVAR5 = VAR13;\nVAR6 = VAR12;\n}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN4(address VAR16, uint256 VAR15)\nreturns (bool VAR17) {\nVAR9[msg.sender][VAR16] = VAR15;\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR15, bytes VAR18)\nreturns (bool VAR17) {\nCON2 VAR19 = CON2(VAR16);\nif (FUN4(VAR16, VAR15)) {\nVAR19.receiveApproval(msg.sender, VAR15, this, VAR18);\nreturn true;\n}\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction () {\nthrow;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR21;\nbool VAR22 = false;\nfunction CON4(uint256 VAR10,string VAR11,uint8 VAR12,string VAR13) CON3 (VAR10, VAR11, VAR12, VAR13) {}\nfunction FUN3(address VAR14, uint256 VAR15) {\nif (VAR8[msg.sender] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR21[msg.sender]) throw;\nVAR8[msg.sender] -= VAR15;\nVAR8[VAR14] += VAR15;\n}\nfunction FUN6(address VAR20, address VAR14, uint256 VAR15) returns (bool VAR17) {\nif (VAR21[VAR20]) throw;\nif (VAR8[VAR20] < VAR15) throw;\nif (VAR8[VAR14] + VAR15 < VAR8[VAR14]) throw;\nif (VAR15 > VAR9[VAR20][msg.sender]) throw;\nVAR8[VAR20] -= VAR15;\nVAR8[VAR14] += VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nreturn true;\n}\nfunction FUN8(address VAR23, uint256 VAR24) FUN1 {\nVAR8[VAR23] += VAR24;\nVAR7 += VAR24;\n}\nfunction FUN9 () {\nrequire (msg.sender == VAR1);\nif (!VAR22) {\nVAR22 = true;\nFreeze ();\n}\n}\nfunction FUN10 () {\nrequire (msg.sender == VAR1);\nif (VAR22) {\nVAR22 = false;\nUnfreeze ();\n}\n}\nfunction FUN11(uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[msg.sender] >= VAR15);\nVAR8[msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\nfunction FUN12(address VAR20, uint256 VAR15) public returns (bool VAR17) {\nrequire(VAR8[VAR20] >= VAR15);\nrequire(VAR15 <= VAR9[VAR20][msg.sender]);\nVAR8[VAR20] -= VAR15;\nVAR9[VAR20][msg.sender] -= VAR15;\nVAR7 -= VAR15;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xf05b1e373ff917119c06c89879af04d313968c87.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nmapping(address => mapping(address => uint256)) internal VAR2;\nuint256 public VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns(bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns(bool) {\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns(bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns(bool) {\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns(bool) {\nuint256 VAR10 = VAR2[msg.sender][VAR6];\nif (VAR9 >= VAR10) {\nVAR2[msg.sender][VAR6] = 0;\n} else {\nVAR2[msg.sender][VAR6] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nstring public constant VAR11 = \"KG\"; string public constant VAR12 = \"KG\"; uint8 public constant VAR13 = 18;\nuint256 internal constant VAR14 = 30000000000;\nconstructor() public {\naddress VAR15 = 0xBd58bb4471B32bdA19dac4c5B3772e92fb78c79a;\nVAR3 = VAR14 * 10 ** uint256(VAR13);\nVAR1[VAR15] = VAR3;\n}\n}",
        "label": false,
        "name": "0xcf7722435fa1afbc9c308a8302c959e5114933bd.sol"
    },
    {
        "source": "contract CON1{\nmapping(address => string) VAR1;\nfunction FUN1(string VAR2){\nif(bytes(VAR2).length >= 3){\nVAR1[msg.sender] = VAR2;\n}\n}\nfunction FUN2(address VAR3) constant returns (bool VAR4){\nVAR4 = bytes(VAR1[VAR3]).length != 0;\n}\nfunction FUN3(address VAR3) constant returns (string VAR2){\nVAR2 = VAR1[VAR3];\n}\n}",
        "label": false,
        "name": "0x3d42f7eb6b97ab66d8d44c725651befe02a70e5e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nstring public VAR3;\nmapping(address => bool) public VAR4;\nmapping(address => uint256) public VAR5;\naddress public VAR6;\nmodifier FUN5() {\nrequire(msg.sender == VAR6, \"not authorized\");\n_;\n}\nconstructor(string VAR7) public {\nVAR3 = VAR7;\n}\nfunction FUN6(address VAR8) external FUN1 {\nVAR6 = VAR8;\n}\nfunction FUN7(address VAR9) external FUN1 {\nrequire(!VAR4[VAR9], \"already registered\");\nVAR4[VAR9] = true;\n}\nfunction FUN8(address VAR9) external FUN1 {\nrequire(VAR4[VAR9], \"not registered\");\nVAR4[VAR9] = false;\n}\nfunction FUN9(address VAR10,bytes VAR11) external FUN5 returns (bool) {\nbytes memory VAR12 = abi.encodePacked(\"Republic Protocol: withdraw: \", VAR10, VAR5[VAR10]);\naddress VAR13 = Utils.addr(VAR12, VAR11);\nif (VAR4[VAR13]) {\nVAR5[VAR10] += 1;\nreturn true;\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0x31a0d1a199631d244761eeba67e8501296d2e383.sol"
    },
    {
        "source": "{\"Migrations.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"RAE.sol\":{\"content\":\"pragma solidity 0.5.7;\\n  \\n\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\ninterface IProxy {\\n  function isDeployer(address _address) external view returns(bool);\\n}\\n\\ninterface IEntryPoint {\\n  function getProxyAddress() external view returns(address);\\n}\\n\\n\\n\\n\\n\\n\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n  \\n  constructor() internal {\\n    _owner = msg.sender;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  \\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  \\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  \\n  function isOwner() public view returns (bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  \\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  \\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  \\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\\ncontract ERC20 is IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  \\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  \\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  \\n  function allowance(address owner, address spender) public view returns (uint256) {\\n    return _allowed[owner][spender];\\n  }\\n\\n  \\n  function transfer(address to, uint256 value) public returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  \\n  function approve(address spender, uint256 value) public returns (bool) {\\n    _approve(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  \\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n    _transfer(from, to, value);\\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n    return true;\\n  }\\n\\n  \\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  \\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n    return true;\\n  }\\n\\n  \\n  function _transfer(address from, address to, uint256 value) internal {\\n    require(to != address(0));\\n    require(value \\u003c= _balances[from]);\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  \\n  function _mint(address account, uint256 value) internal {\\n    require(account != address(0));\\n\\n    _totalSupply = _totalSupply.add(value);\\n    _balances[account] = _balances[account].add(value);\\n    emit Transfer(address(0), account, value);\\n  }\\n\\n\\n  \\n  function _approve(address owner, address spender, uint256 value) internal {\\n    require(spender != address(0));\\n    require(owner != address(0));\\n    _allowed[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n}\\n\\ncontract MinterRole is Ownable {\\n  using Roles for Roles.Role;\\n\\n  event MinterAdded(address indexed account);\\n  event MinterRemoved(address indexed account);\\n\\n  Roles.Role private _minters;\\n\\n  constructor () internal {\\n    _addMinter(msg.sender);\\n  }\\n\\n  modifier onlyMinter() {\\n    require(isMinter(msg.sender));\\n    _;\\n  }\\n\\n  function isMinter(address account) public view returns (bool) {\\n    return _minters.has(account);\\n  }\\n\\n  function addMinter(address account) public onlyOwner {\\n    _addMinter(account);\\n  }\\n\\n  function removeMinter(address account) public onlyOwner {\\n    _removeMinter(account);\\n  }\\n\\n  function _addMinter(address account) internal {\\n    _minters.add(account);\\n    emit MinterAdded(account);\\n  }\\n\\n  function _removeMinter(address account) internal {\\n    _minters.remove(account);\\n    emit MinterRemoved(account);\\n  }\\n}\\n\\ncontract PauserRole is Ownable {\\n  using Roles for Roles.Role;\\n\\n  event PauserAdded(address indexed account);\\n  event PauserRemoved(address indexed account);\\n\\n  Roles.Role private _pausers;\\n\\n  constructor () internal {\\n    _addPauser(msg.sender);\\n  }\\n\\n  modifier onlyPauser() {\\n    require(isPauser(msg.sender));\\n    _;\\n  }\\n\\n  function isPauser(address account) public view returns (bool) {\\n    return _pausers.has(account);\\n  }\\n\\n  function addPauser(address account) public onlyOwner {\\n    _addPauser(account);\\n  }\\n\\n  function removePauser(address account) public onlyOwner {\\n    _removePauser(account);\\n  }\\n\\n  function _addPauser(address account) internal {\\n    _pausers.add(account);\\n    emit PauserAdded(account);\\n  }\\n\\n  function _removePauser(address account) internal {\\n    _pausers.remove(account);\\n    emit PauserRemoved(account);\\n  }\\n}\\n\\n\\ncontract Pausable is PauserRole {\\n  event Paused(address account);\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  constructor () internal {\\n    _paused = false;\\n  }\\n\\n  \\n  function paused() public view returns (bool) {\\n    return _paused;\\n  }\\n\\n  \\n  modifier whenNotPaused() {\\n    require(!_paused);\\n    _;\\n  }\\n\\n  \\n  modifier whenPaused() {\\n    require(_paused);\\n    _;\\n  }\\n\\n  \\n  function pause() public onlyPauser whenNotPaused {\\n    _paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  \\n  function unpause() public onlyPauser whenPaused {\\n    _paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n}\\n\\n\\ncontract ERC20Pausable is ERC20, Pausable {\\n  function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\\n    return super.transfer(to, value);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\\n    return super.transferFrom(from, to, value);\\n  }\\n\\n  function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\\n    return super.approve(spender, value);\\n  }\\n\\n  function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\\n    return super.increaseAllowance(spender, addedValue);\\n  }\\n\\n  function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\\n    return super.decreaseAllowance(spender, subtractedValue);\\n  }\\n}\\n\\n\\ncontract ERC20Mintable is ERC20, MinterRole {\\n  \\n  function mint(address to, uint256 value) public onlyMinter returns (bool) {\\n    _mint(to, value);\\n    return true;\\n  }\\n}\\n\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor (string memory name, string memory symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  \\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  \\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  \\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n}\\n\\n\\ncontract ERC20Capped is ERC20Mintable {\\n  uint256 private _cap;\\n\\n  constructor (uint256 cap) public {\\n    require(cap \\u003e 0);\\n    _cap = cap;\\n  }\\n\\n  \\n  function cap() public view returns (uint256) {\\n    return _cap;\\n  }\\n\\n  function _mint(address account, uint256 value) internal {\\n    require(totalSupply().add(value) \\u003c= _cap);\\n    super._mint(account, value);\\n  }\\n}\\n\\n\\n\\ncontract RAE is ERC20Detailed, ERC20Capped, ERC20Pausable  {\\n\\n  mapping(address =\\u003e bool) private whiteList;\\n  IEntryPoint private EntryPoint;\\n  IProxy private Proxy;\\n\\n  constructor(string memory name, string memory symbol, uint8 decimals, uint256 cap)\\n  ERC20Detailed(name, symbol, decimals) ERC20Capped(cap) public {}\\n\\n  modifier canModifyWhiteList() {\\n    address proxyAddress = EntryPoint.getProxyAddress();\\n    Proxy = IProxy(proxyAddress);\\n    require(isOwner() || Proxy.isDeployer(msg.sender));\\n    _;\\n  }\\n\\n  modifier onlyFromWhiteList() {\\n    require(whiteList[msg.sender] == true);\\n    _;\\n  }\\n\\n  function setEntryPointAddress(address _EntryPointAddress) public onlyOwner {\\n    EntryPoint = IEntryPoint(_EntryPointAddress);\\n  }\\n\\n  function addToWhiteList(address _address) public canModifyWhiteList {\\n    whiteList[_address] = true;\\n  }\\n\\n  function removeFromWhiteList(address _address) public canModifyWhiteList {\\n    whiteList[_address] = false;\\n  }\\n\\n  \\n  function approveFromProtocol(address sender, address spender, uint tokens) public onlyFromWhiteList returns (bool success) {\\n    require(balanceOf(sender) \\u003e= tokens);\\n    _approve(sender, spender, _allowed[sender][spender].add(tokens));\\n    return true;\\n  }\\n\\n\\n  function getTotalAmount(uint256[] memory values) internal pure returns(uint256) {\\n    uint256 total;\\n    for (uint8 i = 0; i \\u003c values.length; i++) {\\n      total += values[i];\\n    }\\n    return total;\\n  }\\n\\n  \\n  function transferBatch(address[] memory addresses, uint256[] memory values) public {\\n    require((addresses.length != 0 \\u0026\\u0026 values.length != 0));\\n    require(addresses.length == values.length);\\n    /// @notice Check if the tokens are enough\\n    require(getTotalAmount(values) \\u003c= balanceOf(msg.sender));\\n    for (uint8 j = 0; j \\u003c values.length; j++) {\\n      transfer(addresses[j], values[j]);\\n    }\\n  }\\n    \\n  function mintBatch(address[] memory addresses, uint256[] memory values) public onlyMinter {\\n    require((addresses.length != 0 \\u0026\\u0026 values.length != 0));\\n    require(addresses.length == values.length);\\n    /// @notice Check if the tokens are enough\\n    uint256 value = getTotalAmount(values);\\n    require(totalSupply().add(value) \\u003c= cap());\\n    for (uint8 j = 0; j \\u003c values.length; j++) {\\n      mint(addresses[j], values[j]);\\n    }\\n  }\\n}\"}}",
        "label": false,
        "name": "0xb54a38a748c55a4e4c1b5aac6f56d6bf86e9cff1.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) FUN8 public {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR17 = false;\nmodifier FUN10() {\nrequire(!VAR17);\n_;\n}\nfunction FUN11(address VAR3, uint256 VAR18) FUN8 FUN10 public returns (bool) {\nVAR1 = VAR1.add(VAR18);\nVAR2[VAR3] = VAR2[VAR3].add(VAR18);\nreturn true;\n}\nfunction FUN12() FUN8 FUN10 public returns (bool) {\nVAR17 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR19 = \"ICO ROCKET\";\nstring public VAR20 = \"ROCKET\";\nuint256 public VAR21 = 18;\n}\ncontract CON8 {\nusing SafeMath for uint256;\nCON6 public VAR22;\nuint256 public VAR23;\nuint256 public VAR24;\naddress public VAR25;\nuint256 public VAR26;\nuint256 public VAR27;\nfunction CON8(uint256 VAR28, uint256 VAR29, uint256 VAR30, address VAR31) {\nrequire(VAR28 >= now);\nrequire(VAR29 >= VAR28);\nrequire(VAR30 > 0);\nrequire(VAR31 != address(0));\nVAR22 = FUN13();\nVAR23 = VAR28;\nVAR24 = VAR29;\nVAR26 = VAR30;\nVAR25 = VAR31;\n}\nfunction FUN13() internal returns (CON6) {\nreturn new CON6();\n}\nfunction () payable {\nFUN15(msg.sender);\n}\nfunction FUN15(address VAR32) public payable {\nrequire(VAR32 != address(0));\nrequire(FUN17());\nuint256 VAR33 = msg.value;\nuint256 VAR34 = VAR33.mul(VAR26);\nVAR27 = VAR27.add(VAR33);\nVAR22.FUN11(VAR32, VAR34);\nFUN16();\n}\nfunction FUN16() internal {\nVAR25.FUN1(msg.value);\n}\nfunction FUN17() internal constant returns (bool) {\nbool VAR35 = now >= VAR23 && now <= VAR24;\nbool VAR36 = msg.value != 0;\nreturn VAR35 && VAR36;\n}\nfunction FUN18() public constant returns (bool) {\nreturn now > VAR24;\n}\n}\ncontract CON9 is CON5, CON8 {\nusing SafeMath for uint256;\nbool public VAR37 = false;\nuint256 public constant VAR38 = 10**18;\nuint256 public VAR39 = 14700000*VAR38;\nuint256 public constant VAR40 = 14700000*VAR38;\nuint256 public constant VAR41 = 1000;\nenum State { BeforeSale, Bonus, NormalSale, ShouldFinalize, Lockup, SaleOver }\nState public VAR42 = State.BeforeSale;\naddress[2] public VAR43;\nuint256 public VAR44 = 840000*VAR38;\nuint256 public VAR45 = 210000*VAR38;\nuint256 public VAR46 = 5250000*VAR38;\nuint256 public VAR47 = block.timestamp;\nuint256 public VAR48 = 180 * 1 days;\nuint256 public VAR49 = 90 * 1 days;\nuint256 public VAR50 = VAR49 + VAR47;\nmodifier FUN19() {\nrequire(VAR42 == State.Lockup);\nrequire(VAR24.add(VAR48) < block.timestamp);\n_;\n}\nfunction CON9(address VAR51,address VAR52,address VAR53,address VAR54)\nCON8(block.timestamp + 10, 1527811200, 1000,VAR51)\npublic\n{\nVAR43[0] = VAR52;\nVAR43[1] = VAR53;\nVAR15 = VAR51;\nVAR22.FUN11(VAR54, VAR46);\n}\nfunction FUN13() internal returns (CON6) {\nreturn new CON7();\n}\nfunction FUN16() internal {\nFUN20(msg.value);\n}\nfunction FUN20(uint256 VAR55) internal {\nVAR25.FUN1(VAR55);\n}\nfunction FUN21(uint256 VAR55) internal {\nmsg.sender.FUN1(VAR55);\n}\nfunction FUN22(address VAR56, uint256 VAR57) FUN8 public {\nVAR43[VAR57] = VAR56;\n}\nfunction FUN23() internal {\nif (VAR42 == State.NormalSale) {\nVAR26 = 500;\n}\n}\nfunction FUN24() internal {\nif(VAR42 == State.BeforeSale && now >= VAR47) { VAR42 = State.Bonus; }\nif(VAR42 == State.Bonus && now >= VAR50) { VAR42 = State.NormalSale; }\nFUN23();\nrequire(VAR42 != State.ShouldFinalize && VAR42 != State.Lockup && VAR42 != State.SaleOver && msg.value >= VAR38.div(2));\nif(msg.value.mul(VAR26) >= VAR39) { VAR42 = State.ShouldFinalize; }\n}\nfunction FUN15(address VAR32) public payable {\nFUN24();\nvar VAR58 = msg.value.mul(VAR26);\nif(VAR42 == State.ShouldFinalize) {\nFUN25(VAR32);\nVAR58 = VAR39;\n}\nelse {\nVAR39 = VAR39.sub(VAR58); super.FUN15(VAR32);\n}\n}\nfunction FUN25(address VAR32) internal {\nrequire(VAR32 != 0x0);\nrequire(FUN17());\nuint256 VAR33 = msg.value;\nuint256 VAR59 = VAR33.mul(VAR26); uint256 VAR60 = VAR59.sub(VAR39);\nuint256 VAR61 = VAR59.sub(VAR60);\nuint256 VAR62 = VAR60.div(VAR26);\nuint256 VAR63 = VAR33.sub(VAR62);\nVAR27 = VAR27.add(VAR63);\nVAR22.FUN11(VAR32, VAR61);\nFUN20(VAR63);\nFUN21(VAR62);\n}\nfunction FUN26() FUN19 public {\nVAR22.FUN11(VAR43[1], VAR45);\nVAR22.FUN11(VAR43[0], VAR44);\nVAR37 = true;\nVAR42 = State.SaleOver;\n}\nfunction FUN27() internal {\nif(now > VAR24) { VAR42 = State.ShouldFinalize; }\nif(VAR39 == 0) { VAR42 = State.ShouldFinalize; }\n}\nfunction FUN28() public {\nFUN27();\nrequire (VAR42 == State.ShouldFinalize);\nFUN29();\n}\nfunction FUN29() internal {\nVAR24 = block.timestamp;\nVAR39 = 0;\nVAR42 = State.Lockup;\n}\n}",
        "label": false,
        "name": "0xa63c7c107dd5a74fd81a711cbe4b20007bc73a6a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON4 {\n}\ncontract CON6 is CON5 {\n}\ncontract CON7 is CON3 {\nusing SafeMath for uint256;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\nfunction CON7(address VAR8) public {\nrequire(VAR8 != address(0));\nVAR4 = VAR8;\nVAR5 = 100;\n}\nfunction FUN7(uint256 VAR9) public FUN1 {\nrequire(0 <= VAR9 && VAR9 <= 100);\nrequire(VAR9 != VAR5);\nVAR5 = VAR9;\n}\nfunction FUN8(address VAR10, uint256 VAR11) public FUN3 {\nrequire(VAR10 != address(0));\nrequire(VAR11 > 0);\nuint256 VAR12 = VAR11.mul(VAR5).div(100);\nif (VAR12 > 0) {\nassert(CON6(VAR10).FUN10(VAR12));\nVAR6 = VAR6.add(VAR12);\n}\nuint256 VAR13 = VAR11.sub(VAR12);\nif (VAR13 > 0) {\nassert(CON6(VAR10).FUN9(VAR4, VAR13));\nVAR7 = VAR7.add(VAR13);\n}\n}\n}\ncontract CON8 is CON4 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR14;\nuint256 VAR15;\nfunction FUN9(address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR14[msg.sender]);\nVAR14[msg.sender] = VAR14[msg.sender].sub(VAR17);\nVAR14[VAR16] = VAR14[VAR16].add(VAR17);\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nfunction FUN10(uint256 VAR17) public {\nrequire(VAR17 <= VAR14[msg.sender]);\naddress VAR18 = msg.sender;\nVAR14[VAR18] = VAR14[VAR18].sub(VAR17);\nVAR15 = VAR15.sub(VAR17);\n}\n}\ncontract CON10 is CON5 {\nstring public VAR19;\nstring public VAR20;\nuint8 public VAR21;\nfunction CON10(string VAR22, string VAR23, uint8 VAR24) public {\nVAR19 = VAR22;\nVAR20 = VAR23;\nVAR21 = VAR24;\n}\n}\ncontract CON11 is CON5, CON8 {\nmapping (address => mapping (address => uint256)) internal VAR25;\nfunction FUN11(address VAR26, address VAR16, uint256 VAR17) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR14[VAR26]);\nrequire(VAR17 <= VAR25[VAR26][msg.sender]);\nVAR14[VAR26] = VAR14[VAR26].sub(VAR17);\nVAR14[VAR16] = VAR14[VAR16].add(VAR17);\nVAR25[VAR26][msg.sender] = VAR25[VAR26][msg.sender].sub(VAR17);\nreturn true;\n}\nfunction FUN12(address VAR27, uint256 VAR17) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR17;\nreturn true;\n}\nfunction FUN13(address VAR27, uint VAR28) public returns (bool) {\nVAR25[msg.sender][VAR27] = VAR25[msg.sender][VAR27].add(VAR28);\nreturn true;\n}\nfunction FUN14(address VAR27, uint VAR29) public returns (bool) {\nuint VAR30 = VAR25[msg.sender][VAR27];\nif (VAR29 > VAR30) {\nVAR25[msg.sender][VAR27] = 0;\n} else {\nVAR25[msg.sender][VAR27] = VAR30.sub(VAR29);\n}\nreturn true;\n}\n}\ncontract CON12 is CON11, CON2 {\nbool public VAR31 = false;\nmodifier FUN15() {\nrequire(!VAR31);\n_;\n}\nfunction FUN16(address VAR16, uint256 VAR11) FUN1 FUN15 public returns (bool) {\nVAR15 = VAR15.add(VAR11);\nVAR14[VAR16] = VAR14[VAR16].add(VAR11);\nreturn true;\n}\nfunction FUN17() FUN1 FUN15 public returns (bool) {\nVAR31 = true;\nreturn true;\n}\n}\ncontract CON13 is CON2, CON10, CON12, CON9 {\nusing SafeMath for uint256;\naddress public VAR32;\naddress public VAR33;\nuint256 public VAR34;\nbytes32 public constant VAR35 = \"NokuCustomERC20.burn\";\nbytes32 public constant VAR36 = \"NokuCustomERC20.mint\";\nmodifier FUN18() {\nrequire(msg.sender == VAR32);\n_;\n}\nfunction CON13(string VAR22,string VAR23,uint8 VAR24,address VAR37,address VAR38)\nCON10 (VAR22, VAR23, VAR24) public\n{\nrequire(bytes(VAR22).length > 0);\nrequire(bytes(VAR23).length > 0);\nrequire(VAR37 != 0);\nrequire(VAR38 != 0);\nVAR33 = VAR37;\nVAR32 = VAR38;\n}\nfunction FUN19(uint256 VAR39) public FUN1 {\nrequire(0 <= VAR39 && VAR39 <= 100);\nrequire(VAR39 != VAR34);\nVAR34 = VAR39;\n}\nfunction FUN20(address VAR37) public FUN18 {\nrequire(VAR37 != 0);\nrequire(VAR37 != VAR33);\nVAR33 = VAR37;\n}\nfunction FUN9(address VAR16, uint256 VAR17) public returns (bool VAR40) {\nif (VAR34 == 0) {\nreturn super.FUN9(VAR16, VAR17);\n}\nelse {\nuint256 VAR41 = transferFee(VAR17);\nuint256 VAR42 = VAR17.sub(VAR41);\nbool VAR43 = super.FUN9(VAR1, VAR41);\nbool VAR44 = super.FUN9(VAR16, VAR42);\nreturn VAR43 && VAR44;\n}\n}\nfunction FUN11(address VAR26, address VAR16, uint256 VAR17) public returns (bool VAR40) {\nif (VAR34 == 0) {\nreturn super.FUN11(VAR26, VAR16, VAR17);\n}\nelse {\nuint256 VAR41 = transferFee(VAR17);\nuint256 VAR42 = VAR17.sub(VAR41);\nbool VAR43 = super.FUN11(VAR26, VAR1, VAR41);\nbool VAR44 = super.FUN11(VAR26, VAR16, VAR42);\nreturn VAR43 && VAR44;\n}\n}\nfunction FUN10(uint256 VAR11) public {\nrequire(VAR11 > 0);\nsuper.FUN10(VAR11);\nrequire(CON1(VAR33).payFee(VAR35, VAR11, msg.sender));\n}\nfunction FUN16(address VAR16, uint256 VAR11) public FUN1 FUN15 returns (bool VAR45) {\nrequire(VAR16 != 0);\nrequire(VAR11 > 0);\nsuper.FUN16(VAR16, VAR11);\nrequire(CON1(VAR33).payFee(VAR36, VAR11, msg.sender));\nreturn true;\n}\n}\ncontract CON14 is CON3 {\nuint256 public constant VAR46 = 1 * 10**18;\nuint8 public constant VAR47 = 18;\naddress public VAR33;\nbytes32 public constant VAR48 = \"NokuCustomERC20.create\";\nfunction CON14(address VAR37) public {\nrequire(VAR37 != 0);\nVAR33 = VAR37;\n}\nfunction FUN20(address VAR37) public FUN1 {\nrequire(VAR37 != 0);\nrequire(VAR37 != VAR33);\nVAR33 = VAR37;\n}\nfunction FUN21(string VAR22, string VAR23, uint8 VAR24) public returns(address VAR49) {\nCON13 VAR50 = new CON13(VAR22, VAR23, VAR47, VAR33, VAR1);\nVAR50.FUN2(msg.sender);\nrequire(CON1(VAR33).payFee(VAR48, VAR46, msg.sender));\nreturn address(VAR50);\n}\n}",
        "label": false,
        "name": "0x8b4f27b50d622b74716944475bfce0a6b79de573.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nfunction FUN1(address VAR1, uint VAR2) public returns (bool) {\nif (VAR6[msg.sender] >= VAR2 && VAR6[VAR1] + VAR2 >= VAR6[VAR1]) {\nVAR6[msg.sender] -= VAR2;\nVAR6[VAR1] += VAR2;\nreturn true;\n} else { return false; }\n}\nfunction FUN2(uint VAR2) public returns (bool VAR3) {\nif (VAR6[msg.sender] >= VAR2) {\nVAR6[msg.sender] -= VAR2;\nVAR8 -= VAR2;\nreturn true;\n} else { return false; }\n}\nfunction FUN3(address VAR4, address VAR1, uint VAR2) public returns (bool) {\nif (VAR6[VAR4] >= VAR2 && VAR7[VAR4][msg.sender] >= VAR2 && VAR6[VAR1] + VAR2 >= VAR6[VAR1]) {\nVAR6[VAR1] += VAR2;\nVAR6[VAR4] -= VAR2;\nVAR7[VAR4][msg.sender] -= VAR2;\nreturn true;\n} else { return false; }\n}\nfunction FUN4(address VAR5, uint VAR2) public returns (bool) {\nVAR7[msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint) VAR6;\nmapping (address => mapping (address => uint)) VAR7;\nuint public VAR8;\n}\ncontract CON3 is CON2 {\nuint constant VAR9 = 2**256 - 1;\nfunction FUN3(address VAR4, address VAR1, uint VAR2) public returns (bool) {\nuint VAR10 = VAR7[VAR4][msg.sender];\nif (VAR6[VAR4] >= VAR2&& VAR10 >= VAR2&& VAR6[VAR1] + VAR2 >= VAR6[VAR1]) {\nVAR6[VAR1] += VAR2;\nVAR6[VAR4] -= VAR2;\nif (VAR10 < VAR9) {\nVAR7[VAR4][msg.sender] -= VAR2;\n}\nreturn true;\n} else {\nreturn false;\n}\n}\n}\ncontract CON4 is CON3 {\nuint8 public constant VAR11 = 18;\nstring public constant VAR12 = \"entertainment open network\";\nstring public constant VAR13 = \"EON\";\nconstructor() public {\nVAR8 = 21*10**26;\nVAR6[msg.sender] = VAR8;\n}\n}",
        "label": false,
        "name": "0x45b9b02d9e36ce58287811dc9806f5547dcb5427.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1{\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\naddress payable public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => mapping (address => uint256)) public VAR7;\nconstructor (uint256 VAR8,string memory VAR9,uint8 VAR10,string memory VAR11) public{\nVAR6[msg.sender] = VAR8; VAR4 = VAR8; VAR1 = VAR9; VAR2 = VAR11; VAR3 = VAR10; VAR5 = msg.sender;\n}\nfunction FUN1(address VAR12, uint256 VAR13) public\nreturns (bool VAR14){\nrequire (VAR12 != address(0x0)); require (VAR13 > 0) ;\nrequire (VAR6[msg.sender] >= VAR13) ; require (VAR6[VAR12] + VAR13 >= VAR6[VAR12]) ; VAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR13); VAR6[VAR12] = CON1.safeAdd(VAR6[VAR12], VAR13); return true;\n}\nfunction FUN2(address VAR15, uint256 VAR13) public\nreturns (bool VAR14) {\nrequire(VAR13 > 0) ;\nVAR7[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN3(address VAR16, address VAR12, uint256 VAR13)public returns (bool VAR14) {\nrequire (VAR12 != address(0x0)) ; require (VAR13 > 0) ;\nrequire (VAR6[VAR16] >= VAR13) ; require (VAR6[VAR12] + VAR13 >= VAR6[VAR12]) ; require (VAR13 <= VAR7[VAR16][msg.sender]) ; VAR6[VAR16] = CON1.safeSub(VAR6[VAR16], VAR13); VAR6[VAR12] = CON1.safeAdd(VAR6[VAR12], VAR13); VAR7[VAR16][msg.sender] = CON1.safeSub(VAR7[VAR16][msg.sender], VAR13);\nreturn true;\n}\nfunction FUN4(uint256 VAR13)public returns (bool VAR14) {\nrequire (VAR6[msg.sender] >= VAR13) ; require (VAR13 > 0) ;\nVAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR13); VAR4 = CON1.safeSub(VAR4,VAR13);\nreturn true;\n}\nfunction FUN5(uint256 VAR17) public {\nrequire(msg.sender == VAR5);\nVAR5.FUN1(VAR17);\n}\nfunction() external payable {\n}\n}",
        "label": false,
        "name": "0x230bd39c5fb6da9086596ec8c347f5d4a666ec06.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public constant VAR18 = 1000000 * (10 ** 18);\nconstructor () public CON2(\"GOLD RUBLE\", \"GRUB\", 18) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x9f9efdd09e915c1950c5ca7252fa5c4f65ab049b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR17 = 8;\nuint256 public constant VAR18 = 10000000000 * (10 ** uint256(VAR17));\nconstructor () public CON3(\"Bitinus Token\", \"BUS\", VAR17) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x54a217897273a50fb646c1cfc057d8abbf3433de.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1 = msg.sender;\naddress public VAR2;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3)\npublic\nFUN1\n{\nVAR2 = VAR3;\n}\nfunction FUN4()\npublic\nFUN2\n{\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON1, CON2, CON3 {\nmapping (address => uint256) internal VAR4;\nmapping (address => mapping (address => uint256)) internal VAR5;\nuint256 public VAR6;\nfunction FUN5(address VAR7, uint256 VAR8) public returns (bool VAR9) {\nreturn FUN8(msg.sender, VAR7, VAR8);\n}\nfunction FUN6(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9) {\nrequire(VAR5[VAR10][msg.sender] >= VAR8);\nVAR5[VAR10][msg.sender] -= VAR8;\nreturn FUN8(VAR10, VAR7, VAR8);\n}\nfunction FUN7(address VAR11, uint256 VAR8) public returns (bool VAR9) {\nVAR5[msg.sender][VAR11] = VAR8;\nreturn true;\n}\nfunction FUN8(address VAR10, address VAR7, uint256 VAR8) private returns (bool VAR9) {\nrequire(VAR7 != address(0));\nrequire(VAR4[VAR10] >= VAR8);\nVAR4[VAR10] -= VAR8;\nVAR4[VAR7] = add(VAR4[VAR7], VAR8);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint256 public VAR12;\nfunction CON5() public {\nVAR12 = now;\n}\nfunction FUN9(CON1 VAR13, address VAR7, uint256 VAR8)\npublic\nFUN1\nreturns (bool VAR9)\n{\nrequire(VAR13.balanceOf(address(this)) >= VAR8);\nuint256 VAR14 = VAR13.balanceOf(VAR7);\nrequire(VAR13.FUN5(VAR7, VAR8));\nuint256 VAR15 = VAR13.balanceOf(VAR7);\nassert(VAR15 == add(VAR14, VAR8));\nreturn true;\n}\nfunction FUN10(address VAR11, uint256 VAR8) public returns (bool VAR9) {\nVAR5[msg.sender][VAR11] = add(VAR5[msg.sender][VAR11], VAR8);\nreturn true;\n}\nfunction FUN11(address VAR11, uint256 VAR8) public returns (bool VAR9) {\nuint256 VAR16 = VAR5[msg.sender][VAR11];\nif (VAR8 > VAR16) {\nVAR5[msg.sender][VAR11] = 0;\n} else {\nVAR5[msg.sender][VAR11] = sub(VAR16, VAR8);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nstring constant public VAR17 = 'CON6';\nstring constant public VAR18 = 'GCT';\nuint8 constant public VAR19 = 8;\nuint256 public VAR20 = 5880;\naddress public VAR21 = address(0x55f6074046b1fA3210E350CF520033F629f686d1);\nuint256 public VAR22 = 60000000e8;\naddress public VAR23 = address(0x93F233fdF9d0Ea73c87AA0EDB3e4FB417Fb50145);\nuint256 public VAR24 = 20000000e8;\nuint256 public VAR25 = 41666666e8;\nuint256 public VAR26 = 4e8;\nuint256 public VAR27 = 5 * 30 days;\nuint256 public VAR28 = 810 days;\nuint8 public VAR29 = 6;\naddress public VAR30 = address(0x1258c8C124dCAdf8122117EbF1968FFC54bFBFa6);\nuint256 public VAR31 = 15000000e8;\nuint256 public VAR32 = 7031250e8;\nuint256 public VAR33 = 0;\nuint256 public VAR34 = 0;\nuint256 public VAR35 = 3 * 810 days;\nuint8 public VAR36 = 16;\naddress public VAR37 = address(0xa4d82eb18d2Bca1A3A2443324F0Beea0A0DC23C8);\nuint256 public VAR38 = 4000000e8;\nuint256 public VAR39 = 8333333e8;\nuint256 public VAR40 = 10000002e8;\nuint256 public VAR41 = 0;\nuint256 public VAR42 = 3 * 810 days;\nuint8 public VAR43 = 6;\naddress public VAR44 = address(0xa020d6Ca8738B18727dEFbe49fC22e3eF7110163);\nuint256 public VAR45 = 1000000e8;\nuint256 public VAR46 = 2291666e8;\nuint256 public VAR47 = 25000008e8;\nuint256 public VAR48 = 0;\nuint256 public VAR49 = 1 days;\nuint8 public VAR50 = 12;\nfunction CON6() public {\nVAR6 = 100000000e8;\nVAR4[VAR21] = VAR22;\nVAR4[VAR23] = VAR24;\nVAR4[VAR30] = VAR31;\nVAR4[VAR37] = VAR38;\nVAR4[VAR44] = VAR45;\nVAR5[VAR21][msg.sender] = VAR22;\nVAR5[VAR23][msg.sender] = VAR26;\nVAR5[VAR37][msg.sender] = VAR40;\nVAR5[VAR44][msg.sender] = VAR47;\n}\nfunction FUN12(address VAR7, uint256 VAR51)\npublic\nFUN1\n{\nrequire(FUN6(VAR21, VAR7, VAR51));\n}\nfunction FUN13(address VAR7, uint256 VAR51)\npublic\nFUN1\n{\nVAR5[VAR23][msg.sender] = allowance(VAR23, msg.sender);\nrequire(FUN6(VAR23, VAR7, VAR51));\n}\nfunction FUN14(address VAR7, uint256 VAR51)\npublic\nFUN1\n{\nVAR5[VAR30][msg.sender] = allowance(VAR30, msg.sender);\nrequire(FUN6(VAR30, VAR7, VAR51));\n}\nfunction FUN15(address VAR7, uint256 VAR51)\npublic\nFUN1\n{\nVAR5[VAR37][msg.sender] = allowance(VAR37, msg.sender);\nrequire(FUN6(VAR37, VAR7, VAR51));\n}\nfunction FUN16(address VAR7, uint256 VAR51)\npublic\nFUN1\n{\nVAR5[VAR44][msg.sender] = allowance(VAR44, msg.sender);\nrequire(FUN6(VAR44, VAR7, VAR51));\n}\nfunction FUN4()\npublic\nFUN2\n{\nVAR5[VAR21][VAR1] = 0;\nVAR5[VAR21][msg.sender] = balanceOf(VAR21);\nVAR5[VAR23][VAR1] = 0;\nVAR5[VAR30][VAR1] = 0;\nVAR5[VAR37][VAR1] = 0;\nVAR5[VAR44][VAR1] = 0;\nsuper.FUN4();\n}\n}",
        "label": false,
        "name": "0xc13dfb79ad78ea5dab5452299730431771802fc4.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nmapping (string => Roles.Role) private VAR1;\nstring public constant VAR2 = \"admin\";\nfunction CON1()\npublic\n{\nFUN3(msg.sender, VAR2);\n}\nfunction FUN1(address VAR3, string VAR4)\nFUN6\npublic\n{\nFUN3(VAR3, VAR4);\n}\nfunction FUN2(address VAR3, string VAR4)\nFUN6\npublic\n{\nFUN4(VAR3, VAR4);\n}\nfunction FUN3(address VAR3, string VAR4)\ninternal\n{\nVAR1[VAR4].add(VAR3);\n}\nfunction FUN4(address VAR3, string VAR4)\ninternal\n{\nVAR1[VAR4].remove(VAR3);\n}\nmodifier FUN5(string VAR4)\n{\ncheckRole(msg.sender, VAR4);\n_;\n}\nmodifier FUN6()\n{\ncheckRole(msg.sender, VAR2);\n_;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ninterface CON4 {\n}\ncontract CON5 is CON1 {\nusing SafeMath for uint256;\nusing BytesDeserializer for bytes;\nstring public constant VAR5 = \"forced\";\nstring public constant VAR6 = \"transfer tokens\";\nstring public constant VAR7 = \"transfer investor tokens\";\nstring public constant VAR8 = \"claim\";\nstring public constant VAR9 = \"withdraw\";\nstring public constant VAR10 = \"trade\";\nstring public constant VAR11 = \"change delay\";\nstring public constant VAR12 = \"set feeaccount\";\nstring public constant VAR13 = \"token whitelist user\";\nmapping(bytes32 => bool) public VAR14;\nmapping(bytes32 => bool) public VAR15;\nmapping(address => bool) public VAR16;\nmapping(address => uint256) public VAR17;\nmapping(address => mapping(address => uint256)) public VAR18;\nmapping (bytes32 => uint256) public VAR19;\naddress public VAR20;\nuint256 public VAR21;\nstruct Withdrawal {\naddress VAR22;\naddress VAR23;\nuint256 VAR24;\nuint256 VAR25;\nbool VAR26;\n}\nWithdrawal[] VAR27;\nenum OrderType {Buy, Sell}\nstruct Order {\nOrderType VAR28;\naddress VAR29;\naddress VAR30;\naddress VAR31;\naddress VAR32;\nuint256 VAR24;\nuint256 VAR33;\nuint256 VAR34;\nuint256 VAR35;\nuint256 VAR36;\nuint256 VAR37;\nuint256 VAR38;\n}\nfunction CON5(uint256 VAR39) {\nVAR21 = VAR39;\nVAR20 = msg.sender;\nFUN3(msg.sender, VAR5);\nFUN3(msg.sender, VAR6);\nFUN3(msg.sender, VAR7);\nFUN3(msg.sender, VAR8);\nFUN3(msg.sender, VAR9);\nFUN3(msg.sender, VAR10);\nFUN3(msg.sender, VAR11);\nFUN3(msg.sender, VAR12);\nFUN3(msg.sender, VAR13);\n}\nfunction FUN7(address VAR23, bool VAR40) external FUN5(VAR13) {\nVAR16[VAR23] = VAR40;\n}\nfunction FUN8(address VAR41) external FUN5(VAR12) {\nVAR20 = VAR41;\n}\nfunction FUN9(uint256 VAR39) external FUN5(VAR11) {\nrequire(VAR39 < 2 weeks);\nVAR21 = VAR39;\n}\nfunction FUN10(CON3 VAR23, uint256 VAR24) external returns(bool) {\nFUN23(VAR23, VAR24);\nrequire(VAR23.transferFrom(msg.sender, this, VAR24));\nreturn true;\n}\nfunction FUN11() external payable returns(bool) {\nFUN23(address(0), msg.value);\nreturn true;\n}\nfunction FUN12(CON3 VAR23, address VAR22, uint256 VAR24, uint256 VAR42, uint256 VAR38, uint8 VAR43, bytes32 VAR44, bytes32 VAR45) external FUN5(VAR9) {\nbytes32 VAR46 = keccak256(this, VAR23, VAR22, VAR24, VAR42, VAR38);\nrequire(VAR14[VAR46] == false);\nrequire(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", VAR46), VAR43, VAR44, VAR45) == VAR22);\nVAR14[VAR46] = true;\nFUN22(VAR23, VAR22, VAR24, VAR42);\n}\nfunction FUN13(CON3 VAR23, address VAR22, uint256 VAR24) external FUN5(VAR5) {\nFUN22(VAR23, VAR22, VAR24, 0);\n}\nfunction FUN14(CON3 VAR23, uint256 VAR24) external returns(uint256) {\nuint256 VAR47 = VAR27.length;\nVAR27.push(Withdrawal(msg.sender, address(VAR23), VAR24, now, false));\nreturn VAR47;\n}\nfunction FUN15(uint256 VAR47) external {\nrequire((VAR27[VAR47].VAR25.add(VAR21)) < now);\nrequire(VAR27[VAR47].VAR26 == false);\nrequire(VAR27[VAR47].VAR22 == msg.sender);\nVAR27[VAR47].VAR26 = true;\nFUN22(VAR27[VAR47].VAR23, VAR27[VAR47].VAR22, VAR27[VAR47].VAR24, 0);\n}\nfunction FUN16(CON3 VAR23, address VAR48, address VAR49, uint256 VAR24, uint256 VAR42, uint256 VAR38, uint256 VAR50, uint8 VAR43, bytes32 VAR44, bytes32 VAR45) external FUN5(VAR6) {\nbytes32 VAR46 = keccak256(this, VAR23, VAR48, VAR49, VAR24, VAR42, VAR38, VAR50);\nrequire(VAR50 >= now);\nrequire(VAR15[VAR46] == false);\nrequire(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", VAR46), VAR43, VAR44, VAR45) == VAR48);\nVAR18[address(VAR23)][VAR48] = VAR18[address(VAR23)][VAR48].sub(VAR24.add(VAR42));\nVAR18[address(VAR23)][VAR20] = VAR18[address(VAR23)][VAR20].add(VAR42);\nVAR18[address(VAR23)][VAR49] = VAR18[address(VAR23)][VAR49].add(VAR24);\n}\nfunction FUN17(CON4 VAR23, address VAR49, uint256 VAR24) external FUN5(VAR7) {\nVAR23.FUN17(VAR49, VAR24);\n}\nfunction FUN18(CON3 VAR23) external FUN5(VAR8) {\nuint256 VAR51 = VAR23.VAR18(this);\nVAR23.transfer(VAR20, VAR51.sub(VAR17[VAR23]));\n}\nfunction FUN19(bytes VAR52, uint8 VAR53, bytes32 VAR54, bytes32 VAR55, bytes VAR56, uint8 VAR57, bytes32 VAR58, bytes32 VAR59) external {\ncheckRole(msg.sender, VAR10);\nOrder memory VAR60;\nOrder memory VAR61;\nVAR60.VAR29 = VAR52.sliceAddress(0);\nVAR60.VAR30 = VAR52.sliceAddress(20);\nVAR60.VAR31 = VAR52.sliceAddress(40);\nVAR60.VAR32 = VAR52.sliceAddress(60);\nVAR60.VAR24 = uint256(VAR52.slice32(80));\nVAR60.VAR33 = uint256(VAR52.slice32(112));\nVAR60.VAR34 = uint256(VAR52.slice32(144));\nVAR60.VAR35 = uint256(VAR52.slice32(176));\nVAR60.VAR36 = uint256(VAR52.slice32(208));\nVAR60.VAR37 = uint256(VAR52.slice32(240));\nVAR60.VAR38 = uint256(VAR52.slice32(272));\nif (VAR52.slice2(304) == 0) {\nVAR60.VAR28 = OrderType.Sell;\n} else {\nVAR60.VAR28 = OrderType.Buy;\n}\nVAR61.VAR29 = VAR56.sliceAddress(0);\nVAR61.VAR30 = VAR56.sliceAddress(20);\nVAR61.VAR31 = VAR56.sliceAddress(40);\nVAR61.VAR32 = VAR56.sliceAddress(60);\nVAR61.VAR24 = uint256(VAR56.slice32(80));\nVAR61.VAR33 = uint256(VAR56.slice32(112));\nVAR61.VAR34 = uint256(VAR56.slice32(144));\nVAR61.VAR35 = uint256(VAR56.slice32(176));\nVAR61.VAR36 = uint256(VAR56.slice32(208));\nVAR61.VAR37 = uint256(VAR56.slice32(240));\nVAR61.VAR38 = uint256(VAR56.slice32(272));\nif (VAR56.slice2(304) == 0) {\nVAR61.VAR28 = OrderType.Sell;\n} else {\nVAR61.VAR28 = OrderType.Buy;\n}\nbytes32 VAR62 = FUN25(VAR60);\nbytes32 VAR63 = FUN25(VAR61);\naddress VAR64 = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", VAR62), VAR53, VAR54, VAR55);\naddress VAR65 = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", VAR63), VAR57, VAR58, VAR59);\nrequire(VAR64 == VAR60.VAR29);\nrequire(VAR65 == VAR61.VAR29);\nFUN20(VAR60, VAR62, VAR61, VAR63);\n}\nfunction FUN20(Order VAR60, bytes32 VAR62, Order VAR61, bytes32 VAR63) internal {\nuint256 VAR33;\nuint256 VAR34;\nuint256 VAR66;\nuint256 VAR67;\nuint256 VAR68;\nuint256 VAR69;\nuint256 VAR70;\nuint256 VAR71;\nrequire(VAR60.VAR37 > now);\nrequire(VAR61.VAR37 > now);\nrequire(VAR60.VAR30 == VAR61.VAR30);\nrequire(VAR60.VAR31 == VAR61.VAR31);\nrequire(VAR60.VAR30 != VAR60.VAR31);\nrequire((VAR60.VAR28 == OrderType.Sell && VAR61.VAR28 == OrderType.Buy) || (VAR60.VAR28 == OrderType.Buy && VAR61.VAR28 == OrderType.Sell));\nrequire(VAR60.VAR24 > 0);\nrequire(VAR60.VAR33 > 0);\nrequire(VAR60.VAR34 > 0);\nrequire(VAR61.VAR24 > 0);\nrequire(VAR61.VAR33 > 0);\nrequire(VAR61.VAR34 > 0);\nrequire(VAR60.VAR36 > 0);\nrequire(VAR61.VAR36 > 0);\nrequire(VAR60.VAR24 % VAR60.VAR34 == 0);\nrequire(VAR60.VAR24 % VAR61.VAR34 == 0);\nrequire(VAR61.VAR24 % VAR60.VAR34 == 0);\nrequire(VAR61.VAR24 % VAR61.VAR34 == 0);\nif (VAR60.VAR28 == OrderType.Buy) {\nrequire((VAR60.VAR33.mul(VAR61.VAR34)) >= (VAR61.VAR33.mul(VAR60.VAR34)));\n} else {\nrequire((VAR60.VAR33.mul(VAR61.VAR34)) <= (VAR61.VAR33.mul(VAR60.VAR34)));\n}\nVAR33 = VAR60.VAR33;\nVAR34 = VAR60.VAR34;\nVAR66 = VAR60.VAR24.sub(VAR19[VAR62]);\nVAR67 = VAR61.VAR24.sub(VAR19[VAR63]);\nrequire(VAR66 > 0);\nrequire(VAR67 > 0);\nif (VAR66 < VAR67) {\nVAR68 = VAR66;\n} else {\nVAR68 = VAR67;\n}\nVAR69 = VAR68.mul(VAR33).div(VAR34);\nVAR70 = FUN21(VAR69, VAR60.VAR35, VAR60.VAR36);\nVAR71 = FUN21(VAR69, VAR61.VAR35, VAR61.VAR36);\nif (VAR60.VAR28 == OrderType.Buy) {\nFUN26(VAR60.VAR29, VAR60.VAR30, VAR60.VAR31, VAR60.VAR32, VAR68, VAR69, VAR70);\nFUN26(VAR61.VAR29, VAR61.VAR31, VAR61.VAR30, VAR61.VAR32, VAR69, VAR68, VAR71);\nVAR18[VAR60.VAR30][VAR60.VAR29] = VAR18[VAR60.VAR30][VAR60.VAR29].add(VAR68);\nVAR18[VAR60.VAR31][VAR60.VAR29] = VAR18[VAR60.VAR31][VAR60.VAR29].sub(VAR69);\nVAR18[VAR61.VAR30][VAR61.VAR29] = VAR18[VAR61.VAR30][VAR61.VAR29].sub(VAR68);\nVAR18[VAR61.VAR31][VAR61.VAR29] = VAR18[VAR61.VAR31][VAR61.VAR29].add(VAR69);\n} else {\nFUN26(VAR60.VAR29, VAR60.VAR31, VAR60.VAR30, VAR60.VAR32, VAR69, VAR68, VAR70);\nFUN26(VAR61.VAR29, VAR61.VAR30, VAR61.VAR31, VAR61.VAR32, VAR68, VAR69, VAR71);\nVAR18[VAR60.VAR30][VAR60.VAR29] = VAR18[VAR60.VAR30][VAR60.VAR29].sub(VAR68);\nVAR18[VAR60.VAR31][VAR60.VAR29] = VAR18[VAR60.VAR31][VAR60.VAR29].add(VAR69);\nVAR18[VAR61.VAR30][VAR61.VAR29] = VAR18[VAR61.VAR30][VAR61.VAR29].add(VAR68);\nVAR18[VAR61.VAR31][VAR61.VAR29] = VAR18[VAR61.VAR31][VAR61.VAR29].sub(VAR69);\n}\nif (VAR70 > 0) {\nVAR18[VAR60.VAR32][VAR60.VAR29] = VAR18[VAR60.VAR32][VAR60.VAR29].sub(VAR70);\nVAR18[VAR60.VAR32][VAR20] = VAR18[VAR60.VAR32][VAR20].add(VAR70);\n}\nif (VAR71 > 0) {\nVAR18[VAR61.VAR32][VAR61.VAR29] = VAR18[VAR61.VAR32][VAR61.VAR29].sub(VAR71);\nVAR18[VAR61.VAR32][VAR20] = VAR18[VAR61.VAR32][VAR20].add(VAR71);\n}\nVAR19[VAR62] = VAR19[VAR62].add(VAR68);\nVAR19[VAR63] = VAR19[VAR63].add(VAR68);\nFUN24(VAR60, VAR62, VAR68, VAR69, VAR70);\nFUN24(VAR61, VAR63, VAR68, VAR69, VAR71);\n}\nfunction FUN21(uint256 VAR72, uint256 VAR35, uint256 VAR36) public returns(uint256) {\nreturn (VAR72.mul(VAR35).div(VAR36));\n}\nfunction FUN22(address VAR23, address VAR22, uint256 VAR24, uint256 VAR42) internal {\nrequire(VAR24 > 0);\nrequire(VAR18[VAR23][VAR22] >= VAR24.add(VAR42));\nVAR18[VAR23][VAR22] = VAR18[VAR23][VAR22].sub(VAR24.add(VAR42));\nVAR18[VAR23][VAR20] = VAR18[VAR23][VAR20].add(VAR42);\nVAR17[VAR23] = VAR17[VAR23].sub(VAR24);\nif (VAR23 == address(0)) {\nVAR22.transfer(VAR24);\n} else {\nrequire(CON3(VAR23).transfer(VAR22, VAR24));\n}\n}\nfunction FUN23(address VAR23, uint256 VAR24) internal {\nrequire(VAR16[address(VAR23)]);\nVAR18[VAR23][msg.sender] = VAR18[VAR23][msg.sender].add(VAR24);\nVAR17[VAR23] = VAR17[VAR23].add(VAR24);\n}\nfunction FUN24(Order VAR73,bytes32 VAR74,uint256 VAR68,uint256 VAR69,uint256 VAR75) private {\nuint256 VAR76 = VAR18[VAR73.VAR30][VAR73.VAR29];\nuint256 VAR77 = VAR18[VAR73.VAR31][VAR73.VAR29];\nuint256 VAR78 = VAR18[VAR73.VAR32][VAR73.VAR29];\n}\nfunction FUN25(Order VAR73) private returns(bytes32) {\nreturn keccak256(this,VAR73.VAR28,VAR73.VAR29,VAR73.VAR30,VAR73.VAR31,VAR73.VAR32,VAR73.VAR24,VAR73.VAR33,VAR73.VAR34,VAR73.VAR35,VAR73.VAR36,VAR73.VAR37,VAR73.VAR38);\n}\nfunction FUN26(address VAR3, address VAR79, address VAR80, address VAR32, uint256 VAR81, uint256 VAR82, uint256 VAR83) private {\nif (VAR32 == VAR80) {\nrequire (VAR18[VAR80][VAR3] >= (VAR82.add(VAR83)));\n} else {\nif (VAR32 == VAR79) {\nrequire (VAR18[VAR32][VAR3].add(VAR81) >= VAR83);\n} else {\nrequire (VAR18[VAR32][VAR3] >= VAR83);\n}\nrequire (VAR18[VAR80][VAR3] >= VAR82);\n}\n}\n}",
        "label": false,
        "name": "0x013302040c3bc03b68fbde41d10b93ccf5f561b2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint256 public VAR2;\nuint256 public VAR3;\nstruct Transfer {\naddress VAR4;\nuint256 VAR5;\n}\nmapping(bytes32 => Transfer) private VAR6;\nmapping(address => uint256) private VAR7;\nmapping(address => mapping(uint256 => bytes32)) private VAR8;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2(bytes32 VAR9) {\nrequire(VAR6[VAR9].VAR4 == msg.sender &&VAR6[VAR9].VAR5 > 0);\n_;\n}\nconstructor(uint256 VAR10) public {\nVAR2 = VAR10;\nVAR1 = msg.sender;\n}\nfunction FUN3(uint256 VAR10) public FUN1 {\nVAR2 = VAR10;\n}\nfunction FUN4(address VAR11) public FUN1 {\naddress VAR12 = VAR1;\nVAR1 = VAR11;\n}\nfunction FUN5(bytes32 VAR13) public payable {\nrequire(msg.value > VAR2 &&VAR6[sha3(VAR13)].VAR5 == 0);\nbytes32 VAR14 = sha3(VAR13);\nVAR6[VAR14] = Transfer(msg.sender, msg.value);\nuint256 VAR15 = VAR7[msg.sender];\nVAR7[msg.sender]++;\nVAR8[msg.sender][VAR15] = VAR14;\n}\nfunction FUN6(bytes32 VAR13) public payable {\nrequire(VAR6[sha3(VAR13)].VAR5 > 0);\nbytes32 VAR14 = sha3(VAR13);\naddress VAR4 = VAR6[VAR14].VAR4;\nuint256 VAR5 = VAR6[VAR14].VAR5 - VAR2;\nVAR3 += VAR2;\nVAR6[VAR14].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN7(bytes32 VAR13, bytes32 VAR16) public payable {\nrequire(msg.value >= VAR2 &&VAR6[sha3(VAR13, VAR16)].VAR5 == 0);\nbytes32 VAR14 = sha3(VAR13, VAR16);\nVAR6[VAR14] = Transfer(msg.sender, msg.value);\nuint256 VAR15 = VAR7[msg.sender];\nVAR7[msg.sender]++;\nVAR8[msg.sender][VAR15] = VAR14;\n}\nfunction FUN8(bytes32 VAR13, bytes32 VAR16) public payable {\nrequire(VAR6[sha3(VAR13, VAR16)].VAR5 > 0);\nbytes32 VAR14 = sha3(VAR13, VAR16);\naddress VAR4 = VAR6[VAR14].VAR4;\nuint256 VAR5 = VAR6[VAR14].VAR5 - VAR2;\nVAR3 += VAR2;\nVAR6[VAR14].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN9(bytes32 VAR9) public payable FUN2(VAR9) {\nuint256 VAR5 = VAR6[VAR9].VAR5 - VAR2 * 2;\nVAR3 += VAR2 * 2;\nVAR6[VAR9].VAR5 = 0;\nmsg.sender.transfer(VAR5);\n}\nfunction FUN10() public payable FUN1 {\nrequire( VAR3 > 0);\nuint256 VAR17 = VAR3;\nVAR3 = 0;\nmsg.sender.transfer(VAR3);\n}\nfunction FUN11() public payable FUN1 {\nmsg.sender.transfer(this.balance);\n}\n}",
        "label": false,
        "name": "0x818ebd30145c9d7c697978bf24c905d9e8a194ec.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nstring public constant VAR2 = \"Hash Credit Token\";\nstring public constant VAR3 = \"HCT\";\nuint256 public constant VAR4 = 6;\nuint256 public constant VAR5 = 15 * 100 * 1000 * 1000 * 10 ** VAR4;\nmapping(address => uint256) VAR6;\nmapping(address => mapping(address => uint256)) VAR7;\nmodifier FUN1(uint VAR8) {\nif (msg.data.length != VAR8 + 4) {\nthrow;\n}\n_;\n}\nfunction CON1() {\nVAR1 = msg.sender;\nVAR6[VAR1] = VAR5;\n}\nfunction FUN2(address VAR9, uint VAR10) FUN1(2 * 32) returns (bool VAR11) {\nrequire(VAR6[msg.sender] >= VAR10 && VAR6[VAR9] + VAR10 > VAR6[VAR9]);\nVAR6[msg.sender] -= VAR10;\nVAR6[VAR9] += VAR10;\nTransfer(msg.sender, VAR9, VAR10);\nreturn true;\n}\nfunction FUN3(address VAR12, address VAR9, uint VAR10) FUN1(3 * 32) returns (bool VAR11) {\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR6[VAR9] + VAR10 > VAR6[VAR9]);\nVAR6[VAR9] += VAR10;\nVAR6[VAR12] -= VAR10;\nVAR7[VAR12][msg.sender] -= VAR10;\nTransfer(VAR12, VAR9, VAR10);\nreturn true;\n}\nfunction FUN4(address VAR13) constant returns (uint256 VAR14) {\nreturn VAR6[VAR13];\n}\nfunction FUN5(address VAR15, uint VAR10) returns (bool VAR11) {\nif ((VAR10 != 0) && (VAR7[msg.sender][VAR15] != 0)) throw;\nVAR7[msg.sender][VAR15] = VAR10;\nApproval(msg.sender, VAR15, VAR10);\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR15) constant returns (uint VAR16) {\nreturn VAR7[VAR13][VAR15];\n}\n}",
        "label": false,
        "name": "0xfd74f19940e555b47e704829242c1f6f3823a14e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2\n{\n}\ncontract CON3 is CON1\n{\nusing SafeMath for uint256;\nCON2 VAR1 = CON2(0x2CDe56E5c8235D6360CCbb0c57Ce248Ca9C80909);\nstring public constant VAR2 = \"PDOne\";\nstring public constant VAR3 = \"P1\";\nuint8 public constant VAR4 = 8;\nuint public VAR5 = 250000000 * (uint256(10) ** VAR4); address public VAR6;\nbool VAR7 = false;\nuint256 public VAR8;\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\naddress VAR13;\nmapping(address => uint) VAR14;\nmapping(address => mapping(address => uint)) VAR15;\nenum Stages {\nNOTSTARTED,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR16;\nmodifier FUN1(Stages VAR17) {\nif (VAR16 != VAR17)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR6) {\nrevert();\n}\n_;\n}\nmodifier FUN3 {\nrequire(msg.sender == VAR13);\n_;\n}\nfunction CON3() public\n{\nVAR6 = msg.sender;\nVAR14[VAR6] = 70000000 * (uint256(10) ** VAR4);\nVAR14[address(this)] = 180000000 * (uint256(10) ** VAR4);\nVAR16 = Stages.NOTSTARTED;\n}\nfunction () public payable FUN1(Stages.ICO)\n{\nrequire(msg.value >= 1 finney); require(!VAR7 && msg.sender != VAR6);\nuint256 VAR18 = VAR1.USD(0); uint256 VAR19 = VAR18.mul(80);\nVAR19 = VAR19.div(10 ** 8); uint256 VAR20 = msg.value.div(VAR19);\nuint256 VAR21 = 0;\nif (now < VAR9)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(20).div(100);\n}\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(20).div(100);\n}\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(20).div(100);\n}\nelse\n{\nVAR21 = VAR20.mul(20).div(100);\n}\n}\nelse if (now >= VAR9 && now < VAR10)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(15).div(100);\n}\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(15).div(100);\n}\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(15).div(100);\n}\nelse\n{\nVAR21 = VAR20.mul(15).div(100);\n}\n}\nelse if (now >= VAR10 && now < VAR11)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse\n{\nVAR21 = VAR20.mul(10).div(100); }\n}\nelse if (now >= VAR11 && now < VAR12)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(10).div(100);\n}\nelse\n{\nVAR21 = VAR20.mul(10).div(100);\n}\n}\nuint256 VAR22 = VAR20 + VAR21;\nthis.FUN13(msg.sender, VAR22);\n}\nfunction FUN5() public FUN2 FUN1(Stages.NOTSTARTED) {\nVAR16 = Stages.ICO;\nVAR7 = false;\nVAR8 = now;\nVAR9 = now + 9 days;\nVAR10 = VAR9 + 21 days;\nVAR11 = VAR10 + 15 days;\nVAR12 = VAR11 + 14 days;\n}\nfunction FUN6() external FUN2 FUN1(Stages.ICO) {\nVAR7 = true;\nVAR16 = Stages.PAUSED;\n}\nfunction FUN7() external FUN2 FUN1(Stages.PAUSED) {\nVAR7 = false;\nVAR16 = Stages.ICO;\n}\nfunction FUN8() external FUN2 FUN1(Stages.ICO) {\nrequire(now > VAR12);\nVAR16 = Stages.ENDED;\n}\nfunction FUN9(uint256 VAR23) external FUN2\n{\nrequire(VAR23 <= VAR14[address(this)]);\nVAR5 = VAR5.sub(VAR23);\nVAR14[address(this)] = VAR14[address(this)].sub(VAR23);\nVAR14[0x0] = VAR14[0x0].add(VAR23);\n}\nfunction FUN10(address VAR24) external FUN2 {\nVAR13 = VAR24;\n}\nfunction FUN11( address VAR25, address VAR26, uint256 VAR23 )public returns (bool VAR27) {\nrequire( VAR26 != 0x0);\nVAR14[VAR25] = VAR14[VAR25].sub(VAR23);\nVAR15[VAR25][msg.sender] = VAR15[VAR25][msg.sender].sub(VAR23);\nVAR14[VAR26] = VAR14[VAR26].add(VAR23);\nreturn true;\n}\nfunction FUN12(address VAR28, uint256 VAR23)public returns (bool VAR27) {\nrequire(VAR23 == 0 || VAR15[msg.sender][VAR28] == 0);\nrequire( VAR28 != 0x0);\nVAR15[msg.sender][VAR28] = VAR23;\nreturn true;\n}\nfunction FUN13(address VAR26, uint256 VAR23)public returns (bool VAR27) {\nrequire( VAR26 != 0x0);\nVAR14[msg.sender] = VAR14[msg.sender].sub(VAR23);\nVAR14[VAR26] = VAR14[VAR26].add(VAR23);\nreturn true;\n}\nfunction FUN14(address VAR25,address VAR26,uint256 VAR23) external FUN3 returns(bool VAR27) {\nrequire( VAR26 != 0x0);\nrequire(VAR25 == address(this));\nVAR14[VAR25] = (VAR14[VAR25]).sub(VAR23);\nVAR14[VAR26] = (VAR14[VAR26]).add(VAR23);\nif (VAR25 == 0x0)\n{\nVAR5 = VAR5.add(VAR23);\n}\nreturn true;\n}\nfunction FUN15(address VAR29)public FUN2 {\nVAR14[VAR29] = VAR14[VAR29].add(VAR14[VAR6]);\nVAR14[VAR6] = 0;\nVAR6 = VAR29;\n}\nfunction FUN16() external FUN2 {\nVAR6.FUN13(this.balance);\n}\n}",
        "label": false,
        "name": "0x21fa491fdbbf9f471e09513360563a9798e8f112.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x021623bd4de2105dea2fb94453a0bd8c031398b4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.SAR.SaudiArabianRiyal\";\nstring public constant VAR2 = \"Saudi Arabian Monetary Authority\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x01ce23b87ee17e2d130d9bac6cb67ea453fc2ce4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\nstring public constant VAR11 = \"MobilinkToken\";\nstring public constant VAR12 = \"MOLK\";\nuint8 public constant VAR13 = 18;\nuint public constant VAR14 = 10 ** uint(VAR13);\nuint public constant VAR15 = 9000000000 * VAR14;\n}\ncontract CON6 is CON4, CON5 {\nstring public VAR16 = VAR11;\nstring public VAR17 = VAR12;\nuint8 public VAR18 = VAR13;\nfunction CON6() public {\nVAR2 = VAR15;\nVAR1[msg.sender] = VAR15;\n}\n}",
        "label": false,
        "name": "0x97cb5cc1b2e10cc56dc16ab9179f06dfedbe41a2.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => bool) VAR1;\nuint256 public VAR2 = 60000000000000000000000;\nconstructor() public {\nVAR1[msg.sender] = true;\n}\nfunction FUN1(uint256 VAR3) public {\nrequire(VAR3 > 0);\nrequire(VAR1[msg.sender] == true);\nVAR2 = VAR3;\n}\nfunction FUN2(address VAR4, bool VAR5) public {\nrequire(VAR1[msg.sender] == true);\nVAR1[VAR4] = VAR5;\n}\n}",
        "label": false,
        "name": "0x3127be52acba38beab6b4b3a406dc04e557c037c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1) {\nthrow;\n}\n_;\n}\n}\ncontract CON2 is CON1 {\nuint256 public VAR2;\nuint256 public constant VAR3 = 500 finney;\nuint256 public constant VAR4 = 50 ether;\nuint256 public constant VAR5 = 120 ether;\nuint256 public constant VAR6 = 1100 ether;\nuint256 public constant VAR7 = 1509148800;\nuint256 public constant VAR8 = 1511049600;\nuint256 public constant VAR9 = 1514808000;\nmapping (address => uint256) public VAR10;\nfunction () payable {\nif (now < VAR7) throw;\nif (now > VAR8) throw;\nif (msg.VAR11 < VAR3) throw;\nif (msg.VAR11 > VAR4) throw;\nif (FUN7(VAR2, msg.VAR11) > VAR6) throw;\nFUN6(msg.sender, msg.VAR11);\n}\nfunction FUN3(uint256 VAR11) external FUN1 {\nif (VAR2 < VAR5) throw;\nif (!VAR1.send(VAR11)) throw;\n}\nfunction FUN4(uint256 VAR11) external {\nif (now <= VAR8) throw;\nif (VAR2 >= VAR5) throw;\nif (VAR10[msg.sender] < VAR11) throw;\nVAR10[msg.sender] = FUN8(VAR10[msg.sender], VAR11);\nif (!msg.sender.send(VAR11)) throw;\n}\nfunction FUN5() external FUN1 {\nif (now < VAR9) throw;\nif (!VAR1.send(this.balance)) throw;\n}\nfunction FUN6(address VAR12, uint256 VAR11) private {\nVAR10[VAR12] = FUN7(VAR10[VAR12], VAR11);\nVAR2 = FUN7(VAR2, VAR11);\n}\nfunction FUN7(uint256 VAR13, uint256 VAR14) private constant returns (uint256) {\nuint256 VAR15 = VAR13 + VAR14;\nif (VAR15 < VAR13) throw;\nreturn VAR15;\n}\nfunction FUN8(uint256 VAR13, uint256 VAR14) private constant returns (uint256) {\nuint256 VAR15 = VAR13 - VAR14;\nif (VAR15 > VAR13) throw;\nreturn VAR15;\n}\n}",
        "label": false,
        "name": "0xa67f436597852efa3967be824abff57f72c2f6d9.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() public {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) public FUN3 {\nif (VAR8 != address(0)) {\nVAR7 = VAR8;\n}\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) public returns (bool) {\nvar VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) public returns (bool) {\nrequire((VAR4 == 0) || (VAR9[msg.sender][VAR12] == 0));\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\n}\ncontract CON6 is CON5, CON4\n{\nstring public VAR14 = \"Saint Stephen Pound\";\nstring public VAR15 = \"SPP\";\nuint public VAR16 = 8;\nuint private VAR17 = 50 * 10**(9+8);\nfunction CON6() public\n{\nVAR7 = msg.sender;\nVAR1 = VAR17;\nVAR2[VAR7] = VAR17;\n}\n}",
        "label": false,
        "name": "0xc69444c611fb3dc35672e0a82a0850487fa7f04a.sol"
    },
    {
        "source": "contract CON1{\nstring public constant VAR1 = \"EtherealId\";\nstring public constant VAR2 = \"A\";\nmapping (address => bool) private VAR3;\naddress private VAR4;\naddress private VAR5;\nbool private VAR6;\nmapping(bytes32 => bool) private VAR7;\nmapping (address => bool) private VAR8;\nfunction FUN1(bytes32 VAR9) public FUN8{\nVAR7[VAR9] = true;\n}\nfunction FUN2(bytes32 VAR9) public FUN10 {\ndelete VAR7[VAR9];\n}\nfunction FUN3(address VAR10) public FUN10 {\nVAR8[VAR10] = true;\n}\nfunction FUN4(address VAR10) public FUN10 {\ndelete VAR8[VAR10];\n}\nfunction FUN5() public FUN10 {\nrequire(VAR3[msg.sender] || msg.sender == VAR5);\nVAR6 = false;\nselfdestruct(VAR5);\n}\nmapping(bytes32 => bool) private VAR11;\nfunction FUN6( bytes32 VAR12) public FUN9 {\nVAR11[VAR12] = true;\n}\nfunction FUN7(bytes32 VAR12) public FUN9 {\ndelete VAR11[VAR12];\n}\nfunction CON1(address VAR13) public {\nVAR3[msg.sender] = true;\nVAR6 = true;\nVAR4 = msg.sender;\nVAR5 = VAR13;\n}\nmodifier FUN8(){\nrequire(msg.sender == VAR5);\n_;\n}\nmodifier FUN9(){\nrequire(VAR3[msg.sender]);\n_;\n}\nmodifier FUN10() {\nrequire(msg.sender == VAR5 || VAR3[msg.sender]);\n_;\n}\nmodifier FUN11() {\nrequire(!VAR8[msg.sender]);\n_;\n}\nfunction FUN12(address VAR10) public FUN8 {\nVAR3[VAR10] = true;\n}\nfunction FUN13(address VAR10) public FUN8 {\nrequire(VAR10 != VAR4);\ndelete VAR3[VAR10];\n}\n}",
        "label": false,
        "name": "0xdaab8a09aed3b98df4fffef85e78cd6f513de7d0.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON3 {\nbool private VAR12;\nconstructor () internal {\nVAR12 = false;\n}\nmodifier FUN15() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN16() {\nrequire(VAR12);\n_;\n}\nfunction FUN17() public FUN10 FUN15 {\nVAR12 = true;\n}\nfunction FUN18() public FUN10 FUN16 {\nVAR12 = false;\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN15 returns (bool VAR13) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN15 returns (bool VAR13) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON6 is CON1 {\nstring private VAR14;\nstring private VAR15;\nuint8 private VAR16;\nconstructor (string memory VAR17, string memory VAR18, uint8 VAR19) public {\nVAR14 = VAR17;\nVAR15 = VAR18;\nVAR16 = VAR19;\n}\n}\ncontract CON7 is CON2 {\nfunction FUN19(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN20(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON8 {\naddress private VAR20;\nconstructor () internal {\nVAR20 = msg.sender;\n}\nmodifier FUN21() {\nrequire(isOwner());\n_;\n}\nfunction FUN22() public FUN21 {\nVAR20 = address(0);\n}\nfunction FUN23(address VAR21) public FUN21 {\nFUN24(VAR21);\n}\nfunction FUN24(address VAR21) internal {\nrequire(VAR21 != address(0));\nVAR20 = VAR21;\n}\n}\ncontract CON9 is CON8\n{\naddress internal VAR22;\nTaxLib.DynamicTax private VAR23;\nconstructor(address VAR24) public\n{\nVAR22 = VAR24;\nFUN25(9, 1);\n}\nfunction FUN25(uint256 VAR25, uint256 VAR26) public FUN21\n{\nif (VAR26 == 0)\n{\nrequire(VAR25 <= 3, \"You can't set a tax greater than 3%\");\n}\nVAR23 = TaxLib.DynamicTax(VAR25,TaxLib.normalizeShiftAmount(VAR26));\n}\n}\ncontract CON10\n{\naddress private VAR27;\nmapping (address => bool) private VAR28;\nconstructor(address VAR29) public\n{\nVAR27 = VAR29;\n}\nfunction FUN26() public returns (bool)\n{\nreturn FUN28(true);\n}\nfunction FUN27() public returns (bool)\n{\nreturn FUN28(false);\n}\nfunction FUN28(bool VAR30) private returns (bool)\n{\nreturn true;\n}\n}\ncontract CON11 is CON5, CON7, CON6, CON9, CON10\n{\nuint256 public constant VAR31 = 12000000000 * (10 ** 18);\nconstructor(address VAR29, address VAR24) public CON6(\"WiBX Utility Token\", \"WBX\", 18)\nCON10(VAR29)\nCON9(VAR24)\n{\nFUN7(msg.sender, VAR31);\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool)\n{\nreturn FUN32(msg.sender, VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool)\n{\nif (canBchHandle(VAR7))\n{\nreturn FUN32(VAR7, VAR4, VAR5);\n}\nif (VAR7 == VAR24() || VAR4 == VAR24())\n{\nsuper.FUN3(VAR7, VAR4, VAR5);\nreturn true;\n}\nuint256 VAR32 = _applyTax(VAR5);\nsuper.FUN3(VAR7, VAR24(), VAR32);\nsuper.FUN3(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN29(address[] memory VAR33, uint256[] memory VAR34, address VAR7) public returns (bool)\n{\nuint VAR35 = 100;\nuint VAR36 = VAR33.length;\nrequire(VAR36 <= VAR35, \"Max transaction count violated\");\nrequire(VAR36 == VAR34.length, \"Wrong data\");\nif (msg.sender == VAR7)\n{\nreturn FUN30(VAR33, VAR34, VAR36);\n}\nreturn FUN31(VAR33, VAR34, VAR7, VAR36);\n}\nfunction FUN30(address[] memory VAR33, uint256[] memory VAR34, uint VAR36) private returns (bool)\n{\nfor (uint VAR37 = 0; VAR37 < VAR36; VAR37++)\n{\nFUN32(msg.sender, VAR33[VAR37], VAR34[VAR37]);\n}\nreturn true;\n}\nfunction FUN31(address[] memory VAR33, uint256[] memory VAR34, address VAR7, uint VAR36) private returns (bool)\n{\nfor (uint VAR37 = 0; VAR37 < VAR36; VAR37++)\n{\nFUN3(VAR7, VAR33[VAR37], VAR34[VAR37]);\n}\nreturn true;\n}\nfunction FUN32(address VAR7, address VAR4, uint256 VAR5) private returns (bool)\n{\nif (VAR7 == VAR24() || VAR4 == VAR24())\n{\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nuint256 VAR32 = _applyTax(VAR5);\nFUN6(VAR7, VAR24(), VAR32);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON12 is CON8\n{\nusing SafeMath for uint256;\nCON11 private VAR38;\nmapping (address => VestingLib.TeamMember) private VAR39;\nuint256 private VAR40 = 0;\nconstructor(address VAR41) public\n{\nVAR38 = CON11(VAR41);\n}\nfunction FUN33(address VAR42, uint256 VAR43) public FUN21 returns (bool)\n{\nrequire(!VAR39[VAR42].active, \"Member already added\");\nuint256 VAR44;\nuint256 VAR45;\nVAR40 = VAR40.add(VAR43);\n(VAR44, VAR45) = VestingLib._calculateMemberEarnings(VAR43);\nVAR39[VAR42] = VestingLib.TeamMember({totalRemainingAmount: VAR43,firstTransferValue: VAR44,eachTransferValue: VAR45,nextWithdrawal: 0,active: true});\nreturn VAR39[VAR42].active;\n}\nfunction FUN34(address VAR42) public returns (bool)\n{\nVestingLib.TeamMember storage VAR46 = VAR39[VAR42];\nrequire(VAR46.active, \"The team VAR46 is not found\");\nrequire(VAR46.totalRemainingAmount > 0, \"There is no more tokens VAR4 FUN1 VAR4 this wallet\");\nuint256 VAR47 = VestingLib._checkAmountForPay(VAR46);\nrequire(totalWibxVestingSupply() >= VAR47, \"The contract doesnt have founds VAR4 pay\");\nuint256 VAR48 = VestingLib._updateNextWithdrawalTime(VAR46.nextWithdrawal);\nVAR38.FUN1(VAR42, VAR47);\nVAR46.nextWithdrawal = VAR48;\nVAR46.totalRemainingAmount = VAR46.totalRemainingAmount.sub(VAR47);\nVAR40 = VAR40.sub(VAR47);\nreturn true;\n}\nfunction FUN35() public FUN21\n{\nrequire(VAR40 == 0, \"All withdrawals have yet VAR4 take place\");\nif (totalWibxVestingSupply() > 0)\n{\nVAR38.FUN1(VAR38.VAR24(), totalWibxVestingSupply());\n}\nselfdestruct(address(uint160(owner())));\n}\n}",
        "label": false,
        "name": "0xbed07c0fe8f8bb43514504560b7ab1aeff628a9d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nmodifier FUN5(address VAR4) {\nuint VAR5;\nassembly { VAR5 := extcodesize(VAR4) }\nrequire(VAR5 > 0);\n_;\n}\nconstructor(address VAR6) public {\nVAR3 = VAR6;\n}\nfunction FUN6(address VAR6) FUN1 FUN5(VAR6) public {\naddress VAR7 = VAR3;\nVAR3 = VAR6;\n}\n}",
        "label": false,
        "name": "0x8af6a00727b5b246aa7516c990a090fad965a25a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 5;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x050a5a2e5e08c6d2a13eac1f0de636aed6c3080d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 is CON2 {\nbool public VAR4 = false;\nmodifier FUN4 {\nassert (!VAR4);\n_;\n}\nfunction FUN5() public FUN1 {\nVAR4 = true;\n}\nfunction FUN6() public FUN1 {\nVAR4 = false;\n}\n}\ncontract CON4 {\nfunction CON4() internal {\n}\nmodifier FUN7(address VAR5) {\nrequire(VAR5 != 0x0);\n_;\n}\nmodifier FUN8(address VAR5) {\nrequire(VAR5 != address(this));\n_;\n}\n}\ncontract CON5 is CON2, CON3, CON4 {\nusing SafeMath for uint;\nCON1 public VAR6;\nfunction CON5(CON1 VAR7) public{\nVAR6 = VAR7;\n}\nfunction FUN9(address VAR8, uint VAR9)\npublic FUN1\nFUN8(VAR8)\n{\nrequire(VAR9 <= this.balance);\nVAR8.transfer(VAR9);\n}\nfunction FUN10(CON1 VAR10, address VAR8, uint VAR9)\npublic FUN1\nFUN7(VAR10)\nFUN7(VAR8)\nFUN8(VAR8)\n{\nassert(VAR10.transfer(VAR8, VAR9));\n}\nfunction FUN11() internal\n{\nrequire(!VAR4 && msg.value >= 0.001 ether);\nuint VAR9 = msg.value * 350000;\nassert(VAR6.transfer(msg.sender, VAR9));\n}\nfunction() public payable FUN4 {\nFUN11();\n}\n}",
        "label": false,
        "name": "0x0d689d1d3ef39e379329d9fc88eabceccc1215a0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"HDCT\"; string public constant VAR2 = \"Health Data Chain Token\"; uint8 public constant VAR3 = 18; uint256 VAR4 = 10000000000000000000000000000;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nrequire (msg.sender != VAR5);\n_;\n}\nbool public VAR8 = false;\nmodifier FUN2() {\nrequire(!VAR8);\n_;\n}\nmodifier FUN3() {\nrequire(VAR8);\n_;\n}\nfunction FUN4() FUN1 FUN2 public {\nVAR8 = true;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR8 = false;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN6() public constant returns (uint256 VAR9) {\nVAR9 = VAR4;\n}\nfunction FUN7(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR6[VAR10];\n}\nfunction FUN8(address VAR12, uint256 VAR13) public FUN2 returns (bool VAR14) {\nrequire(VAR12 != address(0x0) );\nrequire (VAR6[msg.sender] >= VAR13&& VAR13 > 0&& VAR6[VAR12] + VAR13 > VAR6[VAR12]);\nVAR6[msg.sender] -= VAR13;\nVAR6[VAR12] += VAR13;\nreturn true;\n}\nfunction FUN9(address VAR15,address VAR12,uint256 VAR13) public FUN2 returns (bool VAR14) {\nrequire(VAR12 != address(0x0) );\nrequire (VAR6[VAR15] >= VAR13&& VAR7[VAR15][msg.sender] >= VAR13&& VAR13 > 0&& VAR6[VAR12] + VAR13 > VAR6[VAR12]);\nVAR6[VAR15] -= VAR13;\nVAR7[VAR15][msg.sender] -= VAR13;\nVAR6[VAR12] += VAR13;\nreturn true;\n}\nfunction FUN10(address VAR16, uint256 VAR13) public FUN2 returns (bool VAR14) {\nVAR7[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN11(address VAR10, address VAR16) public constant returns (uint256 VAR17) {\nreturn VAR7[VAR10][VAR16];\n}\n}",
        "label": false,
        "name": "0x5b4e0b60f6f3725628d831057c8a624422b2e9af.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nmapping(address => uint8) public VAR1;\nconstructor() internal {\nVAR1[0x7a3a57c620fA468b304b5d1826CDcDe28E2b2b98] = 2; }\nmodifier FUN1(uint8 VAR2) { require(VAR1[msg.sender] >= VAR2, \"You dont have rights for this transaction\");\n_;\n}\nfunction FUN2(address VAR3, uint8 VAR2) public FUN1(2) { require(VAR3 != address(0), \"Address cannot be zero\"); VAR1[VAR3] = VAR2; }\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nenum State {\nOnSale,\nSuccessful\n}\nState public VAR4 = State.OnSale;\nuint256 public VAR5 = now;\nuint256 public VAR6;\nCON1 public VAR7;\nuint256 public VAR8; uint256 public VAR9; uint256 public VAR10; uint256 public constant VAR11 = 2941; uint256 public constant VAR12 = 52500000 * 1e18;\nuint256 public constant VAR13 = 420000000 * 1e18;\nuint256 public constant VAR14 = 3000000 * 1e18;\nmapping(address => uint256) public VAR15;\nmapping(address => uint256) public VAR16;\nmapping(address => uint256) public VAR17;\naddress public VAR18;\naddress payable public VAR19;\nstring public VAR20 = '1';\nmodifier FUN3() {\nrequire(VAR4 != State.Successful, \"Sale have finished\");\n_;\n}\nconstructor(CON1 VAR21) public {\nVAR7 = VAR21;\nVAR18 = 0x7a3a57c620fA468b304b5d1826CDcDe28E2b2b98;\nVAR19 = 0x8605409D35f707714A83410BE9C8025dcefa9faC;\n}\nfunction FUN4(address VAR22, uint256 VAR23) public FUN3 payable {\naddress VAR24;\nuint VAR25;\nuint VAR26;\nuint VAR27;\nuint VAR28;\nuint VAR29;\nuint VAR30;\nif (VAR22 != address(0) && VAR1[msg.sender] >= 1) {\nVAR24 = VAR22;\nVAR25 = VAR23;\n} else {\nVAR24 = msg.sender;\nVAR25 = msg.value;\nVAR15[msg.sender] = VAR15[msg.sender].add(msg.value);\n}\nrequire(VAR25 >= 0.1 ether, \"Not enough value for this transaction\");\nVAR8 = VAR8.add(VAR25);\nVAR26 = VAR25.mul(VAR11);\nVAR30 = VAR25.mul(VAR11);\nif (VAR30 > 0 &&VAR9 < VAR12) {\nVAR29 = VAR12.sub(VAR9);\nif (VAR30 < VAR29) {\nVAR28 = VAR30.mul(4);\nVAR27 = VAR28.div(10);\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR28 = VAR29.mul(4);\nVAR27 = VAR28.div(10);\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nif (VAR30 > 0 &&VAR9 >= VAR12 &&VAR9 < VAR12.mul(2)) {\nVAR29 = VAR12.mul(2).sub(VAR9);\nif (VAR30 < VAR29) {\nVAR28 = VAR30.mul(35);\nVAR27 = VAR27.add(VAR28.div(100));\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR28 = VAR29.mul(35);\nVAR27 = VAR27.add(VAR28.div(100));\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nif (VAR30 > 0 &&VAR9 >= VAR12.mul(2) &&VAR9 < VAR12.mul(3)) {\nVAR29 = VAR12.mul(3).sub(VAR9);\nif (VAR30 < VAR29) {\nVAR28 = VAR30.mul(3);\nVAR27 = VAR27.add(VAR28.div(10));\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR28 = VAR29.mul(3);\nVAR27 = VAR27.add(VAR28.div(10));\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nif (VAR30 > 0 &&VAR9 >= VAR12.mul(3) &&VAR9 < VAR12.mul(4)) {\nVAR29 = VAR12.mul(4).sub(VAR9);\nif (VAR30 < VAR29) {\nVAR28 = VAR30.mul(2);\nVAR27 = VAR27.add(VAR28.div(10));\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR28 = VAR29.mul(2);\nVAR27 = VAR27.add(VAR28.div(10));\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nif (VAR30 > 0 &&VAR9 >= VAR12.mul(4) &&VAR9 < VAR12.mul(5)) {\nVAR29 = VAR12.mul(5).sub(VAR9);\nif (VAR30 < VAR29) {\nVAR27 = VAR27.add(VAR30.div(10));\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR27 = VAR27.add(VAR29.div(10));\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nif (VAR30 > 0 &&VAR9 >= VAR12.mul(5) &&VAR9 < VAR12.mul(6)) {\nVAR29 = VAR12.mul(6).sub(VAR9);\nif (VAR30 < VAR29) {\nVAR28 = VAR30.mul(5);\nVAR27 = VAR27.add(VAR28.div(100));\nVAR9 = VAR9.add(VAR30);\nVAR30 = 0;\nVAR28 = 0;\nVAR29 = 0;\n} else {\nVAR28 = VAR29.mul(5);\nVAR27 = VAR27.add(VAR28.div(100));\nVAR9 = VAR9.add(VAR29);\nVAR30 = VAR30.sub(VAR29);\nVAR28 = 0;\nVAR29 = 0;\n}\n}\nVAR9 = VAR9.add(VAR30);\nVAR10 = VAR10.add(VAR27);\nVAR7.transfer(VAR24, VAR26.add(VAR27));\nVAR16[VAR24] = VAR16[VAR24].add(VAR26);\nVAR17[VAR24] = VAR17[VAR24].add(VAR27);\nFUN5(); }\nfunction FUN5() public {\nif (VAR9.add(VAR10) > VAR13.sub(VAR11)) {\nVAR4 = State.Successful;\nVAR6 = now;\nFUN8();\n}\n}\nfunction FUN6() public FUN1(2) {\nrequire(VAR9 >= VAR14, \"Too early to retrieve funds\");\nVAR19.transfer(address(this).balance);\n}\nfunction FUN7() public FUN3 {\nrequire(VAR9 >= VAR14, \"Too early to retrieve funds\");\nrequire(VAR15[msg.sender] > 0, \"No eth to refund\");\nrequire(\nVAR7.transferFrom(msg.sender,address(this),VAR16[msg.sender].add(VAR17[msg.sender])),\n\"Cannot retrieve tokens\"\n);\nVAR9 = VAR9.sub(VAR16[msg.sender]);\nVAR10 = VAR10.sub(VAR17[msg.sender]);\nVAR16[msg.sender] = 0;\nVAR17[msg.sender] = 0;\nuint VAR31 = VAR15[msg.sender];\nVAR15[msg.sender] = 0;\nmsg.sender.transfer(VAR31);\n}\nfunction FUN8() public { require(VAR4 == State.Successful, \"Wrong Stage\");\nuint256 VAR32 = VAR7.balanceOf(address(this));\nrequire(VAR7.transfer(VAR19, VAR32), \"Transfer could not be made\");\nVAR19.transfer(address(this).balance);\n}\nfunction () external payable {\nFUN4(address(0), 0);\n}\n}",
        "label": false,
        "name": "0x5ac203c782fe5b74ece9cb4ed13b0597bb5c872e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nbool private VAR3 = false;\nmodifier FUN5() {\nrequire(!VAR3);\nVAR3 = true;\n_;\nVAR3 = false;\n}\n}\ncontract CON3 {\nuint internal VAR4;\nmodifier FUN6() {\nVAR4 = gasleft();\n_;\nVAR4 = 0;\n}\n}\ncontract CON4 {\nstruct LoanOrder {\naddress VAR5;\naddress VAR6;\naddress VAR7;\naddress VAR8;\naddress VAR9;\naddress VAR10;\nuint VAR11;\nuint VAR12;\nuint VAR13;\nuint VAR14;\nuint VAR15;\nuint VAR16;\nuint VAR17;\nbytes32 VAR18;\n}\nstruct LoanRef {\nbytes32 VAR18;\naddress VAR19;\n}\nstruct LoanPosition {\naddress VAR20;\naddress VAR19;\naddress VAR21;\naddress VAR22;\nuint VAR23;\nuint VAR24;\nuint VAR25;\nuint VAR26;\nuint VAR27;\nbool VAR28;\n}\nstruct InterestData {\naddress VAR20;\naddress VAR7;\nuint VAR29;\nuint VAR30;\n}\n}\ncontract CON5 is CON4, CON2, CON1, CON3 {\nuint internal constant VAR31 = 2**256 - 1;\naddress public VAR32;\naddress public VAR33;\naddress public VAR34;\naddress public VAR35;\nbool public VAR36 = false;\nmapping (bytes32 => LoanOrder) public VAR37; mapping (address => bytes32[]) public VAR38; mapping (bytes32 => address) public VAR39; mapping (bytes32 => address[]) public VAR40; mapping (bytes32 => uint) public VAR41; mapping (bytes32 => uint) public VAR42; mapping (address => address) public VAR43; mapping (bytes32 => mapping (address => LoanPosition)) public VAR44; mapping (bytes32 => mapping (address => uint)) public VAR45;\nLoanRef[] public VAR46; }\ncontract CON6 {\nmapping (bytes4 => address) public VAR47;\nfunction FUN7(address VAR48) internal {\nrequire(VAR48.delegatecall(0xc4d66de8, VAR48), \"Proxiable::FUN7: failed\");\n}\n}\ncontract CON7 is CON5, CON6 {\nfunction() public {\naddress VAR49 = VAR47[msg.sig];\nbytes memory VAR50 = msg.VAR50;\nassembly {\nlet result := delegatecall(gas, VAR49, add(VAR50, 0x20), mload(VAR50), 0, 0)\nlet size := returndatasize\nlet ptr := mload(0x40)\nreturndatacopy(ptr, 0, size)\nswitch result\ncase 0 { revert(ptr, size) }\ndefault { return(ptr, size) }\n}\n}\nfunction FUN9(address)\npublic\n{\nrevert();\n}\nfunction FUN10(address VAR48)\npublic\nFUN1\n{\nFUN7(VAR48);\n}\nfunction FUN11(string VAR51, address VAR48) public\nFUN1\nreturns(bytes4)\n{\nbytes4 VAR52 = bytes4(keccak256(abi.encodePacked(VAR51)));\nVAR47[VAR52] = VAR48;\nreturn VAR52;\n}\nfunction FUN12(address VAR53,address VAR54,address VAR55,address VAR56)\npublic\nFUN1\n{\nif (VAR53 != address(0) && VAR54 != address(0) && VAR55 != address(0) && VAR56 != address(0))\nVAR32 = VAR53;\nVAR33 = VAR54;\nVAR34 = VAR55;\nVAR35 = VAR56;\n}\nfunction FUN13 (bool VAR57)\npublic\nFUN1\n{\nif (VAR36 != VAR57)\nVAR36 = VAR57;\n}\nfunction FUN14 (address VAR58)\npublic\nFUN1\n{\nif (VAR58 != address(0))\nVAR32 = VAR58;\n}\nfunction FUN15 (address VAR54)\npublic\nFUN1\n{\nif (VAR54 != address(0))\nVAR33 = VAR54;\n}\nfunction FUN16 (address VAR59)\npublic\nFUN1\n{\nif (VAR59 != address(0))\nVAR34 = VAR59;\n}\nfunction FUN17 (address VAR60,address VAR61)\npublic\nFUN1\n{\nif (VAR43[VAR60] != VAR61)\nVAR43[VAR60] = VAR61;\n}\nfunction FUN18 (address VAR62)\npublic\nFUN1\n{\nif (VAR62 != address(0))\nVAR35 = VAR62;\n}\n}",
        "label": false,
        "name": "0x86343be63c60ce182d8b5ac6a84f0722d8d61ae5.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"Biko Bank\";\nstring public constant VAR37 = \"BKB\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 900000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 public VAR42 = 1543363200;\nuint64 public VAR43 = 7776000;\nuint64 public VAR44 = 8640000;\nmapping(address => address) public VAR45;\nconstructor(address VAR46) public payable {\nrequire(VAR46 != address(0));\nVAR40 = VAR46;\nuint256 VAR47 = 805500000;\nFUN14(VAR47, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR48 = 94500000;\nVAR41 = FUN13(VAR48);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR49) internal FUN7 returns (CON7) {\nCON7 VAR50 = new CON7(CON3(this));\nFUN14(VAR49, VAR50);\nVAR50.FUN10();\nreturn VAR50;\n}\nfunction FUN14(uint256 VAR51, address VAR52) internal FUN7 {\nuint256 VAR49 = VAR51 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR49);\nVAR1[VAR52] = VAR1[VAR52].add(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,uint256 VAR53) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR54 = VAR53 * 10**uint256(VAR38);\nif(VAR45[VAR23] == 0x0) {\nCON6 VAR55 = new CON6(VAR23, VAR24, VAR25, VAR26, VAR27, VAR14);\nVAR45[VAR23] = address(VAR55);\n}\nrequire(this.FUN2(VAR41, VAR45[VAR23], VAR54));\n}\nfunction FUN16(address VAR23, uint256 VAR53) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR54 = VAR53 * 10**uint256(VAR38);\nif(VAR45[VAR23] == 0x0) {\nCON6 VAR55 = new CON6(VAR23, VAR42, 0, VAR44, true, VAR14);\nVAR45[VAR23] = address(VAR55);\n}\nrequire(this.FUN2(VAR41, VAR45[VAR23], VAR54));\n}\nfunction FUN17() external {\nFUN18(msg.sender);\n}\nfunction FUN18(address VAR8) public {\nCON6(VAR45[VAR8]).FUN8(this);\n}\nfunction FUN19(address VAR8) public FUN7 {\nCON6(VAR45[VAR8]).FUN9(this);\n}\nfunction FUN20() external FUN7 {\nrequire(VAR41 != address(0));\nVAR41.FUN10();\n}\n}",
        "label": false,
        "name": "0xe382eb93c1838473a22d3c680b82ac29eb0094cc.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) FUN3 {\nif (VAR8 != address(0)) {\nVAR7 = VAR8;\n}\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) returns (bool) {\nvar VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) returns (bool) {\nrequire((VAR4 == 0) || (VAR9[msg.sender][VAR12] == 0));\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\n}\ncontract CON6 is CON5, CON4\n{\nstring public VAR14 = \"ETHER GOLD\";\nstring public VAR15 = \"EG9\";\nuint public VAR16 = 8;\nuint private VAR17 = 18 * 10**16;\nfunction CON6()\n{\nVAR7 = msg.sender;\nVAR1 = VAR17;\nVAR2[VAR7] = VAR17;\n}\n}",
        "label": false,
        "name": "0x5c72b0da98c150f5e6a342508459542fe3b8f0ab.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\naddress public VAR3;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN3(address VAR4) public FUN1 {\nVAR2 = VAR4;\n}\nfunction FUN4() public FUN2 {\nVAR1 = VAR2;\nVAR2 = address(0);\n}\nfunction FUN5(address VAR5) public FUN1 {\nrequire(VAR5 != address(0));\nVAR3 = VAR5;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nuint256 internal VAR6;\nuint8 public VAR7 = 18;\nuint256 public VAR8 = uint256(1000000000) * uint256(10) ** VAR7;\nmapping(address => uint256) internal VAR9;\nmapping(address => mapping (address => uint256)) internal VAR10;\nstring public VAR11 = \"HyperLoot\";\nstring public VAR12 = \"HLT\";\nmodifier FUN6() {\nrequire(msg.sender == VAR3);\nrequire(totalSupply() <= VAR8);\n_;\n}\nfunction FUN7(CON2 VAR13) external FUN1 {\nuint256 VAR14 = VAR13.balanceOf(this);\nVAR13.FUN8(VAR1, VAR14);\n}\nfunction FUN8(address VAR15, uint256 VAR16) public returns (bool) {\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR9[msg.sender]);\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR16);\nVAR9[VAR15] = VAR9[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN9(address VAR17, address VAR15, uint256 VAR16) public returns (bool) {\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR9[VAR17]);\nrequire(VAR16 <= VAR10[VAR17][msg.sender]);\nVAR9[VAR17] = VAR9[VAR17].sub(VAR16);\nVAR9[VAR15] = VAR9[VAR15].add(VAR16);\nVAR10[VAR17][msg.sender] = VAR10[VAR17][msg.sender].sub(VAR16);\nreturn true;\n}\nfunction FUN10(address VAR18, uint256 VAR16) public returns (bool) {\nVAR10[msg.sender][VAR18] = VAR16;\nreturn true;\n}\nfunction FUN11(address VAR18, uint VAR19) public returns (bool) {\nVAR10[msg.sender][VAR18] = VAR10[msg.sender][VAR18].add(VAR19);\nreturn true;\n}\nfunction FUN12(address VAR18, uint VAR20) public returns (bool) {\nuint VAR21 = VAR10[msg.sender][VAR18];\nif (VAR20 > VAR21) {\nVAR10[msg.sender][VAR18] = 0;\n} else {\nVAR10[msg.sender][VAR18] = VAR21.sub(VAR20);\n}\nreturn true;\n}\nfunction FUN13(address VAR15, uint256 VAR22) public FUN6 returns (bool) {\nrequire(VAR22 > 0);\nrequire(VAR15 != address(0));\nVAR6 = VAR6.add(VAR22);\nrequire(VAR6 <= VAR8);\nVAR9[VAR15] = VAR9[VAR15].add(VAR22);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa809d363a66c576a2a814cdbfefc107c600a55f0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON7 is CON5, CON6 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() public FUN6 FUN10 returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON8 is CON6 {\nbool public VAR15 = false;\nmodifier FUN14() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN15() {\nrequire(VAR15);\n_;\n}\nfunction FUN16() public FUN6 FUN14 {\nVAR15 = true;\n}\nfunction FUN17() public FUN6 FUN15 {\nVAR15 = false;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN3(address VAR7,uint256 VAR4)\npublic\nFUN14\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4);\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nFUN14\nreturns (bool VAR16)\n{\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nFUN14\nreturns (bool VAR16)\n{\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON10 is CON9, CON7 {\nstring public constant VAR17 = \"Realty Returns Token\";\nstring public constant VAR18 = \"RRT\";\nuint8 public constant VAR19 = 18;\nconstructor() public {\nFUN16();\n}\n}",
        "label": false,
        "name": "0x7d2ed53cedbf8cddd00e6c814d03ccda747547f1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x174bfa6600bf90c885c7c01c7031389ed1461ab9.sol"
    },
    {
        "source": "contract CON1 {\nuint256 VAR1;\nmapping (address => uint256) VAR2;\nconstructor() public {}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR2[msg.sender] >= VAR4);\nVAR2[msg.sender] = sub(VAR2[msg.sender], VAR4);\nVAR2[VAR3] = add(VAR2[VAR3], VAR4);\nreturn true;\n}\n}\ncontract CON2 is CON1 {\nstring public VAR5 = \"EDC\";\nstring public VAR6 = \"EDC Coin\";\nuint256 public VAR7 = 8;\nuint256 public VAR8 = 38280000*(10**8);\nuint256 public VAR9 = 1560902400;\nuint256 public VAR10 = 1560902400; address public VAR11;\naddress public VAR12 = address(0x01);\nstruct FreezeStruct {\nuint256 VAR13; uint256 VAR14; bool VAR15;\n}\nFreezeStruct[] public VAR16;\nconstructor() public{\nVAR1 = 319000000*(10**8);\nVAR2[VAR12] = VAR8;\nVAR2[msg.sender] = sub(VAR1,VAR8);\nVAR11 = msg.sender;\nVAR16.push(FreezeStruct({VAR13:1586995200, VAR14:9570000*(10**8), VAR15: true})); VAR16.push(FreezeStruct({VAR13:1618531200, VAR14:14355000*(10**8), VAR15: true})); VAR16.push(FreezeStruct({VAR13:1650067200, VAR14:14355000*(10**8), VAR15: true})); }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire (now >= VAR9 || now >= VAR10);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(msg.sender == VAR11);\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN3(uint256 VAR17) public {\nrequire(msg.sender == VAR11);\nrequire(VAR17 <= VAR10);\nVAR9 = VAR17;\n}\nfunction FUN4(uint256 VAR18) public {\nrequire(msg.sender == VAR11);\nrequire(VAR18>=0 && VAR18<VAR16.length);\nrequire(now >= VAR16[VAR18].VAR13 && VAR16[VAR18].VAR15);\nrequire(VAR2[VAR12] >= VAR16[VAR18].VAR14);\nVAR2[VAR12] = sub(VAR2[VAR12], VAR16[VAR18].VAR14);\nVAR2[VAR11] = add(VAR2[VAR11], VAR16[VAR18].VAR14);\nVAR8 = sub(VAR8, VAR16[VAR18].VAR14);\nVAR16[VAR18].VAR15 = false;\n}\n}",
        "label": false,
        "name": "0xe1f39ecbe0eabc8b332308ed4ed520e0007faaa4.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender == VAR1) _;\n}\nfunction FUN2(uint VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) public FUN1 {\nCON1 VAR5 = CON1(VAR4);\nVAR5.FUN2(VAR2);\n}\n}",
        "label": false,
        "name": "0x5902e15b0755d4f4f7e3c814396b1f1a42569291.sol"
    },
    {
        "source": "{\"ApproveAndCall.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract ApproveAndCallFallBack {\\r\\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract ERC20Interface {\\r\\n    function totalSupply() public view returns (uint);\\r\\n    function balanceOf(address tokenOwner) public view returns (uint balance);\\r\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\r\\n    function transfer(address to, uint tokens) public returns (bool success);\\r\\n    function approve(address spender, uint tokens) public returns (bool success);\\r\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n}\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public newOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\r\\n\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        newOwner = _newOwner;\\r\\n    }\\r\\n    function acceptOwnership() public {\\r\\n        require(msg.sender == newOwner);\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n        newOwner = address(0);\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\"},\"TerraToken.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\u0027SafeMath.sol\\u0027;\\r\\nimport \\u0027ERC20.sol\\u0027;\\r\\nimport \\u0027ApproveAndCall.sol\\u0027;\\r\\nimport \\u0027Owned.sol\\u0027;\\r\\n\\r\\ncontract TerraToken is ERC20Interface, Owned {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    string public symbol;\\r\\n    string public  name;\\r\\n    uint8 public decimals;\\r\\n    uint _totalSupply;\\r\\n\\r\\n    mapping(address =\\u003e uint) balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Constructor\\r\\n    // ------------------------------------------------------------------------\\r\\n    constructor() public {\\r\\n        symbol = \\\"TRT\\\";\\r\\n        name = \\\"Terra Token\\\";\\r\\n        decimals = 2;\\r\\n        _totalSupply = 100000 * 10**uint(decimals);\\r\\n        balances[owner] = _totalSupply;\\r\\n        emit Transfer(address(0), owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Total supply\\r\\n    // ------------------------------------------------------------------------\\r\\n    function totalSupply() public view returns (uint) {\\r\\n        return _totalSupply.sub(balances[address(0)]);\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Get the token balance for account `tokenOwner`\\r\\n    // ------------------------------------------------------------------------\\r\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\r\\n        return balances[tokenOwner];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\r\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transfer(address to, uint tokens) public returns (bool success) {\\r\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\r\\n        balances[to] = balances[to].add(tokens);\\r\\n        emit Transfer(msg.sender, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\r\\n    // from the token owner\\u0027s account\\r\\n    //\\r\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n    // recommends that there are no checks for the approval double-spend attack\\r\\n    // as this should be implemented in user interfaces\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approve(address spender, uint tokens) public returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer `tokens` from the `from` account to the `to` account\\r\\n    //\\r\\n    // The calling account must already have sufficient tokens approve(...)-d\\r\\n    // for spending from the `from` account and\\r\\n    // - From account must have sufficient balance to transfer\\r\\n    // - Spender must have sufficient allowance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\\r\\n        balances[from] = balances[from].sub(tokens);\\r\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\r\\n        balances[to] = balances[to].add(tokens);\\r\\n        emit Transfer(from, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Returns the amount of tokens approved by the owner that can be\\r\\n    // transferred to the spender\\u0027s account\\r\\n    // ------------------------------------------------------------------------\\r\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\r\\n        return allowed[tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\r\\n    // from the token owner\\u0027s account. The `spender` contract function\\r\\n    // `receiveApproval(...)` is then executed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Don\\u0027t accept ETH\\r\\n    // ------------------------------------------------------------------------\\r\\n    function () external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\r\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\r\\n    }\\r\\n}\"}}",
        "label": false,
        "name": "0xb1e75d543ec0382370f7274dd830850a28c23095.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nmodifier FUN1(uint256 VAR2) {\nassert(msg.data.length >= VAR2 * 32 + 4);\n_;\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) public VAR3;\nfunction FUN2(address VAR4, uint256 VAR5) FUN1(2) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2, CON4 {\nmapping(address => mapping(address => uint256)) internal VAR6;\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) FUN1(3) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[VAR7]);\nrequire(VAR5 <= VAR6[VAR7][msg.sender]);\nVAR3[VAR7] = VAR3[VAR7].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR8, uint256 VAR5) FUN1(2) public returns (bool) {\nrequire((VAR5 == 0) || (VAR6[msg.sender][VAR8] == 0));\nVAR6[msg.sender][VAR8] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, uint VAR9) FUN1(2) public returns (bool) {\nVAR6[msg.sender][VAR8] = VAR6[msg.sender][VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR8, uint VAR10) FUN1(2) public returns (bool) {\nuint VAR11 = VAR6[msg.sender][VAR8];\nif (VAR10 > VAR11) {\nVAR6[msg.sender][VAR8] = 0;\n} else {\nVAR6[msg.sender][VAR8] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR12;\nfunction CON6() public {\nVAR12 = msg.sender;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN8(address VAR13) public FUN7 {\nrequire(VAR13 != address(0));\nVAR12 = VAR13;\n}\n}\ncontract CON7 is CON6, CON5 {\nstring public constant VAR14 = \"Showcoin\";\nstring public constant VAR15 = \"SHC\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 69000000 * (10 ** uint256(VAR16));\nfunction CON7() public {\nVAR1 = VAR17;\nVAR3[msg.sender] = VAR17;\n}\n}\ncontract CON8 is CON6 {\nusing SafeMath for uint256;\nCON7 public VAR18;\nuint256 public constant VAR19 = 2000;\nuint256 public VAR20;\naddress public VAR21;\nuint256 public constant VAR22 = 3000000 * (10 ** 18);\nuint256 public VAR23;\nbool public VAR24;\nfunction CON8(address VAR25, uint256 VAR26, address VAR27) public {\nrequire(VAR25 != address(0));\nrequire(VAR27 != address(0));\nrequire(VAR26 > now);\nVAR18 = CON7(VAR25);\nVAR21 = VAR27;\nVAR20 = VAR26;\n}\nfunction FUN9(uint256 VAR26) FUN7 public {\nrequire(VAR26 > VAR20);\nVAR20 = VAR26;\n}\nfunction FUN10(address VAR4, uint256 VAR28) FUN7 public {\nrequire(VAR4 != address(0));\nVAR23 = VAR23.add(VAR28);\nrequire(!hasEnded());\nVAR18.FUN2(VAR4, VAR28);\n}\nfunction FUN11(address VAR27) FUN7 public {\nrequire(VAR27 != address(0));\nVAR21 = VAR27;\n}\nfunction FUN12() FUN7 public {\nrequire(hasEnded());\nrequire(!VAR24);\nuint256 VAR29 = VAR18.balanceOf(this);\nVAR18.FUN2(VAR12, VAR29);\nVAR24 = true;\n}\nfunction() external payable {\nFUN14(msg.sender);\n}\nfunction FUN14(address VAR30) public payable {\nrequire(VAR30 != address(0));\nrequire(validPurchase());\nuint256 VAR31 = msg.value;\nuint256 VAR32 = VAR31.mul(VAR19);\nVAR23 = VAR23.add(VAR32);\nrequire(!hasEnded());\nVAR18.FUN2(VAR30, VAR32);\nFUN15();\n}\nfunction FUN15() internal {\nVAR21.FUN2(msg.value);\n}\n}",
        "label": false,
        "name": "0xcf8dc49d37659414d09907d8336622f2ae287004.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint;\naddress public VAR4;\nCON2 public VAR5;\nuint256 public VAR6;\nmapping(address => uint256) public VAR7;\nmapping(address => uint256) public VAR8;\nmapping(address => uint256) public VAR9;\nmapping(address => uint256) public VAR10;\nmapping(address => uint256) public VAR11;\nbool VAR12 = false;\nbool VAR13 = false;\nusing Address for *;\nusing Zero for *;\nconstructor(address VAR14) public {\nVAR5 = CON2(VAR14);\n}\nfunction FUN4(address VAR15) public FUN1 {\nVAR4 = VAR15;\n}\nfunction FUN5(address VAR16, uint256 VAR17) public {\nrequire(msg.sender == VAR1 || msg.sender == VAR4);\nrequire(!VAR13);\nVAR7[VAR16] = VAR7[VAR16].add(VAR17);\nVAR8[VAR16] = VAR8[VAR16].add(VAR17);\nVAR6 = VAR6.add(VAR17);\nVAR5.transfer(VAR16, VAR17);\n}\nfunction FUN6(address VAR16, uint256 VAR18, uint256 VAR19) public {\nrequire(msg.sender == VAR1 || msg.sender == VAR4);\nrequire(!VAR13);\nVAR7[VAR16] = VAR7[VAR16].add(VAR18).add(VAR19);\nVAR8[VAR16] = VAR8[VAR16].add(VAR18);\nVAR9[VAR16] = VAR9[VAR16].add(VAR19);\nVAR6 = VAR6.add(VAR18).add(VAR19);\nVAR5.transfer(VAR16, VAR18.add(VAR19));\n}\nfunction FUN7(address VAR16, uint256 VAR20) public {\nrequire(msg.sender == VAR1 || msg.sender == VAR4);\nrequire(!VAR13);\nVAR7[VAR16] = VAR7[VAR16].add(VAR20);\nVAR10[VAR16] = VAR10[VAR16].add(VAR20);\nVAR6 = VAR6.add(VAR20);\nVAR5.transfer(VAR16, VAR20);\n}\nfunction FUN8(address VAR16, uint256 VAR18, uint256 VAR19, address VAR21, uint256 VAR22) public {\nrequire(msg.sender == VAR1 || msg.sender == VAR4);\nrequire(!VAR13);\nVAR7[VAR16] = VAR7[VAR16].add(VAR18).add(VAR19);\nVAR8[VAR16] = VAR8[VAR16].add(VAR18);\nVAR9[VAR16] = VAR9[VAR16].add(VAR19);\nVAR6 = VAR6.add(VAR18).add(VAR19);\nVAR5.transfer(VAR16, VAR18.add(VAR19));\nVAR7[VAR21] = VAR7[VAR21].add(VAR22);\nVAR11[VAR21] = VAR11[VAR21].add(VAR22);\nVAR6 = VAR6.add(VAR22);\nVAR5.transfer(VAR21, VAR22);\n}\nfunction FUN9(uint256 VAR23) FUN1 public {\nVAR5.transfer(VAR1, VAR23);\n}\n}",
        "label": false,
        "name": "0xd7ba91b3ede1698a7d1f991d7d5bd9c0c8995a58.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON1 {\nbool public VAR15 = false;\nmodifier FUN11() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN12() {\nrequire(VAR15);\n_;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR15 = true;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR15 = false;\n}\n}\ncontract CON8 is CON5, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN11 returns (bool VAR16) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN11 returns (bool VAR16) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON9 is CON8, CON6 {\nstring public VAR17 = \"REBGLO Token\";\nstring public VAR18 = \"REB\";\nuint8 public VAR19 = 18;\nfunction CON9() public {\nFUN13();\n}\n}\ncontract CON10 is CON1 {\nusing SafeMath for uint;\nuint256 public VAR20;\nuint256 public VAR21;\nuint256 public VAR22;\nuint256 public VAR23;\nuint256 public VAR24;\nmapping (address => uint256) public VAR25;\nCON9 public VAR26;\nfunction CON10\n(CON9 VAR27,uint256 VAR28,uint256 VAR29,uint256 VAR30)\npublic\n{\nrequire(VAR27 != address(0));\nVAR26 = CON9(VAR27);\nVAR20 = VAR28;\nVAR21 = VAR29;\nVAR24 = VAR30;\n}\nfunction FUN15(address VAR31, uint256 VAR32)\nexternal\nFUN1\nreturns(bool)\n{\nrequire(VAR25[VAR31] == 0 && VAR31 != address(0));\nVAR23 = VAR23.add(VAR32);\nrequire(VAR23 <= VAR24);\nVAR25[VAR31] = VAR32;\nreturn true;\n}\nfunction FUN16() external {\nrequire(VAR26 != address(0));\nassert(now >= VAR20);\nif (VAR22 == 0) {\nVAR22 = VAR26.balanceOf(this);\n}\nuint256 VAR33 = VAR25[msg.sender];\nVAR25[msg.sender] = 0;\nrequire(VAR26.FUN3(msg.sender, VAR33));\n}\nfunction FUN17() public FUN1 {\nrequire(now >= VAR21);\nuint256 VAR34 = VAR26.balanceOf(this);\nif (VAR34 > 0) {\nVAR26.FUN3(msg.sender, VAR34);\n}\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0xdfc8ecb515c0bb72de8bcbe0cb7a2d84b65c8027.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint VAR1, uint VAR2) internal constant returns (uint) {\nuint VAR3 = VAR1 * VAR2;\nassert(VAR1 == 0 || VAR3 / VAR1 == VAR2);\nreturn VAR3;\n}\nfunction FUN2(uint VAR1, uint VAR2) internal constant returns (uint) {\nrequire(VAR2 > 0);\nuint VAR3 = VAR1 / VAR2;\nassert(VAR1 == VAR2 * VAR3 + VAR1 % VAR2);\nreturn VAR3;\n}\nfunction FUN3(uint VAR1, uint VAR2) internal constant returns (uint) {\nrequire(VAR2 <= VAR1);\nreturn VAR1 - VAR2;\n}\nfunction FUN4(uint VAR1, uint VAR2) internal constant returns (uint) {\nuint VAR3 = VAR1 + VAR2;\nassert(VAR3>=VAR1 && VAR3>=VAR2);\nreturn VAR3;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => uint) public VAR4;\nuint public VAR5;\naddress public VAR6;\nuint public VAR7; uint public VAR8;\nuint public VAR9;\nmodifier FUN5() {\nrequire(block.number >= VAR7 && now <= VAR8);\n_;\n}\nfunction CON2(uint VAR10, uint VAR11, uint VAR12, address VAR13) {\nVAR7 = VAR10;\nVAR8 = VAR11;\nVAR9 = VAR12;\nVAR6 = VAR13;\n}\nfunction() payable {\nFUN7();\n}\nfunction FUN7() FUN5 payable {\nuint VAR14 = FUN2(FUN1(msg.VAR15, FUN8(msg.VAR15)), 1 ether);\nassert(VAR5 + VAR14 <= VAR9);\nVAR6.transfer(msg.VAR15);\nVAR4[msg.sender] += VAR14;\nVAR5 += VAR14;\n}\nfunction FUN8(uint VAR15) constant returns (uint VAR16) {\nif(VAR15 < 150 ether)\nrevert();\nelse if(VAR15 < 300 ether)\nVAR16 = 5800*10**18;\nelse if(VAR15 < 1500 ether)\nVAR16 = 6000*10**18;\nelse if(VAR15 < 3000 ether)\nVAR16 = 6200*10**18;\nelse if(VAR15 >= 3000 ether)\nVAR16 = 6400*10**18;\n}\n}",
        "label": false,
        "name": "0xd652c2c57bb8397a790e89ebc392a1bf4e26450f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 990000000000000000000000000;\nVAR6 = 990000000000000000000000000;\nVAR3 = \"Only Love Coin\";\nVAR4 = \"ONC\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x4cef6e5243f41d9698fc8824a33e9e407987572a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN2 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN4 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0), \"Cannot FUN5 for 0x0 address\");\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0), \"Cannot FUN1 VAR4 0x0 address\");\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0), \"Cannot mint VAR4 0x0 address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR11 = \"Coineru Silver\";\nstring public constant VAR12 = \"CSLV\";\nuint8 public constant VAR13 = 8;\nuint256 public constant VAR14 = 26000000000 * (10 ** uint256(VAR13));\nconstructor () public {\nFUN7(msg.sender, VAR14);\n}\n}",
        "label": false,
        "name": "0x6dc05497f0b087c7692816e6acaa8bdda73907fc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = this;\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x58959e0c71080434f237bd42d07cd84b74cef438.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 10000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Anymous Coin\";\nstring constant public VAR14 = \"AMC\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x4da7e3336b2c89812b0f4b6a04142cf487db005c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"BLM\";\nVAR5 = \"Blume Token\";\nVAR6 = 18;\nVAR7 = 100000000000000000000000000;\nVAR8[0x6FD037a41dB320d2C322229b1F29B9C51EEB0875] = VAR7;\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7 - VAR8[address(0)];\n}\nfunction FUN5(address VAR10) public constant returns (uint VAR11) {\nreturn VAR8[VAR10];\n}\nfunction FUN6(address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[VAR16] = safeSub(VAR8[VAR16], VAR13);\nVAR9[VAR16][msg.sender] = safeSub(VAR9[VAR16][msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR15) public constant returns (uint VAR17) {\nreturn VAR9[VAR10][VAR15];\n}\nfunction FUN10(address VAR15, uint VAR13, bytes VAR18) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nCON3(VAR15).receiveApproval(msg.sender, VAR13, this, VAR18);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN12(address VAR19, uint VAR13) public FUN1 returns (bool VAR14) {\nreturn CON2(VAR19).FUN6(VAR1, VAR13);\n}\n}",
        "label": false,
        "name": "0x2722690a68f97e3361b958eb0b1dedf39190f6ad.sol"
    },
    {
        "source": "contract CON1 {\nuint constant VAR1 = 10 ** 18;\nuint constant VAR2 = 10 ** 27;\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nCON2 public VAR3;\naddress public VAR4;\nconstructor() public {\nVAR4 = msg.sender;\n}\nfunction FUN1(address VAR5)\npublic\nFUN3\n{\nVAR4 = VAR5;\n}\nfunction FUN2(CON2 VAR6)\npublic\nFUN3\n{\nVAR3 = VAR6;\n}\nmodifier FUN3 {\nrequire(isAuthorized(msg.sender, msg.sig));\n_;\n}\n}\ncontract CON5 {\nmodifier FUN4 {\nbytes32 VAR7;\nbytes32 VAR8;\nassembly {\nVAR7 := calldataload(4)\nVAR8 := calldataload(36)\n}\n_;\n}\n}\ncontract CON6 is CON5, CON4 {\nbool public VAR9;\nmodifier FUN5 {\nrequire(!VAR9);\n_;\n}\nfunction FUN6() public FUN3 FUN4 {\nVAR9 = true;\n}\nfunction FUN7() public FUN3 FUN4 {\nVAR9 = false;\n}\n}\ncontract CON7 {\n}\ncontract CON8 is CON7 {\n}\ncontract CON9 is CON8, CON1 {\nuint256 VAR10;\nmapping (address => uint256) VAR11;\nmapping (address => mapping (address => uint256)) VAR12;\nconstructor(uint VAR13) public {\nVAR11[msg.sender] = VAR13;\nVAR10 = VAR13;\n}\nfunction FUN8(address VAR14, uint VAR15) public returns (bool) {\nreturn FUN9(msg.sender, VAR14, VAR15);\n}\nfunction FUN9(address VAR16, address VAR14, uint VAR15)\npublic\nreturns (bool)\n{\nif (VAR16 != msg.sender) {\nVAR12[VAR16][msg.sender] = sub(VAR12[VAR16][msg.sender], VAR15);\n}\nVAR11[VAR16] = sub(VAR11[VAR16], VAR15);\nVAR11[VAR14] = add(VAR11[VAR14], VAR15);\nreturn true;\n}\nfunction FUN10(address VAR17, uint VAR15) public returns (bool) {\nVAR12[msg.sender][VAR17] = VAR15;\nreturn true;\n}\n}\ncontract CON10 is CON9(0), CON6 {\nbytes32 public VAR18;\nuint256 public VAR19 = 18;\nconstructor(bytes32 VAR20) public {\nVAR18 = VAR20;\n}\nfunction FUN10(address VAR17) public FUN5 returns (bool) {\nreturn super.FUN10(VAR17, uint(-1));\n}\nfunction FUN10(address VAR17, uint VAR15) public FUN5 returns (bool) {\nreturn super.FUN10(VAR17, VAR15);\n}\nfunction FUN9(address VAR16, address VAR14, uint VAR15)\npublic\nFUN5\nreturns (bool)\n{\nif (VAR16 != msg.sender && VAR12[VAR16][msg.sender] != uint(-1)) {\nVAR12[VAR16][msg.sender] = sub(VAR12[VAR16][msg.sender], VAR15);\n}\nVAR11[VAR16] = sub(VAR11[VAR16], VAR15);\nVAR11[VAR14] = add(VAR11[VAR14], VAR15);\nreturn true;\n}\nfunction FUN11(address VAR14, uint VAR15) public {\nFUN9(msg.sender, VAR14, VAR15);\n}\nfunction FUN12(address VAR16, uint VAR15) public {\nFUN9(VAR16, msg.sender, VAR15);\n}\nfunction FUN13(address VAR16, address VAR14, uint VAR15) public {\nFUN9(VAR16, VAR14, VAR15);\n}\nfunction FUN14(uint VAR15) public {\nFUN14(msg.sender, VAR15);\n}\nfunction FUN15(uint VAR15) public {\nFUN15(msg.sender, VAR15);\n}\nfunction FUN14(address VAR17, uint VAR15) public FUN3 FUN5 {\nVAR11[VAR17] = add(VAR11[VAR17], VAR15);\nVAR10 = add(VAR10, VAR15);\n}\nfunction FUN15(address VAR17, uint VAR15) public FUN3 FUN5 {\nif (VAR17 != msg.sender && VAR12[VAR17][msg.sender] != uint(-1)) {\nVAR12[VAR17][msg.sender] = sub(VAR12[VAR17][msg.sender], VAR15);\n}\nVAR11[VAR17] = sub(VAR11[VAR17], VAR15);\nVAR10 = sub(VAR10, VAR15);\n}\nbytes32 public VAR21 = \"\";\nfunction FUN16(bytes32 VAR22) public FUN3 {\nVAR21 = VAR22;\n}\n}",
        "label": false,
        "name": "0xbc0746c5b34f6a73b7185988053d8a0dfc37489e.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) internal VAR1;\nmapping (address => mapping (address => uint256)) internal VAR2;\nuint256 internal VAR3;\nconstructor() internal {\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(msg.VAR33, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN5(msg.VAR33, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(VAR7, VAR4, VAR5);\nFUN5(VAR7, msg.VAR33, VAR2[VAR7][msg.VAR33].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 VAR7 the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 VAR4 the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN5(address VAR9, address VAR6, uint256 VAR5) internal {\nrequire(VAR9 != address(0), \"ERC20: FUN2 VAR7 the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 VAR4 the zero address\");\nVAR2[VAR9][VAR6] = VAR5;\n}\n}\ncontract CON3 {\naddress public VAR9;\nusing SafeMath for uint256;\nuint256 public VAR10;\nconstructor() internal {\nVAR9 = msg.VAR33;\nVAR10 = now;\n}\nmodifier FUN6() {\nrequire(msg.VAR33 == VAR9,\"Ownable: caller is not VAR9.\");\n_;\n}\nfunction FUN7(address VAR11) internal FUN6 {\nrequire(VAR11 != address(0), \"Ownable: address is zero.\");\nVAR9 = VAR11;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN9(msg.VAR33);\n}\nmodifier FUN8() {\nrequire(isMinter(msg.VAR33), \"MinterRole: caller does not have the Minter role.\");\n_;\n}\nfunction FUN9(address VAR13) internal {\nVAR12.add(VAR13);\n}\nfunction FUN10(address VAR13) internal {\nVAR12.remove(VAR13);\n}\n}\ncontract CON5 is CON4{\nuint256 private VAR14;\nconstructor (uint256 VAR15) internal {\nrequire(VAR15 > 0, \"ERC20Capped: VAR15 is 0\");\nVAR14 = VAR15;\n}\nfunction FUN11(address VAR4, uint256 VAR5) public FUN8 returns (bool) {\nFUN24(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 {\nbool private VAR16;\nconstructor () internal {\nVAR16 = false;\n}\nmodifier FUN12() {\nrequire(!VAR16, \"Pausable: paused\");\n_;\n}\nmodifier FUN13() {\nrequire(VAR16, \"Pausable: not paused\");\n_;\n}\nfunction FUN14() internal FUN12 {\nVAR16 = true;\n}\nfunction FUN15() internal FUN13 {\nVAR16 = false;\n}\n}\ncontract CON7 {\nconstructor () internal {}\nfunction FUN16(address VAR13, uint256 VAR5) internal{\n}\n}\ncontract CON8 {\nuint256 internal VAR17 = 0;\nmapping(address => uint256) internal VAR18;\nmapping(address => bool) internal VAR19;\nmapping(address => uint256) internal VAR20;\nmodifier FUN17() {\nrequire(VAR19[msg.VAR33] == true, \"Lockable: VAR33 address is locked.\");\n_;\n}\n}\ncontract CON9 {\nusing Roles for Roles.Role;\nRoles.Role private VAR21;\nconstructor () internal {\nFUN19(msg.VAR33);\n}\nmodifier FUN18() {\nrequire(isDelegator(msg.VAR33), \"DelegatorRole: caller does not have the Delegator role.\");\n_;\n}\nfunction FUN19(address VAR13) internal {\nVAR21.add(VAR13);\n}\nfunction FUN20(address VAR13) internal {\nVAR21.remove(VAR13);\n}\n}\ncontract CON10 is CON9{\nusing ECRecovery for bytes32;\nusing SafeMath for uint;\nuint16 private VAR22;\naddress private VAR23;\nmapping(address => uint256) internal VAR24;\nconstructor () internal{\nVAR22 = 10; VAR23 = msg.VAR33;\n}\nfunction FUN21(uint16 VAR25) internal{\nVAR22 = VAR25;\n}\nfunction FUN22(address VAR26) internal{\nVAR23 = VAR26;\n}\nfunction FUN23(address VAR8, address VAR27, uint256 VAR28, uint256 VAR29, bytes calldata VAR30) external FUN18 returns(bool VAR31){\nrequire(VAR29 == nonceOf(VAR8), \"Delegatable: nonce is not correct\");\nbytes32 VAR32 = keccak256(abi.encodePacked(\n\"\\x19Ethereum Signed Message:\\n32\",\nkeccak256(abi.encodePacked(VAR8, VAR27, VAR28, VAR29)))\n);\naddress VAR33 = VAR32.recover(VAR30);\nuint VAR34 = VAR28.mul(VAR22).div(uint(100000));\nif(VAR8 == VAR33){\nif(FUN40(VAR8, VAR27, VAR28, VAR34)){\nuint256 VAR35 = nonceOf(VAR8).add(uint256(1));\nVAR24[VAR8] = VAR35;\nreturn true;\n}\nelse{\nreturn false;\n}\n} else {\nreturn false;\n}\n}\n}\ncontract CON11 is CON2, CON3, CON5, CON6, CON7, CON8, CON10{\nstring private VAR36 = \"TrustShore\";\nstring private VAR37 = \"TST\";\nuint8 private VAR38 = 18;\nconstructor (uint256 VAR15) public CON5(VAR15){\n}\nfunction FUN24(address VAR13, uint256 VAR5) internal {\nrequire(VAR13 != address(0), \"Mintable: FUN11 VAR4 the zero address.\");\nrequire(totalSupply().add(VAR5).add(totalLocked()) <= VAR15(), \"Mintable: VAR15 exceeded.\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR13] = VAR1[VAR13].add(VAR5);\n}\nfunction FUN25() public {\nrequire(msg.VAR33 != VAR9, \"Mintable: Owner cannot renounce. Transfer VAR9 first.\");\nsuper.FUN10(msg.VAR33);\n}\nfunction FUN26(address VAR39) public FUN6{\nsuper.FUN9(VAR39);\n}\nfunction FUN27(address VAR39) public FUN6{\nsuper.FUN10(VAR39);\n}\nfunction FUN28(address VAR11) public{\nrequire(msg.VAR33 == VAR9, \"Ownable: only VAR9 FUN1 ownership\");\nFUN26(VAR11);\nFUN41(VAR11);\nFUN27(VAR9);\nFUN42(VAR9);\nsuper.FUN7(VAR11);\n}\nfunction FUN29() public FUN6 {\nrequire(!paused(), \"Pausable: Already paused.\");\nsuper.FUN14();\n}\nfunction FUN30() public FUN6 {\nrequire(paused(), \"Pausable: Not paused.\");\nsuper.FUN15();\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(!paused(), \"Pausable: token FUN1 is paused.\");\nsuper.FUN4(msg.VAR33, VAR4, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN12 returns (bool) {\nrequire(VAR5 > 0, \"transferFrom: VAR5 is must be greater than zero.\");\nrequire(balanceOf(VAR7) >= VAR5, \"transferFrom: balance of VAR7 address is not enough\");\nrequire(VAR2[VAR7][msg.VAR33] >= VAR5, \"transferFrom: VAR33 are not allowed VAR4 send.\");\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN12 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN31(address VAR13, uint256 VAR5) public FUN6 {\nrequire(VAR13 != address(0), \"Burnable: FUN31 VAR7 the zero address\");\nrequire(VAR1[VAR13] >= VAR5, \"Burnable: not enough tokens\");\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR13] = VAR1[VAR13].sub(VAR5);\nsuper.FUN16(VAR13, VAR5);\n}\nfunction FUN32(address VAR4, uint256 VAR5) public {\nrequire(!_isContract(VAR4),\"SafeTransfer: receiver is contract\");\nFUN1(VAR4,VAR5);\n}\nfunction FUN33(address VAR7, address VAR4, uint256 VAR5) public {\nrequire(!_isContract(VAR7),\"SafeTransfer: VAR33 is contract\");\nrequire(!_isContract(VAR4),\"SafeTransfer: receiver is contract\");\nFUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN34(address VAR6, uint256 VAR5) public {\nrequire(VAR5 != 0, \"SafeTransfer: FUN2 VAR7 non-zero VAR4 non-zero allowance\");\nrequire(!_isContract(VAR6),\"SafeTransfer: VAR6 is contract\");\nFUN2(VAR6, VAR5);\n}\nfunction FUN35(address VAR40, uint256 VAR41, uint256 VAR42) public {\nrequire(msg.VAR33 == VAR9, \"Lockable: only VAR9 can lock token \");\nrequire(VAR3.add(totalLocked()).add(VAR41) <= VAR15(), \"Lockable: locked VAR41 can not exceed total VAR15.\");\nrequire(VAR19[VAR40] == false, \"Lockable: this address is already locked\");\nuint256 VAR43 = block.timestamp.add(VAR42.mul(1 minutes));\nVAR18[VAR40] = VAR43;\nVAR19[VAR40] = true;\nVAR20[VAR40] = VAR41;\nVAR17 = VAR17.add(VAR41);\n}\nfunction FUN36() public returns (bool) {\nrequire(VAR19[msg.VAR33] == true);\nrequire(VAR20[msg.VAR33] > 0);\nuint256 VAR43 = VAR18[msg.VAR33];\nuint256 VAR44 = block.timestamp;\nif(VAR44 > VAR43) {\nuint256 VAR41 = VAR20[msg.VAR33];\nVAR18[msg.VAR33] = 0;\nVAR19[msg.VAR33] = false;\nVAR20[msg.VAR33] = 0;\nVAR3 = VAR3.add(VAR41);\nVAR1[msg.VAR33] = VAR1[msg.VAR33].add(VAR41);\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN37(uint16 VAR25) public{\nrequire(msg.VAR33 == VAR9, \"Delegatable: only VAR9 change the fee rate\");\nFUN21(VAR25);\n}\nfunction FUN38(address VAR26) public{\nrequire(msg.VAR33 == VAR9, \"Delegatable: only VAR9 change the fee collector\");\nFUN22(VAR26);\n}\nfunction FUN39() public {\nrequire(msg.VAR33 != VAR9, \"Delegatable : Owner cannot renounce. Transfer VAR9 first.\");\nsuper.FUN20(msg.VAR33);\n}\nfunction FUN40(address VAR8, address VAR27, uint256 VAR28, uint256 VAR34) internal returns(bool VAR31){\nuint VAR45 = VAR28.add(VAR34);\nif (balanceOf(VAR8) < VAR45)\nreturn false;\nVAR1[VAR8] = balanceOf(VAR8).sub(VAR45);\nVAR1[VAR27] = balanceOf(VAR27).add(VAR28);\nVAR1[feeCollector()] = balanceOf(feeCollector()).add(VAR34);\nreturn true;\n}\nfunction FUN41(address VAR46) public FUN6{\nsuper.FUN19(VAR46);\n}\nfunction FUN42(address VAR46) public FUN6{\nsuper.FUN20(VAR46);\n}\n}",
        "label": false,
        "name": "0xc6003a33f7464d6e6c1dc17344a75a9952187541.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nenum State {Active, Finalized}\nState public VAR3 = State.Active;\nstring public constant VAR4 = \"SKYFchain\";\nstring public constant VAR5 = \"SKYFT\";\nuint8 public VAR6 = 18;\nuint256 public constant VAR7 = 1534334400;\nuint256 public constant VAR8 = VAR7 + 365 days;\nuint256 public constant VAR9 = VAR7 + 182 days;\nuint256 public VAR10 = 1200 * 10 ** 24;\nuint256 public constant VAR11 = 528 * 10 ** 24;\nuint256 public constant VAR12 = 180 * 10 ** 24;\nuint256 public constant VAR13 = 120 * 10 ** 24;\nuint256 public constant VAR14 = 114 * 10 ** 24;\nuint256 public constant VAR15 = 18 * 10 ** 24;\nuint256 public constant VAR16 = 240 * 10 ** 24;\naddress public VAR17;\naddress public VAR18;\naddress public VAR19;\naddress public VAR20;\naddress public VAR21;\naddress public VAR22;\naddress public VAR23;\nmapping (address => mapping (address => uint256)) VAR24;\nmapping (address => uint256) VAR25;\nmapping (address => uint256) VAR26;\nmapping (address => uint256) VAR27;\nconstructor(address VAR28, address VAR29, address VAR30, address VAR31, address VAR32, address VAR33, address VAR34) public {\nrequire(VAR28 != address(0));\nrequire(VAR29 != address(0));\nrequire(VAR30 != address(0));\nrequire(VAR31 != address(0));\nrequire(VAR32 != address(0));\nrequire(VAR33 != address(0));\nrequire(VAR34 != address(0));\nVAR17 = VAR28;\nVAR18 = VAR29;\nVAR19 = VAR30;\nVAR20 = VAR31;\nVAR21 = VAR32;\nVAR22 = VAR33;\nVAR23 = VAR34;\nFUN3(VAR17, VAR11);\nFUN3(VAR18, VAR12);\nFUN3(VAR19, VAR13);\nFUN3(VAR20, VAR14);\nFUN3(VAR21, VAR15);\nFUN3(VAR22, VAR16);\nVAR24[VAR17][VAR23] = VAR11;\nVAR24[VAR17][VAR1] = VAR11;\n}\nfunction FUN3(address VAR35, uint256 VAR36) internal {\nrequire(VAR25[VAR35] == 0);\nVAR25[VAR35] = VAR25[VAR35].add(VAR36);\n}\nmodifier FUN4() {\nrequire(VAR3 == State.Finalized || msg.sender == VAR1|| msg.sender == VAR23 || msg.sender == VAR17);\nrequire (_airdropUnlocked(msg.sender));\n_;\n}\nmodifier FUN5() {\nrequire(msg.sender == VAR1 || msg.sender == VAR23);\n_;\n}\nfunction FUN6(address VAR37) public FUN1 {\nrequire(VAR37 != address(0));\nuint256 VAR38 = VAR24[VAR17][VAR23];\nVAR24[VAR17][VAR23] = 0;\nVAR24[VAR17][VAR37] = VAR24[VAR17][VAR37].add(VAR38);\nVAR23 = VAR37;\n}\nfunction FUN7(address VAR35, uint256 VAR39) public FUN4 returns (bool) {\nrequire(VAR35 != address(0));\nrequire(VAR39 <= VAR25[msg.sender]);\nrequire(_airdropUnlocked(VAR35));\nVAR25[msg.sender] = VAR25[msg.sender].sub(VAR39);\nVAR25[VAR35] = VAR25[VAR35].add(VAR39);\nreturn true;\n}\nfunction FUN8(address VAR40, address VAR35, uint256 VAR39) public FUN4 returns (bool) {\nreturn FUN9(msg.sender, VAR40, VAR35, VAR39);\n}\nfunction FUN9(address VAR41, address VAR40, address VAR35, uint256 VAR39) internal returns (bool) {\nrequire(VAR35 != address(0));\nrequire(VAR39 <= VAR25[VAR40]);\nrequire(_airdropUnlocked(VAR35) || VAR40 == VAR17);\nuint256 VAR42 = VAR24[VAR40][VAR41];\nrequire(VAR39 <= VAR42);\nVAR25[VAR40] = VAR25[VAR40].sub(VAR39);\nVAR25[VAR35] = VAR25[VAR35].add(VAR39);\nVAR24[VAR40][VAR41] = VAR42.sub(VAR39);\nFUN17(VAR35);\nreturn true;\n}\nfunction FUN10(address VAR43, uint256 VAR39) public FUN4 returns (bool) {\nVAR24[msg.sender][VAR43] = VAR39;\nreturn true;\n}\nfunction FUN11(address VAR43, uint256 VAR44) public FUN4 returns (bool) {\nVAR24[msg.sender][VAR43] = (VAR24[msg.sender][VAR43].add(VAR44));\nreturn true;\n}\nfunction FUN12(address VAR43, uint256 VAR45) public FUN4 returns (bool) {\nuint256 VAR46 = VAR24[msg.sender][VAR43];\nif (VAR45 > VAR46) {\nVAR24[msg.sender][VAR43] = 0;\n} else {\nVAR24[msg.sender][VAR43] = VAR46.sub(VAR45);\n}\nreturn true;\n}\nfunction FUN13(uint256 VAR39) public FUN4 {\nFUN14(msg.sender, VAR39);\n}\nfunction FUN14(address VAR41, uint256 VAR39) internal {\nrequire(VAR39 <= VAR25[VAR41]);\nVAR25[VAR41] = VAR25[VAR41].sub(VAR39);\nVAR10 = VAR10.sub(VAR39);\n}\nfunction FUN15() public FUN1 {\nrequire(VAR3 == State.Active);\nrequire(now > VAR7);\nVAR3 = State.Finalized;\nuint256 VAR47 = balanceOf(VAR17);\nuint256 VAR48 = VAR12.mul(VAR47).div(VAR11);\nFUN14(VAR18, VAR48);\nVAR48 = VAR13.mul(VAR47).div(VAR11);\nFUN14(VAR19, VAR48);\nVAR48 = VAR14.mul(VAR47).div(VAR11);\nFUN14(VAR20, VAR48);\nVAR48 = VAR15.mul(VAR47).div(VAR11);\nFUN14(VAR21, VAR48);\nVAR48 = VAR16.mul(VAR47).div(VAR11);\nFUN14(VAR22, VAR48);\nFUN14(VAR17, VAR47);\n}\nfunction FUN16(address VAR49, uint256 VAR36) public FUN5 {\nrequire(VAR49 != VAR17);\nrequire(VAR49 != VAR18);\nrequire(VAR49 != VAR19);\nrequire(VAR49 != VAR21);\nrequire(VAR49 != VAR23);\nrequire(VAR25[VAR49] == 0 || isAirdrop(VAR49));\nif (VAR27[VAR49] != 0) {\nVAR27[VAR49] = VAR27[VAR49].add(VAR36);\n}\nelse {\nVAR26[VAR49] = VAR26[VAR49].add(VAR36);\n}\nFUN9(msg.sender, VAR17, VAR49, VAR36);\n}\nfunction FUN17(address VAR41) internal {\nif(VAR3 == State.Active && isAirdrop(VAR41)) {\nuint256 VAR50 = VAR26[VAR41];\nif (VAR50 > 0) {\nuint256 VAR51 = VAR25[VAR41].div(VAR50);\nif (VAR51 >= 4) {\ndelete VAR26[VAR41];\n} else if (VAR51 >= 2) {\ndelete VAR26[VAR41];\nVAR27[VAR41] = VAR50;\n}\n} else {\nVAR50 = VAR27[VAR41];\nif (VAR50 > 0) {\nVAR51 = VAR25[VAR41].div(VAR50);\nif (VAR51 >= 4) {\ndelete VAR27[VAR41];\n}\n}\n}\n}\n}\n}",
        "label": false,
        "name": "0x5dd0815a4cf119ad91ba045bbbf879f3f7de3c68.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\naddress public VAR11;\nstring public constant VAR12 = \"Finom NOM Token\";\nstring public constant VAR13 = \"NOM\";\nuint32 public constant VAR14 = 18;\nuint256 public constant VAR15 = 113300000 * 1 ether;\nuint256 public VAR16 = VAR15.mul(45).div(100);\nuint256 public VAR17 = VAR15.mul(15).div(100); uint public constant VAR18 = 1579046400; bool public VAR19 = false;\nuint256 public VAR20 = VAR15.mul(20).div(100); uint public constant VAR21 = 1594771200; bool public VAR22 = false;\nuint256 public VAR23 = VAR15.mul(20).div(100); uint public constant VAR24 = 1610668800; bool public VAR25 = false;\nfunction CON5() public {\nVAR11 = msg.sender;\nVAR1 = VAR16;\nVAR2[VAR11] = VAR16;\n}\nfunction FUN6() public returns (bool) {\nrequire(msg.sender == VAR11);\nuint256 VAR26 = 0;\nif (now > VAR18 && !VAR19) {\nVAR26 = VAR26.add(VAR17);\nVAR19 = true;\n}\nif (now > VAR21 && !VAR22) {\nVAR26 = VAR26.add(VAR20);\nVAR22 = true;\n}\nif (now > VAR24 && !VAR25) {\nVAR26 = VAR26.add(VAR23);\nVAR25 = true;\n}\nrequire(VAR26 > 0);\nuint256 VAR27 = VAR1.add(VAR26);\nrequire(VAR27 <= VAR15);\nVAR1 = VAR1.add(VAR26);\nVAR2[VAR11] = VAR2[VAR11].add(VAR26);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd5fcc92743fe55ff080acc35ef7d7ec9c0f3df56.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nassert((VAR3 >= VAR1) && (VAR3 >= VAR2));\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nassert(VAR1 >= VAR2);\nuint256 VAR3 = VAR1 - VAR2;\nreturn VAR3;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 * VAR2;\nassert((VAR1 == 0)||(VAR3/VAR1 == VAR2));\nreturn VAR3;\n}\n}\ncontract CON2 {\nuint256 public VAR4;\n}\ncontract CON3 is CON2 {\nfunction FUN4(address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[msg.sender] -= VAR6;\nVAR13[VAR5] += VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN5(address VAR8, address VAR5, uint256 VAR6) returns (bool VAR7) {\nif (VAR13[VAR8] >= VAR6 && VAR14[VAR8][msg.sender] >= VAR6 && VAR6 > 0) {\nVAR13[VAR5] += VAR6;\nVAR13[VAR8] -= VAR6;\nVAR14[VAR8][msg.sender] -= VAR6;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN6(address VAR9) constant returns (uint256 VAR10) {\nreturn VAR13[VAR9];\n}\nfunction FUN7(address VAR11, uint256 VAR6) returns (bool VAR7) {\nVAR14[msg.sender][VAR11] = VAR6;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR11) constant returns (uint256 VAR12) {\nreturn VAR14[VAR9][VAR11];\n}\nmapping (address => uint256) VAR13;\nmapping (address => mapping (address => uint256)) VAR14;\n}\ncontract CON4 is CON3, CON1 {\nstring public constant VAR15 = \"LockChain\";\nstring public constant VAR16 = \"LOC\";\nuint256 public constant VAR17 = 18;\nstring public VAR18 = \"1.0\";\naddress public VAR19; address public VAR20; address public VAR21;\naddress public VAR22;\nbool public VAR23; bool public VAR24;\nbool public VAR25;\nbool public VAR26;\nuint public VAR27;\nuint public VAR28;\nuint256 public VAR29 = 0; uint256 public constant VAR30 = 155 * (10**6) * 10**VAR17;\nuint256 public constant VAR31 = 50 * (10**6) * 10**VAR17;\nfunction CON4()\n{\nVAR23 = false; VAR19 = '0x013aF31dc76255d3b33d2185A7148300882EbC7a';\nVAR20 = '0xe0F2653e7928e6CB7c6D3206163b3E466a29c7C3';\nVAR21 = '0x25BC70bFda877e1534151cB92D97AC5E69e1F53D';\nVAR22 = '0x953ebf6C38C58C934D58b9b17d8f9D0F121218BB';\nVAR25 = false;\nVAR24 = false;\nVAR26 = false;\nVAR4 = 0;\n}\nfunction () payable {\nif (VAR23) throw;\nif (!VAR25 && !VAR24 && !VAR26) throw;\nif (msg.value == 0) throw;\nuint256 VAR32 = FUN3(msg.value, VAR29); uint256 VAR33 = FUN1(VAR4, VAR32);\nif(!VAR26){\nif (VAR31 < VAR33) throw;\n}\nif (VAR30 < VAR33) throw; VAR4 = VAR33;\nVAR13[msg.sender] += VAR32; }\nfunction FUN10() external {\nif (VAR23) throw;\nif (msg.sender != VAR19) throw; uint256 VAR34 = VAR4;\nuint256 VAR35;\nuint256 VAR36;\nuint256 VAR37 = 10000 * 10**VAR17;\nuint256 VAR38;\nuint256 VAR33 = FUN1(VAR4, VAR34);\nVAR4 = VAR33;\nif (VAR34 % 2 == 0){\nVAR38 = VAR34/2;\nVAR36 = VAR34/2;\nVAR35 = VAR38 - VAR37;\nVAR13[VAR20] += VAR35;\nVAR13[VAR21] += VAR36;\n}\nelse{\nuint256 VAR39 = VAR34 - 1;\nuint256 VAR40 = VAR39/2;\nVAR38 = VAR40;\nVAR36 = VAR40 + 1;\nVAR35 = VAR38 - VAR37;\nVAR13[VAR20] += VAR35;\nVAR13[VAR21] += VAR36;\n}\nVAR13[VAR22] += VAR37;\nif(!VAR19.send(this.VAR10)) throw;\nVAR23 = true; }\nfunction FUN11() external {\nif (msg.sender != VAR19) throw; if(VAR26) throw;\nif(!VAR25){\nVAR25 = true;\nVAR29 = 1150;\n}\nelse if (!VAR24){\nVAR24 = true;\nVAR29 = 1000;\n}\nelse if (!VAR26){\nVAR26 = true;\nif (VAR4 < 10 * (10**6) * 10**VAR17)\n{\nVAR29 = 750;\n}\nelse if (VAR4 >= 10 * (10**6) * 10**VAR17 && VAR4 < 20 * (10**6) * 10**VAR17)\n{\nVAR29 = 700;\n}\nelse if (VAR4 >= 20 * (10**6) * 10**VAR17 && VAR4 < 30 * (10**6) * 10**VAR17)\n{\nVAR29 = 650;\n}\nelse if (VAR4 >= 30 * (10**6) * 10**VAR17 && VAR4 < 40 * (10**6) * 10**VAR17)\n{\nVAR29 = 620;\n}\nelse if (VAR4 >= 40 * (10**6) * 10**VAR17 && VAR4 <= 50 * (10**6) * 10**VAR17)\n{\nVAR29 = 600;\n}\n}\n}\n}",
        "label": false,
        "name": "0x5e3346444010135322268a4630d2ed5f8d09446c.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"CLUE\";\nstring public constant VAR2 = \"Clue\";\nuint8 public constant VAR3 = 8;\nmapping( address => uint ) VAR4;\nmapping( address => mapping( address => uint ) ) VAR5;\nuint public VAR6 = 100000000;\nfunction CON1() {\nVAR4[msg.sender] = 10000000000000000;\n}\nfunction FUN1() constant returns (uint VAR7) {\nreturn VAR6;\n}\nfunction FUN2( address VAR8 ) constant returns (uint VAR9) {\nreturn VAR4[VAR8];\n}\nfunction FUN3( address VAR10, uint VAR9) returns (bool VAR11) {\nif( VAR4[msg.sender] < VAR9 ) {\nthrow;\n}\nif( !FUN7(VAR4[VAR10], VAR9) ) {\nthrow;\n}\nVAR4[msg.sender] -= VAR9;\nVAR4[VAR10] += VAR9;\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR10, uint VAR9) returns (bool VAR11) {\nif( VAR4[VAR12] < VAR9 ) {\nthrow;\n}\nif( VAR5[VAR12][msg.sender] < VAR9 ) {\nthrow;\n}\nif( !FUN7(VAR4[VAR10], VAR9) ) {\nthrow;\n}\nVAR5[VAR12][msg.sender] -= VAR9;\nVAR4[VAR12] -= VAR9;\nVAR4[VAR10] += VAR9;\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR9) returns (bool VAR11) {\nVAR5[msg.sender][VAR13] = VAR9;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR13) constant returns (uint VAR15) {\nreturn VAR5[VAR14][VAR13];\n}\nfunction FUN7(uint VAR16, uint VAR17) internal returns (bool) {\nreturn (VAR16 + VAR17 >= VAR16);\n}\n}",
        "label": false,
        "name": "0x091f601d7b6c0c8073d075a1847bafc6872559a4.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(VAR13);\n_;\n}\nfunction FUN12() public FUN6 FUN10 {\nVAR13 = true;\n}\nfunction FUN13() public FUN6 FUN11 {\nVAR13 = false;\n}\n}\ncontract CON7 is CON4, CON6 {\nstring public VAR14;\nstring public VAR15;\nuint8 public VAR16;\nuint256 public VAR17 = 35e5 * 10 **18;\nuint256 public VAR18 = 525e4 * 10 **18;\nuint256 public VAR19 = 175e4 * 10 **18;\nuint256 public VAR20 = 175e3 * 10 **18;\nconstructor () public {\nVAR14 = \"Encrypt Index\";\nVAR15 = \"NIX\";\nVAR16 = 18;\nVAR2 = 35e6 * 10 ** uint256(VAR16); VAR1[VAR11] = VAR2;\n}\n}\ncontract CON8 is CON7{\nusing SafeMath for uint256;\nuint256 public VAR21;\nuint256 public VAR22;\nuint256 public VAR23 = 8; uint256 public VAR24 = 9; uint256 public VAR25 = 10; uint256 public VAR26;\nuint256 public VAR27 = 1000000; address public VAR28;\nuint256 public VAR29 = 500000000; uint256 public VAR30 = 1500000000; uint256 public VAR31;\nbool public VAR32 = false;\nstruct Investor {\nuint256 VAR33;\nuint256 VAR34;\n}\nmapping(address => Investor) public VAR35;\nmapping (address => bool) public VAR36;\nconstructor (address VAR37, uint256 VAR38) public{\nrequire(VAR37 != address(0x0), \"wallet address must not be zero\");\nVAR28 = VAR37;\nVAR26 = VAR38;\n}\nfunction () external payable{\nFUN24(msg.sender);\n}\nfunction FUN15(address VAR37) public FUN6{\nrequire(VAR37 != address(0x0), \"wallet address must not be zero\");\nVAR28 = VAR37;\n}\nfunction FUN16() external FUN6{\nVAR28.FUN1(address(this).balance);\n}\nfunction FUN17() public FUN6{\nVAR32 = !VAR32;\n}\nfunction FUN18(uint256 VAR38) public FUN6{\nVAR26 = VAR38;\n}\nfunction FUN19(address VAR39) public FUN6{\nrequire(!VAR36[VAR39], \"users is already whitelisted\");\nVAR36[VAR39] = true;\n}\nfunction FUN20(uint256 VAR38) public FUN6{\nrequire (VAR21 == 0);\nVAR26 = VAR38;\nVAR21 = 1;\n}\nfunction FUN21(uint256 VAR38) public FUN6{\nrequire (VAR21 == 1 && VAR22 == 0);\nVAR26 = VAR38;\nVAR22 = 1;\n}\nfunction FUN22(uint256 VAR38) public FUN6{\nrequire (VAR21 == 1 && VAR22 == 1);\nVAR26 = VAR38;\nVAR22 = 2;\n}\nfunction FUN23(uint256 VAR40) public FUN6 {\nrequire(VAR40 > 0, \"min contribution should be greater than 0\");\nVAR27 = VAR40;\n}\nfunction FUN24(address VAR41) internal {\n_preValidatePurchase(VAR41, msg.VAR45);\nuint256 VAR42 = _getTokenAmount(msg.VAR45);\nFUN25(VAR41, VAR42);\nInvestor storage VAR43 = VAR35[VAR41];\nVAR43.VAR34 = VAR43.VAR34.add(VAR42);\nVAR43.VAR33 = VAR43.VAR33.add(msg.VAR45);\nVAR31 = VAR31.add(msg.VAR45);\nVAR28.FUN1(msg.VAR45);\n}\nfunction FUN25(address VAR44, uint256 VAR45) private{\nVAR1[VAR11] = VAR1[VAR11].sub(VAR45);\nVAR1[VAR44] = VAR1[VAR44].add(VAR45);\n}\n}",
        "label": false,
        "name": "0x7906cdac57b29ef289c4887eb7811c2a641a2b75.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nfunction FUN1(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 * VAR3;\nassert(VAR2 == 0 || VAR4 / VAR2 == VAR3);\nreturn VAR4;\n}\nfunction FUN2(uint VAR2, uint VAR3) internal returns (uint) {\nassert(VAR3 > 0);\nuint VAR4 = VAR2 / VAR3;\nassert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);\nreturn VAR4;\n}\nfunction FUN3(uint VAR2, uint VAR3) internal returns (uint) {\nassert(VAR3 <= VAR2);\nreturn VAR2 - VAR3;\n}\nfunction FUN4(uint VAR2, uint VAR3) internal returns (uint) {\nuint VAR4 = VAR2 + VAR3;\nassert(VAR4>=VAR2 && VAR4>=VAR3);\nreturn VAR4;\n}\nfunction FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (uint64) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\nfunction FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 >= VAR3 ? VAR2 : VAR3;\n}\nfunction FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {\nreturn VAR2 < VAR3 ? VAR2 : VAR3;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping(address => uint) VAR5;\nmapping (address => mapping (address => uint)) VAR6;\nfunction FUN9() public constant returns (bool VAR7) {\nreturn true;\n}\nfunction FUN10(address VAR8, uint VAR9) returns (bool VAR10) {\nVAR5[msg.sender] = FUN3(VAR5[msg.sender], VAR9);\nVAR5[VAR8] = FUN4(VAR5[VAR8], VAR9);\nreturn true;\n}\nfunction FUN11(address VAR11, address VAR8, uint VAR9) returns (bool VAR10) {\nuint VAR12 = VAR6[VAR11][msg.sender];\nVAR5[VAR8] = FUN4(VAR5[VAR8], VAR9);\nVAR5[VAR11] = FUN3(VAR5[VAR11], VAR9);\nVAR6[VAR11][msg.sender] = FUN3(VAR12, VAR9);\nreturn true;\n}\nfunction FUN12(address VAR13) constant returns (uint VAR14) {\nreturn VAR5[VAR13];\n}\nfunction FUN13(address VAR15, uint VAR9) returns (bool VAR10) {\nif ((VAR9 != 0) && (VAR6[msg.sender][VAR15] != 0)) throw;\nVAR6[msg.sender][VAR15] = VAR9;\nreturn true;\n}\nfunction FUN14(address VAR13, address VAR15) constant returns (uint VAR16) {\nreturn VAR6[VAR13][VAR15];\n}\n}\ncontract CON5 is CON4 {\naddress public constant VAR17 = 0;\nfunction FUN15(uint VAR18) {\naddress VAR19 = msg.sender;\nVAR5[VAR19] = FUN3(VAR5[VAR19], VAR18);\nVAR1 = FUN3(VAR1, VAR18);\n}\n}\ncontract CON6 {\nuint public VAR20;\nfunction FUN16() public constant returns (bool) {\nreturn true;\n}\n}\ncontract CON7 is CON4 {\naddress public VAR21;\nCON6 public VAR22;\nuint256 public VAR23;\nenum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\nfunction CON7(address VAR24) {\nVAR21 = VAR24;\n}\nfunction FUN17(uint256 VAR25) public {\nUpgradeState VAR26 = FUN19();\nif(!(VAR26 == UpgradeState.ReadyToUpgrade || VAR26 == UpgradeState.Upgrading)) {\nthrow;\n}\nif (VAR25 == 0) throw;\nVAR5[msg.sender] = FUN3(VAR5[msg.sender], VAR25);\nVAR1 = FUN3(VAR1, VAR25);\nVAR23 = FUN4(VAR23, VAR25);\nVAR22.upgradeFrom(msg.sender, VAR25);\n}\nfunction FUN18(address VAR27) external {\nif(!FUN21()) {\nthrow;\n}\nif (VAR27 == 0x0) throw;\nif (msg.sender != VAR21) throw;\nif (FUN19() == UpgradeState.Upgrading) throw;\nVAR22 = CON6(VAR27);\nif(!VAR22.FUN16()) throw;\nif (VAR22.VAR20() != VAR1) throw;\n}\nfunction FUN19() public constant returns(UpgradeState) {\nif(!FUN21()) return UpgradeState.NotAllowed;\nelse if(address(VAR22) == 0x00) return UpgradeState.WaitingForAgent;\nelse if(VAR23 == 0) return UpgradeState.ReadyToUpgrade;\nelse return UpgradeState.Upgrading;\n}\nfunction FUN20(address VAR28) public {\nif (VAR28 == 0x0) throw;\nif (msg.sender != VAR21) throw;\nVAR21 = VAR28;\n}\nfunction FUN21() public constant returns(bool) {\nreturn true;\n}\n}\ncontract CON8 {\naddress public VAR29;\nfunction CON8() {\nVAR29 = msg.sender;\n}\nmodifier FUN22() {\nrequire(msg.sender == VAR29);\n_;\n}\nfunction FUN23(address VAR30) FUN22 public {\nrequire(VAR30 != address(0));\nVAR29 = VAR30;\n}\n}\ncontract CON9 is CON2, CON8 {\naddress public VAR31;\nbool public VAR32 = false;\nmapping (address => bool) public VAR33;\nmodifier FUN24(address VAR34) {\nif(!VAR32) {\nif(!VAR33[VAR34]) {\nthrow;\n}\n}\n_;\n}\nfunction FUN25(address VAR35) FUN22 FUN28(false) public {\nVAR31 = VAR35;\n}\nfunction FUN26(address VAR35, bool VAR26) FUN22 FUN28(false) public {\nVAR33[VAR35] = VAR26;\n}\nfunction FUN27() public FUN29 {\nVAR32 = true;\n}\nmodifier FUN28(bool VAR36) {\nif(VAR36 != VAR32) {\nthrow;\n}\n_;\n}\nmodifier FUN29() {\nif(msg.sender != VAR31) {\nthrow;\n}\n_;\n}\nfunction FUN10(address VAR8, uint VAR9) FUN24(msg.sender) returns (bool VAR10) {\nreturn super.FUN10(VAR8, VAR9);\n}\nfunction FUN11(address VAR11, address VAR8, uint VAR9) FUN24(VAR11) returns (bool VAR10) {\nreturn super.FUN11(VAR11, VAR8, VAR9);\n}\n}\ncontract CON10 is CON4, CON8 {\nusing SafeMathLib for uint;\nbool public VAR37 = false;\nmapping (address => bool) public VAR38;\nfunction FUN30(address VAR39, uint VAR40) FUN32 FUN33 public {\nVAR1 = VAR1.plus(VAR40);\nVAR5[VAR39] = VAR5[VAR39].plus(VAR40);\n}\nfunction FUN31(address VAR35, bool VAR26) FUN22 FUN33 public {\nVAR38[VAR35] = VAR26;\n}\nmodifier FUN32() {\nif(!VAR38[msg.sender]) {\nthrow;\n}\n_;\n}\nmodifier FUN33() {\nif(VAR37) throw;\n_;\n}\n}\ncontract CON11 is CON9, CON10, CON7 {\nstring public VAR41;\nstring public VAR42;\nuint public VAR43;\nfunction CON11(string VAR44, string VAR45, uint VAR46, uint VAR47, bool VAR48)\nCON7(msg.sender) {\nVAR29 = msg.sender;\nVAR41 = VAR44;\nVAR42 = VAR45;\nVAR1 = VAR46;\nVAR43 = VAR47;\nVAR5[VAR29] = VAR1;\nif(VAR1 > 0) {\n}\nif(!VAR48) {\nVAR37 = true;\nif(VAR1 == 0) {\nthrow; }\n}\n}\nfunction FUN27() public FUN29 {\nVAR37 = true;\nsuper.FUN27();\n}\nfunction FUN21() public constant returns(bool) {\nreturn VAR32 && super.FUN21();\n}\nfunction FUN34(string VAR44, string VAR45) FUN22 {\nVAR41 = VAR44;\nVAR42 = VAR45;\n}\n}\ncontract CON12 is CON5, CON11 {\nfunction CON12(string VAR44, string VAR45, uint VAR46, uint VAR47, bool VAR48)\nCON11(VAR44, VAR45, VAR46, VAR47, VAR48) {\n}\n}",
        "label": false,
        "name": "0xac3211a5025414af2866ff09c23fc18bc97e79b1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\nuint256 public VAR4;\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[msg.sender]);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR5[VAR9] = VAR5[VAR9].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10, uint VAR11) public FUN3 returns (bool VAR14) {\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10, uint VAR12) public FUN3 returns (bool VAR14) {\nreturn super.FUN11(VAR10, VAR12);\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint256;\nstring public constant VAR15 = 'Costume Token';\nstring public constant VAR16 = 'COST';\nuint8 public constant VAR17 = 18;\nuint256 public constant VAR4 = 200e24;\nuint256 public VAR18 = 120e24;\nuint256 public VAR19 = 80e24;\nuint256 public VAR20 = 0;\naddress public VAR21;\nmodifier FUN12() {\nrequire(msg.sender == VAR21);\n_;\n}\nfunction CON8() public {\nVAR5[msg.sender] = VAR18;\n}\nfunction FUN13(address VAR22) external FUN1 FUN3 {\nrequire(VAR21 == address(0));\nrequire(VAR22 != address(0));\nVAR21 = VAR22;\n}\nfunction FUN14(address VAR23, uint VAR24) external FUN12 FUN3 {\nrequire(VAR23 != address(0));\nrequire(VAR24 > 0);\nrequire(VAR20 < VAR19);\nrequire(VAR20.add(VAR24) <= VAR19);\nVAR20 = VAR20.add(VAR24);\nVAR5[VAR23] = VAR5[VAR23].add(VAR24);\n}\n}",
        "label": false,
        "name": "0x59f2cc9bbeb3ccbef4991769deb29611a28acf83.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint public VAR3;\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON4, CON2, CON1 {\nstring public VAR4 = \"PayFair Token\";\nstring public VAR5 = \"PFR\";\nuint public constant VAR6 = 8;\nuint public constant VAR7 = 11109031;\nuint public constant VAR8 = 10 ** VAR6;\nCON2 public VAR9;\nmapping (address => mapping (address => uint)) VAR10;\nmapping(address => uint) VAR11;\nmodifier FUN3(uint VAR12) {\nrequire(msg.data.VAR27 >= VAR12 + 4);\n_;\n}\nconstructor (address VAR13) public {\nVAR9 = CON2(VAR13);\nVAR3 = convertToDecimal(VAR7);\nVAR11[VAR1] = convertToDecimal(VAR7);\n}\nfunction() external payable {\nrevert();\n}\nfunction FUN5(uint VAR14) public {\nrequire(VAR14 <= VAR9.balanceOf(msg.sender));\nrequire(VAR14 <= VAR9.allowance(msg.sender, address(this)));\nVAR3 = safeAdd(VAR3, VAR14);\nVAR11[msg.sender] = safeAdd(VAR11[msg.sender], VAR14);\nVAR9.FUN7(msg.sender, address(0x0), VAR14);\n}\nfunction FUN6(address VAR15, uint VAR16) public returns (bool VAR17) {\nbytes memory VAR18;\nreturn FUN6(VAR15, VAR16, VAR18);\n}\nfunction FUN7(address VAR19, address VAR15, uint VAR16) public returns (bool VAR17) {\nbytes memory VAR18;\nreturn FUN7(VAR19, VAR15, VAR16, VAR18);\n}\nfunction FUN6(address VAR15, uint VAR16, bytes memory VAR20) public FUN3(2 * 32) returns (bool VAR17) {\nVAR11[msg.sender] = safeSub(VAR11[msg.sender], VAR16);\nVAR11[VAR15] = safeAdd(VAR11[VAR15], VAR16);\nif (FUN10(VAR15)) return FUN9(msg.sender, VAR15, VAR16, VAR20);\nreturn true;\n}\nfunction FUN7(address VAR19, address VAR15, uint VAR16, bytes memory VAR20) public FUN3(2 * 32) returns (bool VAR17) {\nuint256 VAR21 = VAR10[VAR19][msg.sender];\nVAR11[VAR15] = safeAdd(VAR11[VAR15], VAR16);\nVAR11[VAR19] = safeSub(VAR11[VAR19], VAR16);\nVAR10[VAR19][msg.sender] = safeSub(VAR21, VAR16);\nif (FUN10(VAR15)) return FUN9(msg.sender, VAR15, VAR16, VAR20);\nreturn true;\n}\nfunction FUN8(address VAR22, uint VAR16) public returns (bool VAR17) {\nrequire ((VAR16 == 0) || (VAR10[msg.sender][VAR22] == 0));\nVAR10[msg.sender][VAR22] = VAR16;\nreturn true;\n}\nfunction FUN9(address VAR23, address VAR15, uint VAR16, bytes memory VAR20) private returns (bool VAR17) {\nCON3 VAR24 = CON3(VAR15);\nreturn VAR24.tokenFallback(msg.sender, VAR23, VAR16, VAR20);\n}\nfunction FUN10(address VAR25) private returns (bool VAR26) {\nuint VAR27;\nassembly { VAR27 := extcodesize(VAR25) }\nreturn VAR27 > 0;\n}\n}",
        "label": false,
        "name": "0x6353eadf8d1d4421002332bb9074222b14d54881.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 400000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = \"Yuntoo Nuclear Body\"; VAR2 = \"YTNB\"; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xdbe29649c763d18b37c65c8fdd12ccbb241faafd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nstruct Beneficiary {\nuint256 VAR1;\nuint256 VAR2;\nuint256 VAR3;\nuint256 VAR4;\nuint256 VAR5;\n}\nmapping (address => Beneficiary) public VAR6;\nCON1 public VAR7;\nuint256 public VAR8 = 696523;\nmodifier FUN1 (address VAR9) { require(VAR6[VAR9].VAR1 != 0); _; }\nconstructor (CON1 VAR10) public {\nrequire(VAR10 != CON1(0x0));\nVAR7 = VAR10;\n}\nfunction FUN2 (address VAR9) public FUN1(VAR9) {\nuint256 VAR11 = releasableAmount(VAR9);\nrequire(VAR11 > 0);\nVAR6[VAR9].VAR5 = VAR6[VAR9].VAR5.add(VAR11);\nVAR7.transfer(VAR9, VAR11);\nif (VAR6[VAR9].VAR5 == VAR6[VAR9].VAR4) { delete VAR6[VAR9];\n}\n}\nfunction FUN3 (address VAR9,uint256 VAR1,uint256 VAR2,uint256 VAR3,uint256 VAR12) public {\nrequire(VAR12 != 0 && VAR1 != 0 && VAR9 != address(0x0) && VAR3 < VAR2 && VAR6[VAR9].VAR1 == 0);\nrequire(VAR7.transferFrom(msg.sender, address(this), VAR12));\nVAR6[VAR9] = Beneficiary({VAR1: VAR1,VAR2: VAR2,VAR3: VAR1.add(VAR3),VAR4: VAR12,VAR5: 0});\n}\n}",
        "label": false,
        "name": "0x7e2991baf45028374c784971f837b1983cd5e5cd.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"abc\";\nstring public VAR2 = \"asd\";\nmapping (string => string) VAR3;\naddress VAR4;\nconstructor() public {\nVAR4 = msg.sender;\n}\nfunction FUN1(string memory VAR5, string memory VAR6) public {\nrequire(msg.sender == VAR4);\nVAR3[VAR5] = VAR6;\n}\n}",
        "label": false,
        "name": "0x7def4eace7a34f148894edd2ab78b8d72b93bb59.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath\nfor uint;\nmapping(address => uint) public VAR1;\nmapping(address => uint) public VAR2;\nmapping(address => uint) public VAR3;\naddress public VAR4 = 0x18e9F86ed0430679f79EF2eA0cc5E1186b80c570;\naddress public VAR5 = 0xf36EEbB7438aDef0E7fE4650a6Cd6dB238B58c6a;\nuint VAR6 = 8;\nuint public VAR7 = 5;\nuint public VAR8 = 1 hours;\nuint public VAR9 = 250;\nuint public VAR10 = 300;\nuint public VAR11 = 350;\nuint public VAR12 = 375;\nuint public VAR13 = 1000 ether;\nuint public VAR14 = 2500 ether;\nuint public VAR15 = 5000 ether;\nuint public VAR16 = 0;\nuint public VAR17 = 0;\nmodifier FUN1() {\nrequire(VAR1[msg.sender] > 0, \"Deposit not found\");\n_;\n}\nmodifier FUN2() {\nrequire(now >= VAR2[msg.sender].add(VAR8), \"Too fast VAR18 request\");\n_;\n}\nfunction FUN3() FUN1 FUN2 internal {\nif ((VAR1[msg.sender].mul(2)) <= VAR3[msg.sender]) {\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\n} else {\nuint VAR18 = payoutAmount();\nVAR2[msg.sender] = now;\nVAR3[msg.sender] += VAR18;\nmsg.sender.transfer(VAR18);\n}\n}\nfunction FUN4() private {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR16 += 1;\n}\nif (VAR1[msg.sender] > 0 && now > VAR2[msg.sender].add(VAR8)) {\nFUN3();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR4.transfer(msg.value.mul(VAR6).div(100));\nuint VAR19 = msg.value.mul(VAR7).div(100);\nVAR17+=VAR19;\nVAR5.transfer(VAR19);\n} else {\nFUN3();\n}\n}\nfunction FUN5() FUN1 private {\nuint VAR20 = VAR1[msg.sender].sub(VAR3[msg.sender]).sub(VAR1[msg.sender].mul(VAR6).div(100));\nrequire(VAR1[msg.sender] > VAR20, 'You have already repaid your deposit');\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\nmsg.sender.transfer(VAR20);\n}\nfunction() external payable {\nif (msg.value == 0.00000112 ether) {\nFUN5();\n} else {\nFUN4();\n}\n}\n}",
        "label": false,
        "name": "0xb79258d3e2de118ff7ab458c0dbaa58f64d6ee1c.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) private VAR1;\naddress private VAR2;\naddress private VAR3;\nconstructor(address VAR4) public payable {\nVAR2 = VAR4;\nVAR3 = msg.sender;\n}\nfunction () external payable {\n}\nfunction FUN2(address VAR5, uint256 VAR6) public {\nrequire(msg.sender == VAR3);\nrequire(VAR5 != address(0) && VAR5 != address(this));\nrequire(VAR6 > 0);\nrequire(VAR1[VAR5] == 0);\nVAR1[VAR5] = VAR6;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public {\nrequire(msg.sender == VAR2);\nrequire(VAR6 > 0);\nrequire(VAR1[VAR5] == VAR6);\nVAR1[VAR5] = 0;\nVAR5.transfer(VAR6);\n}\nfunction FUN4(address VAR5) public {\nrequire(msg.sender == VAR2 || msg.sender == VAR3);\nVAR1[VAR5] = 0;\n}\n}",
        "label": false,
        "name": "0x1beb353fa1e215457ff16fceec07f7eab9f06565.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nmapping (address => bool) public VAR3;\nmodifier FUN5() {\nrequire(VAR3[msg.sender],\"AccessControlledBase#FUN5: Sender not authorized\");\n_;\n}\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nuint256 public VAR4;\nconstructor(uint256 VAR5)\npublic\nCON1()\n{\nVAR4 = block.timestamp.add(VAR5);\n}\nfunction FUN6(address VAR6)\nexternal\nFUN1\n{\nrequire(block.timestamp < VAR4,\"StaticAccessControlled#FUN6: Cannot grant access after grace period\");\nVAR3[VAR6] = true;\n}\n}\ninterface CON4 {\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nconstructor(uint256 VAR5)\npublic\nCON3(VAR5)\n{}\nfunction FUN7(address VAR7,address VAR8,address VAR9,uint256 VAR10)\nexternal\nFUN5\n{\nTokenInteract.transferFrom(VAR7,VAR8,VAR9,VAR10);\n}\n}\ncontract CON6 is CON3\n{\nusing SafeMath for uint256;\naddress public VAR11;\nmapping (bytes32 => mapping (address => uint256)) public VAR12;\nmapping (address => uint256) public VAR13;\nconstructor(address VAR14,uint256 VAR5)\npublic\nCON3(VAR5)\n{\nVAR11 = VAR14;\n}\nfunction FUN8(address VAR7,address VAR9)\nexternal\nFUN1\nreturns (uint256)\n{\nuint256 VAR15 = TokenInteract.balanceOf(VAR7, address(this));\nuint256 VAR16 = VAR13[VAR7];\nuint256 VAR17 = VAR15.sub(VAR16);\nrequire(VAR17 != 0,\"Vault#FUN8: Withdrawable VAR7 VAR19 must be non-zero\");\nTokenInteract.transfer(VAR7, VAR9, VAR17);\nreturn VAR17;\n}\nfunction FUN9(bytes32 VAR18,address VAR7,address VAR8,uint256 VAR19)\nexternal\nFUN5\n{\nCON5(VAR11).FUN7(VAR7,VAR8,address(this),VAR19);\nVAR12[VAR18][VAR7] = VAR12[VAR18][VAR7].add(VAR19);\nVAR13[VAR7] = VAR13[VAR7].add(VAR19);\nassert(VAR13[VAR7] >= VAR12[VAR18][VAR7]);\nvalidateBalance(VAR7);\n}\nfunction FUN10(bytes32 VAR18,address VAR7,address VAR9,uint256 VAR19)\nexternal\nFUN5\n{\nVAR12[VAR18][VAR7] = VAR12[VAR18][VAR7].sub(VAR19);\nVAR13[VAR7] = VAR13[VAR7].sub(VAR19);\nassert(VAR13[VAR7] >= VAR12[VAR18][VAR7]);\nTokenInteract.transfer(VAR7, VAR9, VAR19);\nvalidateBalance(VAR7);\n}\n}",
        "label": false,
        "name": "0x5199071825cc1d6cd019b0d7d42b08106f6cf16d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) public VAR3;\nmapping (address => address) public VAR4;\nfunction CON2() {\n}\nfunction FUN3(address VAR5) external FUN1 {\nrequire(VAR5 != 0x0 && !VAR3[VAR5]);\nVAR3[VAR5] = true;\n}\nfunction FUN4(address VAR5) external FUN1 {\nrequire(VAR5 != 0x0 && VAR3[VAR5]);\nVAR3[VAR5] = false;\n}\nfunction FUN5(address VAR5, address VAR6) external FUN1 {\nrequire(VAR5 != 0x0 && VAR6 != 0x0 && VAR4[VAR5] == 0x0 && VAR5 != VAR6);\nVAR4[VAR5] = VAR6;\n}\nfunction FUN6(address VAR5) constant external returns (bool VAR7) {\nreturn VAR3[VAR5];\n}\nfunction FUN7(address VAR5) constant external returns (address VAR7) {\nreturn VAR4[VAR5];\n}\n}",
        "label": false,
        "name": "0x1fd6cf63b36e1258ddea7d0accd3838f0fe1aab7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: mint to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nstring private VAR13;\nstring private VAR14;\nuint8 private VAR15;\nconstructor () public CON3() {\nVAR13=\"Gold Pressed Latinum\";\nVAR14=\"GPL\";\nVAR15=18;\nFUN7(msg.VAR8, 100000000 * (10 ** uint256(decimals())));\n}\n}",
        "label": false,
        "name": "0xeeddaa78e0b2de769e969bd049c8faff3280df97.sol"
    },
    {
        "source": "contract CON1 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nmapping (address => uint256) public VAR4;\nfunction CON1 (uint256 VAR5, string VAR6, uint8 VAR7, string VAR8) {\nVAR4[msg.sender] = VAR5; VAR1 = VAR6; VAR2 = VAR8; VAR3 = VAR7; }\nfunction FUN1(address VAR9, uint256 VAR10) {\nif (VAR4[msg.sender] < VAR10) throw; if (VAR4[VAR9] + VAR10 < VAR4[VAR9]) throw; VAR4[msg.sender] -= VAR10; VAR4[VAR9] += VAR10; }\n}",
        "label": false,
        "name": "0x628b25d7faa0f64c0893334a5c973feb77b1f33b.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\naddress private VAR11;\nuint256 VAR12;\nbool VAR13 = false;\nfunction CON4 (uint256 VAR14) public {\nVAR11 = msg.sender;\nVAR12 = VAR14;\nVAR9 [msg.sender] = VAR14;\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN1 (VAR2, VAR3);\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nif (VAR13) return false;\nelse return CON3.FUN2 (VAR6, VAR2, VAR3);\n}\nfunction FUN3 (address VAR8, uint256 VAR15, uint256 VAR16)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR15)\nreturn FUN3 (VAR8, VAR16);\nelse return false;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool VAR4) {\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR12 = safeSub (VAR12, VAR3);\nreturn true;\n} else return true;\n}\nfunction FUN5 (address VAR17) public {\nrequire (msg.sender == VAR11);\nVAR11 = VAR17;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR11);\nif (!VAR13) {\nVAR13 = true;\nFreeze ();\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR11);\nif (VAR13) {\nVAR13 = false;\nUnfreeze ();\n}\n}\n}",
        "label": false,
        "name": "0xb5dbc6d3cf380079df3b27135664b6bcf45d1869.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xacde57e511fedc9b563d48bbc3c74ec16dcedf21.sol"
    },
    {
        "source": "contract CON1 {\naddress constant VAR1 = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\nfunction CON1() {\nVAR3 = VAR1.balance > 10000 ether;\n}\nfunction FUN1(address VAR2) {\nif (VAR3)\nthrow;\nif (!VAR2.send(msg.value))\nthrow;\n}\nfunction FUN2(address VAR2) {\nif (!VAR3)\nthrow;\nif (!VAR2.send(msg.value))\nthrow;\n}\nbool public VAR3;\n}",
        "label": false,
        "name": "0xe7aa95217eb415b2c400c81e2b65359e720ab936.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON4 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nfunction CON5(string VAR7, string VAR8, uint8 VAR9) public {\nVAR4 = VAR7;\nVAR5 = VAR8;\nVAR6 = VAR9;\n}\n}\ncontract CON6 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR10;\nuint256 VAR11;\nfunction FUN7(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nreturn true;\n}\n}\ncontract CON7 is CON4, CON6 {\nmapping (address => mapping (address => uint256)) internal VAR14;\nfunction FUN8(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR10[VAR15]);\nrequire(VAR13 <= VAR14[VAR15][msg.sender]);\nVAR10[VAR15] = VAR10[VAR15].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR14[VAR15][msg.sender] = VAR14[VAR15][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN9(address VAR16, uint256 VAR13) public returns (bool) {\nVAR14[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN10(address VAR16, uint VAR17) public returns (bool) {\nVAR14[msg.sender][VAR16] = VAR14[msg.sender][VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN11(address VAR16, uint VAR18) public returns (bool) {\nuint VAR19 = VAR14[msg.sender][VAR16];\nif (VAR18 > VAR19) {\nVAR14[msg.sender][VAR16] = 0;\n} else {\nVAR14[msg.sender][VAR16] = VAR19.sub(VAR18);\n}\nreturn true;\n}\n}\ncontract CON8 is CON5(\"BlockRx Digital Token\", \"BKRx\", 18), CON2, CON7 {\nusing SafeMath for uint256;\nuint256 public VAR20;\nfunction CON8(uint256 VAR21) public {\nrequire(VAR21 > 0);\nVAR20 = VAR21;\nVAR10[msg.sender] = VAR20;\nFUN5();\n}\nfunction FUN12(address VAR12, uint256 VAR22) public FUN1 {\nrequire(VAR12 != address(0));\nrequire(VAR22 > 0);\nsuper.FUN7(VAR12, VAR22);\n}\nfunction FUN13(uint256 VAR22) public FUN3 {\nrequire(VAR22 > 0);\nVAR10[msg.sender] = balanceOf(msg.sender).sub(VAR22);\nVAR20 = VAR20.sub(VAR22);\n}\nfunction FUN7(address VAR12, uint256 VAR22) public FUN3 returns (bool) {\nreturn super.FUN7(VAR12, VAR22);\n}\nfunction FUN8(address VAR15, address VAR12, uint256 VAR22) public FUN3 returns (bool) {\nreturn super.FUN8(VAR15, VAR12, VAR22);\n}\nfunction FUN9(address VAR16, uint256 VAR22) public FUN3 returns (bool) {\nreturn super.FUN9(VAR16, VAR22);\n}\nfunction FUN10(address VAR16, uint VAR23) public FUN3 returns (bool VAR24) {\nreturn super.FUN10(VAR16, VAR23);\n}\nfunction FUN11(address VAR16, uint VAR25) public FUN3 returns (bool VAR24) {\nreturn super.FUN11(VAR16, VAR25);\n}\n}",
        "label": false,
        "name": "0x3cf9e0c385a5abec9fd2a71790aa344c4e8e3570.sol"
    },
    {
        "source": "{\"Migrations.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"RNBW5.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\ncontract SafeMath {\\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\\n        c = a + b;\\n        require(c \\u003e= a);\\n    }\\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003c= a);\\n        c = a - b;\\n    }\\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003e 0);\\n        c = a / b;\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC Token Standard #20 Interface\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n// ----------------------------------------------------------------------------\\ncontract ERC20Interface {\\n    function totalSupply() public view returns (uint);\\n    function balanceOf(address tokenOwner) public view returns (uint balance);\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n    function transfer(address to, uint tokens) public returns (bool success);\\n    function approve(address spender, uint tokens) public returns (bool success);\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\\n\\n// ----------------------------------------------------------------------------\\n// Contract function to receive approval and execute function in one call\\n// ----------------------------------------------------------------------------\\ncontract ApproveAndCallFallBack {\\n    function receiveApproval(address from, uint256 tokens, address payable token, bytes memory data) public;\\n}\\n\\n// ----------------------------------------------------------------------------\\n// Owned contract\\n// ----------------------------------------------------------------------------\\ncontract Owned {\\n    address payable public _owner;\\n    address payable private _newOwner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    constructor() public {\\n        _owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == _owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address payable newOwner) public onlyOwner {\\n        _newOwner = newOwner;\\n    }\\n\\n    function acceptOwnership() public {\\n        require(msg.sender == _newOwner);\\n        emit OwnershipTransferred(_owner, _newOwner);\\n        _owner = _newOwner;\\n        _newOwner = address(0);\\n    }\\n}\\n\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\\n// token transfers\\n// ----------------------------------------------------------------------------\\ncontract RNBW5 is ERC20Interface, Owned, SafeMath {\\n\\n    string public symbol;\\n    string public name;\\n    string public description;\\n    uint8 public decimals;\\n    uint private _startDate;\\n    uint private _endDate;\\n    uint private _bonusOneEnds;\\n    uint private _bonusTwoEnds;\\n    uint private _bonusThreeEnds;\\n    uint private _bonusFourEnds;\\n    uint private _bonusFiveEnds;\\n    \\n    uint256 private _softCap;\\n    uint256 private _hardCap;\\n    uint256 private _totalSupply;\\n\\n    mapping(address =\\u003e uint256) _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) _allowed;\\n    mapping(address =\\u003e bool) _freezeState;\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(\\n        address payable minter) public {\\n\\n        _owner = minter;\\n        \\n        name   = \\\"RNBW5 Token\\\";\\n        description = \\\"\\\";\\n        symbol = \\\"RNBW5\\\";\\n        decimals = 18;\\n        _softCap =   22222000 * 1000000000000000000; //18 decimals\\n        _hardCap = 1481481000 * 1000000000000000000; //18 decimals\\n        \\n        _startDate = now;        \\n        _bonusOneEnds   = now + 4 weeks;\\n        _bonusTwoEnds   = now + 8 weeks;\\n        _bonusThreeEnds = now + 12 weeks;\\n        _bonusFourEnds  = now + 16 weeks;\\n        _bonusFiveEnds  = now + 20 weeks;\\n        _endDate = now + 24 weeks;\\n    }\\n\\n    modifier IcoSuccessful {\\n        require(now \\u003e= _endDate);\\n        require(_totalSupply \\u003e= _softCap);\\n        _;\\n    }\\n    modifier IcoRunning {\\n        require(now \\u003c= _endDate);\\n        require(_totalSupply \\u003c= _hardCap);\\n        _;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply - _balances[address(0)];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\n        return _balances[tokenOwner];\\n    }\\n    \\n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\\n        return _freezeState[tokenOwner];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\\n        require(_freezeState[msg.sender] == false);\\n        \\n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\\n        _balances[to] = safeAdd(_balances[to], tokens);\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces\\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\\n        require( _freezeState[spender] == false);\\n        _allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    //\\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\\n        require( _freezeState[from] == false \\u0026\\u0026 _freezeState[to] == false);\\n        \\n        _balances[from] = safeSub(_balances[from], tokens);\\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\\n        _balances[to] = safeAdd(_balances[to], tokens);\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender\\u0027s account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\n        require(_freezeState[spender] == false);\\n        return _allowed[tokenOwner][spender];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account. The `spender` contract function\\n    // `receiveApproval(...)` is then executed\\n    // ------------------------------------------------------------------------\\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\\n        require(_freezeState[spender] == false);\\n        _allowed[msg.sender][spender] = tokens;\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // 1 rnbw Tokens per 1 finney\\n    // ------------------------------------------------------------------------\\n    function purchase() public IcoRunning payable {\\n    \\n        require(now \\u003e= _startDate \\u0026\\u0026 now \\u003c= _endDate);\\n        require(msg.value \\u003e= 500 finney);\\n        \\n        uint256 weiValue = msg.value;\\n        uint256 tokens = safeMul(weiValue, 1000);// 1 finney = 1000000000000000 wei\\n        uint256 ownerTokens = safeMul( safeDiv(tokens, 10), 3);\\n        \\n        if (now \\u003c= _bonusOneEnds) {\\n            tokens = safeMul( safeDiv(tokens, 10) , 15 );\\n        }\\n        if (now \\u003c= _bonusTwoEnds \\u0026\\u0026 now \\u003e _bonusOneEnds) {\\n            tokens = safeMul( safeDiv(tokens, 10) , 14 );\\n        }\\n        if (now \\u003c= _bonusThreeEnds \\u0026\\u0026 now \\u003e _bonusTwoEnds) {\\n            tokens = safeMul( safeDiv(tokens, 10) , 13 );\\n        }\\n        if (now \\u003c= _bonusFourEnds \\u0026\\u0026 now \\u003e _bonusThreeEnds) {\\n            tokens = safeMul( safeDiv(tokens, 10) , 12 );\\n        }\\n        if (now \\u003c= _bonusFiveEnds \\u0026\\u0026 now \\u003e _bonusFourEnds) {\\n            tokens = safeMul( safeDiv(tokens, 10) , 11 );\\n        }       \\n        _freezeState[msg.sender] = false;\\n        \\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);        \\n        _totalSupply = safeAdd(_totalSupply, tokens);        \\n        emit Transfer(address(0), msg.sender, tokens);\\n        \\n        _balances[_owner] = safeAdd(_balances[_owner], ownerTokens);\\n        _totalSupply = safeAdd(ownerTokens, tokens);\\n        emit Transfer(address(0), _owner, ownerTokens);\\n    }\\n    \\n    function () payable external {\\n        purchase();\\n    }\\n\\n    function withdraw() public onlyOwner returns (bool success) {\\n        _owner.transfer(address(this).balance);\\n        return true;\\n    }\\n\\n    function freeze(address account) public onlyOwner returns (bool success) {\\n        require(account != _owner \\u0026\\u0026 account != address(0));\\n        _freezeState[account] = true;\\n        return true;\\n    }\\n    \\n    function unfreeze(address account) public onlyOwner returns (bool success) {\\n        require(account != _owner \\u0026\\u0026 account != address(0));\\n        _freezeState[account] = false;\\n        return true;\\n    }\\n   \\n    // ------------------------------------------------------------------------\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n    // ------------------------------------------------------------------------\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\\n    }\\n}\\n\"}}",
        "label": false,
        "name": "0xcc69d7074c45cf464295f69a85f40ce11ba74069.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN16 to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN17 from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR13;\nstring private VAR14;\nuint8 private VAR15;\nconstructor (string memory VAR16, string memory VAR17, uint8 VAR18) public {\nVAR13 = VAR16;\nVAR14 = VAR17;\nVAR15 = VAR18;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR19;\nconstructor () internal {\nFUN14(msg.VAR8);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.VAR8), \"MinterRole: caller does not have the Minter role\");\n_;\n}\nfunction FUN12(address VAR11) public FUN11 {\nFUN14(VAR11);\n}\nfunction FUN13() public {\nFUN15(msg.VAR8);\n}\nfunction FUN14(address VAR11) internal {\nVAR19.add(VAR11);\n}\nfunction FUN15(address VAR11) internal {\nVAR19.remove(VAR11);\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN16(address VAR11, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR11, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON2 {\nfunction FUN17(uint256 VAR5) public {\nFUN8(msg.VAR8, VAR5);\n}\nfunction FUN18(address VAR11, uint256 VAR5) public {\nFUN10(VAR11, VAR5);\n}\n}\ncontract CON7 is CON2, CON3, CON5, CON6 {\nconstructor(address VAR20)\nCON6()\nCON5()\nCON3(\"Edex\", \"EDX\", 18)\nCON2()\npublic {\nFUN7(VAR20, 10000000 * 10 ** 18);\nFUN14(VAR20);\n}\n}",
        "label": false,
        "name": "0xbf8d8f1242b95dfbae532af6b0f4463905415cc1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON1 {\nstruct APIForSale {\nuint VAR3;\nbytes32 VAR4;\nbytes32 VAR5;\naddress VAR6;\nstring VAR7;\nstring VAR8;\n}\nmapping(string => uint) internal VAR9;\nmapping(uint => APIForSale) public VAR10;\nuint public VAR11;\nuint public VAR12;\nconstructor() public {\nVAR11 = 0;\nVAR12 = 1;\n}\nfunction FUN3(address VAR13, uint VAR14) public FUN1 returns (bool VAR15) {\nreturn CON3(VAR13).transfer(VAR1, VAR14);\n}\nfunction FUN4(uint VAR3, bytes32 VAR4, bytes32 VAR5, string VAR7, string VAR8) public {\nrequire(VAR3 != 0 && VAR4 != \"\" && VAR5 != \"\" && bytes(VAR7).length != 0);\nrequire(VAR9[VAR7] == 0);\nVAR11 += 1;\nVAR9[VAR7] = VAR11;\nAPIForSale storage VAR16 = VAR10[VAR11];\nVAR16.VAR3 = VAR3;\nVAR16.VAR4 = VAR4;\nVAR16.VAR5 = VAR5;\nVAR16.VAR6 = msg.sender;\nVAR16.VAR7 = VAR7;\nVAR16.VAR8 = VAR8;\n}\nfunction FUN5(uint VAR17, uint VAR3, address VAR6, string VAR8) public {\nrequire(VAR17 != 0 && VAR3 != 0 && VAR6 != address(0));\nAPIForSale storage VAR16 = VAR10[VAR17];\nrequire(VAR16.VAR3 != 0 && VAR16.VAR4 != \"\" && VAR16.VAR5 != \"\" && bytes(VAR16.VAR7).length != 0 && VAR16.VAR6 != address(0));\nrequire(msg.sender == VAR16.VAR6 || msg.sender == VAR1);\nVAR16.VAR3 = VAR3;\nVAR16.VAR6 = VAR6;\nVAR16.VAR8 = VAR8;\n}\n}",
        "label": false,
        "name": "0x4d87bb38c53b4afda61bdb38eb13a1114a8fec77.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\naddress public VAR2;\nuint256 public VAR3;\nconstructor () public {\nVAR1 = 0;\nVAR2 = msg.sender;\nVAR3 = now;\n}\nfunction () public payable {\nrequire(msg.sender == tx.origin);\nrequire(msg.value >= 0.001 ether);\nuint256 VAR4 = uint256(keccak256(blockhash(block.number - 1)));\nif (VAR4 > VAR1) {\nVAR2 = msg.sender;\nVAR3 = now;\n}\n}\nfunction FUN2() public {\nrequire(now > VAR3 + 1 days);\nrequire(msg.sender == VAR2);\nmsg.sender.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0x66322181534ff227904daf5ea692a2f2ba62d582.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 {\nusing SafeMath for uint256;\naddress private constant VAR1 = address(0);\nstring internal constant VAR2 = \"LPT_ORDER_SELL_ORDER_COMMITTED_TO\";\nstring internal constant VAR3 = \"LPT_ORDER_SELL_ORDER_NOT_COMMITTED_TO\";\nstring internal constant VAR4 = \"LPT_ORDER_INITIALISED_ORDER\";\nstring internal constant VAR5 = \"LPT_ORDER_UNINITIALISED_ORDER\";\nstring internal constant VAR6 = \"LPT_ORDER_COMMITMENT_WITHIN_UNBONDING_PERIOD\";\nstring internal constant VAR7 = \"LPT_ORDER_NOT_BUYER\";\nstring internal constant VAR8 = \"LPT_ORDER_STILL_WITHIN_LOCK_PERIOD\";\nstruct LptSellOrder {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\naddress VAR13;\n}\nCON2 VAR14;\nCON1 VAR15;\nmapping(address => LptSellOrder) public VAR16;\nconstructor(address VAR17, address VAR18) public {\nVAR14 = CON2(VAR17);\nVAR15 = CON1(VAR18);\n}\nfunction FUN1(uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public {\nLptSellOrder storage VAR23 = VAR16[msg.sender];\nrequire(VAR23.VAR11 == 0, VAR4);\nVAR15.transferFrom(msg.sender, address(this), VAR21);\nVAR16[msg.sender] = LptSellOrder(VAR19, VAR20, VAR21, VAR22, VAR1);\n}\nfunction FUN2() public {\nLptSellOrder storage VAR23 = VAR16[msg.sender];\nrequire(VAR23.VAR13 == VAR1, VAR2);\nVAR15.transfer(msg.sender, VAR23.VAR11);\ndelete VAR16[msg.sender];\n}\nfunction FUN3(address VAR24) public {\nLptSellOrder storage VAR23 = VAR16[VAR24];\nrequire(VAR23.VAR9 > 0, VAR5);\nrequire(VAR23.VAR13 == VAR1, VAR2);\nrequire(VAR23.VAR12.sub(_getUnbondingPeriodLength()) > block.number, VAR6);\nVAR15.transferFrom(msg.sender, address(this), VAR23.VAR10);\nVAR23.VAR13 = msg.sender;\n}\nfunction FUN4(address VAR24) public {\nLptSellOrder storage VAR23 = VAR16[VAR24];\nrequire(VAR23.VAR13 == msg.sender, VAR7);\nrequire(VAR23.VAR12 < block.number, VAR8);\nuint256 VAR25 = VAR23.VAR10.add(VAR23.VAR11);\nVAR15.transfer(msg.sender, VAR25);\n}\nfunction FUN5() public {\nLptSellOrder storage VAR23 = VAR16[msg.sender];\nrequire(VAR23.VAR13 != VAR1, VAR3);\nCON1 VAR26 = CON1(_getLivepeerContractAddress(\"LivepeerToken\"));VAR26.transferFrom(msg.sender, VAR23.VAR13, VAR23.VAR9);\nuint256 VAR25 = VAR23.VAR10.add(VAR23.VAR11);\nVAR15.transfer(msg.sender, VAR25);\ndelete VAR16[msg.sender];\n}\n}",
        "label": false,
        "name": "0xd43ff5612420c8bcc6316dcc15fedfb4b791df32.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nmapping (string => Roles.Role) private VAR4;\nfunction FUN7(address VAR5, string VAR6)\ninternal\n{\nVAR4[VAR6].add(VAR5);\n}\nfunction FUN8(address VAR5, string VAR6)\ninternal\n{\nVAR4[VAR6].remove(VAR5);\n}\nmodifier FUN9(string VAR6)\n{\ncheckRole(msg.sender, VAR6);\n_;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON4 {\n}\ncontract CON6 is CON2, CON3 {\nusing SafeMath for uint256;\nstring constant VAR7 = \"oracle\";\nCON5 VAR8;\nCON5 VAR9; address public VAR10;\nR.Rational public VAR11;\nR.Rational public VAR12;\nfunction CON6(address VAR13,address VAR14,address VAR15,uint256 VAR16,uint256 VAR17,uint256 VAR18,uint256 VAR19) public {\nVAR8 = CON5(VAR13);\nVAR9 = CON5(VAR14);\nFUN7(VAR15, VAR7);\nVAR10 = VAR15;\nVAR11 = R.Rational(VAR16, VAR17);\nVAR12 = R.Rational(VAR18, VAR19);\n}\nfunction FUN10(uint256 VAR20) public FUN3() payable {\nuint256 VAR21 = calculateAmountForETH(msg.value);\nrequire(VAR21 == VAR20);\nrequire(VAR8.transfer(msg.sender, VAR21));\n}\nfunction FUN11(uint256 VAR22, uint256 VAR20) public FUN3() {\nuint256 VAR21 = calculateAmountForDAI(VAR22);\nrequire(VAR21 == VAR20);\nrequire(VAR9.transferFrom(msg.sender, address(this), VAR22));\nrequire(VAR8.transfer(msg.sender, VAR21));\n}\nfunction FUN12(uint256 VAR23, uint256 VAR24) external FUN9(VAR7) {\nVAR11 = R.Rational(VAR23, VAR24);\n}\nfunction FUN13(uint256 VAR23, uint256 VAR24) external FUN9(VAR7) {\nVAR12 = R.Rational(VAR23, VAR24);\n}\nfunction FUN14(address VAR25, uint256 VAR26) external FUN1 {\nCON5 VAR27 = CON5(VAR25);\nrequire(VAR27.transfer(VAR1, VAR26));\n}\nfunction FUN15(address VAR15) external FUN1 {\nFUN8(VAR10, VAR7);\nFUN7(VAR15, VAR7);\nVAR10 = VAR15;\n}\nfunction FUN16() external FUN1 {\nVAR1.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0xa2d75fdceb750cc0fd96b3d6c10780ef1a12c58b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR34, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.VAR34][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.VAR34] = VAR2[VAR7][msg.VAR34].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.VAR34][VAR6] = VAR2[msg.VAR34][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.VAR34][VAR6] = VAR2[msg.VAR34][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.VAR34] = VAR2[VAR10][msg.VAR34].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.VAR34);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.VAR34));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.VAR34);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4, uint256 VAR5) public FUN10 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint256 private VAR12;\nconstructor (uint256 VAR13) public {\nrequire(VAR13 > 0);\nVAR12 = VAR13;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= VAR12);\nsuper.FUN7(VAR10, VAR5);\n}\n}\ncontract CON6 is CON1 {\nstring private VAR14;\nstring private VAR15;\nuint8 private VAR16;\nconstructor (string memory VAR17, string memory VAR18, uint8 VAR19) public {\nVAR14 = VAR17;\nVAR15 = VAR18;\nVAR16 = VAR19;\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR20;\nconstructor () internal {\nFUN19(msg.VAR34);\n}\nmodifier FUN16() {\nrequire(isPauser(msg.VAR34));\n_;\n}\nfunction FUN17(address VAR10) public FUN16 {\nFUN19(VAR10);\n}\nfunction FUN18() public {\nFUN20(msg.VAR34);\n}\nfunction FUN19(address VAR10) internal {\nVAR20.add(VAR10);\n}\nfunction FUN20(address VAR10) internal {\nVAR20.remove(VAR10);\n}\n}\ncontract CON8 is CON7 {\nbool private VAR21;\nconstructor () internal {\nVAR21 = false;\n}\nmodifier FUN21() {\nrequire(!VAR21);\n_;\n}\nmodifier FUN22() {\nrequire(VAR21);\n_;\n}\nfunction FUN23() public FUN16 FUN21 {\nVAR21 = true;\n}\nfunction FUN24() public FUN16 FUN22 {\nVAR21 = false;\n}\n}\ncontract CON9 is CON2, CON8 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN21 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN21 returns (bool VAR22) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN21 returns (bool VAR22) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON10 {\naddress private VAR23;\nconstructor () internal {\nVAR23 = msg.VAR34;\n}\nmodifier FUN25() {\nrequire(isOwner());\n_;\n}\nfunction FUN26() public FUN25 {\nVAR23 = address(0);\n}\nfunction FUN27(address VAR24) public FUN25 {\nFUN28(VAR24);\n}\nfunction FUN28(address VAR24) internal {\nrequire(VAR24 != address(0));\nVAR23 = VAR24;\n}\n}\ncontract CON11 is CON10, CON9, CON6, CON5 {\nusing SafeMath for uint256;\nuint8 constant VAR25 = 18;\nuint256 constant VAR26 = 690900000;\nuint256 VAR27 = VAR26.mul(uint256(10) ** VAR25);\naddress[] private VAR28 = new address[](0);\nmapping(address => bool) private VAR29;\nconstructor(address VAR30)\npublic\nCON6('CON11', 'OCEAN', VAR25)\nCON5(VAR27)\nCON10()\n{\nFUN17(VAR30);\nFUN18();\nFUN11(VAR30);\nFUN12();\nFUN27(VAR30);\n}\nfunction FUN1(address VAR31,uint256 VAR32)\npublic\nreturns (bool)\n{\nbool VAR22 = super.FUN1(VAR31, VAR32);\nif (VAR22) {\nFUN32(msg.VAR34, VAR31);\n}\nreturn VAR22;\n}\nfunction FUN3(address VAR33,address VAR31,uint256 VAR32)\npublic\nreturns (bool)\n{\nbool VAR22 = super.FUN3(VAR33, VAR31, VAR32);\nif (VAR22) {\nFUN32(VAR33, VAR31);\n}\nreturn VAR22;\n}\nfunction FUN29()\nexternal\nFUN25\n{\nselfdestruct(address(uint160(owner())));\n}\nfunction()\nexternal\npayable\n{\nrevert('Invalid ether FUN1');\n}\nfunction FUN31(address VAR10)\nprivate\n{\nif (!VAR29[VAR10] && super.balanceOf(VAR10) > 0)\n{\nVAR28.push(VAR10);\nVAR29[VAR10] = true;\n}\n}\nfunction FUN32(address VAR34,address VAR35)\nprivate\n{\nFUN31(VAR34);\nFUN31(VAR35);\n}\n}",
        "label": false,
        "name": "0x985dd3d42de1e256d09e1c10f112bccb8015ad41.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) CON2(VAR7, VAR8, VAR9) public {}\n}",
        "label": false,
        "name": "0x2436cbd43c245cbad04f2cc71b9b3bbeb65c24d7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\naddress private VAR1;\nstring public VAR2 = \"Quick pass coin\";\nstring public VAR3 = \"QPC\";\nuint8 public constant VAR4 = 18;\nuint256 public constant VAR5 = 10 ** uint256(VAR4);\nuint256 public constant VAR6 = 1000000000 * VAR5;\nmapping (address => uint256) VAR7;\nmapping (address => mapping (address => uint256)) internal VAR8;\nconstructor() public {\nVAR7[msg.sender] = VAR6;\nVAR1 = msg.sender;\n}\nfunction FUN1(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR7[msg.sender]);\nrequire(block.timestamp >= 1545102693);\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN2(address VAR11, address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR7[VAR11]);\nrequire(VAR10 <= VAR8[VAR11][msg.sender]);\nrequire(block.timestamp >= 1545102693);\nVAR7[VAR11] = VAR7[VAR11].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nVAR8[VAR11][msg.sender] = VAR8[VAR11][msg.sender].sub(VAR10);\nreturn true;\n}\nfunction FUN3(address VAR12, uint256 VAR10) public returns (bool) {\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN4(address VAR12, uint VAR13) public returns (bool) {\nVAR8[msg.sender][VAR12] = VAR8[msg.sender][VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR12, uint VAR14) public returns (bool) {\nuint VAR15 = VAR8[msg.sender][VAR12];\nif (VAR14 > VAR15) {\nVAR8[msg.sender][VAR12] = 0;\n} else {\nVAR8[msg.sender][VAR12] = VAR15.sub(VAR14);\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0x245ea83dc835ac37cf7d75cd8bbf4407437e3492.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\nfunction CON1(uint256 VAR2) public {\nVAR1[msg.sender] = VAR2; }\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool VAR5) {\nrequire(VAR1[msg.sender] >= VAR4); require(VAR1[VAR3] + VAR4 >= VAR1[VAR3]); VAR1[msg.sender] -= VAR4; VAR1[VAR3] += VAR4; return true;\n}\n}",
        "label": false,
        "name": "0x20f3648677f3aa39875787a349ef76ed1d9140ef.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 > 0);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR4 != address(0));\nuint256 VAR7 = VAR3[VAR6][msg.sender];\nVAR2[VAR6] = VAR2[VAR6].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nVAR3[VAR6][msg.sender] = VAR7.sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR8) public constant returns (uint256 VAR9) {\nreturn VAR2[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR10] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR3[VAR8][VAR10];\n}\n}\ncontract CON3 is CON2 {\nstring public VAR12 = \"M Coin\";\nstring public VAR13 = \"M\";\nuint public VAR14 = 18;\nuint public constant VAR15 = 1000000000e18;\naddress public constant VAR16 = 0x2b029366a7751aE24c93482c78F8BC85F9AE1bEC;\nfunction CON3() public {\nVAR2[msg.sender] = VAR15;\nVAR1 = VAR15;\n}\nfunction FUN6() public {\nif(FUN3(this) > 0)\nthis.FUN1(VAR16, FUN3(this));\n}\n}",
        "label": false,
        "name": "0xf50f37c0adc8f15874a2bffa533dba8dcaf0a49b.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR10) public FUN11 {\nFUN14(VAR10);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN15(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN16(address VAR4, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint256 private VAR13;\nconstructor (uint256 VAR14) public {\nrequire(VAR14 > 0);\nVAR13 = VAR14;\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(totalSupply().add(VAR5) <= VAR13);\nsuper.FUN7(VAR10, VAR5);\n}\n}\ncontract CON6 is CON5(10000000000 ether) {\nstring public VAR15 = \"Hackers Live Coin\";\nstring public VAR16 = \"HCL\";\nuint8 public VAR17 = 18;\naddress public VAR18;\naddress public VAR19;\nconstructor () public {\nVAR19 = msg.sender;\nVAR18 = msg.sender;\n}\nfunction FUN17(address VAR20) external {\nrequire(msg.sender == VAR19);\nVAR19 = VAR20;\n}\nfunction FUN18(address VAR21) external {\nrequire(msg.sender == VAR19);\nVAR18 = VAR21;\n}\nfunction () payable external {\n}\nfunction FUN20() external {\nrequire(msg.sender == VAR18 || msg.sender == VAR19);\nmsg.sender.FUN1(address(this).balance);\n}\nfunction FUN21(address VAR10) external {\nrequire(msg.sender == VAR18 || msg.sender == VAR19);\nFUN15(VAR10);\n}\n}",
        "label": false,
        "name": "0x6e2fe65d96ed63aaca9e475f6f251d4232c3842c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 10;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = 200000000; VAR5[msg.sender] = VAR4; VAR1 = \"VManCoin\"; VAR2 = \"VMC\"; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6fa800102b18d53c2a9ba085355ad8cc725d234d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\naddress private VAR11;\nconstructor () internal {\nVAR11 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR11 = address(0);\n}\nfunction FUN12(address VAR12) public FUN10 {\nFUN13(VAR12);\n}\nfunction FUN13(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring public constant VAR13 = \"Bitenny\";\nstring public constant VAR14 = \"BTNY\";\nuint32 public constant VAR15 = 18;\naddress public VAR16;\nbool public VAR17;\nuint256 internal VAR18;\nuint256 internal VAR19 = uint256(9e7).mul(1 ether);\nuint256 internal VAR20 = uint256(1e7).mul(1 ether);\nuint256 internal VAR21 = uint256(7e8).mul(1 ether);\nuint256 internal VAR22 = uint256(2e8).mul(1 ether);\nmapping(address => uint256) public VAR23;\nmapping(address => uint256) public VAR24;\nmapping(address => uint256) public VAR25;\nmapping(address => uint256) public VAR26;\nconstructor(address VAR27) public {\nFUN13(VAR27);\nVAR18 = now;\nuint256 VAR28 = VAR19.add(VAR20);\nVAR19 = 0;\nVAR20 = 0;\nFUN7(VAR27, VAR28);\n}\nfunction FUN14() public {\naddress VAR29 = msg.sender;\nuint256 VAR30 = _teamToRelease(VAR29);\nuint256 VAR31 = _advisorsToRelease(VAR29);\nuint256 VAR28 = VAR30.add(VAR31);\nrequire(VAR28 > 0);\nif (VAR30 > 0)\nVAR24[VAR29] = VAR24[VAR29].add(VAR30);\nif (VAR31 > 0)\nVAR26[VAR29] = VAR26[VAR29].add(VAR31);\nFUN7(VAR29, VAR28);\n}\nfunction FUN15 (address VAR29, uint256 VAR32) public FUN10 {\nrequire(VAR29 != address(0));\nVAR22 = VAR22.sub(VAR32);\nVAR23[VAR29] = VAR23[VAR29].add(VAR32);\n}\nfunction FUN16 (address VAR29, uint256 VAR32) public FUN10 {\nrequire(VAR29 != address(0));\nVAR22 = VAR22.sub(VAR32);\nVAR25[VAR29] = VAR25[VAR29].add(VAR32);\n}\nfunction FUN17(address VAR33) public FUN10 {\nrequire(VAR33 != address(0));\nrequire(!VAR17);\nVAR16 = VAR33;\nVAR17 = true;\nFUN7(VAR16, VAR21);\nVAR21 = 0;\n}\nfunction FUN18(uint256 VAR32) public returns (bool) {\nrequire(VAR16 != address(0));\nrequire(msg.sender == VAR16);\nFUN8(VAR16, VAR32);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x763a67be94e2494dbffdcc62cee4ed8f761f6770.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nuint256 public VAR3;\nbool public VAR4;\naddress public VAR5;\naddress public VAR6;\nCON3 internal VAR7;\nbytes32 public constant VAR8 = \"yes\";\nuint256 internal constant VAR9 = 30 days;\nconstructor(address VAR10, address VAR11, address VAR12) public payable CON1() {\nVAR7 = CON3(VAR10);\nVAR5 = VAR11;\nVAR6 = VAR12;\nVAR4 = false;\nVAR3 = now + VAR9;\n}\nfunction() external payable FUN8 {\nrequire(VAR4 == false);\nrequire(now < VAR3);\n}\nfunction FUN6() public FUN7() {\nrequire(address(this).balance > 0);\nif (VAR7.current() == VAR8) {\nVAR4 = true;\nVAR6.transfer(address(this).balance);\n} else if (now >= VAR3) {\nVAR4 = true;\nVAR5.transfer(address(this).balance);\n}\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR1 || msg.sender == VAR5 || msg.sender == VAR6, \"Only authorized users may call this function.\");\n_;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR5, \"Only the VAR5 may call this function.\");\n_;\n}\n}\ninterface CON3{\n}",
        "label": false,
        "name": "0x49aa6a3075f14a05d0440c09f91ef229762b8cbc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1(){\nVAR1 = msg.sender;\n}\nmodifier FUN1(){\nif(msg.sender != VAR1) throw;\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nmapping (address => uint256) public VAR3;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint256 public VAR7;\nfunction CON2(uint256 VAR8, string VAR9, string VAR10, uint8 VAR11){\nVAR3[msg.sender] = VAR8;\nVAR7 = VAR8;\nVAR6 = VAR11;\nVAR5 = VAR10;\nVAR4 = VAR9;\n}\nfunction FUN3(address VAR12, uint256 VAR13){\nif(VAR3[msg.sender] < VAR13) throw;\nif(VAR3[VAR12] + VAR13 < VAR3[VAR12]) throw;\nVAR3[msg.sender] -= VAR13;\nVAR3[VAR12] += VAR13;\n}\n}\ncontract CON3 is CON1, CON2{\nfunction CON3(uint256 VAR8, string VAR9, string VAR10, uint8 VAR11, address VAR14) CON2 (0, VAR9, VAR10, VAR11 ){\nVAR7 = VAR8;\nif(VAR14 != 0)\nVAR1 = VAR14;\nelse\nVAR1 = msg.sender;\nVAR3[VAR1] = VAR8;\nVAR7 = VAR8;\n}\nfunction FUN4(address VAR15, uint256 VAR16) FUN1{\nVAR3[VAR15] += VAR16;\nVAR7 += VAR16;\n}\nfunction FUN3(address VAR12, uint256 VAR13){\nif(VAR3[msg.sender] <= 0) throw;\nif(VAR3[msg.sender] < VAR13) throw;\nif(VAR3[VAR12] + VAR13 < VAR3[VAR12]) throw;\nVAR3[msg.sender] -= VAR13;\nVAR3[VAR12] += VAR13;\n}\n}",
        "label": false,
        "name": "0xe4b260f9205293c15010b75df30804df9009ea2d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor (uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5);\nVAR7[msg.sender] = VAR6;\nVAR3 = VAR10;\nVAR4 = VAR11;\n}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\n}\ncontract CON3 is CON1, CON2 {\nmapping (address => bool) public VAR18;\nconstructor (uint256 VAR9,string memory VAR10,string memory VAR11) CON2(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 >= VAR7[VAR13]);\nrequire(!VAR18[VAR12]);\nrequire(!VAR18[VAR13]);\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\n}\nfunction FUN7(address VAR19, uint256 VAR20) FUN1 public {\nVAR7[VAR19] += VAR20;\nVAR6 += VAR20;\n}\nfunction FUN8(address VAR19, bool VAR21) FUN1 public {\nVAR18[VAR19] = VAR21;\n}\n}",
        "label": false,
        "name": "0x51599d4c62b625aa88e8cb33431c67a6879e7513.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR11 = \"XUAN Token\"; string public constant VAR12 = \"XUAN\"; uint8 public constant VAR13 = 18;\nuint256 public constant VAR14 = (10 ** 9) * (10 ** uint256(VAR13));\nconstructor() public {\nVAR2 = VAR14;\nVAR1[msg.sender] = VAR14;\n}\n}",
        "label": false,
        "name": "0x72a8e0272fdf57f26588dfca90082f01d51cb29a.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nconstructor() public {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) public FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5\n{\nstring public VAR17 = \"Could you send VIR token back?\";\nstring public VAR18 = \"Please\";\nuint public VAR19 = 18;\nuint private constant VAR20 = 2011100110110111101110011;\nconstructor() public\n{\nVAR15 = msg.sender;\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\nfunction FUN10() public\n{\nselfdestruct(address(0));\n}\n}",
        "label": false,
        "name": "0xf3b8ed45284a7eee12bbfc373dd40f56fee61253.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping(address => mapping(address => uint256)) VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nuint256 VAR7 = VAR5[VAR6][msg.sender];\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR7.sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR8] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, uint VAR9) public returns (bool VAR10) {\nVAR5[msg.sender][VAR8] = VAR5[msg.sender][VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN5(address VAR8, uint VAR11) public returns (bool VAR10) {\nuint VAR12 = VAR5[msg.sender][VAR8];\nif (VAR11 > VAR12) {\nVAR5[msg.sender][VAR8] = 0;\n} else {\nVAR5[msg.sender][VAR8] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress internal VAR13;\nconstructor() public {\nVAR13 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR13);\n_;\n}\nfunction FUN7(address VAR14) FUN6 public returns (bool) {\nrequire(VAR14 != address(0x0));\nVAR13 = VAR14;\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nfunction FUN8(address VAR3, uint256 VAR15) FUN6 public returns (bool) {\nVAR1 = SafeMath.add(VAR1, VAR15);\nVAR2[VAR3] = VAR2[VAR3].add(VAR15);\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nuint256 public VAR16;\nconstructor(uint256 VAR17) public {\nrequire(VAR17 > 0);\nVAR16 = VAR17;\n}\nfunction FUN8(address VAR3, uint256 VAR15) FUN6 public returns (bool) {\nrequire(VAR1.add(VAR15) <= VAR16);\nreturn super.FUN8(VAR3, VAR15);\n}\n}\ncontract CON8 is CON7 {\nstring public constant VAR18 = \"BitNautic Token\";\nstring public constant VAR19 = \"BTNT\";\nuint8 public constant VAR20 = 18;\nconstructor()\nCON7(50_000_000 ether) public\n{\n}\n}",
        "label": false,
        "name": "0xc45dbdf28844fdb1482c502897d433ac08d6ccd0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = \"CanYaCoin\";\nstring public constant VAR2 = \"CAN\";\nuint256 public constant VAR3 = 6;\nuint256 public constant VAR4 = 100000000 * (10 ** VAR3);\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nfunction CON2() {\nVAR5[msg.sender] = VAR4;\n}\nfunction FUN1() constant returns (uint256) {\nreturn VAR4;\n}\nfunction FUN2(address VAR7, uint256 VAR8) public returns (bool) {\nif (VAR5[msg.sender] >= VAR8) {\nVAR5[msg.sender] -= VAR8;\nVAR5[VAR7] += VAR8;\nreturn true;\n}\nreturn false;\n}\nfunction FUN3(address VAR9, address VAR7, uint256 VAR8) public returns (bool) {\nif (VAR5[VAR9] >= VAR8 && VAR6[VAR9][msg.sender] >= VAR8) {\nVAR5[VAR9] -= VAR8;\nVAR6[VAR9][msg.sender] -= VAR8;\nVAR5[VAR7] += VAR8;\nreturn true;\n}\nreturn false;\n}\nfunction FUN4(address VAR10) constant public returns (uint256) {\nreturn VAR5[VAR10];\n}\nfunction FUN5(address VAR11, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR11] = VAR8;\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR11) constant public returns (uint256 VAR12) {\nreturn VAR6[VAR10][VAR11];\n}\n}",
        "label": false,
        "name": "0x1d462414fe14cf489c7a21cac78509f4bf8cd7c0.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\nstring public VAR1 = \"Blackstone\";\nstring public VAR2 = \"BLST\";\nuint256 public VAR3 = 0;\nuint256 public VAR4 = 40000000;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR1;\nVAR2;\nVAR3;\nVAR5[msg.sender] = VAR4;\n}\nfunction FUN1(address VAR7, address VAR8, uint256 VAR9) internal {\nrequire(VAR7 != address(0));\nrequire(VAR8 != address(0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8].add(VAR9) >= VAR5[VAR8]);\nuint256 VAR10 = VAR5[VAR7].add(VAR5[VAR8]);\nVAR5[VAR7] = VAR5[VAR7].sub(VAR9);\nVAR5[VAR8] = VAR5[VAR8].add(VAR9);\nassert(VAR5[VAR7].add(VAR5[VAR8]) == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR9);\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR12 != address(0));\nrequire(VAR5[msg.sender] >= VAR9);\nrequire(VAR6[msg.sender][VAR12].add(VAR9) >= VAR6[msg.sender][VAR12]);\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR12 != address(0));\nrequire(VAR5[msg.sender] >= VAR9);\nrequire(VAR5[msg.sender] >= VAR6[msg.sender][VAR12].add(VAR9));\nrequire(VAR6[msg.sender][VAR12].add(VAR9) >= VAR6[msg.sender][VAR12]);\nVAR6[msg.sender][VAR12] = VAR6[msg.sender][VAR12].add(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR12 != address(0));\nVAR6[msg.sender][VAR12] = VAR6[msg.sender][VAR12].sub(VAR9);\nreturn true;\n}\nfunction FUN7(address VAR12, uint256 VAR9, bytes memory VAR13) public returns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif(FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR9);\nVAR4 = VAR4.sub(VAR9);\nreturn true;\n}\nfunction FUN9(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR7 != address(0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR9 <= VAR6[VAR7][msg.sender]);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR9);\nVAR5[VAR7] = VAR5[VAR7].sub(VAR9);\nVAR4 = VAR4.sub(VAR9);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x65430ce5c77dd3ef0551f12be20b92567854af6b.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstruct participant {\naddress VAR1; uint256 VAR2; uint256 VAR3; uint256 VAR4;\nbool VAR5; uint8 VAR6;\n}\nmapping(address => bool) public VAR7;\nmapping(address => bool) public VAR8;\nmapping(address => bool) public VAR9;\nmapping(address => bool) public VAR10;\nmapping(address => participant) public VAR11;\naddress[] public VAR12;\nbool public VAR13 = false; bool public VAR14 = false; bool public VAR15 = false;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nuint256 public VAR19;\nuint256 public VAR20;\nuint256 public VAR21;\nuint256 public VAR22; uint256 public VAR23; uint256 public VAR24 = 18000000;\nuint256 public VAR25;\nuint256 public VAR26;\nuint256 public VAR27;\nuint256 public VAR28;\nconstructor() public {\nVAR8[msg.sender] = true;\n}\nfunction FUN1(address VAR29) public FUN8 {\nVAR8[VAR29] = true;\n}\nfunction FUN2(address VAR29) public FUN8 {\nVAR8[VAR29] = false;\n}\nfunction FUN3(address VAR30) public FUN8 {\nVAR9[VAR30] = true;\n}\nfunction FUN4(address VAR30) public FUN8 {\nVAR9[VAR30] = false;\n}\nfunction FUN5(address VAR30) public FUN8 {\nVAR10[VAR30] = true;\n}\nfunction FUN6(address VAR30) public FUN8 {\nVAR10[VAR30] = false;\n}\nmodifier FUN7(address VAR31) {\nVAR12.push(VAR31); _;\n}\nmodifier FUN8() {\nrequire(VAR8[msg.sender]);\n_;\n}\nmodifier FUN9() {\nrequire(VAR10[msg.sender]);\n_;\n}\nmodifier FUN10() {\nrequire(VAR9[msg.sender] || VAR8[msg.sender]);\n_;\n}\nfunction FUN11(address VAR32, bool VAR33) public FUN10 {\nVAR7[VAR32] = VAR33;\n}\nfunction FUN12(uint256 VAR33) public FUN10 {\nVAR20 = VAR33;\n}\nfunction FUN13(uint256 VAR33) public FUN10 {\nVAR21 = VAR33;\n}\nfunction FUN14(uint256 VAR33) public FUN10 {\nVAR17 = VAR33;\n}\nfunction FUN15(uint256 VAR33) public FUN10 {\nVAR16 = VAR33;\n}\nfunction FUN16(uint256 VAR33) public FUN10 {\nVAR19 = VAR33;\n}\nfunction FUN17(uint256 VAR33) public FUN10 {\nVAR18 = VAR33;\n}\nfunction FUN18(uint256 VAR33) public FUN10 {\nVAR23 = VAR33;\n}\nfunction FUN19(uint256 VAR33) public FUN10 {\nVAR22 = VAR33;\n}\nfunction FUN20(uint256 VAR33) public FUN10 {\nVAR24 = VAR33;\n}\nfunction FUN21(uint256 VAR33) public FUN10 {\nVAR25 = VAR33;\n}\nfunction FUN22(uint256 VAR33) public FUN10 {\nVAR26 = VAR33;\n}\nfunction FUN23(uint256 VAR33) public FUN10 {\nVAR27 = VAR33;\n}\nfunction FUN24(uint256 VAR33) public FUN10 {\nVAR28 = VAR33;\n}\nfunction FUN25(address VAR32,uint256 VAR34,uint256 VAR35,uint256 VAR36,bool VAR37,uint8 VAR38) public FUN10 FUN7(VAR32) {\nparticipant storage VAR39 = VAR11[VAR32];\nVAR39.VAR1 = VAR32;\nVAR39.VAR2 = VAR34;\nVAR39.VAR3 = VAR35;\nVAR39.VAR4 = VAR36;\nVAR39.VAR5 = VAR37;\nVAR39.VAR6 = VAR38;\n}\nfunction FUN26(address VAR32,uint8 VAR33) public FUN10 FUN7(VAR32) {\nVAR11[VAR32].VAR6 = VAR33;\n}\nfunction FUN27(address VAR32,uint256 VAR34) public FUN10 FUN7(VAR32) {\nVAR11[VAR32].VAR2 = VAR34;\n}\nfunction FUN28(address VAR32,uint256 VAR33) public FUN10 FUN7(VAR32) {\nVAR11[VAR32].VAR3 = VAR33;\n}\nfunction FUN29(address VAR32,uint256 VAR33) public FUN10 FUN7(VAR32) {\nVAR11[VAR32].VAR4 = VAR33;\n}\nfunction FUN30(address VAR32,bool VAR33) public FUN9 FUN7(VAR32) {\nVAR11[VAR32].VAR5 = VAR33;\n}\nfunction FUN31(bool VAR33) public FUN10 {\nVAR14 = VAR33;\n}\nfunction FUN32(bool VAR33) public FUN10 {\nVAR13 = VAR33;\n}\nfunction FUN33(bool VAR33) public FUN10 {\nVAR15 = VAR33;\n}\n}\ncontract CON2 {\nusing topl_database_lib for address;\nusing SafeMath for uint256;\naddress public VAR40;\naddress public VAR41;\nconstructor(address VAR42) public {\nVAR40 = VAR42;\nVAR41 = msg.sender;\n}\nfunction FUN34() public { VAR40.FUN11(VAR41, true);\n}\nmodifier FUN8() {\nrequire(VAR40.get_sale_owner(msg.sender));\n_;\n}\nfunction FUN35(address VAR32, uint256 VAR33) public FUN8 {\nVAR40.set_iconiq_tokens(VAR32, VAR33);\n}\n}",
        "label": false,
        "name": "0x230c018122e0e101e57889c4a067787678bcf853.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) CON2(VAR7, VAR8, VAR9) public {}\n}",
        "label": false,
        "name": "0xb639685aa7a7bd67fc79e662b0e4c7939e392245.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"NRX\";\nVAR5 = \"Neroex\";\nVAR6 = 8;\nVAR7 = 38000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x9652847049867929260c9e16b31dfbb3b011817f.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x5d0fdc4f46af16d28324788a2ff4e86b1667d578.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nstring public VAR6; uint8 public VAR7; string public VAR8;\nfunction CON4() public {\nVAR7 = 4;\nVAR2 = 10000000000 * 10 ** uint(VAR7);\nVAR1[msg.sender] = VAR2;\nVAR6 = \"PG Game Platform\";\nVAR8 = \"PGG\";\n}\nfunction FUN2(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR5[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR9][msg.sender] = VAR5[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR10, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR4;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1979ff5afcf742224f09491901854dd09774a8f9.sol"
    },
    {
        "source": "{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    \\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    \\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\n\\ninterface IERC20 {\\n    \\n    function totalSupply() external view returns (uint256);\\n\\n    \\n    function balanceOf(address account) external view returns (uint256);\\n\\n    \\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    \\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    \\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    \\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n\\n\\n\"},\"SmartInvoice.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract SmartInvoice {\\n    enum Status { UNCOMMITTED, COMMITTED, SETTLED }\\n    function getStatusString(Status status)\\n    public\\n    pure\\n    returns (string memory)\\n    {\\n        if (Status.UNCOMMITTED == status) {\\n            return \\\"UNCOMMITTED\\\";\\n        }\\n        if (Status.COMMITTED == status) {\\n            return \\\"COMMITTED\\\";\\n        }\\n        if (Status.SETTLED == status) {\\n            return \\\"SETTLED\\\";\\n        }\\n        return \\\"ERROR\\\";\\n    }\\n\\n    uint256 public amount;\\n    uint256 public dueDate;\\n    IERC20 public assetToken;\\n    address public beneficiary;\\n    address public payer;\\n    string public referenceHash;\\n\\n    Status  public status;\\n\\n    \\n    constructor(uint256 _amount,\\n                uint256 _dueDate,\\n                IERC20 _assetToken,\\n                address _beneficiary,\\n                address _payer,\\n                string memory _referenceHash) public {\\n        require(_beneficiary != address(0), \\\"beneficiary cannot be 0x0\\\");\\n        require(_payer != address(0), \\\"payer cannot be 0x0\\\");\\n        amount = _amount;\\n        dueDate = _dueDate;\\n        assetToken = _assetToken;\\n        beneficiary = _beneficiary;\\n        payer = _payer;\\n        referenceHash = _referenceHash;\\n\\n        status = Status.UNCOMMITTED;\\n    }\\n\\n    function changeBeneficiary(address _newBeneficiary) public returns (bool) {\\n        require(msg.sender == beneficiary, \\\"caller not current beneficiary\\\");\\n        require(_newBeneficiary != address(0), \\\"new beneficiary cannot be 0x0\\\");\\n        require(status != Status.SETTLED, \\\"can not change beneficiary after settlement\\\");\\n        beneficiary = _newBeneficiary;\\n        return true;\\n    }\\n\\n    function commit() public returns (bool) {\\n        require(msg.sender == payer, \\\"only payer can commit to settle\\\");\\n        require(status == Status.UNCOMMITTED, \\\"can only commit while status in UNCOMMITTED\\\");\\n        status = Status.COMMITTED;\\n        return true;\\n    }\\n\\n    function settle() public returns (bool) {\\n        require(msg.sender == payer, \\\"only payer can settle\\\");\\n        require(status != Status.SETTLED, \\\"already settled\\\");\\n        require(now \\u003e= dueDate, \\\"can only settle after due date\\\");\\n        require(assetToken.transferFrom(payer, beneficiary, amount), \\\"could not complete transfer\\\");\\n        status = Status.SETTLED;\\n        return true;\\n    }\\n\\n}\\n\\n\"},\"SmartInvoiceToken.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SmartInvoice.sol\\\";\\n\\n\\ncontract SmartInvoiceToken is ERC20 {\\n\\n    SmartInvoice public smartInvoice;\\n\\n    constructor(uint256 _amount,\\n                uint256 _dueDate,\\n                IERC20 _assetToken,\\n                address _beneficiary,\\n                address _payer,\\n                string memory _referenceHash) public {\\n        smartInvoice = new SmartInvoice(_amount, _dueDate, _assetToken, address(this), _payer, _referenceHash);\\n        _mint(_beneficiary, smartInvoice.amount());\\n    }\\n\\n    function canRedeem() public view returns (bool) {\\n        return smartInvoice.status() == SmartInvoice.Status.SETTLED;\\n    }\\n\\n    function redeem(uint256 amount) public returns (bool) {\\n        require(canRedeem(), \\\"Can only redeem after settlement\\\");\\n        require(smartInvoice.assetToken().transfer(msg.sender, amount), \\\"smartInvoice uses different asset token\\\");\\n        //note the internal _burn function will fail if not enough tokens to burn\\n        _burn(msg.sender, amount);\\n        return true;\\n    }\\n\\n}\\n\"},\"SmartInvoiceWallet.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SmartInvoice.sol\\\";\\nimport \\\"./SmartInvoiceToken.sol\\\";\\n\\ncontract SmartInvoiceWallet {\\n  using SafeMath for uint256;\\n\\n  address public owner;\\n  IERC20 public assetToken;\\n\\n  //internal book keeping. Needed so that we only pay invoices we know we explicitly committed to pay\\n  mapping(address =\\u003e SmartInvoice.Status) private _smartInvoiceStatus;\\n\\n  modifier isOwner() {\\n    require(msg.sender == owner, \\\"not owner\\\");\\n    _;\\n  }\\n\\n  constructor(address _owner, IERC20 _assetToken) public {\\n    require(_owner != address(0), \\\"owner can not be 0x0\\\");\\n    require(address(_assetToken) != address(0), \\\"asset token can not be 0x0\\\");\\n    owner = _owner;\\n    assetToken = _assetToken;\\n  }\\n\\n  function () external payable {\\n    require(false, \\\"Eth transfers not allowed\\\");\\n  }\\n\\n  function balance() public view returns (uint256) {\\n    return this.assetToken().balanceOf(address(this));\\n  }\\n\\n  function transfer(address to, uint256 value) external isOwner returns (bool) {\\n    return this.assetToken().transfer(to, value);\\n  }\\n\\n  function invoiceTokenTransfer(SmartInvoiceToken smartInvoiceToken, address to, uint256 value) external isOwner  returns (bool) {\\n    return smartInvoiceToken.transfer(to, value);\\n  }\\n\\n  function invoiceTokenBalance(SmartInvoiceToken smartInvoiceToken) public view returns (uint256) {\\n    require(smartInvoiceToken.smartInvoice().assetToken() == this.assetToken(), \\\"smartInvoice uses different asset token\\\");\\n\\n    return smartInvoiceToken.balanceOf(address(this));\\n  }\\n\\n  function invoiceTokenBalanceSum(SmartInvoiceToken[] memory smartInvoiceTokens) public view returns (uint256) {\\n    uint256 total = 0;\\n    for (uint32 index = 0; index \\u003c smartInvoiceTokens.length; index++) {\\n      require(smartInvoiceTokens[index].smartInvoice().assetToken() == this.assetToken(), \\\"smartInvoice uses different asset token\\\");\\n      total = total.add(smartInvoiceTokens[index].balanceOf(address(this)));\\n    }\\n    return total;\\n  }\\n\\n  //Note: owner (or their advocate) is expected to have audited what they commit to,\\n  // including confidence that the terms are guaranteed not to change. i.e. the smartInvoice is trusted\\n  function commit(SmartInvoice smartInvoice) external isOwner  returns (bool) {\\n    require(smartInvoice.payer() == address(this), \\\"not smart invoice payer\\\");\\n    require(smartInvoice.status() == SmartInvoice.Status.UNCOMMITTED, \\\"smart invoice already committed\\\");\\n    require(smartInvoice.assetToken() == this.assetToken(), \\\"smartInvoice uses different asset token\\\");\\n    require(smartInvoice.commit(), \\\"could not commit\\\");\\n    require(smartInvoice.status() == SmartInvoice.Status.COMMITTED, \\\"commit did not update status\\\");\\n    _smartInvoiceStatus[address(smartInvoice)] = SmartInvoice.Status.COMMITTED;\\n    return true;\\n  }\\n\\n  function hasValidCommit(SmartInvoice smartInvoice) public view returns (bool) {\\n    return smartInvoice.payer() == address(this)\\n        \\u0026\\u0026 smartInvoice.status() == SmartInvoice.Status.COMMITTED\\n        \\u0026\\u0026 _smartInvoiceStatus[address(smartInvoice)] == SmartInvoice.Status.COMMITTED;\\n  }\\n\\n  function canSettleSmartInvoice(SmartInvoice smartInvoice) public view returns (bool) {\\n    return hasValidCommit(smartInvoice)\\n        \\u0026\\u0026 now \\u003e= smartInvoice.dueDate();\\n  }\\n\\n  function settle(SmartInvoice smartInvoice) external returns (bool) {\\n    require(canSettleSmartInvoice(smartInvoice), \\\"settle not valid\\\");\\n    require(assetToken.approve(address(smartInvoice), smartInvoice.amount()), \\\"approve failed\\\");\\n    require(smartInvoice.settle(), \\\"settle smart invoice failed\\\");\\n    require(smartInvoice.status() == SmartInvoice.Status.SETTLED, \\\"settle did not update status\\\");\\n    _smartInvoiceStatus[address(smartInvoice)] = SmartInvoice.Status.SETTLED;\\n    return true;\\n  }\\n\\n  function redeem(SmartInvoiceToken smartInvoiceToken) external isOwner returns (bool) {\\n    require(smartInvoiceToken.canRedeem(), \\\"redeem not valid\\\");\\n    require(smartInvoiceToken.smartInvoice().assetToken() == this.assetToken(), \\\"smartInvoice uses different asset token\\\");\\n    uint256 amount = this.invoiceTokenBalance(smartInvoiceToken);\\n    require(smartInvoiceToken.redeem(amount), \\\"redeem smart invoice failed\\\");\\n    return true;\\n  }\\n}\\n\\n\"}}",
        "label": false,
        "name": "0x9f7c7ec1d32262911c19b257841eda5d0ffaaf5a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nfunction FUN8(uint256 VAR6) public {\nrequire(VAR6 > 0);\nrequire(VAR6 <= VAR4[msg.sender]);\naddress VAR13 = msg.sender;\nVAR4[VAR13] = VAR4[VAR13].sub(VAR6);\nVAR3 = VAR3.sub(VAR6);\n}\n}\ncontract CON7 is CON5, CON1 {\nbool public VAR14 = false;\nmodifier FUN9() {\nrequire(!VAR14);\n_;\n}\nfunction FUN10(address VAR5, uint256 VAR15) FUN1 FUN9 public returns (bool) {\nVAR3 = VAR3.add(VAR15);\nVAR4[VAR5] = VAR4[VAR5].add(VAR15);\nreturn true;\n}\nfunction FUN11() FUN1 FUN9 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON8 is CON1 {\nbool public VAR16 = false;\nmodifier FUN12() {\nrequire(!VAR16);\n_;\n}\nmodifier FUN13() {\nrequire(VAR16);\n_;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR16 = true;\n}\nfunction FUN15() FUN1 FUN13 public {\nVAR16 = false;\n}\n}\ncontract CON9 is CON5, CON8 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN12 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN12 returns (bool VAR17) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN12 returns (bool VAR17) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON10 is CON9, CON7, CON6 {\nstring public constant VAR18 = \"PilarCoin\";\nstring public constant VAR19 = \"PILAR\";\nuint8 public constant VAR20 = 2;\n}",
        "label": false,
        "name": "0x77476b54ea80ef1249a76bf2bb2155f3cfe695cc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"SP Coin\";\nstring public constant VAR2 = \"SPS\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 2500000000 *10 ** 18; address public VAR5;\nuint256 constant public VAR6 = 20000 ;\nuint256 VAR7;\nuint256 VAR8;\nuint256 VAR9;\nbool VAR10 = false;\nuint256 public VAR11;\nuint256 public VAR12;\nuint256 VAR13;\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\nbool public VAR17 = true;\nmapping(address => uint) VAR18;\nmapping(address => mapping(address => uint)) VAR19;\naddress VAR20 = 0x649BbCF5625E78f8A1dE1AE07d9D5E3E0fDCa932; mapping (address => bool) public VAR21;\nuint256 public VAR22;\nuint256 public VAR23;\nuint256 public VAR24;\nuint constant public VAR25 = 1 ether; uint VAR26;\nuint public VAR27;\nuint VAR28 ;\nenum Stages {\nNOTSTARTED,\nPREICO,\nICO,\nENDED\n}\nStages public VAR29;\nmodifier FUN1(Stages VAR30) {\nif (VAR29 != VAR30)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction CON2() public\n{\nVAR5 = msg.sender;\nVAR18[VAR5] = 1250000000 *10 ** 18; VAR29 = Stages.NOTSTARTED;\n}\nfunction () public payable\n{\nrequire(VAR29 != Stages.ENDED && msg.value >= VAR25);\nrequire(!VAR10 && msg.sender != VAR5);\nrequire(VAR21[msg.sender]);\nif( VAR29 == Stages.PREICO && now <= VAR13 )\n{\nVAR7 =(msg.value).mul(VAR6);\nVAR24 = VAR24.add(msg.value);\nVAR27= FUN4();\nVAR8 = ((VAR7).mul(VAR27)).div(100); VAR9 = VAR7 + VAR8;\nVAR22= VAR22.add(VAR7);\nVAR23= VAR23.add(VAR8);\nFUN16(msg.sender,VAR9);\n}\nelse\nif(VAR29 == Stages.ICO && now <= VAR14 )\n{\nVAR7 =((msg.value).mul(VAR6));\nVAR24 = VAR24.add(msg.value);\nVAR27= FUN5(msg.value);\nVAR8 = ((VAR7).mul(VAR27)).div(100); VAR9 = VAR7 + VAR8;\nVAR22= VAR22.add(VAR7);\nVAR23= VAR23.add(VAR8);\nFUN16(msg.sender,VAR9);\n}\nelse {\nrevert();\n}\n}\nfunction FUN4() private returns (uint256 VAR31)\n{\nuint VAR32 = 30;\nVAR26 = (block.timestamp.sub(VAR11)).div(86400); if(VAR26 == 0)\n{\nVAR32 = 30;\n}\nelse if(VAR26 >= 15)\n{\nVAR32 = 2;\n}\nelse{\nVAR32 -= VAR26* 2;\n}\nreturn VAR32;\n}\nfunction FUN5(uint256 VAR33) private returns (uint256 VAR31){\nVAR28 = VAR33/(10**18);\nuint VAR32;\nif (VAR28>=2 && VAR28 <5){\nVAR32 = 1;\n}\nelse if (VAR28>=5 && VAR28 <15){\nVAR32 = 2;\n}\nelse if (VAR28>=15 && VAR28 <25){\nVAR32 = 3;\n}\nelse if (VAR28>=25 && VAR28 <40){\nVAR32 = 4;\n}\nelse if (VAR28>=40 && VAR28 <60){\nVAR32 = 5;\n}\nelse if (VAR28>=60 && VAR28 <70){\nVAR32 = 6;\n}\nelse if (VAR28>=70 && VAR28 <80){\nVAR32 = 7;\n}\nelse if (VAR28>=80 && VAR28 <90){\nVAR32 = 8;\n}\nelse if (VAR28>=90 && VAR28 <100){\nVAR32 = 9;\n}\nelse if (VAR28>=100){\nVAR32 = 10;\n}\nelse{\nVAR32 = 0;\n}\nreturn VAR32;\n}\nfunction FUN6() public FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR29 = Stages.PREICO;\nVAR10 = false;\nVAR15 = 350000000 * 10 ** 18; VAR18[address(this)] = VAR15;\nVAR11 = now;\nVAR13 = now + 20 days;\n}\nfunction FUN7() public FUN2 FUN1(Stages.PREICO)\n{\nVAR29 = Stages.ICO;\nVAR10 = false;\nVAR16 = 900000000 * 10 **18; VAR18[address(this)] = VAR18[address(this)].add(VAR16);\nVAR12 = now;\nVAR14 = now + 25 days;\n}\nfunction FUN8() external FUN2 {\nVAR10 = true;\n}\nfunction FUN9() external FUN2\n{\nVAR10 = false;\n}\nfunction FUN10(address VAR34) external FUN2{\nVAR21[VAR34] = true;\n}\nfunction FUN11() external FUN2 FUN1(Stages.ICO)\n{\nrequire(now > VAR14);\nVAR29 = Stages.ENDED;\nVAR17= false;\nVAR4 = (VAR4).sub(VAR18[address(this)]);\nVAR18[address(this)] = 0;\n}\nfunction FUN12(bool VAR35 ) external FUN2\n{\nVAR17 = VAR35;\n}\nfunction FUN13( address VAR36, address VAR37, uint256 VAR38 )public returns (bool VAR39) {\nrequire( VAR37 != 0x0);\nrequire(VAR18[VAR36] >= VAR38 && VAR19[VAR36][msg.sender] >= VAR38 && VAR38 >= 0);\nVAR18[VAR36] = (VAR18[VAR36]).sub(VAR38);\nVAR19[VAR36][msg.sender] = (VAR19[VAR36][msg.sender]).sub(VAR38);\nVAR18[VAR37] = (VAR18[VAR37]).add(VAR38);\nreturn true;\n}\nfunction FUN14(address VAR40, uint256 VAR38)public returns (bool VAR39) {\nrequire(!VAR17);\nrequire( VAR40 != 0x0);\nVAR19[msg.sender][VAR40] = VAR38;\nreturn true;\n}\nfunction FUN15(address VAR37, uint256 VAR38) public returns (bool VAR39) {\nif(VAR17 && msg.sender == VAR5)\n{\nrequire(VAR18[VAR5] >= VAR38 && VAR38 >= 0 && VAR18[VAR37] + VAR38 > VAR18[VAR37]);\nVAR18[VAR5] = (VAR18[VAR5]).sub(VAR38);\nVAR18[VAR37] = (VAR18[VAR37]).add(VAR38);\nreturn true;\n}\nelse if(!VAR17)\n{\nrequire(VAR18[msg.sender] >= VAR38 && VAR38 >= 0 && VAR18[VAR37] + VAR38 > VAR18[VAR37]);\nVAR18[msg.sender] = (VAR18[msg.sender]).sub(VAR38);\nVAR18[VAR37] = (VAR18[VAR37]).add(VAR38);\nreturn true;\n}\nelse\nrevert();\n}\nfunction FUN16(address VAR37, uint256 VAR38) private returns(bool VAR39) {\nrequire( VAR37 != 0x0);\nrequire(VAR18[address(this)] >= VAR38 && VAR38 > 0);\nVAR18[address(this)] = (VAR18[address(this)]).sub(VAR38);\nVAR18[VAR37] = (VAR18[VAR37]).add(VAR38);\nreturn true;\n}\nfunction FUN17(address VAR41)public FUN2\n{\nVAR18[VAR41] = (VAR18[VAR41]).add(VAR18[VAR5]);\nVAR18[VAR5] = 0;\nVAR5 = VAR41;\n}\nfunction FUN18() external FUN2 {\nVAR20.FUN15(this.balance);\n}\n}",
        "label": false,
        "name": "0xb57afd2fdb1892ca8eccf26c820bc31ddda7ce99.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ncontract CON3 {\naddress public VAR1;\nfunction CON3() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON3, CON1 {\nusing SafeMath for uint256;\nuint256 public constant VAR3 = 10;\nuint256 public constant VAR4 = 10**36;\nCON2 public VAR5;\nuint256 private VAR6;\nuint256 private VAR7;\nmodifier FUN3(uint256 VAR8) {\nrequire(validRate(VAR8));\n_;\n}\nconstructor(CON2 VAR9) {\nrequire(VAR9 != address(0));\nVAR5 = VAR9;\nVAR6 = convertToRate(VAR9.read());\nVAR7 = now;\n}\nfunction FUN4(uint256 VAR8)\nexternal\nFUN1\nFUN3(VAR8)\n{\nVAR6 = VAR8;\nVAR7 = now;\n}\n}",
        "label": false,
        "name": "0x02ab3549536c140af39ebb1c42f25a8e70b4a10a.sol"
    },
    {
        "source": "contract CON1 {\nstring public constant VAR1 = \"Chicken\";\nstring public constant VAR2 = \"CHK\";\nuint256 VAR3;\nuint256 VAR4;\nmapping(address => uint256) VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => uint256) VAR7;\nfunction FUN1() public {\nVAR3 = 0;\nVAR4 = 5;\n}\nfunction FUN2(uint256 VAR8) internal returns (bool) {\nif (today() > VAR6[msg.sender]) {\nVAR7[msg.sender] = 0;\nVAR6[msg.sender] = today();\n}\nif (VAR7[msg.sender] + VAR8 >= VAR7[msg.sender] && VAR7[msg.sender] + VAR8 <= VAR4) {\nVAR7[msg.sender] += VAR8;\nreturn true;\n}\nreturn false;\n}\nmodifier FUN3(uint256 VAR8) {\nrequire(FUN2(VAR8));\n_;\n}\nfunction FUN4(address VAR9, uint256 VAR8) public FUN3(VAR8) returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR9 != msg.sender);\nVAR3 += VAR8;\nVAR5[VAR9] += VAR8;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1a1759d929041ec22a826edc71e60b4b4ec856e0.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nfunction CON4() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nfunction CON5() public {\nVAR4 = \"SGDT\";\nVAR5 = \"SG Tether\";\nVAR6 = 18;\nVAR7 = 5108324482000000000000000000;\nVAR8[0x8834821DA5c9bA1ef263CAA2A5746D57Ec8590de] = VAR7;\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7 - VAR8[address(0)];\n}\nfunction FUN5(address VAR10) public constant returns (uint VAR11) {\nreturn VAR8[VAR10];\n}\nfunction FUN6(address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[VAR16] = safeSub(VAR8[VAR16], VAR13);\nVAR9[VAR16][msg.sender] = safeSub(VAR9[VAR16][msg.sender], VAR13);\nVAR8[VAR12] = safeAdd(VAR8[VAR12], VAR13);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR15) public constant returns (uint VAR17) {\nreturn VAR9[VAR10][VAR15];\n}\nfunction FUN10(address VAR15, uint VAR13, bytes VAR18) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nCON3(VAR15).receiveApproval(msg.sender, VAR13, this, VAR18);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN12(address VAR19, uint VAR13) public FUN1 returns (bool VAR14) {\nreturn CON2(VAR19).FUN6(VAR1, VAR13);\n}\nfunction FUN13(uint VAR13) public returns (bool VAR14) {\nrequire(VAR8[msg.sender] >= VAR13);\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR13);\nVAR7 = safeSub(VAR7, VAR13);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa211785891eea553d98dedc901254797d5de756e.sol"
    },
    {
        "source": "# @title Uniswap Exchange Interface V1\r\n# @notice Source code found at https:# @notice Use at your own risk\r\n\r\ncontract Factory():\r\n    def getExchange(token_addr: address) -> address: constant\r\n\r\ncontract Exchange():\r\n    def getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei): constant\r\n    def ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256: modifying\r\n    def ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei): modifying\r\n\r\nTokenPurchase: event({buyer: indexed(address), eth_sold: indexed(uint256(wei)), tokens_bought: indexed(uint256)})\r\nEthPurchase: event({buyer: indexed(address), tokens_sold: indexed(uint256), eth_bought: indexed(uint256(wei))})\r\nAddLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nRemoveLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nname: public(bytes32)                             # Uniswap V1\r\nsymbol: public(bytes32)                           # UNI-V1\r\ndecimals: public(uint256)                         # 18\r\ntotalSupply: public(uint256)                      # total number of UNI in existence\r\nbalances: uint256[address]                        # UNI balance of an address\r\nallowances: (uint256[address])[address]           # UNI allowance of one address on another\r\ntoken: address(ERC20)                             # address of the ERC20 token traded on this contract\r\nfactory: Factory                                  # interface for the factory that created this contract\r\n\r\n# @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n#      using create_with_code_of(). It is called once by the factory during contract creation.\r\n@public\r\ndef setup(token_addr: address):\r\n    assert (self.factory == ZERO_ADDRESS and self.token == ZERO_ADDRESS) and token_addr != ZERO_ADDRESS\r\n    self.factory = msg.sender\r\n    self.token = token_addr\r\n    self.name = 0x556e697377617020563100000000000000000000000000000000000000000000\r\n    self.symbol = 0x554e492d56310000000000000000000000000000000000000000000000000000\r\n    self.decimals = 18\r\n\r\n# @notice Deposit ETH and Tokens (self.token) at current ratio to mint UNI tokens.\r\n# @dev min_liquidity does nothing when total UNI supply is 0.\r\n# @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n# @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of UNI minted.\r\n@public\r\n@payable\r\ndef addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert deadline > block.timestamp and (max_tokens > 0 and msg.value > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    if total_liquidity > 0:\r\n        assert min_liquidity > 0\r\n        eth_reserve: uint256(wei) = self.balance - msg.value\r\n        token_reserve: uint256 = self.token.balanceOf(self)\r\n        token_amount: uint256 = msg.value * token_reserve / eth_reserve + 1\r\n        liquidity_minted: uint256 = msg.value * total_liquidity / eth_reserve\r\n        assert max_tokens >= token_amount and liquidity_minted >= min_liquidity\r\n        self.balances[msg.sender] += liquidity_minted\r\n        self.totalSupply = total_liquidity + liquidity_minted\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, liquidity_minted)\r\n        return liquidity_minted\r\n    else:\r\n        assert (self.factory != ZERO_ADDRESS and self.token != ZERO_ADDRESS) and msg.value >= 1000000000\r\n        assert self.factory.getExchange(self.token) == self\r\n        token_amount: uint256 = max_tokens\r\n        initial_liquidity: uint256 = as_unitless_number(self.balance)\r\n        self.totalSupply = initial_liquidity\r\n        self.balances[msg.sender] = initial_liquidity\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, initial_liquidity)\r\n        return initial_liquidity\r\n\r\n# @dev Burn UNI tokens to withdraw ETH and Tokens at current ratio.\r\n# @param amount Amount of UNI burned.\r\n# @param min_eth Minimum ETH withdrawn.\r\n# @param min_tokens Minimum Tokens withdrawn.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of ETH and Tokens withdrawn.\r\n@public\r\ndef removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -> (uint256(wei), uint256):\r\n    assert (amount > 0 and deadline > block.timestamp) and (min_eth > 0 and min_tokens > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    assert total_liquidity > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_amount: uint256(wei) = amount * self.balance / total_liquidity\r\n    token_amount: uint256 = amount * token_reserve / total_liquidity\r\n    assert eth_amount >= min_eth and token_amount >= min_tokens\r\n    self.balances[msg.sender] -= amount\r\n    self.totalSupply = total_liquidity - amount\r\n    send(msg.sender, eth_amount)\r\n    assert self.token.transfer(msg.sender, token_amount)\r\n    log.RemoveLiquidity(msg.sender, eth_amount, token_amount)\r\n    log.Transfer(msg.sender, ZERO_ADDRESS, amount)\r\n    return eth_amount, token_amount\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param input_amount Amount of ETH or Tokens being sold.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens bought.\r\n@private\r\n@constant\r\ndef getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    input_amount_with_fee: uint256 = input_amount * 997\r\n    numerator: uint256 = input_amount_with_fee * output_reserve\r\n    denominator: uint256 = (input_reserve * 1000) + input_amount_with_fee\r\n    return numerator / denominator\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param output_amount Amount of ETH or Tokens being bought.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens sold.\r\n@private\r\n@constant\r\ndef getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    numerator: uint256 = input_reserve * output_amount * 1000\r\n    denominator: uint256 = (output_reserve - output_amount) * 997\r\n    return numerator / denominator + 1\r\n\r\n@private\r\ndef ethToTokenInput(eth_sold: uint256(wei), min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (eth_sold > 0 and min_tokens > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_bought: uint256 = self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance - eth_sold), token_reserve)\r\n    assert tokens_bought >= min_tokens\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, eth_sold, tokens_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value).\r\n# @dev User cannot specify minimum output or deadline.\r\n@public\r\n@payable\r\ndef __default__():\r\n    self.ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value) and minimum output.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies exact input (msg.value) and minimum output\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef ethToTokenOutput(tokens_bought: uint256, max_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance - max_eth), token_reserve)\r\n    # Throws if eth_sold > max_eth\r\n    eth_refund: uint256(wei) = max_eth - as_wei_value(eth_sold, 'wei')\r\n    if eth_refund > 0:\r\n        send(buyer, eth_refund)\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, as_wei_value(eth_sold, 'wei'), tokens_bought)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenSwapOutput(tokens_bought: uint256, deadline: timestamp) -> uint256(wei):\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_sold > 0 and min_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth\r\n    send(recipient, wei_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return wei_bought\r\n\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthSwapInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp) -> uint256(wei):\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthTransferInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens >= tokens_sold\r\n    send(recipient, eth_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthSwapOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthTransferOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToTokenInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert (deadline >= block.timestamp and tokens_sold > 0) and (min_tokens_bought > 0 and min_eth_bought > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    tokens_bought: uint256 = Exchange(exchange_addr).ethToTokenTransferInput(min_tokens_bought, deadline, recipient, value=wei_bought)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n@private\r\ndef tokenToTokenOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth_sold > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    eth_bought: uint256(wei) = Exchange(exchange_addr).getEthToTokenOutputPrice(tokens_bought)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens_sold >= tokens_sold and max_eth_sold >= eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    eth_sold: uint256(wei) = Exchange(exchange_addr).ethToTokenTransferOutput(tokens_bought, deadline, recipient, value=eth_bought)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact input.\r\n# @param eth_sold Amount of ETH sold.\r\n# @return Amount of Tokens that can be bought with input ETH.\r\n@public\r\n@constant\r\ndef getEthToTokenInputPrice(eth_sold: uint256(wei)) -> uint256:\r\n    assert eth_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance), token_reserve)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact output.\r\n# @param tokens_bought Amount of Tokens bought.\r\n# @return Amount of ETH needed to buy output Tokens.\r\n@public\r\n@constant\r\ndef getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei):\r\n    assert tokens_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance), token_reserve)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact input.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @return Amount of ETH that can be bought with input Tokens.\r\n@public\r\n@constant\r\ndef getTokenToEthInputPrice(tokens_sold: uint256) -> uint256(wei):\r\n    assert tokens_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    return as_wei_value(eth_bought, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact output.\r\n# @param eth_bought Amount of output ETH.\r\n# @return Amount of Tokens needed to buy output ETH.\r\n@public\r\n@constant\r\ndef getTokenToEthOutputPrice(eth_bought: uint256(wei)) -> uint256:\r\n    assert eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n\r\n# @return Address of Token that is sold on this exchange.\r\n@public\r\n@constant\r\ndef tokenAddress() -> address:\r\n    return self.token\r\n\r\n# @return Address of factory that created this exchange.\r\n@public\r\n@constant\r\ndef factoryAddress() -> address(Factory):\r\n    return self.factory\r\n\r\n# ERC20 compatibility for exchange liquidity modified from\r\n# https:@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256:\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self.balances[msg.sender] -= _value\r\n    self.balances[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]",
        "label": false,
        "name": "0x44d2142f6f3686c5ca7dbdd7c9d8882c630a0b86.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nbool public VAR2;\nmapping (address => uint256) public VAR3;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire(VAR2);\n_;\n}\nfunction CON1() public {\nVAR1 = msg.sender;\nVAR2 = false;\n}\nfunction FUN3(bool VAR4) public FUN1 {\nVAR2 = VAR4;\n}\nfunction () external payable FUN2 {\nFUN5(msg.sender);\n}\nfunction FUN5(address VAR5) public payable FUN2 {\nVAR3[VAR5] = VAR3[VAR5] + msg.value;\nVAR1.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x8f098c013158f9151a21e06a958cdd8756752696.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => Holding) public VAR3;\nuint256 constant public VAR4 = 90 days;\nuint256 constant public VAR5 = 90 days;\nuint256 constant public VAR6 = 360 days;\nuint256 constant public VAR7 = 14300000 ether;\nuint256 public VAR8;\nstruct Holding {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\n}\nfunction FUN5(address VAR12)\nexternal\nFUN1\nreturns (uint256 VAR13)\n{\nuint256 VAR10 = VAR3[VAR12].VAR10;\nuint256 VAR11 = VAR3[VAR12].VAR11;\nrequire(VAR10 > 0, \"All tokens claimed\");\nrequire(now.sub(VAR11) > VAR4, \"Claiming period not started yet\");\nif (now.sub(VAR11) >= VAR6) {\nVAR13 = VAR10;\ndelete VAR3[VAR12];\n} else {\nuint256 VAR14 = calculatePercentageToRelease(VAR11);\nuint256 VAR15 = (VAR3[VAR12].VAR9.mul(100 - VAR14)).div(100);\nVAR13 = VAR10.sub(VAR15);\nVAR10 = VAR15;\nVAR3[VAR12].VAR10 = VAR10;\n}\n}\nfunction FUN6(address VAR16,uint256 VAR17,uint256 VAR18)\nexternal\nFUN1\n{\nVAR8 = VAR8.add(VAR17);\nrequire(VAR8 <= VAR7);\nif (VAR3[VAR16].VAR9 != 0) {\nVAR3[VAR16].VAR9 = VAR3[VAR16].VAR9.add(VAR17);\nVAR3[VAR16].VAR10 = VAR3[VAR16].VAR10.add(VAR17);\n} else {\nVAR3[VAR16] = Holding(VAR17,VAR17,VAR18);\n}\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => Holding) public VAR3;\nuint256 constant public VAR5 = 90 days;\nuint256 constant public VAR6 = 630 days;\nuint256 constant public VAR19 = 54100000 ether;\nuint256 public VAR20;\nstruct Holding {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\n}\nfunction FUN5(address VAR12)\nexternal\nFUN1\nreturns (uint256 VAR13)\n{\nuint256 VAR10 = VAR3[VAR12].VAR10;\nuint256 VAR11 = VAR3[VAR12].VAR11;\nrequire(VAR10 > 0, \"All tokens claimed\");\nif (now.sub(VAR11) >= VAR6) {\nVAR13 = VAR10;\ndelete VAR3[VAR12];\n} else {\nuint256 VAR21 = calculatePermillToRelease(VAR11);\nuint256 VAR15 = (VAR3[VAR12].VAR9.mul(1000 - VAR21)).div(1000);\nVAR13 = VAR10.sub(VAR15);\nVAR10 = VAR15;\nVAR3[VAR12].VAR10 = VAR10;\n}\n}\nfunction FUN6(address VAR16,uint256 VAR17,uint256 VAR18)\nexternal\nFUN1\n{\nVAR20 = VAR20.add(VAR17);\nrequire(VAR20 <= VAR19);\nif (VAR3[VAR16].VAR9 != 0) {\nVAR3[VAR16].VAR9 = VAR3[VAR16].VAR9.add(VAR17);\nVAR3[VAR16].VAR10 = VAR3[VAR16].VAR10.add(VAR17);\n} else {\nVAR3[VAR16] = Holding(VAR17,VAR17,VAR18);\n}\n}\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nenum User { Public, Seed, Private, Advisor }\nmapping (address => Holding) public VAR3;\nuint256 constant public VAR4 = 90 days;\nuint256 constant public VAR5 = 30 days;\nuint256 constant public VAR6 = 180 days;\nuint256 constant public VAR22 = 28000000 ether; uint256 constant public VAR23 = 9000000 ether; uint256 constant public VAR24 = 7400000 ether;\nuint256 public VAR25;\nuint256 public VAR26;\nuint256 public VAR27;\nstruct Holding {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nUser VAR28;\n}\nfunction FUN5(address VAR12)\nexternal\nFUN1\nreturns (uint256 VAR13)\n{\nuint256 VAR10 = VAR3[VAR12].VAR10;\nuint256 VAR11 = VAR3[VAR12].VAR11;\nrequire(VAR10 > 0, \"All tokens claimed\");\nrequire(now.sub(VAR11) > VAR4, \"Claiming period not started yet\");\nif (now.sub(VAR11) >= VAR6) {\nVAR13 = VAR10;\ndelete VAR3[VAR12];\n} else {\nuint256 VAR14 = calculatePercentageToRelease(VAR11);\nuint256 VAR15 = (VAR3[VAR12].VAR9.mul(100 - VAR14)).div(100);\nVAR13 = VAR10.sub(VAR15);\nVAR10 = VAR15;\nVAR3[VAR12].VAR10 = VAR10;\n}\n}\nfunction FUN6(address VAR16,uint256 VAR17,uint256 VAR18,uint8 VAR28)\nexternal\nFUN1\n{\nUser VAR29;\nif (VAR28 == uint8(User.Seed)) {\nVAR29 = User.Seed;\nVAR25 = VAR25.add(VAR17);\nrequire(VAR25 <= VAR22);\n} else if (VAR28 == uint8(User.Private)) {\nVAR29 = User.Private;\nVAR26 = VAR26.add(VAR17);\nrequire(VAR26 <= VAR23);\n} else if (VAR28 == uint8(User.Advisor)) {\nVAR29 = User.Advisor;\nVAR27 = VAR27.add(VAR17);\nrequire(VAR27 <= VAR24);\n} else {\nrevert( \"incorrect VAR40, not eligible for vesting\" );\n}\nif (VAR3[VAR16].VAR9 != 0) {\nVAR3[VAR16].VAR9 = VAR3[VAR16].VAR9.add(VAR17);\nVAR3[VAR16].VAR10 = VAR3[VAR16].VAR10.add(VAR17);\n} else {\nVAR3[VAR16] = Holding(VAR17,VAR17,VAR18,VAR29);\n}\n}\n}\ncontract CON5 is CON1 {\nusing SafeMath for uint256;\nmapping (address => Holding) public VAR3;\nuint256 constant public VAR4 = 180 days;\nuint256 constant public VAR5 = 180 days;\nuint256 constant public VAR6 = 720 days;\nuint256 constant public VAR30 = 12200000 ether;\nuint256 public VAR31;\nstruct Holding {\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\n}\nfunction FUN5(address VAR12)\nexternal\nFUN1\nreturns (uint256 VAR13)\n{\nuint256 VAR10 = VAR3[VAR12].VAR10;\nuint256 VAR11 = VAR3[VAR12].VAR11;\nrequire(VAR10 > 0, \"All tokens claimed\");\nrequire(now.sub(VAR11) > VAR4, \"Claiming period not started yet\");\nif (now.sub(VAR11) >= VAR6) {\nVAR13 = VAR10;\ndelete VAR3[VAR12];\n} else {\nuint256 VAR14 = calculatePercentageToRelease(VAR11);\nuint256 VAR15 = (VAR3[VAR12].VAR9.mul(100 - VAR14)).div(100);\nVAR13 = VAR10.sub(VAR15);\nVAR10 = VAR15;\nVAR3[VAR12].VAR10 = VAR10;\n}\n}\nfunction FUN6(address VAR16,uint256 VAR17,uint256 VAR18)\nexternal\nFUN1\n{\nVAR31 = VAR31.add(VAR17);\nrequire(VAR31 <= VAR30);\nif (VAR3[VAR16].VAR9 != 0) {\nVAR3[VAR16].VAR9 = VAR3[VAR16].VAR9.add(VAR17);\nVAR3[VAR16].VAR10 = VAR3[VAR16].VAR10.add(VAR17);\n} else {\nVAR3[VAR16] = Holding(VAR17,VAR17,VAR18);\n}\n}\n}\ninterface CON6 {\n}\ncontract CON7 is CON1 {\nusing SafeMath for uint256;\nenum VestingUser { Public, Seed, Private, Advisor, Team, Community, Ecosystem }\nCON6 public VAR32;\nCON2 public VAR33;\nCON5 public VAR34;\nCON3 public VAR35;\nCON4 public VAR36;\nmapping (address => VestingUser) public VAR37;\nuint256 public VAR38;\nconstructor(address VAR39) public {\nVAR32 = CON6(VAR39);\nVAR33 = new CON2();\nVAR34 = new CON5();\nVAR35 = new CON3();\nVAR36 = new CON4();\n}\nfunction FUN5() external {\nuint8 VAR40 = uint8(VAR37[msg.sender]);\nuint256 VAR13;\nif (VAR40 == 1 || VAR40 == 2 || VAR40 == 3) {\nVAR13 = VAR36.FUN5(msg.sender);\n} else if (VAR40 == 4) {\nVAR13 = VAR34.FUN5(msg.sender);\n} else if (VAR40 == 5) {\nVAR13 = VAR33.FUN5(msg.sender);\n} else if (VAR40 == 6){\nVAR13 = VAR35.FUN5(msg.sender);\n} else {\nrevert( \"incorrect VAR40, maybe unknown user\" );\n}\nVAR38 = VAR38.sub(VAR13);\nrequire(VAR32.transfer(msg.sender, VAR13), \"Insufficient balance in vesting contract\");\n}\nfunction FUN6(address VAR16,uint256 VAR17,uint256 VAR18,VestingUser VAR28)\nexternal\nFUN1\n{\nuint8 VAR40 = uint8(VAR28);\nrequire(VAR40 != 0, \"Not eligible for vesting\");\nrequire( uint8(VAR37[VAR16]) == 0 || VAR37[VAR16] == VAR28, \"cannot change VAR28 category\" );\nVAR37[VAR16] = VAR28;\nVAR38 = VAR38.add(VAR17);\nif (VAR40 == 1 || VAR40 == 2 || VAR40 == 3) {\nVAR36.FUN6(VAR16, VAR17, VAR18, VAR40);\n} else if (VAR40 == 4) {\nVAR34.FUN6(VAR16, VAR17, VAR18);\n} else if (VAR40 == 5) {\nVAR33.FUN6(VAR16, VAR17, VAR18);\n} else if (VAR40 == 6){\nVAR35.FUN6(VAR16, VAR17, VAR18);\n} else {\nrevert( \"incorrect VAR40, not eligible for vesting\" );\n}\n}\nfunction FUN7( address VAR41) external FUN1{\nuint256 VAR42 = VAR32.balanceOf(address(this));\nuint256 VAR43 = VAR42.sub(VAR38);\nVAR32.transfer(VAR41, VAR43);\n}\n}",
        "label": false,
        "name": "0x92126dfa40af12ae742660cbe2f680e895a8cfa1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\naddress public VAR1;\nbytes public VAR2;\nbool public VAR3;\nint public VAR4;\nmodifier FUN1 () {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction CON2(address VAR5, bytes VAR6)\npublic\n{\nrequire(VAR6.length == 46);\nVAR1 = VAR5;\nVAR2 = VAR6;\n}\nfunction FUN2(address VAR7)\npublic\nFUN1\n{\nrequire(!VAR3);\nVAR1 = VAR7;\n}\nfunction FUN3(int VAR8)\npublic\nFUN1\n{\nrequire(!VAR3);\nVAR3 = true;\nVAR4 = VAR8;\n}\nfunction FUN4()\npublic\nconstant\nreturns (bool)\n{\nreturn VAR3;\n}\nfunction FUN5()\npublic\nconstant\nreturns (int)\n{\nreturn VAR4;\n}\n}\ncontract CON3 {\nfunction FUN6(bytes VAR2)\npublic\nreturns (CON2 VAR9)\n{\nVAR9 = new CON2(msg.sender, VAR2);\n}\n}",
        "label": false,
        "name": "0xc4f4b8c0259c8264376fc32984e2a8cf4a3c70ca.sol"
    },
    {
        "source": "contract SellOrder {\r\n  \r\n\r\n  \r\n\r\n  \r\n\r\n      address public challengeOwner;\r\n  address public owner;   uint256 public tokens;\r\n  uint256 public price; \r\n  \r\n\r\n\r\n  \r\n\r\n  modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n  modifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n  modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n  \r\n\r\n  function SellOrder (uint256 _tokens, uint256 _price, address _challengeOwner) noEther {\r\n    owner = msg.sender;\r\n\r\n    tokens = _tokens;\r\n    price = _price;\r\n\r\n        challengeOwner = _challengeOwner;\r\n  }\r\n\r\n  function () {\r\n    throw;\r\n  }\r\n\r\n  \r\n\r\n  \r\n\r\n  function cancel () noEther onlyOwner {\r\n    suicide(owner);\r\n  }\r\n\r\n  function execute () {\r\n    \r\n          }\r\n\r\n    function terminate() noEther onlyChallengeOwner {\r\n    suicide(challengeOwner);\r\n  }\r\n}\r\n\r\ncontract AbstractDaoChallenge {\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);\r\n\tfunction tokenPrice() returns (uint256);\r\n}\r\n\r\ncontract DaoAccount\r\n{\r\n\t\r\n\r\n\t\r\n\r\n\t\r\n\t\r\n\r\n\taddress public daoChallenge; \r\n\t    address public challengeOwner;\r\n\r\n\t\r\n\r\n\tuint256 tokenBalance;   address owner;        \r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) noEther {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\t\ttokenBalance = 0;\r\n\r\n        challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tthrow;\r\n\t}\r\n\r\n\t\r\n\r\n\t\r\n\r\n\tfunction getOwnerAddress() constant returns (address ownerAddress) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction getTokenBalance() constant returns (uint256 tokens) {\r\n\t\treturn tokenBalance;\r\n\t}\r\n\r\n\tfunction buyTokens() onlyDaoChallenge returns (uint256 tokens) {\r\n\t\tuint256 amount = msg.value;\r\n\t\tuint256 tokenPrice = AbstractDaoChallenge(daoChallenge).tokenPrice();\r\n\r\n\t\t\t\tif (amount == 0) throw;\r\n\r\n\t\t\t\tif (amount % tokenPrice != 0) throw;\r\n\r\n\t\ttokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge {\r\n\t\tif (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n\t\tif (tokenBalance - tokens > tokenBalance) throw; \t\ttokenBalance -= tokens;\r\n\t\trecipient.receiveTokens(tokens);\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 tokens) {\r\n\t\t\t\tDaoAccount sender = DaoAccount(msg.sender);\r\n\t\tif (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw;\r\n\r\n\t\tif (tokens > sender.getTokenBalance()) throw;\r\n\r\n\t\t\t\tif (tokenBalance + tokens < tokenBalance) throw;\r\n\r\n\t\ttokenBalance += tokens;\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther onlyDaoChallenge returns (SellOrder) {\r\n    if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n    if (tokenBalance - tokens > tokenBalance) throw;     tokenBalance -= tokens;\r\n\r\n    SellOrder order = new SellOrder(tokens, price, challengeOwner);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(SellOrder order) noEther onlyDaoChallenge {\r\n    uint256 tokens = order.tokens();\r\n    tokenBalance += tokens;\r\n    order.cancel();\r\n  }\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\n\r\ncontract DaoChallenge\r\n{\r\n\t\r\n\r\n\r\n\t\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\tevent notifyTokenIssued(uint256 n, uint256 price, uint deadline);\r\n\r\n\tevent notifyNewAccount(address owner, address account);\r\n\tevent notifyBuyToken(address owner, uint256 tokens, uint256 price);\r\n\tevent notifyTransfer(address owner, address recipient, uint256 tokens);\r\n  event notifyPlaceSellOrder(uint256 tokens, uint256 price);\r\n  event notifyCancelSellOrder();\r\n\r\n\t\r\n\r\n\t\tuint public tokenIssueDeadline = now;\r\n\tuint256 public tokensIssued = 0;\r\n\tuint256 public tokensToIssue = 0;\r\n\tuint256 public tokenPrice = 1000000000000000; \r\n\tmapping (address => DaoAccount) public daoAccounts;\r\n  mapping (address => SellOrder) public sellOrders;\r\n\r\n    address public challengeOwner;\r\n\r\n\t\r\n\r\n\t\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t\r\n\r\n\tfunction DaoChallenge () {\r\n\t\tchallengeOwner = msg.sender; \t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\r\n\t\tDaoAccount account = daoAccounts[accountOwner];\r\n\r\n\t\tif(account == DaoAccount(0x00) && createNew) {\r\n\t\t\taccount = new DaoAccount(accountOwner, challengeOwner);\r\n\t\t\tdaoAccounts[accountOwner] = account;\r\n\t\t\tnotifyNewAccount(accountOwner, address(account));\r\n\t\t}\r\n\r\n\t\treturn account;\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction createAccount () {\r\n\t\taccountFor(msg.sender, true);\r\n\t}\r\n\r\n\t\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) {\r\n\t\tif (account == DaoAccount(0x00)) return false;\r\n\t\tif (allegedOwnerAddress == 0x00) return false;\r\n\t\tif (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false;\r\n\t\t\t\tif (daoAccounts[allegedOwnerAddress] != account) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getTokenBalance () constant noEther returns (uint256 tokens) {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) return 0;\r\n\t\treturn account.getTokenBalance();\r\n\t}\r\n\r\n\t\t\t\tfunction issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner {\r\n\t\t\t\tif (now < tokenIssueDeadline) throw;\r\n\r\n\t\t\t\tif (deadline < now) throw;\r\n\r\n\t\t\t\tif (n == 0) throw;\r\n\r\n\t\ttokenPrice = price;\r\n\t\ttokenIssueDeadline = deadline;\r\n\t\ttokensToIssue = n;\r\n\t\ttokensIssued = 0;\r\n\r\n\t\tnotifyTokenIssued(n, price, deadline);\r\n\t}\r\n\r\n\tfunction buyTokens () returns (uint256 tokens) {\r\n\t\ttokens = msg.value / tokenPrice;\r\n\r\n\t\tif (now > tokenIssueDeadline) throw;\r\n\t\tif (tokensIssued >= tokensToIssue) throw;\r\n\r\n\t\t\t\t\t\ttokensIssued += tokens;\r\n\t\tif (tokensIssued > tokensToIssue) throw;\r\n\r\n\t  DaoAccount account = accountFor(msg.sender, true);\r\n\t\tif (account.buyTokens.value(msg.value)() != tokens) throw;\r\n\r\n\t\tnotifyBuyToken(msg.sender, tokens, msg.value);\r\n\t\treturn tokens;\r\n \t}\r\n\r\n\tfunction transfer(uint256 tokens, address recipient) noEther {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) throw;\r\n\r\n\t\tDaoAccount recipientAcc = accountFor(recipient, false);\r\n\t\tif (recipientAcc == DaoAccount(0x00)) throw;\r\n\r\n\t\taccount.transfer(tokens, recipientAcc);\r\n\t\tnotifyTransfer(msg.sender, recipient, tokens);\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther returns (SellOrder) {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = account.placeSellOrder(tokens, price);\r\n\r\n    sellOrders[address(order)] = order;\r\n\r\n    notifyPlaceSellOrder(tokens, price);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(address addr) noEther {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = sellOrders[addr];\r\n    if (order == SellOrder(0x00)) throw;\r\n\r\n    if (order.owner() != address(account)) throw;\r\n\r\n    sellOrders[addr] = SellOrder(0x00);\r\n\r\n    account.cancelSellOrder(order);\r\n\r\n    notifyCancelSellOrder();\r\n  }\r\n\r\n\t\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}",
        "label": false,
        "name": "0xb5232102e71a7ff376ebdeae59e19d031cbe30af.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nstring public VAR11 = \"BitherToken\";\nstring public VAR12 = \"BTR\";\nuint256 public VAR13 = 18;\nconstructor() public {\nFUN7(msg.sender, 47000000 * (10 ** VAR13));\n}\n}",
        "label": false,
        "name": "0x07843efd5be9ed17074b36f84bd42a907c2c2239.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 { address public VAR1; bool public VAR2; bool public VAR3; address public VAR4;\nconstructor() internal {\nVAR1 = 0x129e3B92f033d553E38599AD3aa9C45A2FACaF73;\n}\nfunction FUN1(address VAR5) FUN2 public {\nVAR4 = VAR5;\n}\nmodifier FUN2() { require(msg.sender == VAR1);\n_;\n}\nmodifier FUN3() { require(VAR2 == false);\n_;\n}\nmodifier FUN4() { require(VAR3 == false || VAR4 == msg.sender);\n_;\n}\nfunction FUN5(address VAR6) FUN2 public { require(VAR6 != address(0));\nVAR1 = VAR6;\n}\nfunction FUN6(bool VAR7) FUN2 public { VAR2 = VAR7;\n}\nfunction FUN7(bool VAR7) FUN2 public { VAR3 = VAR7;\n}\n}\ncontract CON4 is CON1, CON3 { using SafeMath for uint256;\nuint256 public VAR8;\nmapping (address => uint256) VAR9; mapping (address => mapping (address => uint256)) VAR10; mapping (address => bool) VAR11;\nfunction FUN8(address VAR5, uint256 VAR12) FUN4 public returns (bool VAR13) {\nrequire(VAR5 != address(0)); require(VAR11[msg.sender]==false);\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR12);\nVAR9[VAR5] = VAR9[VAR5].add(VAR12);\nreturn true;\n}\nfunction FUN9(address VAR14, address VAR5, uint256 VAR12) FUN4 public returns (bool VAR13) {\nrequire(VAR5 != address(0)); require(VAR11[VAR14]==false);\nVAR10[VAR14][msg.sender] = VAR10[VAR14][msg.sender].sub(VAR12);\nVAR9[VAR14] = VAR9[VAR14].sub(VAR12);\nVAR9[VAR5] = VAR9[VAR5].add(VAR12);\nreturn true;\n}\nfunction FUN10(address VAR15, uint256 VAR12) public returns (bool VAR13) {\nrequire((VAR12 == 0) || (VAR10[msg.sender][VAR15] == 0));\nVAR10[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN11(address VAR16, uint256 VAR12, bytes memory VAR17) public returns (bool VAR13) {\nrequire((VAR12 == 0) || (VAR10[msg.sender][VAR16] == 0));\nVAR10[msg.sender][VAR16] = VAR12;\nCON2(VAR16).receiveApproval(msg.sender, VAR12, address(this), VAR17);\nreturn true;\n}\nfunction FUN12(address VAR18, uint256 VAR19) FUN2 FUN3 public {\nrequire(VAR8.add(VAR19) <= 1000000000 * (10 ** 2) ); VAR9[VAR18] = SafeMath.add(VAR9[VAR18], VAR19);\nVAR8 = SafeMath.add(VAR8, VAR19);\n}\nfunction FUN13(uint256 VAR20) FUN2 FUN3 public {\nVAR9[msg.sender] = SafeMath.sub(VAR9[msg.sender], VAR20);\nVAR8 = SafeMath.sub(VAR8, VAR20);\n}\n}\ncontract CON5 is CON4 {\nstring public VAR21 = 'PGcoin';\nuint8 public VAR22 = 2;\nstring public VAR23 = 'PGC';\nstring public VAR24 = '2';\nconstructor() public {\nVAR8 = 200000000 * (10 ** uint256(VAR22)); VAR9[0x129e3B92f033d553E38599AD3aa9C45A2FACaF73] = VAR8;\n}\nfunction() external {\nrevert();\n}\n}",
        "label": false,
        "name": "0xd445e2b21fb896571ab7ec8c00a682cce6feb995.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON3 {\nstring public VAR11;\nstring public VAR12;\nuint8 public VAR13;\nconstructor(string VAR14, string VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON6 {\naddress public VAR17;\nconstructor() public {\nVAR17 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR17);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR17 = address(0);\n}\nfunction FUN8(address VAR18) public FUN6 {\nFUN9(VAR18);\n}\nfunction FUN9(address VAR18) internal {\nrequire(VAR18 != address(0));\nVAR17 = VAR18;\n}\n}\ncontract CON7 is CON4, CON6 {\nbool public VAR19 = false;\nmodifier FUN10() {\nrequire(!VAR19);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR17);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR20)\npublic\nFUN11\nFUN10\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR20);\nVAR1[VAR3] = VAR1[VAR3].add(VAR20);\nreturn true;\n}\nfunction FUN13() public FUN6 FUN10 returns (bool) {\nVAR19 = true;\nreturn true;\n}\n}\ncontract CON8 is CON2 {\nfunction FUN14(uint256 VAR4) public {\nFUN15(msg.sender, VAR4);\n}\nfunction FUN15(address VAR21, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR21]);\nVAR1[VAR21] = VAR1[VAR21].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON6 {\nbool public VAR22 = false;\nmodifier FUN16() {\nrequire(!VAR22);\n_;\n}\nmodifier FUN17() {\nrequire(VAR22);\n_;\n}\nfunction FUN18() public FUN6 FUN16 {\nVAR22 = true;\n}\nfunction FUN19() public FUN6 FUN17 {\nVAR22 = false;\n}\n}\ncontract CON10 is CON4, CON9 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN16\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nFUN16\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN3(address VAR7,uint256 VAR4)\npublic\nFUN16\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4);\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nFUN16\nreturns (bool VAR23)\n{\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nFUN16\nreturns (bool VAR23)\n{\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON11 is CON6 {\naddress public VAR24;\nmodifier FUN20() {\nrequire(msg.sender == VAR24);\n_;\n}\nfunction FUN8(address VAR25) public FUN6 {\nVAR24 = VAR25;\n}\nfunction FUN21() public FUN20 {\nVAR17 = VAR24;\nVAR24 = address(0);\n}\n}\ncontract CON12 is CON6 {\nusing SafeERC20 for CON1;\nfunction FUN22(CON1 VAR26) external FUN6 {\nuint256 VAR27 = VAR26.balanceOf(this);\nVAR26.safeTransfer(VAR17, VAR27);\n}\n}\ncontract CON13 is CON12, CON11 { }\ncontract CON14 is CON4, CON5(\"Wrapped BTC\", \"WBTC\", 8),\nCON7, CON8, CON10, CON13 {\nfunction FUN14(uint VAR28) public FUN6 {\nsuper.FUN14(VAR28);\n}\nfunction FUN13() public FUN6 returns (bool) {\nreturn false;\n}\nfunction FUN7() public FUN6 {\nrevert(\"renouncing ownership is blocked\");\n}\n}",
        "label": false,
        "name": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599.sol"
    },
    {
        "source": "\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract database {\r\n\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    \r\n    struct participant {\r\n        address eth_address;         uint256 topl_address;         uint256 arbits;         uint256 num_of_pro_rata_tokens_alloted;\r\n        bool arbits_kyc_whitelist;         uint8 num_of_uses;\r\n    }\r\n\r\n    \r\n        mapping(address => bool) public sale_owners;\r\n    mapping(address => bool) public owners;\r\n    mapping(address => bool) public masters;\r\n    mapping(address => bool) public kycers;\r\n\r\n        mapping(address => participant) public participants;\r\n    address[] public participant_keys;\r\n\r\n        bool public arbits_presale_open = false;     bool public iconiq_presale_open = false;     bool public arbits_sale_open = false; \r\n        uint256 public pre_kyc_bonus_denominator;\r\n    uint256 public pre_kyc_bonus_numerator;\r\n    uint256 public pre_kyc_iconiq_bonus_denominator;\r\n    uint256 public pre_kyc_iconiq_bonus_numerator;\r\n\r\n    uint256 public contrib_arbits_min;\r\n    uint256 public contrib_arbits_max;\r\n\r\n        uint256 public presale_arbits_per_ether;            uint256 public presale_iconiq_arbits_per_ether;     uint256 public presale_arbits_total = 18000000;\r\n    uint256 public presale_arbits_sold;\r\n\r\n        uint256 public sale_arbits_per_ether;\r\n    uint256 public sale_arbits_total;\r\n    uint256 public sale_arbits_sold;\r\n\r\n    \r\n    constructor() public {\r\n        owners[msg.sender] = true;\r\n    }\r\n\r\n    \r\n    function add_owner(address __subject) public only_owner {\r\n        owners[__subject] = true;\r\n    }\r\n\r\n    function remove_owner(address __subject) public only_owner {\r\n        owners[__subject] = false;\r\n    }\r\n\r\n    function add_master(address _subject) public only_owner {\r\n        masters[_subject] = true;\r\n    }\r\n\r\n    function remove_master(address _subject) public only_owner {\r\n        masters[_subject] = false;\r\n    }\r\n\r\n    function add_kycer(address _subject) public only_owner {\r\n        kycers[_subject] = true;\r\n    }\r\n\r\n    function remove_kycer(address _subject) public only_owner {\r\n        kycers[_subject] = false;\r\n    }\r\n\r\n    \r\n    modifier log_participant_update(address __eth_address) {\r\n        participant_keys.push(__eth_address);         _;\r\n    }\r\n\r\n    modifier only_owner() {\r\n        require(owners[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier only_kycer() {\r\n        require(kycers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier only_master_or_owner() {\r\n        require(masters[msg.sender] || owners[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    \r\n            function get_sale_owner(address _a) public view returns(bool) {\r\n        return sale_owners[_a];\r\n    }\r\n    \r\n    function get_contrib_arbits_min() public view returns(uint256) {\r\n        return contrib_arbits_min;\r\n    }\r\n\r\n    function get_contrib_arbits_max() public view returns(uint256) {\r\n        return contrib_arbits_max;\r\n    }\r\n\r\n    function get_pre_kyc_bonus_numerator() public view returns(uint256) {\r\n        return pre_kyc_bonus_numerator;\r\n    }\r\n\r\n    function get_pre_kyc_bonus_denominator() public view returns(uint256) {\r\n        return pre_kyc_bonus_denominator;\r\n    }\r\n\r\n    function get_pre_kyc_iconiq_bonus_numerator() public view returns(uint256) {\r\n        return pre_kyc_iconiq_bonus_numerator;\r\n    }\r\n\r\n    function get_pre_kyc_iconiq_bonus_denominator() public view returns(uint256) {\r\n        return pre_kyc_iconiq_bonus_denominator;\r\n    }\r\n\r\n    function get_presale_iconiq_arbits_per_ether() public view returns(uint256) {\r\n        return (presale_iconiq_arbits_per_ether);\r\n    }\r\n\r\n    function get_presale_arbits_per_ether() public view returns(uint256) {\r\n        return (presale_arbits_per_ether);\r\n    }\r\n\r\n    function get_presale_arbits_total() public view returns(uint256) {\r\n        return (presale_arbits_total);\r\n    }\r\n\r\n    function get_presale_arbits_sold() public view returns(uint256) {\r\n        return (presale_arbits_sold);\r\n    }\r\n\r\n    function get_sale_arbits_per_ether() public view returns(uint256) {\r\n        return (sale_arbits_per_ether);\r\n    }\r\n\r\n    function get_sale_arbits_total() public view returns(uint256) {\r\n        return (sale_arbits_total);\r\n    }\r\n\r\n    function get_sale_arbits_sold() public view returns(uint256) {\r\n        return (sale_arbits_sold);\r\n    }\r\n\r\n        function set_sale_owner(address _a, bool _v) public only_master_or_owner {\r\n        sale_owners[_a] = _v;\r\n    }\r\n\r\n    function set_contrib_arbits_min(uint256 _v) public only_master_or_owner {\r\n        contrib_arbits_min = _v;\r\n    }\r\n\r\n    function set_contrib_arbits_max(uint256 _v) public only_master_or_owner {\r\n        contrib_arbits_max = _v;\r\n    }\r\n\r\n    function set_pre_kyc_bonus_numerator(uint256 _v) public only_master_or_owner {\r\n        pre_kyc_bonus_numerator = _v;\r\n    }\r\n\r\n    function set_pre_kyc_bonus_denominator(uint256 _v) public only_master_or_owner {\r\n        pre_kyc_bonus_denominator = _v;\r\n    }\r\n\r\n    function set_pre_kyc_iconiq_bonus_numerator(uint256 _v) public only_master_or_owner {\r\n        pre_kyc_iconiq_bonus_numerator = _v;\r\n    }\r\n\r\n    function set_pre_kyc_iconiq_bonus_denominator(uint256 _v) public only_master_or_owner {\r\n        pre_kyc_iconiq_bonus_denominator = _v;\r\n    }\r\n\r\n    function set_presale_iconiq_arbits_per_ether(uint256 _v) public only_master_or_owner {\r\n        presale_iconiq_arbits_per_ether = _v;\r\n    }\r\n\r\n    function set_presale_arbits_per_ether(uint256 _v) public only_master_or_owner {\r\n        presale_arbits_per_ether = _v;\r\n    }\r\n\r\n    function set_presale_arbits_total(uint256 _v) public only_master_or_owner {\r\n        presale_arbits_total = _v;\r\n    }\r\n\r\n    function set_presale_arbits_sold(uint256 _v) public only_master_or_owner {\r\n        presale_arbits_sold = _v;\r\n    }\r\n\r\n    function set_sale_arbits_per_ether(uint256 _v) public only_master_or_owner {\r\n        sale_arbits_per_ether = _v;\r\n    }\r\n\r\n    function set_sale_arbits_total(uint256 _v) public only_master_or_owner {\r\n        sale_arbits_total = _v;\r\n    }\r\n\r\n    function set_sale_arbits_sold(uint256 _v) public only_master_or_owner {\r\n        sale_arbits_sold = _v;\r\n    }\r\n\r\n            function get_participant(address _a) public view returns(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        bool,\r\n        uint8\r\n    ) {\r\n        participant storage subject = participants[_a];\r\n        return (\r\n            subject.eth_address,\r\n            subject.topl_address,\r\n            subject.arbits,\r\n            subject.num_of_pro_rata_tokens_alloted,\r\n            subject.arbits_kyc_whitelist,\r\n            subject.num_of_uses\r\n        );\r\n    }\r\n\r\n    function get_participant_num_of_uses(address _a) public view returns(uint8) {\r\n        return (participants[_a].num_of_uses);\r\n    }\r\n\r\n    function get_participant_topl_address(address _a) public view returns(uint256) {\r\n        return (participants[_a].topl_address);\r\n    }\r\n\r\n    function get_participant_arbits(address _a) public view returns(uint256) {\r\n        return (participants[_a].arbits);\r\n    }\r\n\r\n    function get_participant_num_of_pro_rata_tokens_alloted(address _a) public view returns(uint256) {\r\n        return (participants[_a].num_of_pro_rata_tokens_alloted);\r\n    }\r\n\r\n    function get_participant_arbits_kyc_whitelist(address _a) public view returns(bool) {\r\n        return (participants[_a].arbits_kyc_whitelist);\r\n    }\r\n\r\n        function set_participant(\r\n        address _a,\r\n        uint256 _ta,\r\n        uint256 _arbits,\r\n        uint256 _prta,\r\n        bool _v3,\r\n        uint8 _nou\r\n    ) public only_master_or_owner log_participant_update(_a) {\r\n        participant storage subject = participants[_a];\r\n        subject.eth_address = _a;\r\n        subject.topl_address = _ta;\r\n        subject.arbits = _arbits;\r\n        subject.num_of_pro_rata_tokens_alloted = _prta;\r\n        subject.arbits_kyc_whitelist = _v3;\r\n        subject.num_of_uses = _nou;\r\n    }\r\n\r\n    function set_participant_num_of_uses(\r\n        address _a,\r\n        uint8 _v\r\n    ) public only_master_or_owner log_participant_update(_a) {\r\n        participants[_a].num_of_uses = _v;\r\n    }\r\n\r\n    function set_participant_topl_address(\r\n        address _a,\r\n        uint256 _ta\r\n    ) public only_master_or_owner log_participant_update(_a) {\r\n        participants[_a].topl_address = _ta;\r\n    }\r\n\r\n    function set_participant_arbits(\r\n        address _a,\r\n        uint256 _v\r\n    ) public only_master_or_owner log_participant_update(_a) {\r\n        participants[_a].arbits = _v;\r\n    }\r\n\r\n    function set_participant_num_of_pro_rata_tokens_alloted(\r\n        address _a,\r\n        uint256 _v\r\n    ) public only_master_or_owner log_participant_update(_a) {\r\n        participants[_a].num_of_pro_rata_tokens_alloted = _v;\r\n    }\r\n\r\n    function set_participant_arbits_kyc_whitelist(\r\n        address _a,\r\n        bool _v\r\n    ) public only_kycer log_participant_update(_a) {\r\n        participants[_a].arbits_kyc_whitelist = _v;\r\n    }\r\n\r\n\r\n        \r\n        function get_iconiq_presale_open() public view only_master_or_owner returns(bool) {\r\n        return iconiq_presale_open;\r\n    }\r\n\r\n    function get_arbits_presale_open() public view only_master_or_owner returns(bool) {\r\n        return arbits_presale_open;\r\n    }\r\n\r\n    function get_arbits_sale_open() public view only_master_or_owner returns(bool) {\r\n        return arbits_sale_open;\r\n    }\r\n\r\n        function set_iconiq_presale_open(bool _v) public only_master_or_owner {\r\n        iconiq_presale_open = _v;\r\n    }\r\n\r\n    function set_arbits_presale_open(bool _v) public only_master_or_owner {\r\n        arbits_presale_open = _v;\r\n    }\r\n\r\n    function set_arbits_sale_open(bool _v) public only_master_or_owner {\r\n        arbits_sale_open = _v;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract iconiq_presale {\r\n\r\n        using topl_database_lib for address;\r\n    using SafeMath for uint256;\r\n\r\n        address public owner;\r\n    address public db;\r\n\r\n        struct participant {\r\n        address eth_address;         uint256 topl_address;         uint256 arbits;         uint256 num_of_pro_rata_tokens_alloted;\r\n        bool arbits_kyc_whitelist;         uint8 num_of_uses;\r\n    }\r\n\r\n        constructor(address __db) public {\r\n        db = __db;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function owner_linkage() public {         db.set_sale_owner(owner, true);\r\n    }\r\n\r\n    modifier only_owner() {\r\n        require(db.get_sale_owner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function add_owner(address __subject) public only_owner {\r\n        db.set_sale_owner(__subject, true);\r\n        emit e_add_owner(msg.sender, __subject);\r\n    }\r\n\r\n    function remove_owner(address __subject) public only_owner {\r\n        db.set_sale_owner(__subject, false);\r\n        emit e_remove_owner(msg.sender, __subject);\r\n    }\r\n\r\n        function participate_in_arbits_presale_crypto() public payable presale_open use_count {\r\n                                                                                           (                                                                              address p1,                                                                uint256 p2,                                                                uint256 p3,                                                                uint256 p4,                                                                bool p5,                                                                   uint8 p6                                                               ) = db.get_participant(msg.sender);                                        participant memory subject = participant(p1, p2, p3, p4, p5, p6);                                                                                     \r\n                \r\n                                                                             require(subject.num_of_pro_rata_tokens_alloted > 0);                                                                      \r\n                                                                                                                                                           uint256 subject_tokens_to_add_at_iconiq_price = msg.value.mul(db.get_presale_iconiq_arbits_per_ether()).div(1 ether);          uint256 subject_tokens_to_add_at_reg_price = msg.value.mul(db.get_presale_arbits_per_ether()).div(1 ether);                    uint256 amount_of_pro_rata_tokens_subject_can_get = subject.num_of_pro_rata_tokens_alloted;                                                uint256 subject_tokens_to_add = 0;                                                                                                         if (amount_of_pro_rata_tokens_subject_can_get >= subject.arbits.add(subject_tokens_to_add_at_iconiq_price)) {                                  subject_tokens_to_add = subject_tokens_to_add_at_iconiq_price;          } else {                                                                                                                                       if (subject.arbits < amount_of_pro_rata_tokens_subject_can_get) {                                                                              uint256 delta = amount_of_pro_rata_tokens_subject_can_get.sub(subject.arbits);                  subject_tokens_to_add = delta.add(                                                                  subject_tokens_to_add_at_iconiq_price                                                           .sub(delta)                                                                                     .mul(db.get_presale_arbits_per_ether())                                                         .div(db.get_presale_iconiq_arbits_per_ether())                                              );                                                                                          } else {                                                                                                                                       subject_tokens_to_add = subject_tokens_to_add_at_reg_price;              }                                                                                                                                      }                                                                                                                                          if (subject.arbits_kyc_whitelist) {                                                                                                            subject_tokens_to_add = subject_tokens_to_add                         .mul(db.get_pre_kyc_iconiq_bonus_numerator())                     .div(db.get_pre_kyc_iconiq_bonus_denominator());          }                                                                                                                                                                                                                                                                                     \r\n                        \r\n                                                                                                                            require(db.get_presale_arbits_total() >= db.get_presale_arbits_sold().add(subject_tokens_to_add));          require(db.get_arbits_max_contribution() >= subject_tokens_to_add);         require(db.get_arbits_min_contribution() <= subject_tokens_to_add);                                                                                                                     \r\n                                                                                                   db.add_presale_arbits_sold(subject_tokens_to_add);         db.add_arbits(msg.sender, subject_tokens_to_add);                                                                                            \r\n                                                                                             emit e_participate_in_arbits_presale_crypto(msg.sender, msg.value);                                                                                           }\r\n\r\n    function() public payable {\r\n        participate_in_arbits_presale_crypto();         emit e_fallback(msg.sender, msg.value);\r\n    }\r\n\r\n        function kill_and_withdraw(address withdraw_to) public only_owner {\r\n        emit e_kill_and_withdraw(withdraw_to);\r\n        selfdestruct(withdraw_to);\r\n    }\r\n\r\n    function withdraw_some_amount(address withdraw_to, uint256 amount) public only_owner {\r\n        withdraw_to.transfer(amount);         emit e_withdraw_some_amount(withdraw_to, amount);\r\n    }\r\n\r\n        function set_sale_open() public only_owner {\r\n        require(db.get_presale_arbits_per_ether() > 0);\r\n        require(db.get_presale_iconiq_arbits_per_ether() > 0);\r\n        require(db.get_arbits_max_contribution() > 0);\r\n        require(db.get_arbits_min_contribution() > 0);\r\n        require(db.get_pre_kyc_iconiq_bonus_numerator() > 0);\r\n        require(db.get_pre_kyc_iconiq_bonus_denominator() > 0);\r\n        db.set_iconiq_presale_open(true);\r\n    }\r\n\r\n    function set_sale_closed() public only_owner {\r\n        db.set_iconiq_presale_open(false);\r\n    }\r\n\r\n    function set_iconiq_arbits_per_ether(uint256 _v) public only_owner {\r\n        db.set_presale_iconiq_arbits_per_ether(_v);     }\r\n\r\n    function set_iconiq_pre_kyc_bonus_numerator(uint256 _v) public only_owner {\r\n        db.set_pre_kyc_iconiq_bonus_numerator(_v);\r\n    }\r\n\r\n    function set_iconiq_pre_kyc_bonus_denominator(uint256 _v) public only_owner {\r\n        db.set_pre_kyc_iconiq_bonus_denominator(_v);\r\n    }\r\n\r\n        modifier presale_open() {\r\n        require(db.get_iconiq_presale_open());\r\n        _;\r\n    }\r\n\r\n    modifier use_count() {\r\n        uint8 uses = db.get_num_of_uses(msg.sender);\r\n        require(uses < 5);\r\n        db.set_num_of_uses(msg.sender, uses + 1);\r\n        _;\r\n    }\r\n\r\n        function is_presale_open() public view returns(bool) {\r\n        return db.get_iconiq_presale_open();\r\n    }\r\n\r\n    function am_i_on_the_whitelist() public view returns(bool) {\r\n        return db.get_arbits_whitelist(msg.sender);\r\n    }\r\n\r\n    function how_many_arbits_do_i_have() public view returns(uint256) {\r\n        return db.get_arbits(msg.sender);\r\n    }\r\n\r\n                                event e_add_owner(address, address);     event e_remove_owner(address, address);     event e_participate_in_arbits_presale_crypto(address, uint256);     event e_fallback(address, uint256);         event e_kill_and_withdraw(address);     event e_withdraw_some_amount(address, uint256); }",
        "label": false,
        "name": "0xc609b80c81d690b2ec39f70a5638fff8902a1d89.sol"
    },
    {
        "source": "{\"Address.sol\":{\"content\":\"/**\\n * The MIT License (MIT)\\n *\\n * Copyright (c) 2016-2019 zOS Global Limited\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining\\n * a copy of this software and associated documentation files (the\\n * \\\"Software\\\"), to deal in the Software without restriction, including\\n * without limitation the rights to use, copy, modify, merge, publish,\\n * distribute, sublicense, and/or sell copies of the Software, and to\\n * permit persons to whom the Software is furnished to do so, subject to\\n * the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included\\n * in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n */\\n\\npragma solidity ^0.4.25;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"base64.sol\":{\"content\":\"pragma solidity ^0.4.25;\\n\\n/**\\n * This method was modified from the GPLv3 solidity code found in this repository\\n * https://github.com/vcealicu/melonport-price-feed/blob/master/pricefeed/PriceFeed.sol\\n */\\n\\n\\n/// @title Base64 provides base 64 decoding functionality.\\ncontract Base64 {\\n    bytes constant BASE64_DECODE_CHAR = hex\\\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\\\";\\n\\n    /// @return decoded array of bytes.\\n    /// @param _encoded base 64 encoded array of bytes.\\n    function _base64decode(bytes _encoded) internal pure returns (bytes) {\\n        byte v1;\\n        byte v2;\\n        byte v3;\\n        byte v4;\\n        uint length = _encoded.length;\\n        bytes memory result = new bytes(length);\\n        uint index;\\n\\n        // base64 encoded strings can\\u0027t be length 0 and they must be divisble by 4\\n        require(length \\u003e 0  \\u0026\\u0026 length % 4 == 0, \\\"invalid base64 encoding\\\");\\n\\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\\\"=\\\")) {\\n              length -= 2;\\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\\\"=\\\")) {\\n              length -= 1;\\n          }\\n          uint count = length \\u003e\\u003e 2 \\u003c\\u003c 2;\\n          for (uint i = 0; i \\u003c count;) {\\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n\\n              result[index++] = (v1 \\u003c\\u003c 2 | v2 \\u003e\\u003e 4) \\u0026 255;\\n              result[index++] = (v2 \\u003c\\u003c 4 | v3 \\u003e\\u003e 2) \\u0026 255;\\n              result[index++] = (v3 \\u003c\\u003c 6 | v4) \\u0026 255;\\n          }\\n          if (length - count == 2) {\\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              result[index++] = (v1 \\u003c\\u003c 2 | v2 \\u003e\\u003e 4) \\u0026 255;\\n          } else if (length - count == 3) {\\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\\n\\n              result[index++] = (v1 \\u003c\\u003c 2 | v2 \\u003e\\u003e 4) \\u0026 255;\\n              result[index++] = (v2 \\u003c\\u003c 4 | v3 \\u003e\\u003e 2) \\u0026 255;\\n          }\\n\\n        // Set to correct length.\\n        assembly {\\n            mstore(result, index)\\n        }\\n\\n        return result;\\n    }\\n}\\n\"},\"controllable.sol\":{\"content\":\"/**\\n *  Controller Interface\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./controller.sol\\\";\\nimport \\\"./ENS.sol\\\";\\n\\n/// @title Resolver returns the controller contract address.\\ninterface IResolver {\\n    function addr(bytes32) external view returns (address);\\n}\\n\\n\\n/// @title Controllable implements access control functionality based on a controller set in ENS.\\ncontract Controllable {\\n    /// @dev _ENS points to the ENS registry smart contract.\\n    ENS private _ENS;\\n    /// @dev Is the registered ENS name of the controller contract.\\n    bytes32 private _node;\\n\\n    /// @dev Constructor initializes the controller contract object.\\n    /// @param _ens is the address of the ENS.\\n    /// @param _controllerName is the ENS name of the Controller.\\n    constructor(address _ens, bytes32 _controllerName) internal {\\n      _ENS = ENS(_ens);\\n      _node = _controllerName;\\n    }\\n\\n    /// @dev Checks if message sender is the controller.\\n    modifier onlyController() {\\n        require(_isController(msg.sender), \\\"sender is not a controller\\\");\\n        _;\\n    }\\n\\n    /// @return true if the provided account is the controller.\\n    function _isController(address _account) internal view returns (bool) {\\n        return IController(IResolver(_ENS.resolver(_node)).addr(_node)).isController(_account);\\n    }\\n}\\n\"},\"controller.sol\":{\"content\":\"/**\\n *  Controller\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\n/// @title The Controller interface provides access to an external list of controllers.\\ninterface IController {\\n    function isController(address) external view returns (bool);\\n}\\n\\n\\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\\ncontract Controller is IController {\\n    event AddedController(address _sender, address _controller);\\n    event RemovedController(address _sender, address _controller);\\n\\n    mapping (address =\\u003e bool) private _isController;\\n    uint private _controllerCount;\\n\\n    /// @dev Constructor initializes the list of controllers with the provided address.\\n    /// @param _account address to add to the list of controllers.\\n    constructor(address _account) public {\\n        _addController(_account);\\n    }\\n\\n    /// @dev Checks if message sender is a controller.\\n    modifier onlyController() {\\n        require(isController(msg.sender), \\\"sender is not a controller\\\");\\n        _;\\n    }\\n\\n    /// @dev Add a new controller to the list of controllers.\\n    /// @param _account address to add to the list of controllers.\\n    function addController(address _account) external onlyController {\\n        _addController(_account);\\n    }\\n\\n    /// @dev Remove a controller from the list of controllers.\\n    /// @param _account address to remove from the list of controllers.\\n    function removeController(address _account) external onlyController {\\n        _removeController(_account);\\n    }\\n\\n    /// @return true if the provided account is a controller.\\n    function isController(address _account) public view returns (bool) {\\n        return _isController[_account];\\n    }\\n\\n    /// @return the current number of controllers.\\n    function controllerCount() public view returns (uint) {\\n        return _controllerCount;\\n    }\\n\\n    /// @dev Internal-only function that adds a new controller.\\n    function _addController(address _account) internal {\\n        require(!_isController[_account], \\\"provided account is already a controller\\\");\\n        _isController[_account] = true;\\n        _controllerCount++;\\n        emit AddedController(msg.sender, _account);\\n    }\\n\\n    /// @dev Internal-only function that removes an existing controller.\\n    function _removeController(address _account) internal {\\n        require(_isController[_account], \\\"provided account is not a controller\\\");\\n        require(_controllerCount \\u003e 1, \\\"cannot remove the last controller\\\");\\n        _isController[_account] = false;\\n        _controllerCount--;\\n        emit RemovedController(msg.sender, _account);\\n    }\\n}\\n\"},\"date.sol\":{\"content\":\"/**\\n *  Month Parser\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\n\\n/// @title Date provides date parsing functionality.\\ncontract Date {\\n\\n    bytes32 constant private JANUARY = keccak256(\\\"Jan\\\");\\n    bytes32 constant private FEBRUARY = keccak256(\\\"Feb\\\");\\n    bytes32 constant private MARCH = keccak256(\\\"Mar\\\");\\n    bytes32 constant private APRIL = keccak256(\\\"Apr\\\");\\n    bytes32 constant private MAY = keccak256(\\\"May\\\");\\n    bytes32 constant private JUNE = keccak256(\\\"Jun\\\");\\n    bytes32 constant private JULY = keccak256(\\\"Jul\\\");\\n    bytes32 constant private AUGUST = keccak256(\\\"Aug\\\");\\n    bytes32 constant private SEPTEMBER = keccak256(\\\"Sep\\\");\\n    bytes32 constant private OCTOBER = keccak256(\\\"Oct\\\");\\n    bytes32 constant private NOVEMBER = keccak256(\\\"Nov\\\");\\n    bytes32 constant private DECEMBER = keccak256(\\\"Dec\\\");\\n\\n    /// @return the number of the month based on its name.\\n    /// @param _month the first three letters of a month\\u0027s name e.g. \\\"Jan\\\".\\n    function _monthToNumber(string _month) internal pure returns (uint8) {\\n        bytes32 month = keccak256(abi.encodePacked(_month));\\n        if (month == JANUARY) {\\n            return 1;\\n        } else if (month == FEBRUARY) {\\n            return 2;\\n        } else if (month == MARCH) {\\n            return 3;\\n        } else if (month == APRIL) {\\n            return 4;\\n        } else if (month == MAY) {\\n            return 5;\\n        } else if (month == JUNE) {\\n            return 6;\\n        } else if (month == JULY) {\\n            return 7;\\n        } else if (month == AUGUST) {\\n            return 8;\\n        } else if (month == SEPTEMBER) {\\n            return 9;\\n        } else if (month == OCTOBER) {\\n            return 10;\\n        } else if (month == NOVEMBER) {\\n            return 11;\\n        } else if (month == DECEMBER) {\\n            return 12;\\n        } else {\\n            revert(\\\"not a valid month\\\");\\n        }\\n    }\\n}\\n\"},\"ENS.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n *\\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\\n    function setResolver(bytes32 node, address resolver) public;\\n    function setOwner(bytes32 node, address owner) public;\\n    function setTTL(bytes32 node, uint64 ttl) public;\\n    function owner(bytes32 node) public view returns (address);\\n    function resolver(bytes32 node) public view returns (address);\\n    function ttl(bytes32 node) public view returns (uint64);\\n\\n}\\n\"},\"ENSRegistry.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n * \\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n * \\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n * \\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n * \\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n * \\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./ENS.sol\\\";\\n\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENSRegistry is ENS {\\n    struct Record {\\n        address owner;\\n        address resolver;\\n        uint64 ttl;\\n    }\\n\\n    mapping (bytes32 =\\u003e Record) records;\\n\\n    // Permits modifications only by the owner of the specified node.\\n    modifier only_owner(bytes32 node) {\\n        require(records[node].owner == msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructs a new ENS registrar.\\n     */\\n    constructor() public {\\n        records[0x0].owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n     * @param node The node to transfer ownership of.\\n     * @param owner The address of the new owner.\\n     */\\n    function setOwner(bytes32 node, address owner) public only_owner(node) {\\n        emit Transfer(node, owner);\\n        records[node].owner = owner;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n     * @param node The parent node.\\n     * @param label The hash of the label specifying the subnode.\\n     * @param owner The address of the new owner.\\n     */\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        emit NewOwner(node, label, owner);\\n        records[subnode].owner = owner;\\n    }\\n\\n    /**\\n     * @dev Sets the resolver address for the specified node.\\n     * @param node The node to update.\\n     * @param resolver The address of the resolver.\\n     */\\n    function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n        emit NewResolver(node, resolver);   \\n        records[node].resolver = resolver;\\n    }\\n\\n    /**\\n     * @dev Sets the TTL for the specified node.\\n     * @param node The node to update.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n        emit NewTTL(node, ttl);\\n        records[node].ttl = ttl;\\n    }\\n\\n    /**\\n     * @dev Returns the address that owns the specified node.\\n     * @param node The specified node.\\n     * @return address of the owner.\\n     */\\n    function owner(bytes32 node) public view returns (address) {\\n        return records[node].owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the resolver for the specified node.\\n     * @param node The specified node.\\n     * @return address of the resolver.\\n     */\\n    function resolver(bytes32 node) public view returns (address) {\\n        return records[node].resolver;\\n    }\\n\\n    /**\\n     * @dev Returns the TTL of a node, and any records associated with it.\\n     * @param node The specified node.\\n     * @return ttl of the node.\\n     */\\n    function ttl(bytes32 node) public view returns (uint64) {\\n        return records[node].ttl;\\n    }\\n\\n}\\n\"},\"json.sol\":{\"content\":\"/**\\n *  JSON Parser\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./strings.sol\\\";\\nimport \\\"./oraclizeAPI_0.4.25.sol\\\";\\n\\n\\n/// @title JSON provides JSON parsing functionality.\\ncontract JSON is usingOraclize{\\n    using strings for *;\\n\\n    bytes32 constant private prefixHash = keccak256(\\\"{\\\\\\\"ETH\\\\\\\":\\\");\\n\\n    /// @dev Extracts JSON rate value from the response object.\\n    /// @param _json body of the JSON response from the CryptoCompare API.\\n    function parseRate(string _json) public pure returns (string) {\\n\\n        uint json_len = abi.encodePacked(_json).length;\\n        //{\\\"ETH\\\":}.length = 8, assuming a (maximum of) 18 digit prevision\\n        require(json_len \\u003e 8 \\u0026\\u0026 json_len \\u003c= 28, \\\"misformatted input\\\");\\n\\n        bytes memory jsonPrefix = new bytes(7);\\n        copyBytes(abi.encodePacked(_json), 0, 7, jsonPrefix, 0);\\n        require(keccak256(jsonPrefix) == prefixHash, \\\"prefix mismatch\\\");\\n\\n        strings.slice memory body = _json.toSlice();\\n        body.split(\\\":\\\".toSlice()); //we are sure that \\u0027:\\u0027 is included in the string, body now contains the rate+\\u0027}\\u0027\\n        json_len = body._len;\\n        body.until(\\\"}\\\".toSlice());\\n        require(body._len == json_len-1,\\\"not json format\\\"); //ensure that the json is properly terminated with a \\u0027}\\u0027\\n        return body.toString();\\n\\n    }\\n}\\n\"},\"oracle.sol\":{\"content\":\"/**\\n *  Token Exchange Rate Oracle\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n *\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n *\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./date.sol\\\";\\nimport \\\"./json.sol\\\";\\nimport \\\"./parseIntScientific.sol\\\";\\nimport \\\"./strings.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./base64.sol\\\";\\n\\n\\n/// @title Oracle converts ERC20 token amounts into equivalent ether amounts based on cryptocurrency exchange rates.\\ninterface IOracle {\\n    function convert(address, uint) external view returns (bool, uint);\\n}\\n\\n\\n/// @title Oracle provides asset exchange rates and conversion functionality.\\ncontract Oracle is usingOraclize, Base64, Date, JSON, Controllable, ParseIntScientific, IOracle {\\n    using strings for *;\\n    using SafeMath for uint256;\\n\\n\\n    /*******************/\\n    /*     Events     */\\n    /*****************/\\n\\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude);\\n    event RemovedToken(address _sender, address _token);\\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\\n\\n    event SetGasPrice(address _sender, uint _gasPrice);\\n    event Converted(address _sender, address _token, uint _amount, uint _ether);\\n\\n    event RequestedUpdate(string _symbol);\\n    event FailedUpdateRequest(string _reason);\\n\\n    event VerifiedProof(bytes _publicKey, string _result);\\n\\n    event SetCryptoComparePublicKey(address _sender, bytes _publicKey);\\n\\n    /**********************/\\n    /*     Constants     */\\n    /********************/\\n\\n    uint constant private PROOF_LEN = 165;\\n    uint constant private ECDSA_SIG_LEN = 65;\\n    uint constant private ENCODING_BYTES = 2;\\n    uint constant private HEADERS_LEN = PROOF_LEN - 2 * ENCODING_BYTES - ECDSA_SIG_LEN; // 2 bytes encoding headers length + 2 for signature.\\n    uint constant private DIGEST_BASE64_LEN = 44; //base64 encoding of the SHA256 hash (32-bytes) of the result: fixed length.\\n    uint constant private DIGEST_OFFSET = HEADERS_LEN - DIGEST_BASE64_LEN; // the starting position of the result hash in the headers string.\\n\\n    uint constant private MAX_BYTE_SIZE = 256; //for calculating length encoding\\n\\n    struct Token {\\n        string symbol;    // Token symbol\\n        uint magnitude;   // 10^decimals\\n        uint rate;        // Token exchange rate in wei\\n        uint lastUpdate;  // Time of the last rate update\\n        bool exists;      // Flags if the struct is empty or not\\n    }\\n\\n    mapping(address =\\u003e Token) public tokens;\\n    address[] private _tokenAddresses;\\n\\n    bytes public APIPublicKey;\\n    mapping(bytes32 =\\u003e address) private _queryToToken;\\n\\n    /// @dev Construct the oracle with multiple controllers, address resolver and custom gas price.\\n    /// @dev _resolver is the oraclize address resolver contract address.\\n    /// @param _ens is the address of the ENS.\\n    /// @param _controllerName is the ENS name of the Controller.\\n    constructor(address _resolver, address _ens, bytes32 _controllerName) Controllable(_ens, _controllerName) public {\\n        APIPublicKey = hex\\\"a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\\\";\\n        OAR = OraclizeAddrResolverI(_resolver);\\n        oraclize_setCustomGasPrice(10000000000);\\n        oraclize_setProof(proofType_Native);\\n    }\\n\\n    /// @dev Updates the Crypto Compare public API key.\\n    function updateAPIPublicKey(bytes _publicKey) external onlyController {\\n        APIPublicKey = _publicKey;\\n        emit SetCryptoComparePublicKey(msg.sender, _publicKey);\\n    }\\n\\n    /// @dev Sets the gas price used by oraclize query.\\n    function setCustomGasPrice(uint _gasPrice) external onlyController {\\n        oraclize_setCustomGasPrice(_gasPrice);\\n        emit SetGasPrice(msg.sender, _gasPrice);\\n    }\\n\\n    /// @dev Convert ERC20 token amount to the corresponding ether amount (used by the wallet contract).\\n    /// @param _token ERC20 token contract address.\\n    /// @param _amount amount of token in base units.\\n    function convert(address _token, uint _amount) external view returns (bool, uint) {\\n        // Store the token in memory to save map entry lookup gas.\\n        Token storage token = tokens[_token];\\n        // If the token exists require that its rate is not zero\\n        if (token.exists) {\\n            require(token.rate != 0, \\\"token rate is 0\\\");\\n            // Safely convert the token amount to ether based on the exchange rate.\\n            // return the value and a \\u0027true\\u0027 implying that the token is protected\\n            return (true, _amount.mul(token.rate).div(token.magnitude));\\n        }\\n        // this returns a \\u0027false\\u0027 to imply that a card is not protected \\n        return (false, 0);\\n        \\n    }\\n\\n    /// @dev Add ERC20 tokens to the list of supported tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    /// @param _symbols ERC20 token names.\\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\\n    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, uint _updateDate) external onlyController {\\n        // Require that all parameters have the same length.\\n        require(_tokens.length == _symbols.length \\u0026\\u0026 _tokens.length == _magnitude.length, \\\"parameter lengths do not match\\\");\\n        // Add each token to the list of supported tokens.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            // Require that the token doesn\\u0027t already exist.\\n            address token = _tokens[i];\\n            require(!tokens[token].exists, \\\"token already exists\\\");\\n            // Store the intermediate values.\\n            string memory symbol = _symbols[i].toSliceB32().toString();\\n            uint magnitude = _magnitude[i];\\n            // Add the token to the token list.\\n            tokens[token] = Token({\\n                symbol : symbol,\\n                magnitude : magnitude,\\n                rate : 0,\\n                exists : true,\\n                lastUpdate: _updateDate\\n            });\\n            // Add the token address to the address list.\\n            _tokenAddresses.push(token);\\n            // Emit token addition event.\\n            emit AddedToken(msg.sender, token, symbol, magnitude);\\n        }\\n    }\\n\\n    /// @dev Remove ERC20 tokens from the list of supported tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    function removeTokens(address[] _tokens) external onlyController {\\n        // Delete each token object from the list of supported tokens based on the addresses provided.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            //token must exist, reverts on duplicates as well\\n            require(tokens[_tokens[i]].exists, \\\"token does not exist\\\");\\n            // Store the token address.\\n            address token = _tokens[i];\\n            // Delete the token object.\\n            delete tokens[token];\\n            // Remove the token address from the address list.\\n            for (uint j = 0; j \\u003c _tokenAddresses.length.sub(1); j++) {\\n                if (_tokenAddresses[j] == token) {\\n                    _tokenAddresses[j] = _tokenAddresses[_tokenAddresses.length.sub(1)];\\n                    break;\\n                }\\n            }\\n            _tokenAddresses.length--;\\n            // Emit token removal event.\\n            emit RemovedToken(msg.sender, token);\\n        }\\n    }\\n\\n    /// @dev Update ERC20 token exchange rate manually.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _rate ERC20 token exchange rate in wei.\\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyController {\\n        // Require that the token exists.\\n        require(tokens[_token].exists, \\\"token does not exist\\\");\\n        // Update the token\\u0027s rate.\\n        tokens[_token].rate = _rate;\\n        // Update the token\\u0027s last update timestamp.\\n        tokens[_token].lastUpdate = _updateDate;\\n        // Emit the rate update event.\\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\\n    }\\n\\n    /// @dev Update ERC20 token exchange rates for all supported tokens.\\n    //// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\\n    function updateTokenRates(uint _gasLimit) external payable onlyController {\\n        _updateTokenRates(_gasLimit);\\n    }\\n\\n    //// @dev Withdraw ether from the smart contract to the specified account.\\n    function withdraw(address _to, uint _amount) external onlyController {\\n        _to.transfer(_amount);\\n    }\\n\\n    //// @dev Handle Oraclize query callback and verifiy the provided origin proof.\\n    //// @param _queryID Oraclize query ID.\\n    //// @param _result query result in JSON format.\\n    //// @param _proof origin proof from crypto compare.\\n    // solium-disable-next-line mixedcase\\n    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\\n        // Require that the caller is the Oraclize contract.\\n        require(msg.sender == oraclize_cbAddress(), \\\"sender is not oraclize\\\");\\n        // Use the query ID to find the matching token address.\\n        address _token = _queryToToken[_queryID];\\n        require(_token != address(0), \\\"queryID matches to address 0\\\");\\n        // Get the corresponding token object.\\n        Token storage token = tokens[_token];\\n\\n        bool valid;\\n        uint timestamp;\\n        (valid, timestamp) = _verifyProof(_result, _proof, APIPublicKey, token.lastUpdate);\\n\\n        // Require that the proof is valid.\\n        if (valid) {\\n            // Parse the JSON result to get the rate in wei.\\n            token.rate = _parseIntScientificWei(parseRate(_result));\\n            // Set the update time of the token rate.\\n            token.lastUpdate = timestamp;\\n            // Remove query from the list.\\n            delete _queryToToken[_queryID];\\n            // Emit the rate update event.\\n            emit UpdatedTokenRate(msg.sender, _token, token.rate);\\n        }\\n    }\\n\\n    /// @dev Re-usable helper function that performs the Oraclize Query.\\n    //// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\\n    function _updateTokenRates(uint _gasLimit) private {\\n        // Check if there are any existing tokens.\\n        if (_tokenAddresses.length == 0) {\\n            // Emit a query failure event.\\n            emit FailedUpdateRequest(\\\"no tokens\\\");\\n        // Check if the contract has enough Ether to pay for the query.\\n        } else if (oraclize_getPrice(\\\"URL\\\") * _tokenAddresses.length \\u003e address(this).balance) {\\n            // Emit a query failure event.\\n            emit FailedUpdateRequest(\\\"insufficient balance\\\");\\n        } else {\\n            // Set up the cryptocompare API query strings.\\n            strings.slice memory apiPrefix = \\\"https://min-api.cryptocompare.com/data/price?fsym=\\\".toSlice();\\n            strings.slice memory apiSuffix = \\\"\\u0026tsyms=ETH\\u0026sign=true\\\".toSlice();\\n\\n            // Create a new oraclize query for each supported token.\\n            for (uint i = 0; i \\u003c _tokenAddresses.length; i++) {\\n                // Store the token symbol used in the query.\\n                strings.slice memory symbol = tokens[_tokenAddresses[i]].symbol.toSlice();\\n                // Create a new oraclize query from the component strings.\\n                bytes32 queryID = oraclize_query(\\\"URL\\\", apiPrefix.concat(symbol).toSlice().concat(apiSuffix), _gasLimit);\\n                // Store the query ID together with the associated token address.\\n                _queryToToken[queryID] = _tokenAddresses[i];\\n                // Emit the query success event.\\n                emit RequestedUpdate(symbol.toString());\\n            }\\n        }\\n    }\\n\\n    /// @dev Verify the origin proof returned by the cryptocompare API.\\n    /// @param _result query result in JSON format.\\n    /// @param _proof origin proof from cryptocompare.\\n    /// @param _publicKey cryptocompare public key.\\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\\n    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\\n\\n        //expecting fixed length proofs\\n        if (_proof.length != PROOF_LEN)\\n          revert(\\\"invalid proof length\\\");\\n\\n        //proof should be 65 bytes long: R (32 bytes) + S (32 bytes) + v (1 byte)\\n        if (uint(_proof[1]) != ECDSA_SIG_LEN)\\n          revert(\\\"invalid signature length\\\");\\n\\n        bytes memory signature = new bytes(ECDSA_SIG_LEN);\\n\\n        signature = copyBytes(_proof, 2, ECDSA_SIG_LEN, signature, 0);\\n\\n        // Extract the headers, big endian encoding of headers length\\n        if (uint(_proof[ENCODING_BYTES + ECDSA_SIG_LEN]) * MAX_BYTE_SIZE + uint(_proof[ENCODING_BYTES + ECDSA_SIG_LEN + 1]) != HEADERS_LEN)\\n          revert(\\\"invalid headers length\\\");\\n\\n        bytes memory headers = new bytes(HEADERS_LEN);\\n        headers = copyBytes(_proof, 2*ENCODING_BYTES + ECDSA_SIG_LEN, HEADERS_LEN, headers, 0);\\n\\n        // Check if the signature is valid and if the signer address is matching.\\n        if (!_verifySignature(headers, signature, _publicKey)) {\\n            revert(\\\"invalid signature\\\");\\n        }\\n\\n        // Check if the date is valid.\\n        bytes memory dateHeader = new bytes(20);\\n        //keep only the relevant string(e.g. \\\"16 Nov 2018 16:22:18\\\")\\n        dateHeader = copyBytes(headers, 11, 20, dateHeader, 0);\\n\\n        bool dateValid;\\n        uint timestamp;\\n        (dateValid, timestamp) = _verifyDate(string(dateHeader), _lastUpdate);\\n\\n        // Check whether the date returned is valid or not\\n        if (!dateValid)\\n            revert(\\\"invalid date\\\");\\n\\n        // Check if the signed digest hash matches the result hash.\\n        bytes memory digest = new bytes(DIGEST_BASE64_LEN);\\n        digest = copyBytes(headers, DIGEST_OFFSET, DIGEST_BASE64_LEN, digest, 0);\\n\\n        if (keccak256(abi.encodePacked(sha256(abi.encodePacked(_result)))) != keccak256(_base64decode(digest)))\\n          revert(\\\"result hash not matching\\\");\\n\\n        emit VerifiedProof(_publicKey, _result);\\n        return (true, timestamp);\\n    }\\n\\n    /// @dev Verify the HTTP headers and the signature\\n    /// @param _headers HTTP headers provided by the cryptocompare api\\n    /// @param _signature signature provided by the cryptocompare api\\n    /// @param _publicKey cryptocompare public key.\\n    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\\n        address signer;\\n        bool signatureOK;\\n\\n        // Checks if the signature is valid by hashing the headers\\n        (signatureOK, signer) = ecrecovery(sha256(_headers), _signature);\\n        return signatureOK \\u0026\\u0026 signer == address(keccak256(_publicKey));\\n    }\\n\\n    /// @dev Verify the signed HTTP date header.\\n    /// @param _dateHeader extracted date string e.g. Wed, 12 Sep 2018 15:18:14 GMT.\\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\\n    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\\n\\n        //called by verifyProof(), _dateHeader is always a string of length = 20\\n        assert(abi.encodePacked(_dateHeader).length == 20);\\n\\n        //Split the date string and get individual date components.\\n        strings.slice memory date = _dateHeader.toSlice();\\n        strings.slice memory timeDelimiter = \\\":\\\".toSlice();\\n        strings.slice memory dateDelimiter = \\\" \\\".toSlice();\\n\\n        uint day = _parseIntScientific(date.split(dateDelimiter).toString());\\n        require(day \\u003e 0 \\u0026\\u0026 day \\u003c 32, \\\"day error\\\");\\n\\n        uint month = _monthToNumber(date.split(dateDelimiter).toString());\\n        require(month \\u003e 0 \\u0026\\u0026 month \\u003c 13, \\\"month error\\\");\\n\\n        uint year = _parseIntScientific(date.split(dateDelimiter).toString());\\n        require(year \\u003e 2017 \\u0026\\u0026 year \\u003c 3000, \\\"year error\\\");\\n\\n        uint hour = _parseIntScientific(date.split(timeDelimiter).toString());\\n        require(hour \\u003c 25, \\\"hour error\\\");\\n\\n        uint minute = _parseIntScientific(date.split(timeDelimiter).toString());\\n        require(minute \\u003c 60, \\\"minute error\\\");\\n\\n        uint second = _parseIntScientific(date.split(timeDelimiter).toString());\\n        require(second \\u003c 60, \\\"second error\\\");\\n\\n        uint timestamp = year * (10 ** 10) + month * (10 ** 8) + day * (10 ** 6) + hour * (10 ** 4) + minute * (10 ** 2) + second;\\n\\n        return (timestamp \\u003e _lastUpdate, timestamp);\\n    }\\n}\\n\"},\"oraclize-resolver.sol\":{\"content\":\"/**\\n *  OraclizeResolver\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./controllable.sol\\\";\\n\\n\\n/// @title OraclizeResolver implements on-chain contract address resolution.\\ncontract OraclizeResolver is Controllable {\\n\\n    address private _address;\\n\\n    /// @dev Constructor initializes the resolver target and sets up controller authentication.\\n    /// @param _target initial address of the target contract.\\n    /// @param _ens is the address of the ENS registry.\\n    /// @param _controllerName is the registered ENS name for the controller contract.\\n    constructor(address _target, address _ens, bytes32 _controllerName) Controllable(_ens, _controllerName) public {\\n        _address = _target;\\n    }\\n\\n    /// @return the address of the target contract.\\n    /// @notice this function is compatible with the oraclize contract API.\\n    function getAddress() public view returns (address) {\\n        return _address;\\n    }\\n\\n    /// @dev Sets the address of the target contract.\\n    /// @param _target new address of the target contract.\\n    function setAddress(address _target) public onlyController {\\n        _address = _target;\\n    }\\n}\\n\"},\"oraclizeAPI_0.4.25.sol\":{\"content\":\"// \\u003cORACLIZE_API\\u003e\\n// Release targetted at solc 0.4.25 to silence compiler warning/error messages, compatible down to 0.4.22\\n/*\\nCopyright (c) 2015-2016 Oraclize SRL\\nCopyright (c) 2016 Oraclize LTD\\n\\n\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\n\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\n\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n*/\\n\\n// This api is currently targeted at 0.4.22 to 0.4.25 (stable builds), please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\\n\\npragma solidity \\u003e=0.4.22;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\\n\\ncontract OraclizeI {\\n    address public cbAddress;\\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\\n    function getPrice(string _datasource) public returns (uint _dsprice);\\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\\n    function setProofType(byte _proofType) external;\\n    function setCustomGasPrice(uint _gasPrice) external;\\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\\n}\\n\\ncontract OraclizeAddrResolverI {\\n    function getAddress() public returns (address _addr);\\n}\\n\\n/*\\nBegin solidity-cborutils\\n\\nhttps://github.com/smartcontractkit/solidity-cborutils\\n\\nMIT License\\n\\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n */\\n\\nlibrary Buffer {\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    function init(buffer memory buf, uint _capacity) internal pure {\\n        uint capacity = _capacity;\\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(ptr, capacity))\\n        }\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if(a \\u003e b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n     * @dev Appends a byte array to the end of the buffer. Resizes if doing so\\n     *      would exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\\n        if(data.length + buf.buf.length \\u003e buf.capacity) {\\n            resize(buf, max(buf.capacity, data.length) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        uint len = data.length;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + buffer length + sizeof(buffer length)\\n            dest := add(add(bufptr, buflen), 32)\\n            // Update buffer length\\n            mstore(bufptr, add(buflen, mload(data)))\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for(; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function append(buffer memory buf, uint8 data) internal pure {\\n        if(buf.buf.length + 1 \\u003e buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + buffer length + sizeof(buffer length)\\n            let dest := add(add(bufptr, buflen), 32)\\n            mstore8(dest, data)\\n            // Update buffer length\\n            mstore(bufptr, add(buflen, 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        if(len + buf.buf.length \\u003e buf.capacity) {\\n            resize(buf, max(buf.capacity, len) * 2);\\n        }\\n\\n        uint mask = 256 ** len - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, buflen), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length\\n            mstore(bufptr, add(buflen, len))\\n        }\\n        return buf;\\n    }\\n}\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\\n        if(value \\u003c= 23) {\\n            buf.append(uint8((major \\u003c\\u003c 5) | value));\\n        } else if(value \\u003c= 0xFF) {\\n            buf.append(uint8((major \\u003c\\u003c 5) | 24));\\n            buf.appendInt(value, 1);\\n        } else if(value \\u003c= 0xFFFF) {\\n            buf.append(uint8((major \\u003c\\u003c 5) | 25));\\n            buf.appendInt(value, 2);\\n        } else if(value \\u003c= 0xFFFFFFFF) {\\n            buf.append(uint8((major \\u003c\\u003c 5) | 26));\\n            buf.appendInt(value, 4);\\n        } else if(value \\u003c= 0xFFFFFFFFFFFFFFFF) {\\n            buf.append(uint8((major \\u003c\\u003c 5) | 27));\\n            buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\\n        buf.append(uint8((major \\u003c\\u003c 5) | 31));\\n    }\\n\\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\\n        encodeType(buf, MAJOR_TYPE_INT, value);\\n    }\\n\\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\\n        if(value \\u003e= 0) {\\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\\n        } else {\\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\\n        }\\n    }\\n\\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\\n        buf.append(value);\\n    }\\n\\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\\n        buf.append(bytes(value));\\n    }\\n\\n    function startArray(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n    }\\n\\n    function startMap(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n    }\\n\\n    function endSequence(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n    }\\n}\\n\\n/*\\nEnd solidity-cborutils\\n */\\n\\ncontract usingOraclize {\\n    uint constant day = 60*60*24;\\n    uint constant week = 60*60*24*7;\\n    uint constant month = 60*60*24*30;\\n    byte constant proofType_NONE = 0x00;\\n    byte constant proofType_TLSNotary = 0x10;\\n    byte constant proofType_Ledger = 0x30;\\n    byte constant proofType_Android = 0x40;\\n    byte constant proofType_Native = 0xF0;\\n    byte constant proofStorage_IPFS = 0x01;\\n    uint8 constant networkID_auto = 0;\\n    uint8 constant networkID_mainnet = 1;\\n    uint8 constant networkID_testnet = 2;\\n    uint8 constant networkID_morden = 2;\\n    uint8 constant networkID_consensys = 161;\\n\\n    OraclizeAddrResolverI OAR;\\n\\n    OraclizeI oraclize;\\n    modifier oraclizeAPI {\\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\\n            oraclize_setNetwork(networkID_auto);\\n\\n        if(address(oraclize) != OAR.getAddress())\\n            oraclize = OraclizeI(OAR.getAddress());\\n\\n        _;\\n    }\\n    modifier coupon(string code){\\n        oraclize = OraclizeI(OAR.getAddress());\\n        _;\\n    }\\n\\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\\n      return oraclize_setNetwork();\\n      networkID; // silence the warning and remain backwards compatible\\n    }\\n    function oraclize_setNetwork() internal returns(bool){\\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)\\u003e0){ //mainnet\\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\\n            oraclize_setNetworkName(\\\"eth_mainnet\\\");\\n            return true;\\n        }\\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)\\u003e0){ //ropsten testnet\\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\\n            oraclize_setNetworkName(\\\"eth_ropsten3\\\");\\n            return true;\\n        }\\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)\\u003e0){ //kovan testnet\\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\\n            oraclize_setNetworkName(\\\"eth_kovan\\\");\\n            return true;\\n        }\\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)\\u003e0){ //rinkeby testnet\\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\\n            oraclize_setNetworkName(\\\"eth_rinkeby\\\");\\n            return true;\\n        }\\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)\\u003e0){ //ethereum-bridge\\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\\n            return true;\\n        }\\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)\\u003e0){ //ether.camp ide\\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\\n            return true;\\n        }\\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)\\u003e0){ //browser-solidity\\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function __callback(bytes32 myid, string result) public {\\n        __callback(myid, result, new bytes(0));\\n    }\\n    function __callback(bytes32 myid, string result, bytes proof) public {\\n      return;\\n      // Following should never be reached with a preceding return, however\\n      // this is just a placeholder function, ideally meant to be defined in\\n      // child contract when proofs are used\\n      myid; result; proof; // Silence compiler warnings\\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \\n    }\\n\\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\\n        return oraclize.getPrice(datasource);\\n    }\\n\\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\\n        return oraclize.getPrice(datasource, gaslimit);\\n    }\\n\\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        return oraclize.query.value(price)(0, datasource, arg);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        return oraclize.query.value(price)(timestamp, datasource, arg);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        bytes memory args = stra2cbor(argN);\\n        return oraclize.queryN.value(price)(0, datasource, args);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        bytes memory args = stra2cbor(argN);\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        bytes memory args = stra2cbor(argN);\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        bytes memory args = stra2cbor(argN);\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n\\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n\\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        string[] memory dynargs = new string[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        bytes memory args = ba2cbor(argN);\\n        return oraclize.queryN.value(price)(0, datasource, args);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource);\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\n        bytes memory args = ba2cbor(argN);\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        bytes memory args = ba2cbor(argN);\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\n        bytes memory args = ba2cbor(argN);\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](1);\\n        dynargs[0] = args[0];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n\\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](2);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](3);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n\\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](4);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(timestamp, datasource, dynargs);\\n    }\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\n    }\\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\n        bytes[] memory dynargs = new bytes[](5);\\n        dynargs[0] = args[0];\\n        dynargs[1] = args[1];\\n        dynargs[2] = args[2];\\n        dynargs[3] = args[3];\\n        dynargs[4] = args[4];\\n        return oraclize_query(datasource, dynargs, gaslimit);\\n    }\\n\\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\\n        return oraclize.cbAddress();\\n    }\\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\\n        return oraclize.setProofType(proofP);\\n    }\\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\\n        return oraclize.setCustomGasPrice(gasPrice);\\n    }\\n\\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\\n        return oraclize.randomDS_getSessionPubKeyHash();\\n    }\\n\\n    function getCodeSize(address _addr) view internal returns(uint _size) {\\n        assembly {\\n            _size := extcodesize(_addr)\\n        }\\n    }\\n\\n    function parseAddr(string _a) internal pure returns (address){\\n        bytes memory tmp = bytes(_a);\\n        uint160 iaddr = 0;\\n        uint160 b1;\\n        uint160 b2;\\n        for (uint i=2; i\\u003c2+2*20; i+=2){\\n            iaddr *= 256;\\n            b1 = uint160(tmp[i]);\\n            b2 = uint160(tmp[i+1]);\\n            if ((b1 \\u003e= 97)\\u0026\\u0026(b1 \\u003c= 102)) b1 -= 87;\\n            else if ((b1 \\u003e= 65)\\u0026\\u0026(b1 \\u003c= 70)) b1 -= 55;\\n            else if ((b1 \\u003e= 48)\\u0026\\u0026(b1 \\u003c= 57)) b1 -= 48;\\n            if ((b2 \\u003e= 97)\\u0026\\u0026(b2 \\u003c= 102)) b2 -= 87;\\n            else if ((b2 \\u003e= 65)\\u0026\\u0026(b2 \\u003c= 70)) b2 -= 55;\\n            else if ((b2 \\u003e= 48)\\u0026\\u0026(b2 \\u003c= 57)) b2 -= 48;\\n            iaddr += (b1*16+b2);\\n        }\\n        return address(iaddr);\\n    }\\n\\n    function strCompare(string _a, string _b) internal pure returns (int) {\\n        bytes memory a = bytes(_a);\\n        bytes memory b = bytes(_b);\\n        uint minLength = a.length;\\n        if (b.length \\u003c minLength) minLength = b.length;\\n        for (uint i = 0; i \\u003c minLength; i ++)\\n            if (a[i] \\u003c b[i])\\n                return -1;\\n            else if (a[i] \\u003e b[i])\\n                return 1;\\n        if (a.length \\u003c b.length)\\n            return -1;\\n        else if (a.length \\u003e b.length)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n\\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\\n        bytes memory h = bytes(_haystack);\\n        bytes memory n = bytes(_needle);\\n        if(h.length \\u003c 1 || n.length \\u003c 1 || (n.length \\u003e h.length))\\n            return -1;\\n        else if(h.length \\u003e (2**128 -1))\\n            return -1;\\n        else\\n        {\\n            uint subindex = 0;\\n            for (uint i = 0; i \\u003c h.length; i ++)\\n            {\\n                if (h[i] == n[0])\\n                {\\n                    subindex = 1;\\n                    while(subindex \\u003c n.length \\u0026\\u0026 (i + subindex) \\u003c h.length \\u0026\\u0026 h[i + subindex] == n[subindex])\\n                    {\\n                        subindex++;\\n                    }\\n                    if(subindex == n.length)\\n                        return int(i);\\n                }\\n            }\\n            return -1;\\n        }\\n    }\\n\\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory _bc = bytes(_c);\\n        bytes memory _bd = bytes(_d);\\n        bytes memory _be = bytes(_e);\\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\n        bytes memory babcde = bytes(abcde);\\n        uint k = 0;\\n        for (uint i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\n        for (i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\n        for (i = 0; i \\u003c _bc.length; i++) babcde[k++] = _bc[i];\\n        for (i = 0; i \\u003c _bd.length; i++) babcde[k++] = _bd[i];\\n        for (i = 0; i \\u003c _be.length; i++) babcde[k++] = _be[i];\\n        return string(babcde);\\n    }\\n\\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\n    }\\n\\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\n    }\\n\\n    function strConcat(string _a, string _b) internal pure returns (string) {\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\n    }\\n\\n    // parseInt\\n    function parseInt(string _a) internal pure returns (uint) {\\n        return parseInt(_a, 0);\\n    }\\n\\n    // parseInt(parseFloat*10^_b)\\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\\n        bytes memory bresult = bytes(_a);\\n        uint mint = 0;\\n        bool decimals = false;\\n        for (uint i=0; i\\u003cbresult.length; i++){\\n            if ((bresult[i] \\u003e= 48)\\u0026\\u0026(bresult[i] \\u003c= 57)){\\n                if (decimals){\\n                   if (_b == 0) break;\\n                    else _b--;\\n                }\\n                mint *= 10;\\n                mint += uint(bresult[i]) - 48;\\n            } else if (bresult[i] == 46) decimals = true;\\n        }\\n        if (_b \\u003e 0) mint *= 10**_b;\\n        return mint;\\n    }\\n\\n    function uint2str(uint i) internal pure returns (string){\\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint len;\\n        while (j != 0){\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len - 1;\\n        while (i != 0){\\n            bstr[k--] = byte(48 + i % 10);\\n            i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    using CBOR for Buffer.buffer;\\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\\n        safeMemoryCleaner();\\n        Buffer.buffer memory buf;\\n        Buffer.init(buf, 1024);\\n        buf.startArray();\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\n            buf.encodeString(arr[i]);\\n        }\\n        buf.endSequence();\\n        return buf.buf;\\n    }\\n\\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\\n        safeMemoryCleaner();\\n        Buffer.buffer memory buf;\\n        Buffer.init(buf, 1024);\\n        buf.startArray();\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\n            buf.encodeBytes(arr[i]);\\n        }\\n        buf.endSequence();\\n        return buf.buf;\\n    }\\n\\n    string oraclize_network_name;\\n    function oraclize_setNetworkName(string _network_name) internal {\\n        oraclize_network_name = _network_name;\\n    }\\n\\n    function oraclize_getNetworkName() internal view returns (string) {\\n        return oraclize_network_name;\\n    }\\n\\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\\n        require((_nbytes \\u003e 0) \\u0026\\u0026 (_nbytes \\u003c= 32));\\n        // Convert from seconds to ledger timer ticks\\n        _delay *= 10;\\n        bytes memory nbytes = new bytes(1);\\n        nbytes[0] = byte(_nbytes);\\n        bytes memory unonce = new bytes(32);\\n        bytes memory sessionKeyHash = new bytes(32);\\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\\n        assembly {\\n            mstore(unonce, 0x20)\\n            // the following variables can be relaxed\\n            // check relaxed random contract under ethereum-examples repo\\n            // for an idea on how to override and replace comit hash vars\\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\\n            mstore(sessionKeyHash, 0x20)\\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\\n        }\\n        bytes memory delay = new bytes(32);\\n        assembly {\\n            mstore(add(delay, 0x20), _delay)\\n        }\\n\\n        bytes memory delay_bytes8 = new bytes(8);\\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\\n\\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\\n        bytes32 queryId = oraclize_query(\\\"random\\\", args, _customGasLimit);\\n\\n        bytes memory delay_bytes8_left = new bytes(8);\\n\\n        assembly {\\n            let x := mload(add(delay_bytes8, 0x20))\\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\\n\\n        }\\n\\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\\n        return queryId;\\n    }\\n\\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\\n        oraclize_randomDS_args[queryId] = commitment;\\n    }\\n\\n    mapping(bytes32=\\u003ebytes32) oraclize_randomDS_args;\\n    mapping(bytes32=\\u003ebool) oraclize_randomDS_sessionKeysHashVerified;\\n\\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\\n        bool sigok;\\n        address signer;\\n\\n        bytes32 sigr;\\n        bytes32 sigs;\\n\\n        bytes memory sigr_ = new bytes(32);\\n        uint offset = 4+(uint(dersig[3]) - 0x20);\\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\\n        bytes memory sigs_ = new bytes(32);\\n        offset += 32 + 2;\\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\\n\\n        assembly {\\n            sigr := mload(add(sigr_, 32))\\n            sigs := mload(add(sigs_, 32))\\n        }\\n\\n\\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\\n        if (address(keccak256(pubkey)) == signer) return true;\\n        else {\\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\\n            return (address(keccak256(pubkey)) == signer);\\n        }\\n    }\\n\\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\\n        bool sigok;\\n\\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\\n\\n        bytes memory appkey1_pubkey = new bytes(64);\\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\\n\\n        bytes memory tosign2 = new bytes(1+65+32);\\n        tosign2[0] = byte(1); //role\\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\\n        bytes memory CODEHASH = hex\\\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\\\";\\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\\n\\n        if (sigok == false) return false;\\n\\n\\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\\n        bytes memory LEDGERKEY = hex\\\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\\\";\\n\\n        bytes memory tosign3 = new bytes(1+65);\\n        tosign3[0] = 0xFE;\\n        copyBytes(proof, 3, 65, tosign3, 1);\\n\\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\\n\\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\\n\\n        return sigok;\\n    }\\n\\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\n        require((_proof[0] == \\\"L\\\") \\u0026\\u0026 (_proof[1] == \\\"P\\\") \\u0026\\u0026 (_proof[2] == 1));\\n\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\n        require(proofVerified);\\n\\n        _;\\n    }\\n\\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\n        if ((_proof[0] != \\\"L\\\")||(_proof[1] != \\\"P\\\")||(_proof[2] != 1)) return 1;\\n\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\n        if (proofVerified == false) return 2;\\n\\n        return 0;\\n    }\\n\\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\\n        bool match_ = true;\\n\\n        require(prefix.length == n_random_bytes);\\n\\n        for (uint256 i=0; i\\u003c n_random_bytes; i++) {\\n            if (content[i] != prefix[i]) match_ = false;\\n        }\\n\\n        return match_;\\n    }\\n\\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\\n\\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\\n        bytes memory keyhash = new bytes(32);\\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\\n\\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\\n\\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if \\u0027result\\u0027 is the prefix of sha256(sig1)\\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\\n\\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\\n        // This is to verify that the computed args match with the ones specified in the query.\\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\\n\\n        bytes memory sessionPubkey = new bytes(64);\\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\\n\\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\\n            delete oraclize_randomDS_args[queryId];\\n        } else return false;\\n\\n\\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\\n        bytes memory tosign1 = new bytes(32+8+1+32);\\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\\n\\n        // verify if sessionPubkeyHash was verified already, if not.. let\\u0027s do it!\\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\\n        }\\n\\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\\n    }\\n\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\\n        uint minLength = length + toOffset;\\n\\n        // Buffer too small\\n        require(to.length \\u003e= minLength); // Should be a better way?\\n\\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\\n        uint i = 32 + fromOffset;\\n        uint j = 32 + toOffset;\\n\\n        while (i \\u003c (32 + fromOffset + length)) {\\n            assembly {\\n                let tmp := mload(add(from, i))\\n                mstore(add(to, j), tmp)\\n            }\\n            i += 32;\\n            j += 32;\\n        }\\n\\n        return to;\\n    }\\n\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\n    // Duplicate Solidity\\u0027s ecrecover, but catching the CALL return value\\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\\n        // We do our own memory management here. Solidity uses memory offset\\n        // 0x40 to store the current end of memory. We write past it (as\\n        // writes are memory extensions), but don\\u0027t update the offset so\\n        // Solidity will reuse it. The memory used here is only needed for\\n        // this context.\\n\\n        // FIXME: inline assembly can\\u0027t access return values\\n        bool ret;\\n        address addr;\\n\\n        assembly {\\n            let size := mload(0x40)\\n            mstore(size, hash)\\n            mstore(add(size, 32), v)\\n            mstore(add(size, 64), r)\\n            mstore(add(size, 96), s)\\n\\n            // NOTE: we can reuse the request memory because we deal with\\n            //       the return code\\n            ret := call(3000, 1, 0, size, 128, size, 32)\\n            addr := mload(size)\\n        }\\n\\n        return (ret, addr);\\n    }\\n\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65)\\n          return (false, 0);\\n\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n\\n            // Here we are loading the last 32 bytes. We exploit the fact that\\n            // \\u0027mload\\u0027 will pad with zeroes if we overread.\\n            // There is no \\u0027mload8\\u0027 to do this, but that would be nicer.\\n            v := byte(0, mload(add(sig, 96)))\\n\\n            // Alternative solution:\\n            // \\u0027byte\\u0027 is not working due to the Solidity parser, so lets\\n            // use the second best option, \\u0027and\\u0027\\n            // v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\\n        // to match the YP range of [27, 28]\\n        //\\n        // geth uses [0, 1] and some clients have followed. This might change, see:\\n        //  https://github.com/ethereum/go-ethereum/issues/2053\\n        if (v \\u003c 27)\\n          v += 27;\\n\\n        if (v != 27 \\u0026\\u0026 v != 28)\\n            return (false, 0);\\n\\n        return safer_ecrecover(hash, v, r, s);\\n    }\\n\\n    function safeMemoryCleaner() internal pure {\\n        assembly {\\n            let fmem := mload(0x40)\\n            codecopy(fmem, codesize, sub(msize, fmem))\\n        }\\n    }\\n\\n}\\n// \\u003c/ORACLIZE_API\\u003e\\n\"},\"oraclizeConnector.sol\":{\"content\":\"/*\\nCopyright (c) 2015-2016 Oraclize SRL\\nCopyright (c) 2016-2017 Oraclize LTD\\n*/\\n\\n/*\\nOraclize Connector v1.2.0\\n*/\\n\\n// \\u0027compressed\\u0027 alternative, where all modifiers have been changed to FUNCTIONS\\n// which is cheaper for deployment, potentially cheaper execution\\n\\npragma solidity ^0.4.11;\\n\\ncontract Oraclize {\\n    mapping (address =\\u003e uint) reqc;\\n\\n    mapping (address =\\u003e byte) public cbAddresses;\\n\\n    mapping (address =\\u003e bool) public offchainPayment;\\n\\n    event Log1(address sender, bytes32 cid, uint timestamp, string datasource, string arg, uint gaslimit, byte proofType, uint gasPrice);\\n    event Log2(address sender, bytes32 cid, uint timestamp, string datasource, string arg1, string arg2, uint gaslimit, byte proofType, uint gasPrice);\\n    event LogN(address sender, bytes32 cid, uint timestamp, string datasource, bytes args, uint gaslimit, byte proofType, uint gasPrice);\\n    event Log1_fnc(address sender, bytes32 cid, uint timestamp, string datasource, string arg, function() external callback, uint gaslimit, byte proofType, uint gasPrice);\\n    event Log2_fnc(address sender, bytes32 cid, uint timestamp, string datasource, string arg1, string arg2, function() external callback, uint gaslimit, byte proofType, uint gasPrice);\\n    event LogN_fnc(address sender, bytes32 cid, uint timestamp, string datasource, bytes args, function() external callback, uint gaslimit, byte proofType, uint gasPrice);\\n\\n    event Emit_OffchainPaymentFlag(address indexed idx_sender, address sender, bool indexed idx_flag, bool flag);\\n\\n    address owner;\\n    address paymentFlagger;\\n\\n    function changeAdmin(address _newAdmin)\\n    external\\n    {\\n        onlyadmin();\\n        owner = _newAdmin;\\n    }\\n\\n    function changePaymentFlagger(address _newFlagger)\\n    external\\n    {\\n        onlyadmin();\\n        paymentFlagger = _newFlagger;\\n    }\\n\\n    function addCbAddress(address newCbAddress, byte addressType)\\n    external\\n    {\\n        onlyadmin();\\n        //bytes memory nil = \\u0027\\u0027;\\n        addCbAddress(newCbAddress, addressType, hex\\u0027\\u0027);\\n    }\\n\\n    // proof is currently a placeholder for when associated proof for addressType is added\\n    function addCbAddress(address newCbAddress, byte addressType, bytes proof)\\n    public\\n    {\\n        onlyadmin();\\n        cbAddresses[newCbAddress] = addressType;\\n    }\\n\\n    function removeCbAddress(address newCbAddress)\\n    external\\n    {\\n        onlyadmin();\\n        delete cbAddresses[newCbAddress];\\n    }\\n\\n    function cbAddress()\\n    constant\\n    returns (address _cbAddress)\\n    {\\n        if (cbAddresses[tx.origin] != 0)\\n            _cbAddress = tx.origin;\\n    }\\n\\n    function addDSource(string dsname, uint multiplier)\\n    external\\n    {\\n        addDSource(dsname, 0x00, multiplier);\\n    }\\n\\n    function addDSource(string dsname, byte proofType, uint multiplier)\\n    public\\n    {\\n        onlyadmin();\\n        bytes32 dsname_hash = sha3(dsname, proofType);\\n        dsources[dsources.length++] = dsname_hash;\\n        price_multiplier[dsname_hash] = multiplier;\\n    }\\n\\n    // Utilized by bridge\\n    function multiAddDSource(bytes32[] dsHash, uint256[] multiplier)\\n    external\\n    {\\n        onlyadmin();\\n        // dsHash -\\u003e sha3(DATASOURCE_NAME, PROOF_TYPE);\\n        for (uint i=0; i\\u003cdsHash.length; i++) {\\n            dsources[dsources.length++] = dsHash[i];\\n            price_multiplier[dsHash[i]] = multiplier[i];\\n        }\\n    }\\n\\n    function multisetProofType(uint[] _proofType, address[] _addr)\\n    external\\n    {\\n        onlyadmin();\\n        for (uint i=0; i\\u003c_addr.length; i++) addr_proofType[_addr[i]] = byte(_proofType[i]);\\n    }\\n\\n    function multisetCustomGasPrice(uint[] _gasPrice, address[] _addr)\\n    external\\n    {\\n        onlyadmin();\\n        for (uint i=0; i\\u003c_addr.length; i++) addr_gasPrice[_addr[i]] = _gasPrice[i];\\n    }\\n\\n    uint gasprice = 20000000000;\\n\\n    function setGasPrice(uint newgasprice)\\n    external\\n    {\\n        onlyadmin();\\n        gasprice = newgasprice;\\n    }\\n\\n    function setBasePrice(uint new_baseprice)\\n    external\\n    { //0.001 usd in ether\\n        onlyadmin();\\n        baseprice = new_baseprice;\\n        for (uint i=0; i\\u003cdsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\\n    }\\n\\n    function setBasePrice(uint new_baseprice, bytes proofID)\\n    external\\n    { //0.001 usd in ether\\n        onlyadmin();\\n        baseprice = new_baseprice;\\n        for (uint i=0; i\\u003cdsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\\n    }\\n\\n    function setOffchainPayment(address _addr, bool _flag)\\n    external\\n    {\\n      if (msg.sender != paymentFlagger) throw;\\n      offchainPayment[_addr] = _flag;\\n      Emit_OffchainPaymentFlag(_addr, _addr, _flag, _flag);\\n    }\\n\\n    function withdrawFunds(address _addr)\\n    external\\n    {\\n        onlyadmin();\\n        _addr.send(this.balance);\\n    }\\n\\n    // unnecessary?\\n    //function() {}\\n\\n    function Oraclize() {\\n        owner = msg.sender;\\n    }\\n\\n    // Pesudo-modifiers\\n\\n    function onlyadmin()\\n    private {\\n        if (msg.sender != owner) throw;\\n    }\\n\\n    function costs(string datasource, uint gaslimit)\\n    private\\n    returns (uint price) {\\n        price = getPrice(datasource, gaslimit, msg.sender);\\n\\n        if (msg.value \\u003e= price){\\n            uint diff = msg.value - price;\\n            if (diff \\u003e 0) {\\n                // added for correct query cost to be returned\\n                if(!msg.sender.send(diff)) {\\n                    throw;\\n                }\\n            }\\n        } else throw;\\n    }\\n\\n    mapping (address =\\u003e byte) addr_proofType;\\n    mapping (address =\\u003e uint) addr_gasPrice;\\n    uint public baseprice;\\n    mapping (bytes32 =\\u003e uint) price;\\n    mapping (bytes32 =\\u003e uint) price_multiplier;\\n    bytes32[] dsources;\\n\\n    bytes32[] public randomDS_sessionPubKeysHash;\\n\\n    function randomDS_updateSessionPubKeysHash(bytes32[] _newSessionPubKeysHash)\\n    external\\n    {\\n        onlyadmin();\\n        randomDS_sessionPubKeysHash.length = 0;\\n        for (uint i=0; i\\u003c_newSessionPubKeysHash.length; i++) randomDS_sessionPubKeysHash.push(_newSessionPubKeysHash[i]);\\n    }\\n\\n    function randomDS_getSessionPubKeyHash()\\n    external\\n    constant\\n    returns (bytes32) {\\n        uint i = uint(sha3(reqc[msg.sender]))%randomDS_sessionPubKeysHash.length;\\n        return randomDS_sessionPubKeysHash[i];\\n    }\\n\\n    function setProofType(byte _proofType)\\n    external\\n    {\\n        addr_proofType[msg.sender] = _proofType;\\n    }\\n\\n    function setCustomGasPrice(uint _gasPrice)\\n    external\\n    {\\n        addr_gasPrice[msg.sender] = _gasPrice;\\n    }\\n\\n    function getPrice(string _datasource)\\n    public\\n    returns (uint _dsprice)\\n    {\\n        return getPrice(_datasource, msg.sender);\\n    }\\n\\n    function getPrice(string _datasource, uint _gaslimit)\\n    public\\n    returns (uint _dsprice)\\n    {\\n        return getPrice(_datasource, _gaslimit, msg.sender);\\n    }\\n\\n    function getPrice(string _datasource, address _addr)\\n    private\\n    returns (uint _dsprice)\\n    {\\n        return getPrice(_datasource, 200000, _addr);\\n    }\\n\\n    function getPrice(string _datasource, uint _gaslimit, address _addr)\\n    private\\n    returns (uint _dsprice)\\n    {\\n        uint gasprice_ = addr_gasPrice[_addr];\\n        if (\\n                (offchainPayment[_addr])\\n            ||(\\n                (_gaslimit \\u003c= 200000)\\u0026\\u0026\\n                (reqc[_addr] == 0)\\u0026\\u0026\\n                (gasprice_ \\u003c= gasprice)\\u0026\\u0026\\n                (tx.origin != cbAddress())\\n            )\\n        ) return 0;\\n\\n        if (gasprice_ == 0) gasprice_ = gasprice;\\n        _dsprice = price[sha3(_datasource, addr_proofType[_addr])];\\n        _dsprice += _gaslimit*gasprice_;\\n        return _dsprice;\\n    }\\n\\n    function getCodeSize(address _addr)\\n    private\\n    constant\\n    returns(uint _size)\\n    {\\n        assembly {\\n            _size := extcodesize(_addr)\\n        }\\n    }\\n\\n    function query(string _datasource, string _arg)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(0, _datasource, _arg, 200000);\\n    }\\n\\n    function query1(string _datasource, string _arg)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(0, _datasource, _arg, 200000);\\n    }\\n\\n    function query2(string _datasource, string _arg1, string _arg2)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query2(0, _datasource, _arg1, _arg2, 200000);\\n    }\\n\\n    function queryN(string _datasource, bytes _args)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return queryN(0, _datasource, _args, 200000);\\n    }\\n\\n    function query(uint _timestamp, string _datasource, string _arg)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(_timestamp, _datasource, _arg, 200000);\\n    }\\n\\n    function query1(uint _timestamp, string _datasource, string _arg)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(_timestamp, _datasource, _arg, 200000);\\n    }\\n\\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query2(_timestamp, _datasource, _arg1, _arg2, 200000);\\n    }\\n\\n    function queryN(uint _timestamp, string _datasource, bytes _args)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return queryN(_timestamp, _datasource, _args, 200000);\\n    }\\n\\n/*  Needless?\\n    function query(uint _timestamp, string _datasource, string _arg, uint _gaslimit)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\\n    }\\n*/\\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\\n    }\\n\\n    function query1_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\\n    }\\n\\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return query2(_timestamp, _datasource, _arg1, _arg2, _gaslimit);\\n    }\\n\\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _args, uint _gaslimit)\\n    payable\\n    external\\n    returns (bytes32 _id)\\n    {\\n        return queryN(_timestamp, _datasource, _args, _gaslimit);\\n    }\\n\\n    function query1(uint _timestamp, string _datasource, string _arg, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n    \\tif ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        Log1(msg.sender, _id, _timestamp, _datasource, _arg, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n\\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n    \\tif ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n\\n    function queryN(uint _timestamp, string _datasource, bytes _args, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n    \\tif ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        LogN(msg.sender, _id, _timestamp, _datasource, _args, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n\\n    function query1_fnc(uint _timestamp, string _datasource, string _arg, function() external _fnc, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n        if ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)||address(_fnc) != msg.sender) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        Log1_fnc(msg.sender, _id, _timestamp, _datasource, _arg, _fnc, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n\\n    function query2_fnc(uint _timestamp, string _datasource, string _arg1, string _arg2, function() external _fnc, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n        if ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)||address(_fnc) != msg.sender) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        Log2_fnc(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _fnc,  _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n\\n    function queryN_fnc(uint _timestamp, string _datasource, bytes _args, function() external _fnc, uint _gaslimit)\\n    payable\\n    public\\n    returns (bytes32 _id)\\n    {\\n        costs(_datasource, _gaslimit);\\n        if ((_timestamp \\u003e now+3600*24*60)||(_gaslimit \\u003e block.gaslimit)||address(_fnc) != msg.sender) throw;\\n\\n        _id = sha3(this, msg.sender, reqc[msg.sender]);\\n        reqc[msg.sender]++;\\n        LogN_fnc(msg.sender, _id, _timestamp, _datasource, _args, _fnc, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\\n        return _id;\\n    }\\n}\\n\"},\"ownable.sol\":{\"content\":\"/**\\n *  Ownable\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\n\\n/// @title Ownable has an owner address and provides basic authorization control functions.\\n/// This contract is modified version of the MIT OpenZepplin Ownable contract \\n/// This contract doesn\\u0027t allow for multiple changeOwner operations\\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\\ncontract Ownable {\\n    event TransferredOwnership(address _from, address _to);\\n\\n    address private _owner;\\n    bool private _isTransferable;\\n\\n    /// @dev Constructor sets the original owner of the contract and whether or not it is one time transferable.\\n    constructor(address _account, bool _transferable) internal {\\n        _owner = _account;\\n        _isTransferable = _transferable;\\n        emit TransferredOwnership(address(0), _account);\\n    }\\n\\n    /// @dev Reverts if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(_isOwner(), \\\"sender is not an owner\\\");\\n        _;\\n    }\\n\\n    /// @dev Allows the current owner to transfer control of the contract to a new address.\\n    /// @param _account address to transfer ownership to.\\n    function transferOwnership(address _account) external onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        // Require that the new owner is not the zero address.\\n        require(_account != address(0), \\\"owner cannot be set to zero address\\\");\\n        // Set the transferable flag to false.\\n        _isTransferable = false;\\n        // Emit the ownership transfer event.\\n        emit TransferredOwnership(_owner, _account);\\n        // Set the owner to the provided address.\\n        _owner = _account;\\n    }\\n\\n    /// @dev Allows the current owner to relinquish control of the contract.\\n    /// @notice Renouncing to ownership will leave the contract without an owner and unusable.\\n    /// It will not be possible to call the functions with the `onlyOwner` modifier anymore.\\n    function renounceOwnership() public onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        emit TransferredOwnership(_owner, address(0));\\n        // note that this could be terminal\\n        _owner = address(0);\\n    }\\n\\n    /// @return the address of the owner.\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /// @return true if the ownership is transferable.\\n    function isTransferable() public view returns (bool) {\\n        return _isTransferable;\\n    }\\n\\n    /// @return true if sender is the owner of the contract.\\n    function _isOwner() internal view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n}\\n\"},\"parseIntScientific.sol\":{\"content\":\"/**\\n *  ParseIntScientific\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n*/\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/// @title ParseIntScientific provides floating point in scientific notation (e.g. e-5) parsing functionality.\\ncontract ParseIntScientific {\\n\\n    using SafeMath for uint256;\\n\\n    byte constant private PLUS_ASCII = byte(43); //decimal value of \\u0027+\\u0027\\n    byte constant private DASH_ASCII = byte(45); //decimal value of \\u0027-\\u0027\\n    byte constant private DOT_ASCII = byte(46); //decimal value of \\u0027.\\u0027\\n    byte constant private ZERO_ASCII = byte(48); //decimal value of \\u00270\\u0027\\n    byte constant private NINE_ASCII = byte(57); //decimal value of \\u00279\\u0027\\n    byte constant private E_ASCII = byte(69); //decimal value of \\u0027E\\u0027\\n    byte constant private e_ASCII = byte(101); //decimal value of \\u0027e\\u0027\\n\\n    /// @dev ParseIntScientific delegates the call to _parseIntScientific(string, uint) with the 2nd argument being 0.\\n    function _parseIntScientific(string _inString) internal pure returns (uint) {\\n        return _parseIntScientific(_inString, 0);\\n    }\\n\\n    /// @dev ParseIntScientificWei parses a rate expressed in ETH and returns its wei denomination\\n    function _parseIntScientificWei(string _inString) internal pure returns (uint) {\\n        return _parseIntScientific(_inString, 18);\\n    }\\n\\n    /// @dev ParseIntScientific parses a JSON standard - floating point number.\\n    /// @param _inString is input string.\\n    /// @param _magnitudeMult multiplies the number with 10^_magnitudeMult.\\n    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\\n\\n        bytes memory inBytes = bytes(_inString);\\n        uint mint = 0; // the final uint returned\\n        uint mintDec = 0; // the uint following the decimal point\\n        uint mintExp = 0; // the exponent\\n        uint decMinted = 0; // how many decimals were \\u0027minted\\u0027.\\n        uint expIndex = 0; // the position in the byte array that \\u0027e\\u0027 was found (if found)\\n        bool integral = false; // indicates the existence of the integral part, it should always exist (even if 0) e.g. \\u0027e+1\\u0027  or \\u0027.1\\u0027 is not valid\\n        bool decimals = false; // indicates a decimal number, set to true if \\u0027.\\u0027 is found\\n        bool exp = false; // indicates if the number being parsed has an exponential representation\\n        bool minus = false; // indicated if the exponent is negative\\n        bool plus = false; // indicated if the exponent is positive\\n\\n        for (uint i = 0; i \\u003c inBytes.length; i++) {\\n            if ((inBytes[i] \\u003e= ZERO_ASCII) \\u0026\\u0026 (inBytes[i] \\u003c= NINE_ASCII) \\u0026\\u0026 (!exp)) {\\n                // \\u0027e\\u0027 not encountered yet, minting integer part or decimals\\n                if (decimals) {\\n                    // \\u0027.\\u0027 encountered\\n                    //use safeMath in case there is an overflow\\n                    mintDec = mintDec.mul(10);\\n                    mintDec = mintDec.add(uint(inBytes[i]) - uint(ZERO_ASCII));\\n                    decMinted++; //keep track of the #decimals\\n                } else {\\n                    // integral part (before \\u0027.\\u0027)\\n                    integral = true;\\n                    //use safeMath in case there is an overflow\\n                    mint = mint.mul(10);\\n                    mint = mint.add(uint(inBytes[i]) - uint(ZERO_ASCII));\\n                }\\n            } else if ((inBytes[i] \\u003e= ZERO_ASCII) \\u0026\\u0026 (inBytes[i] \\u003c= NINE_ASCII) \\u0026\\u0026 (exp)) {\\n                //exponential notation (e-/+) has been detected, mint the exponent\\n                mintExp = mintExp.mul(10);\\n                mintExp = mintExp.add(uint(inBytes[i]) - uint(ZERO_ASCII));\\n            } else if (inBytes[i] == DOT_ASCII) {\\n                //an integral part before should always exist before \\u0027.\\u0027\\n                require(integral, \\\"missing integral part\\\");\\n                // an extra decimal point makes the format invalid\\n                require(!decimals, \\\"duplicate decimal point\\\");\\n                //the decimal point should always be before the exponent\\n                require(!exp, \\\"decimal after exponent\\\");\\n                decimals = true;\\n            } else if (inBytes[i] == DASH_ASCII) {\\n                // an extra \\u0027-\\u0027 should be considered an invalid character\\n                require(!minus, \\\"duplicate -\\\");\\n                require(!plus, \\\"extra sign\\\");\\n                require(expIndex + 1 == i, \\\"- sign not immediately after e\\\");\\n                minus = true;\\n            } else if (inBytes[i] == PLUS_ASCII) {\\n                // an extra \\u0027+\\u0027 should be considered an invalid character\\n                require(!plus, \\\"duplicate +\\\");\\n                require(!minus, \\\"extra sign\\\");\\n                require(expIndex + 1 == i, \\\"+ sign not immediately after e\\\");\\n                plus = true;\\n            } else if ((inBytes[i] == E_ASCII) || (inBytes[i] == e_ASCII)) {\\n                //an integral part before should always exist before \\u0027e\\u0027\\n                require(integral, \\\"missing integral part\\\");\\n                // an extra \\u0027e\\u0027 or \\u0027E\\u0027 should be considered an invalid character\\n                require(!exp, \\\"duplicate exponent symbol\\\");\\n                exp = true;\\n                expIndex = i;\\n            } else {\\n                revert(\\\"invalid digit\\\");\\n            }\\n        }\\n\\n        if (minus || plus) {\\n            // end of string e[x|-] without specifying the exponent\\n            require(i \\u003e expIndex + 2);\\n        } else if (exp) {\\n            // end of string (e) without specifying the exponent\\n            require(i \\u003e expIndex + 1);\\n        }\\n\\n        if (minus) {\\n            // e^(-x)\\n            if (mintExp \\u003e= _magnitudeMult) {\\n                // the (negative) exponent is bigger than the given parameter for \\\"shifting left\\\".\\n                // use integer division to reduce the precision.\\n                require(mintExp - _magnitudeMult \\u003c 78, \\\"exponent \\u003e 77\\\"); //\\n                mint /= 10 ** (mintExp - _magnitudeMult);\\n                return mint;\\n\\n            } else {\\n                // the (negative) exponent is smaller than the given parameter for \\\"shifting left\\\".\\n                //no need for underflow check\\n                _magnitudeMult = _magnitudeMult - mintExp;\\n            }\\n        } else {\\n            // e^(+x), positive exponent or no exponent\\n            // just shift left as many times as indicated by the exponent and the shift parameter\\n            _magnitudeMult = _magnitudeMult.add(mintExp);\\n          }\\n\\n          if (_magnitudeMult \\u003e= decMinted) {\\n              // the decimals are fewer or equal than the shifts: use all of them\\n              // shift number and add the decimals at the end\\n              // include decimals if present in the original input\\n              require(decMinted \\u003c 78, \\\"more than 77 decimal digits parsed\\\"); //\\n              mint = mint.mul(10 ** (decMinted));\\n              mint = mint.add(mintDec);\\n              //// add zeros at the end if the decimals were fewer than #_magnitudeMult\\n              require(_magnitudeMult - decMinted \\u003c 78, \\\"exponent \\u003e 77\\\"); //\\n              mint = mint.mul(10 ** (_magnitudeMult - decMinted));\\n          } else {\\n              // the decimals are more than the #_magnitudeMult shifts\\n              // use only the ones needed, discard the rest\\n              decMinted -= _magnitudeMult;\\n              require(decMinted \\u003c 78, \\\"more than 77 decimal digits parsed\\\"); //\\n              mintDec /= 10 ** (decMinted);\\n              // shift number and add the decimals at the end\\n              require(_magnitudeMult \\u003c 78, \\\"more than 77 decimal digits parsed\\\"); //\\n              mint = mint.mul(10 ** (_magnitudeMult));\\n              mint = mint.add(mintDec);\\n          }\\n\\n        return mint;\\n    }\\n}\\n\"},\"PublicResolver.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n * \\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n * \\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n * \\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n * \\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n * \\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./ENS.sol\\\";\\n\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver {\\n\\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\\n    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\\n\\n    event AddrChanged(bytes32 indexed node, address a);\\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\\n    event NameChanged(bytes32 indexed node, string name);\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\\n    event MultihashChanged(bytes32 indexed node, bytes hash);\\n\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    struct Record {\\n        address addr;\\n        bytes32 content;\\n        string name;\\n        PublicKey pubkey;\\n        mapping(string=\\u003estring) text;\\n        mapping(uint256=\\u003ebytes) abis;\\n        bytes multihash;\\n    }\\n\\n    ENS ens;\\n\\n    mapping (bytes32 =\\u003e Record) records;\\n\\n    modifier only_owner(bytes32 node) {\\n        require(ens.owner(node) == msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * Constructor.\\n     * @param ensAddr The ENS registrar contract.\\n     */\\n    constructor(ENS ensAddr) public {\\n        ens = ensAddr;\\n    }\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param addr The address to set.\\n     */\\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\\n        records[node].addr = addr;\\n        emit AddrChanged(node, addr);\\n    }\\n\\n    /**\\n     * Sets the content hash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * Note that this resource type is not standardized, and will likely change\\n     * in future to a resource type based on multihash.\\n     * @param node The node to update.\\n     * @param hash The content hash to set\\n     */\\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\\n        records[node].content = hash;\\n        emit ContentChanged(node, hash);\\n    }\\n\\n    /**\\n     * Sets the multihash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The multihash to set\\n     */\\n    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\\n        records[node].multihash = hash;\\n        emit MultihashChanged(node, hash);\\n    }\\n    \\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param name The name to set.\\n     */\\n    function setName(bytes32 node, string name) public only_owner(node) {\\n        records[node].name = name;\\n        emit NameChanged(node, name);\\n    }\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) \\u0026 contentType) == 0);\\n        \\n        records[node].abis[contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n    \\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\\n        records[node].pubkey = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\\n        records[node].text[key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string key) public view returns (string) {\\n        return records[node].text[key];\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x, y the X and Y coordinates of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\\n        return (records[node].pubkey.x, records[node].pubkey.y);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\\n        Record storage record = records[node];\\n        for (contentType = 1; contentType \\u003c= contentTypes; contentType \\u003c\\u003c= 1) {\\n            if ((contentType \\u0026 contentTypes) != 0 \\u0026\\u0026 record.abis[contentType].length \\u003e 0) {\\n                data = record.abis[contentType];\\n                return;\\n            }\\n        }\\n        contentType = 0;\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) public view returns (string) {\\n        return records[node].name;\\n    }\\n\\n    /**\\n     * Returns the content hash associated with an ENS node.\\n     * Note that this resource type is not standardized, and will likely change\\n     * in future to a resource type based on multihash.\\n     * @param node The ENS node to query.\\n     * @return The associated content hash.\\n     */\\n    function content(bytes32 node) public view returns (bytes32) {\\n        return records[node].content;\\n    }\\n\\n    /**\\n     * Returns the multihash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated multihash.\\n     */\\n    function multihash(bytes32 node) public view returns (bytes) {\\n        return records[node].multihash;\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) public view returns (address) {\\n        return records[node].addr;\\n    }\\n\\n    /**\\n     * Returns true if the resolver implements the interface specified by the provided hash.\\n     * @param interfaceID The ID of the interface to check for.\\n     * @return True if the contract implements the requested interface.\\n     */\\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\\n        return interfaceID == ADDR_INTERFACE_ID ||\\n        interfaceID == CONTENT_INTERFACE_ID ||\\n        interfaceID == NAME_INTERFACE_ID ||\\n        interfaceID == ABI_INTERFACE_ID ||\\n        interfaceID == PUBKEY_INTERFACE_ID ||\\n        interfaceID == TEXT_INTERFACE_ID ||\\n        interfaceID == MULTIHASH_INTERFACE_ID ||\\n        interfaceID == INTERFACE_META_ID;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"/**\\n * The MIT License (MIT)\\n * \\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\\n * \\n * Permission is hereby granted, free of charge, to any person obtaining\\n * a copy of this software and associated documentation files (the\\n * \\\"Software\\\"), to deal in the Software without restriction, including\\n * without limitation the rights to use, copy, modify, merge, publish,\\n * distribute, sublicense, and/or sell copies of the Software, and to\\n * permit persons to whom the Software is furnished to do so, subject to\\n * the following conditions:\\n * \\n * The above copyright notice and this permission notice shall be included\\n * in all copies or substantial portions of the Software.\\n * \\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"},\"strings.sol\":{\"content\":\"/*\\n * Copyright 2016 Nick Johnson\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/*\\n * @title String \\u0026 slice utility library for Solidity contracts.\\n * @author Nick Johnson \\u003carachnid@notdot.net\\u003e\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a \\u0027slice\\u0027. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first \\u0027.\\u0027,\\n *      modifying s to only contain the remainder of the string after the \\u0027.\\u0027.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew(\\u0027.\\u0027)` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.4.14;\\n\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (self \\u0026 0xffffffffffffffffffffffffffffffff == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (self \\u0026 0xffffffffffffffff == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (self \\u0026 0xffffffff == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (self \\u0026 0xffff == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (self \\u0026 0xff == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice\\u0027s text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr \\u003c end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b \\u003c 0x80) {\\n                ptr += 1;\\n            } else if(b \\u003c 0xE0) {\\n                ptr += 2;\\n            } else if(b \\u003c 0xF0) {\\n                ptr += 3;\\n            } else if(b \\u003c 0xF8) {\\n                ptr += 4;\\n            } else if(b \\u003c 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len \\u003c self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask = uint256(-1); // 0xffff...\\n                if(shortest \\u003c 32) {\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\n                if (diff != 0)\\n                    return int(diff);\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b \\u003c 0x80) {\\n            l = 1;\\n        } else if(b \\u003c 0xE0) {\\n            l = 2;\\n        } else if(b \\u003c 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l \\u003e self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b \\u003c 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if(b \\u003c 0xE0) {\\n            ret = b \\u0026 0x1F;\\n            length = 2;\\n        } else if(b \\u003c 0xF0) {\\n            ret = b \\u0026 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b \\u0026 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length \\u003e self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i \\u003c length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) \\u0026 0xFF;\\n            if (b \\u0026 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b \\u0026 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003e= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003c= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr \\u003e= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr \\u003c= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for(uint i = 0; i \\u003c parts.length; i++)\\n            length += parts[i]._len;\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for(i = 0; i \\u003c parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i \\u003c parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n\"},\"wallet.sol\":{\"content\":\"/**\\n *  The Consumer Contract Wallet\\n *  Copyright (C) 2018 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.4.25;\\n\\nimport \\\"./oracle.sol\\\";\\nimport \\\"./ownable.sol\\\";\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./PublicResolver.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/// @title ERC20 interface is a subset of the ERC20 specification.\\ninterface ERC20 {\\n    function transfer(address, uint) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\n\\n/// @title ERC165 interface specifies a standard way of querying if a contract implements an interface.\\ninterface ERC165 {\\n    function supportsInterface(bytes4) external view returns (bool);\\n}\\n\\n\\n/// @title Whitelist provides payee-whitelist functionality.\\ncontract Whitelist is Controllable, Ownable {\\n    event AddedToWhitelist(address _sender, address[] _addresses);\\n    event SubmittedWhitelistAddition(address[] _addresses, bytes32 _hash);\\n    event CancelledWhitelistAddition(address _sender, bytes32 _hash);\\n\\n    event RemovedFromWhitelist(address _sender, address[] _addresses);\\n    event SubmittedWhitelistRemoval(address[] _addresses, bytes32 _hash);\\n    event CancelledWhitelistRemoval(address _sender, bytes32 _hash);\\n\\n    mapping(address =\\u003e bool) public isWhitelisted;\\n    address[] private _pendingWhitelistAddition;\\n    address[] private _pendingWhitelistRemoval;\\n    bool public submittedWhitelistAddition;\\n    bool public submittedWhitelistRemoval;\\n    bool public initializedWhitelist;\\n\\n    /// @dev Check if the provided addresses contain the owner or the zero-address address.\\n    modifier hasNoOwnerOrZeroAddress(address[] _addresses) {\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            require(_addresses[i] != owner(), \\\"provided whitelist contains the owner address\\\");\\n            require(_addresses[i] != address(0), \\\"provided whitelist contains the zero address\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Check that neither addition nor removal operations have already been submitted.\\n    modifier noActiveSubmission() {\\n        require(!submittedWhitelistAddition \\u0026\\u0026 !submittedWhitelistRemoval, \\\"whitelist operation has already been submitted\\\");\\n        _;\\n    }\\n\\n    /// @dev Getter for pending addition array.\\n    function pendingWhitelistAddition() external view returns(address[]) {\\n        return _pendingWhitelistAddition;\\n    }\\n\\n    /// @dev Getter for pending removal array.\\n    function pendingWhitelistRemoval() external view returns(address[]) {\\n        return _pendingWhitelistRemoval;\\n    }\\n\\n    /// @dev Getter for pending addition/removal array hash.\\n    function pendingWhitelistHash(address[] _pendingWhitelist) public pure returns(bytes32) {\\n        return keccak256(abi.encodePacked(_pendingWhitelist));\\n    }\\n\\n    /// @dev Add initial addresses to the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\\n    function initializeWhitelist(address[] _addresses) external onlyOwner hasNoOwnerOrZeroAddress(_addresses) {\\n        // Require that the whitelist has not been initialized.\\n        require(!initializedWhitelist, \\\"whitelist has already been initialized\\\");\\n        // Add each of the provided addresses to the whitelist.\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            isWhitelisted[_addresses[i]] = true;\\n        }\\n        initializedWhitelist = true;\\n        // Emit the addition event.\\n        emit AddedToWhitelist(msg.sender, _addresses);\\n    }\\n\\n    /// @dev Add addresses to the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\\n    function submitWhitelistAddition(address[] _addresses) external onlyOwner noActiveSubmission hasNoOwnerOrZeroAddress(_addresses) {\\n        // Require that the whitelist has been initialized.\\n        require(initializedWhitelist, \\\"whitelist has not been initialized\\\");\\n        // Require this array of addresses not empty\\n        require(_addresses.length \\u003e 0, \\\"pending whitelist addition is empty\\\");\\n        // Set the provided addresses to the pending addition addresses.\\n        _pendingWhitelistAddition = _addresses;\\n        // Flag the operation as submitted.\\n        submittedWhitelistAddition = true;\\n        // Emit the submission event.\\n        emit SubmittedWhitelistAddition(_addresses, pendingWhitelistHash(_pendingWhitelistAddition));\\n    }\\n\\n    /// @dev Confirm pending whitelist addition.\\n    function confirmWhitelistAddition(bytes32 _hash) external onlyController {\\n        // Require that the whitelist addition has been submitted.\\n        require(submittedWhitelistAddition, \\\"whitelist addition has not been submitted\\\");\\n\\n        // Require that confirmation hash and the hash of the pending whitelist addition match\\n        require(_hash == pendingWhitelistHash(_pendingWhitelistAddition), \\\"hash of the pending whitelist addition do not match\\\");\\n\\n        // Whitelist pending addresses.\\n        for (uint i = 0; i \\u003c _pendingWhitelistAddition.length; i++) {\\n            isWhitelisted[_pendingWhitelistAddition[i]] = true;\\n        }\\n        // Emit the addition event.\\n        emit AddedToWhitelist(msg.sender, _pendingWhitelistAddition);\\n        // Reset pending addresses.\\n        delete _pendingWhitelistAddition;\\n        // Reset the submission flag.\\n        submittedWhitelistAddition = false;\\n    }\\n\\n    /// @dev Cancel pending whitelist addition.\\n    function cancelWhitelistAddition(bytes32 _hash) external onlyController {\\n        // Check if operation has been submitted.\\n        require(submittedWhitelistAddition, \\\"whitelist addition has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist addition match\\n        require(_hash == pendingWhitelistHash(_pendingWhitelistAddition), \\\"hash of the pending whitelist addition does not match\\\");\\n        // Reset pending addresses.\\n        delete _pendingWhitelistAddition;\\n        // Reset the submitted operation flag.\\n        submittedWhitelistAddition = false;\\n        // Emit the cancellation event.\\n        emit CancelledWhitelistAddition(msg.sender, _hash);\\n    }\\n\\n    /// @dev Remove addresses from the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be removed.\\n    function submitWhitelistRemoval(address[] _addresses) external onlyOwner noActiveSubmission {\\n        // Require that the whitelist has been initialized.\\n        require(initializedWhitelist, \\\"whitelist has not been initialized\\\");\\n        // Require that the array of addresses is not empty\\n        require(_addresses.length \\u003e 0, \\\"submitted whitelist removal is empty\\\");\\n        // Add the provided addresses to the pending addition list.\\n        _pendingWhitelistRemoval = _addresses;\\n        // Flag the operation as submitted.\\n        submittedWhitelistRemoval = true;\\n        // Emit the submission event.\\n        emit SubmittedWhitelistRemoval(_addresses, pendingWhitelistHash(_pendingWhitelistRemoval));\\n    }\\n\\n    /// @dev Confirm pending removal of whitelisted addresses.\\n    function confirmWhitelistRemoval(bytes32 _hash) external onlyController {\\n        // Require that the pending whitelist is not empty and the operation has been submitted.\\n        require(submittedWhitelistRemoval, \\\"whitelist removal has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist removal match\\n        require(_hash == pendingWhitelistHash(_pendingWhitelistRemoval), \\\"hash of the pending whitelist removal does not match the confirmed hash\\\");\\n        // Remove pending addresses.\\n        for (uint i = 0; i \\u003c _pendingWhitelistRemoval.length; i++) {\\n            isWhitelisted[_pendingWhitelistRemoval[i]] = false;\\n        }\\n        // Emit the removal event.\\n        emit RemovedFromWhitelist(msg.sender, _pendingWhitelistRemoval);\\n        // Reset pending addresses.\\n        delete _pendingWhitelistRemoval;\\n        // Reset the submission flag.\\n        submittedWhitelistRemoval = false;\\n    }\\n\\n    /// @dev Cancel pending removal of whitelisted addresses.\\n    function cancelWhitelistRemoval(bytes32 _hash) external onlyController {\\n        // Check if operation has been submitted.\\n        require(submittedWhitelistRemoval, \\\"whitelist removal has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist removal match\\n        require(_hash == pendingWhitelistHash(_pendingWhitelistRemoval), \\\"hash of the pending whitelist removal does not match\\\");\\n        // Reset pending addresses.\\n        delete _pendingWhitelistRemoval;\\n        // Reset the submitted operation flag.\\n        submittedWhitelistRemoval = false;\\n        // Emit the cancellation event.\\n        emit CancelledWhitelistRemoval(msg.sender, _hash);\\n    }\\n}\\n\\n\\n//// @title SpendLimit provides daily spend limit functionality.\\ncontract SpendLimit is Controllable, Ownable {\\n    event SetSpendLimit(address _sender, uint _amount);\\n    event SubmittedSpendLimitChange(uint _amount);\\n    event CancelledSpendLimitChange(address _sender, uint _amount);\\n\\n    using SafeMath for uint256;\\n\\n    uint public spendLimit;\\n    uint private _spendLimitDay;\\n    uint private _spendAvailable;\\n\\n    uint public pendingSpendLimit;\\n    bool public submittedSpendLimit;\\n    bool public initializedSpendLimit;\\n\\n    /// @dev Constructor initializes the daily spend limit in wei.\\n    constructor(uint _spendLimit) internal {\\n        spendLimit = _spendLimit;\\n        _spendLimitDay = now;\\n        _spendAvailable = spendLimit;\\n    }\\n\\n    /// @dev Returns the available daily balance - accounts for daily limit reset.\\n    /// @return amount of ether in wei.\\n    function spendAvailable() public view returns (uint) {\\n        if (now \\u003e _spendLimitDay + 24 hours) {\\n            return spendLimit;\\n        } else {\\n            return _spendAvailable;\\n        }\\n    }\\n\\n    /// @dev Initialize a daily spend (aka transfer) limit for non-whitelisted addresses.\\n    /// @param _amount is the daily limit amount in wei.\\n    function initializeSpendLimit(uint _amount) external onlyOwner {\\n        // Require that the spend limit has not been initialized.\\n        require(!initializedSpendLimit, \\\"spend limit has already been initialized\\\");\\n        // Modify spend limit based on the provided value.\\n        _modifySpendLimit(_amount);\\n        // Flag the operation as initialized.\\n        initializedSpendLimit = true;\\n        // Emit the set limit event.\\n        emit SetSpendLimit(msg.sender, _amount);\\n    }\\n\\n    /// @dev Set a daily transfer limit for non-whitelisted addresses.\\n    /// @param _amount is the daily limit amount in wei.\\n    function submitSpendLimit(uint _amount) external onlyOwner {\\n        // Require that the spend limit has been initialized.\\n        require(initializedSpendLimit, \\\"spend limit has not been initialized\\\");\\n        // Assign the provided amount to pending daily limit change.\\n        pendingSpendLimit = _amount;\\n        // Flag the operation as submitted.\\n        submittedSpendLimit = true;\\n        // Emit the submission event.\\n        emit SubmittedSpendLimitChange(_amount);\\n    }\\n\\n    /// @dev Confirm pending set daily limit operation.\\n    function confirmSpendLimit(uint _amount) external onlyController {\\n        // Require that the operation has been submitted.\\n        require(submittedSpendLimit, \\\"spend limit has not been submitted\\\");\\n        // Require that pending and confirmed spend limit are the same\\n        require(pendingSpendLimit == _amount, \\\"confirmed and submitted spend limits dont match\\\");\\n        // Modify spend limit based on the pending value.\\n        _modifySpendLimit(pendingSpendLimit);\\n        // Emit the set limit event.\\n        emit SetSpendLimit(msg.sender, pendingSpendLimit);\\n        // Reset the submission flag.\\n        submittedSpendLimit = false;\\n        // Reset pending daily limit.\\n        pendingSpendLimit = 0;\\n    }\\n\\n    /// @dev Cancel pending set daily limit operation.\\n    function cancelSpendLimit(uint _amount) external onlyController {\\n        // Require a spendlimit has been submitted\\n        require(submittedSpendLimit, \\\"a spendlimit needs to be submitted\\\");\\n        // Require that pending and confirmed spend limit are the same\\n        require(pendingSpendLimit == _amount, \\\"pending and cancelled spend limits dont match\\\");\\n        // Reset pending daily limit.\\n        pendingSpendLimit = 0;\\n        // Reset the submitted operation flag.\\n        submittedSpendLimit = false;\\n        // Emit the cancellation event.\\n        emit CancelledSpendLimitChange(msg.sender, _amount);\\n    }\\n\\n    // @dev Setter method for the available daily spend limit.\\n    function _setSpendAvailable(uint _amount) internal {\\n        _spendAvailable = _amount;\\n    }\\n\\n    /// @dev Update available spend limit based on the daily reset.\\n    function _updateSpendAvailable() internal {\\n        if (now \\u003e _spendLimitDay.add(24 hours)) {\\n            // Advance the current day by how many days have passed.\\n            uint extraDays = now.sub(_spendLimitDay).div(24 hours);\\n            _spendLimitDay = _spendLimitDay.add(extraDays.mul(24 hours));\\n            // Set the available limit to the current spend limit.\\n            _spendAvailable = spendLimit;\\n        }\\n    }\\n\\n    /// @dev Modify the spend limit and spend available based on the provided value.\\n    /// @dev _amount is the daily limit amount in wei.\\n    function _modifySpendLimit(uint _amount) private {\\n        // Account for the spend limit daily reset.\\n        _updateSpendAvailable();\\n        // Set the daily limit to the provided amount.\\n        spendLimit = _amount;\\n        // Lower the available limit if it\\u0027s higher than the new daily limit.\\n        if (_spendAvailable \\u003e spendLimit) {\\n            _spendAvailable = spendLimit;\\n        }\\n    }\\n}\\n\\n\\n//// @title Asset store with extra security features.\\ncontract Vault is Whitelist, SpendLimit, ERC165 {\\n    event Received(address _from, uint _amount);\\n    event Transferred(address _to, address _asset, uint _amount);\\n    event BulkTransferred(address _to, address[] _assets);\\n\\n    using SafeMath for uint256;\\n\\n    /// @dev Supported ERC165 interface ID.\\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7; // solium-disable-line uppercase\\n\\n    /// @dev ENS points to the ENS registry smart contract.\\n    ENS internal _ENS;\\n    /// @dev Is the registered ENS name of the oracle contract.\\n    bytes32 internal _oracleNode;\\n\\n    /// @dev Constructor initializes the vault with an owner address and spend limit. It also sets up the oracle and controller contracts.\\n    /// @param _owner is the owner account of the wallet contract.\\n    /// @param _transferable indicates whether the contract ownership can be transferred.\\n    /// @param _ens is the ENS public registry contract address.\\n    /// @param _oracleName is the ENS name of the Oracle.\\n    /// @param _controllerName is the ENS name of the controller.\\n    /// @param _spendLimit is the initial spend limit.\\n    constructor(address _owner, bool _transferable, address _ens, bytes32 _oracleName, bytes32 _controllerName, uint _spendLimit) SpendLimit(_spendLimit) Ownable(_owner, _transferable) Controllable(_ens, _controllerName) public {\\n        _ENS = ENS(_ens);\\n        _oracleNode = _oracleName;\\n    }\\n\\n    /// @dev Checks if the value is not zero.\\n    modifier isNotZero(uint _value) {\\n        require(_value != 0, \\\"provided value cannot be zero\\\");\\n        _;\\n    }\\n\\n    /// @dev Ether can be deposited from any source, so this contract must be payable by anyone.\\n    function() public payable {\\n        //TODO question: Why is this check here, is it necessary or are we building into a corner?\\n        require(msg.data.length == 0, \\\"data in fallback\\\");\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /// @dev Returns the amount of an asset owned by the contract.\\n    /// @param _asset address of an ERC20 token or 0x0 for ether.\\n    /// @return balance associated with the wallet address in wei.\\n    function balance(address _asset) external view returns (uint) {\\n        if (_asset != address(0)) {\\n            return ERC20(_asset).balanceOf(this);\\n        } else {\\n            return address(this).balance;\\n        }\\n    }\\n\\n    /// @dev This is a bulk transfer convenience function, used to migrate contracts.\\n    /// If any of the transfers fail, this will revert.\\n    /// @param _to is the recipient\\u0027s address, can\\u0027t be the zero (0x0) address: transfer() will revert.\\n    /// @param _assets is an array of addresses of ERC20 tokens or 0x0 for ether.\\n    function bulkTransfer(address _to, address[] _assets) public onlyOwner {\\n        // check to make sure that _assets isn\\u0027t empty\\n        require(_assets.length != 0, \\\"asset array should be non-empty\\\");\\n        // This loops through all of the transfers to be made\\n        for (uint i = 0; i \\u003c _assets.length; i++) {\\n            uint amount;\\n            // Get amount based on whether eth or erc20\\n            if (_assets[i] == address(0)) {\\n                amount = address(this).balance;\\n            } else {\\n                amount = ERC20(_assets[i]).balanceOf(address(this));\\n            }\\n            // use our safe, daily limit protected transfer\\n            transfer(_to, _assets[i], amount);\\n        }\\n        emit BulkTransferred(_to, _assets);\\n    }\\n\\n    /// @dev Transfers the specified asset to the recipient\\u0027s address.\\n    /// @param _to is the recipient\\u0027s address.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount of tokens to be transferred in base units.\\n    function transfer(address _to, address _asset, uint _amount) public onlyOwner isNotZero(_amount) {\\n        // Checks if the _to address is not the zero-address\\n        require(_to != address(0), \\\"_to address cannot be set to 0x0\\\");\\n\\n        // If address is not whitelisted, take daily limit into account.\\n        if (!isWhitelisted[_to]) {\\n            // Update the available spend limit.\\n            _updateSpendAvailable();\\n            // Convert token amount to ether value.\\n            uint etherValue;\\n            bool tokenExists;\\n            if (_asset != address(0)) {\\n                (tokenExists, etherValue) = IOracle(PublicResolver(_ENS.resolver(_oracleNode)).addr(_oracleNode)).convert(_asset, _amount);\\n            } else {\\n                etherValue = _amount;\\n            }\\n\\n            // If token is supported by our oracle or is ether\\n            // Check against the daily spent limit and update accordingly\\n            if (tokenExists || _asset == address(0)) {\\n                // Require that the value is under remaining limit.\\n                require(etherValue \\u003c= spendAvailable(), \\\"transfer amount exceeds available spend limit\\\");\\n                // Update the available limit.\\n                _setSpendAvailable(spendAvailable().sub(etherValue));\\n            }\\n        }\\n        // Transfer token or ether based on the provided address.\\n        if (_asset != address(0)) {\\n            require(ERC20(_asset).transfer(_to, _amount), \\\"ERC20 token transfer was unsuccessful\\\");\\n        } else {\\n            _to.transfer(_amount);\\n        }\\n        // Emit the transfer event.\\n        emit Transferred(_to, _asset, _amount);\\n    }\\n\\n    /// @dev Checks for interface support based on ERC165.\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\\n        return interfaceID == _ERC165_INTERFACE_ID;\\n    }\\n}\\n\\n\\n//// @title Asset wallet with extra security features and gas top up management.\\ncontract Wallet is Vault {\\n\\n    using Address for address;\\n\\n    event SetTopUpLimit(address _sender, uint _amount);\\n    event SubmittedTopUpLimitChange(uint _amount);\\n    event CancelledTopUpLimitChange(address _sender, uint _amount);\\n\\n    event ToppedUpGas(address _sender, address _owner, uint _amount);\\n\\n    event ExecutedTransaction(address _destination, uint _value, bytes _data);\\n\\n    using SafeMath for uint256;\\n\\n    uint constant private MINIMUM_TOPUP_LIMIT = 1 finney; // solium-disable-line uppercase\\n    uint constant private MAXIMUM_TOPUP_LIMIT = 500 finney; // solium-disable-line uppercase\\n\\n    /// @dev these are needed to allow for the executeTransaction method\\n    uint32 private constant _TRANSFER= 0xa9059cbb;\\n    uint32 private constant _APPROVE = 0x095ea7b3;\\n\\n    uint public topUpLimit;\\n    uint private _topUpLimitDay;\\n    uint private _topUpAvailable;\\n\\n    uint public pendingTopUpLimit;\\n    bool public submittedTopUpLimit;\\n    bool public initializedTopUpLimit;\\n\\n    /// @dev Constructor initializes the wallet top up limit and the vault contract.\\n    /// @param _owner is the owner account of the wallet contract.\\n    /// @param _transferable indicates whether the contract ownership can be transferred.\\n    /// @param _ens is the address of the ENS.\\n    /// @param _oracleName is the ENS name of the Oracle.\\n    /// @param _controllerName is the ENS name of the Controller.\\n    /// @param _spendLimit is the initial spend limit.\\n    constructor(address _owner, bool _transferable, address _ens, bytes32 _oracleName, bytes32 _controllerName, uint _spendLimit) Vault(_owner, _transferable, _ens, _oracleName, _controllerName, _spendLimit) public {\\n        _topUpLimitDay = now;\\n        topUpLimit = MAXIMUM_TOPUP_LIMIT;\\n        _topUpAvailable = topUpLimit;\\n    }\\n\\n    /// @dev Returns the available daily gas top up balance - accounts for daily limit reset.\\n    /// @return amount of gas in wei.\\n    function topUpAvailable() external view returns (uint) {\\n        if (now \\u003e _topUpLimitDay + 24 hours) {\\n            return topUpLimit;\\n        } else {\\n            return _topUpAvailable;\\n        }\\n    }\\n\\n    /// @dev Initialize a daily gas top up limit.\\n    /// @param _amount is the gas top up amount in wei.\\n    function initializeTopUpLimit(uint _amount) external onlyOwner {\\n        // Require that the top up limit has not been initialized.\\n        require(!initializedTopUpLimit, \\\"top up limit has already been initialized\\\");\\n        // Require that the limit amount is within the acceptable range.\\n        require(MINIMUM_TOPUP_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= MAXIMUM_TOPUP_LIMIT, \\\"top up amount is outside of the min/max range\\\");\\n        // Modify spend limit based on the provided value.\\n        _modifyTopUpLimit(_amount);\\n        // Flag operation as initialized.\\n        initializedTopUpLimit = true;\\n        // Emit the set limit event.\\n        emit SetTopUpLimit(msg.sender, _amount);\\n    }\\n\\n    /// @dev Set a daily top up top up limit.\\n    /// @param _amount is the daily top up limit amount in wei.\\n    function submitTopUpLimit(uint _amount) external onlyOwner {\\n        // Require that the top up limit has been initialized.\\n        require(initializedTopUpLimit, \\\"top up limit has not been initialized\\\");\\n        // Require that the limit amount is within the acceptable range.\\n        require(MINIMUM_TOPUP_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= MAXIMUM_TOPUP_LIMIT, \\\"top up amount is outside of the min/max range\\\");\\n        // Assign the provided amount to pending daily limit change.\\n        pendingTopUpLimit = _amount;\\n        // Flag the operation as submitted.\\n        submittedTopUpLimit = true;\\n        // Emit the submission event.\\n        emit SubmittedTopUpLimitChange(_amount);\\n    }\\n\\n    /// @dev Confirm pending set top up limit operation.\\n    function confirmTopUpLimit(uint _amount) external onlyController {\\n        // Require that the operation has been submitted.\\n        require(submittedTopUpLimit, \\\"top up limit has not been submitted\\\");\\n        // Assert that the pending top up limit amount is within the acceptable range.\\n        require(MINIMUM_TOPUP_LIMIT \\u003c= pendingTopUpLimit \\u0026\\u0026 pendingTopUpLimit \\u003c= MAXIMUM_TOPUP_LIMIT, \\\"top up amount is outside the min/max range\\\");\\n        // Assert that confirmed and pending topup limit are the same.\\n        require(_amount == pendingTopUpLimit, \\\"confirmed and pending topup limit are not same\\\");\\n        // Modify top up limit based on the pending value.\\n        _modifyTopUpLimit(pendingTopUpLimit);\\n        // Emit the set limit event.\\n        emit SetTopUpLimit(msg.sender, pendingTopUpLimit);\\n        // Reset pending daily limit.\\n        pendingTopUpLimit = 0;\\n        // Reset the submission flag.\\n        submittedTopUpLimit = false;\\n    }\\n\\n    /// @dev Cancel pending set top up limit operation.\\n    function cancelTopUpLimit(uint _amount) external onlyController {\\n        // Make sure a topup limit update has been submitted\\n        require(submittedTopUpLimit, \\\"a topup limit has to be submitted\\\");\\n        // Require that pending and confirmed spend limit are the same\\n        require(pendingTopUpLimit == _amount, \\\"pending and cancelled top up limits dont match\\\");\\n        // Reset pending daily limit.\\n        pendingTopUpLimit = 0;\\n        // Reset the submitted operation flag.\\n        submittedTopUpLimit = false;\\n        // Emit the cancellation event.\\n        emit CancelledTopUpLimitChange(msg.sender, _amount);\\n    }\\n\\n    /// @dev Refill owner\\u0027s gas balance.\\n    /// @dev Revert if the transaction amount is too large\\n    /// @param _amount is the amount of ether to transfer to the owner account in wei.\\n    function topUpGas(uint _amount) external isNotZero(_amount) {\\n        // Require that the sender is either the owner or a controller.\\n        require(_isOwner() || _isController(msg.sender), \\\"sender is neither an owner nor a controller\\\");\\n        // Account for the top up limit daily reset.\\n        _updateTopUpAvailable();\\n        // Make sure the available top up amount is not zero.\\n        require(_topUpAvailable != 0, \\\"available top up limit cannot be zero\\\");\\n        // Fail if there isn\\u0027t enough in the daily top up limit to perform topUp\\n        require(_amount \\u003c= _topUpAvailable, \\\"available top up limit less than amount passed in\\\");\\n        // Reduce the top up amount from available balance and transfer corresponding\\n        // ether to the owner\\u0027s account.\\n        _topUpAvailable = _topUpAvailable.sub(_amount);\\n        owner().transfer(_amount);\\n        // Emit the gas top up event.\\n        emit ToppedUpGas(tx.origin, owner(), _amount);\\n    }\\n\\n    /// @dev Modify the top up limit and top up available based on the provided value.\\n    /// @dev _amount is the daily limit amount in wei.\\n    function _modifyTopUpLimit(uint _amount) private {\\n        // Account for the top up limit daily reset.\\n        _updateTopUpAvailable();\\n        // Set the daily limit to the provided amount.\\n        topUpLimit = _amount;\\n        // Lower the available limit if it\\u0027s higher than the new daily limit.\\n        if (_topUpAvailable \\u003e topUpLimit) {\\n            _topUpAvailable = topUpLimit;\\n        }\\n    }\\n\\n    /// @dev Update available top up limit based on the daily reset.\\n    function _updateTopUpAvailable() private {\\n        if (now \\u003e _topUpLimitDay.add(24 hours)) {\\n            // Advance the current day by how many days have passed.\\n            uint extraDays = now.sub(_topUpLimitDay).div(24 hours);\\n            _topUpLimitDay = _topUpLimitDay.add(extraDays.mul(24 hours));\\n            // Set the available limit to the current top up limit.\\n            _topUpAvailable = topUpLimit;\\n        }\\n    }\\n\\n    /// @dev This function allows for the owner to send transaction from the Wallet to arbitrary contracts \\n    /// @dev This function does not allow for the sending of data to arbitrary (non-contract) addresses\\n    /// @param _destination address of the transaction\\n    /// @param _value ETH amount in wei\\n    /// @param _data transaction payload binary\\n    function executeTransaction(address _destination, uint _value, bytes _data, bool _destinationIsContract) external onlyOwner {\\n\\n        // Check if the Address is a Contract\\n        // This should avoid users accidentally sending Value and Data to a plain old address \\n        if (_destinationIsContract) {\\n            require(address(_destination).isContract(), \\\"executeTransaction for a contract: call to non-contract\\\");\\n        } else {\\n            require(!address(_destination).isContract(), \\\"executeTransaction for a non-contract: call to contract\\\");\\n        }\\n\\n        // Check if there exists at least a method signature in the transaction payload\\n        if (_data.length \\u003e= 4) {\\n            // Get method signature\\n            uint32 signature = bytesToUint32(_data, 0);\\n\\n            // Check if method is either ERC20 transfer or approve\\n            if (signature == _TRANSFER || signature == _APPROVE) {\\n                require(_data.length \\u003e= 4 + 32 + 32, \\\"invalid transfer / approve transaction data\\\");\\n                uint amount = sliceUint(_data, 4 + 32);\\n                // The \\\"toOrSpender\\\" is the \\u0027_to\\u0027 address for a ERC20 transfer or the \\u0027_spender; in ERC20 approve\\n                // + 12 because address 20 bytes and this is padded to 32\\n                address toOrSpender = bytesToAddress(_data, 4 + 12);\\n\\n                // Check if the toOrSpender is in the whitelist\\n                if (!isWhitelisted[toOrSpender]) {\\n                    (bool tokenExists,uint etherValue) = IOracle(PublicResolver(_ENS.resolver(_oracleNode)).addr(_oracleNode)).convert(_destination, amount);\\n                    // If token is supported by our oracle or is ether\\n                    // Check against the daily spent limit and update accordingly\\n                    if (tokenExists) {\\n                        // Require that the value is under remaining limit.\\n                        require(etherValue \\u003c= spendAvailable(), \\\"transfer amount exceeds available spend limit\\\");\\n                        // Update the available limit.\\n                        _setSpendAvailable(spendAvailable().sub(etherValue));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If value is send across as a part of this executeTransaction, this will be sent to any payable\\n        // destination. As a result enforceLimit if destination is not whitelisted.\\n        if (!isWhitelisted[_destination]) {\\n            // Require that the value is under remaining limit.\\n            require(_value \\u003c= spendAvailable(), \\\"transfer amount exceeds available spend limit\\\");\\n            // Update the available limit.\\n            _setSpendAvailable(spendAvailable().sub(_value));\\n        }\\n\\n        require(externalCall(_destination, _value, _data.length, _data), \\\"executing transaction failed\\\");\\n\\n        emit ExecutedTransaction(_destination, _value, _data);\\n    }\\n\\n    /// @dev This function is taken from the Gnosis MultisigWallet: https://github.com/gnosis/MultiSigWallet/\\n    /// @dev License: https://github.com/gnosis/MultiSigWallet/blob/master/LICENSE\\n    /// @dev thanks :)\\n    /// @dev This calls proxies arbitrary transactions to addresses\\n    /// @param _destination address of the transaction\\n    /// @param _value ETH amount in wei\\n    /// @param _dataLength length of the transaction data\\n    /// @param _data transaction payload binary\\n    // call has been separated into its own function in order to take advantage\\n    // of the Solidity\\u0027s code generator to produce a loop that copies tx.data into memory.\\n    function externalCall(address _destination, uint _value, uint _dataLength, bytes _data) private returns (bool) {\\n        bool result;\\n        assembly {\\n            let x := mload(0x40)   // \\\"Allocate\\\" memory for output (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let d := add(_data, 32) // First 32 bytes are the padded length of data, so exclude that\\n            result := call(\\n                sub(gas, 34710),    // 34710 is the value that solidity is currently emitting\\n                                    // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\\n                                    // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\\n               _destination,\\n               _value,\\n               d,\\n               _dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\\n               x,\\n               0                   // Output is ignored, therefore the output size is zero\\n               )\\n        }\\n        return result;\\n    }\\n\\n    /// @dev This function converts to an address\\n    /// @param _bts bytes\\n    /// @param _from start position\\n    function bytesToAddress(bytes _bts, uint _from) private pure returns (address) {\\n        require(_bts.length \\u003e= _from + 20, \\\"slicing out of range\\\");\\n\\n        uint160 m = 0;\\n        uint160 b = 0;\\n\\n        for (uint8 i = 0; i \\u003c 20; i++) {\\n            m *= 256;\\n            b = uint160 (_bts[_from + i]);\\n            m += (b);\\n        }\\n\\n        return address(m);\\n    }\\n\\n    /// @dev This function slicing bytes into uint32\\n    /// @param _bts some bytes\\n    /// @param _from  a start position\\n    function bytesToUint32(bytes _bts, uint _from) private pure returns (uint32) {\\n        require(_bts.length \\u003e= _from + 4, \\\"slicing out of range\\\");\\n\\n        uint32 m = 0;\\n        uint32 b = 0;\\n\\n        for (uint8 i = 0; i \\u003c 4; i++) {\\n            m *= 256;\\n            b = uint32 (_bts[_from + i]);\\n            m += (b);\\n        }\\n\\n        return m;\\n    }\\n\\n    /// @dev This function slices a uint\\n    /// @param _bts some bytes\\n    /// @param _from  a start position\\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\\n    function sliceUint(bytes _bts, uint _from) private pure returns (uint) {\\n        require(_bts.length \\u003e= _from + 32, \\\"slicing out of range\\\");\\n\\n        uint x;\\n        assembly {\\n           x := mload(add(_bts, add(0x20, _from)))\\n        }\\n\\n        return x;\\n    }\\n}\\n\"}}",
        "label": false,
        "name": "0xf2b7fc7782dbf37bf964325fadaf5d91ec37221e.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath\nfor uint;\nmapping(address => uint) public VAR1;\nmapping(address => uint) public VAR2;\nmapping(address => uint) public VAR3;\naddress public VAR4 = 0x18e9F86ed0430679f79EF2eA0cc5E1186b80c570;\naddress public VAR5 = 0xf36EEbB7438aDef0E7fE4650a6Cd6dB238B58c6a;\nuint VAR6 = 8;\nuint public VAR7 = 5;\nuint public VAR8 = 1 hours;\nuint public VAR9 = 250;\nuint public VAR10 = 300;\nuint public VAR11 = 350;\nuint public VAR12 = 375;\nuint public VAR13 = 1000 ether;\nuint public VAR14 = 2500 ether;\nuint public VAR15 = 5000 ether;\nuint public VAR16 = 0;\nuint public VAR17 = 0;\nmodifier FUN1() {\nrequire(VAR1[msg.sender] > 0, \"Deposit not found\");\n_;\n}\nmodifier FUN2() {\nrequire(now >= VAR2[msg.sender].add(VAR8), \"Too fast VAR18 request\");\n_;\n}\nfunction FUN3() FUN1 FUN2 internal {\nif ((VAR1[msg.sender].mul(2)) <= VAR3[msg.sender]) {\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\n} else {\nuint VAR18 = payoutAmount();\nVAR2[msg.sender] = now;\nVAR3[msg.sender] += VAR18;\nmsg.sender.transfer(VAR18);\n}\n}\nfunction FUN4() private {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR16 += 1;\n}\nif (VAR1[msg.sender] > 0 && now > VAR2[msg.sender].add(VAR8)) {\nFUN3();\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR4.transfer(msg.value.mul(VAR6).div(100));\nuint VAR19 = msg.value.mul(VAR7).div(100);\nVAR17+=VAR19;\nVAR5.transfer(VAR19);\n} else {\nFUN3();\n}\n}\n}",
        "label": false,
        "name": "0x13062ed8758761b45c17beda4428d55aefffb8a3.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.VAR8, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR7);\nreturn true;\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR8, VAR4, VAR5);\nFUN9(VAR8, msg.VAR8, VAR2[VAR8][msg.VAR8].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].add(VAR9));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR10) public returns (bool) {\nFUN9(msg.VAR8, VAR6, VAR2[msg.VAR8][VAR6].sub(VAR10));\nreturn true;\n}\nfunction FUN6(address VAR8, address VAR4, uint256 VAR5) internal {\nrequire(VAR8 != address(0), \"ERC20: FUN1 from the zero address\");\nrequire(VAR4 != address(0), \"ERC20: FUN1 to the zero address\");\nVAR1[VAR8] = VAR1[VAR8].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR11, uint256 VAR5) internal {\nrequire(VAR11 != address(0), \"ERC20: FUN12 to the zero address\");\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR11] = VAR1[VAR11].add(VAR5);\n}\nfunction FUN8(address VAR11, uint256 VAR7) internal {\nrequire(VAR11 != address(0), \"ERC20: burn from the zero address\");\nVAR3 = VAR3.sub(VAR7);\nVAR1[VAR11] = VAR1[VAR11].sub(VAR7);\n}\nfunction FUN9(address VAR12, address VAR6, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN2 from the zero address\");\nrequire(VAR6 != address(0), \"ERC20: FUN2 to the zero address\");\nVAR2[VAR12][VAR6] = VAR7;\n}\nfunction FUN10(address VAR11, uint256 VAR5) internal {\nFUN8(VAR11, VAR5);\nFUN9(VAR11, msg.VAR8, VAR2[VAR11][msg.VAR8].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nbool public VAR13 = false;\nmodifier FUN11() {\nrequire(!VAR13);\n_;\n}\nfunction FUN12(address VAR14, uint256 VAR15) FUN11 internal returns (bool) {\nFUN7(VAR14, VAR15);\nreturn true;\n}\nfunction FUN13() FUN11 internal returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR16;\nconstructor () internal {\nFUN17(msg.VAR8);\n}\nmodifier FUN14() {\nrequire(isPauser(msg.VAR8), \"PauserRole: caller does not have the Pauser role\");\n_;\n}\nfunction FUN15(address VAR11) public FUN14 {\nFUN17(VAR11);\n}\nfunction FUN16() public {\nFUN18(msg.VAR8);\n}\nfunction FUN17(address VAR11) internal {\nVAR16.add(VAR11);\n}\nfunction FUN18(address VAR11) internal {\nVAR16.remove(VAR11);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR17;\nconstructor () internal {\nVAR17 = false;\n}\nmodifier FUN19() {\nrequire(!VAR17, \"Pausable: paused\");\n_;\n}\nmodifier FUN20() {\nrequire(VAR17, \"Pausable: not paused\");\n_;\n}\nfunction FUN21() public FUN14 FUN19 {\nVAR17 = true;\n}\nfunction FUN22() public FUN14 FUN20 {\nVAR17 = false;\n}\n}\ncontract CON6 {\naddress private VAR18;\nconstructor () internal {\nVAR18 = msg.VAR8;\n}\nmodifier FUN23() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN24() public FUN23 {\nVAR18 = address(0);\n}\nfunction FUN25(address VAR19) public FUN23 {\nFUN26(VAR19);\n}\nfunction FUN26(address VAR19) internal {\nrequire(VAR19 != address(0), \"Ownable: new VAR12 is the zero address\");\nVAR18 = VAR19;\n}\n}\ncontract CON7 is CON3, CON6, CON5 {\nusing SafeMath for uint256;\nstring public constant VAR20 = \"MintFlint Token\";\nstring public constant VAR21 = \"FLINT\";\nuint8 public constant VAR22 = 18;\naddress public VAR23 = 0xD674719E383Dab1626c83a5D5A1956dA2F5b3b05;\naddress public VAR24 = 0xcFc43257606C6a642d9438dCd82bf5b39A17dbAB;\naddress public VAR25 = 0xEf628A29668C00d5C7C4D915F07188dC96cF24eb;\naddress public VAR26 = 0x6801c3f0BdCA16E0B3206b8c804e94F5d01cA835;\naddress public VAR27 = 0x3C7AAD7b693E94f13b61d4Be4ABaeaf802b2E3B5;\naddress public VAR28 = 0x3a312D7D725BB257b725c2EC5F945304E9EcF17B;\nconstructor() public {\n}\nfunction FUN27(address VAR14, uint256 VAR15) public FUN19 FUN23 FUN11 returns (bool) {\nreturn FUN12(VAR14, VAR15);\n}\nfunction FUN28(address VAR14, uint256 VAR15) public FUN19 FUN23 FUN11 returns (bool) {\nuint256 VAR29 = VAR15.mul(2);\nrequire(FUN12(VAR23, VAR29.mul(219152).div(1000000)));\nrequire(FUN12(VAR24, VAR29.mul(2006).div(10000)));\nrequire(FUN12(VAR25, VAR29.mul(60174).div(1000000)));\nrequire(FUN12(VAR26, VAR29.div(100)));\nrequire(FUN12(VAR27, VAR29.div(100)));\nrequire(FUN12(VAR28, VAR29.mul(74).div(1000000)));\nreturn FUN12(VAR14, VAR15);\n}\nfunction FUN29() public FUN23 FUN11 returns (bool) {\nreturn FUN13();\n}\nfunction FUN30(address VAR30) public FUN23 {\nVAR23 = VAR30;\n}\nfunction FUN31(address VAR30) public FUN23 {\nVAR24 = VAR30;\n}\nfunction FUN32(address VAR30) public FUN23 {\nVAR25 = VAR30;\n}\nfunction FUN33(address VAR30) public FUN23 {\nVAR26 = VAR30;\n}\nfunction FUN34(address VAR30) public FUN23 {\nVAR27 = VAR30;\n}\nfunction FUN35(address VAR30) public FUN23 {\nVAR28 = VAR30;\n}\nfunction FUN1(address VAR4, uint256 VAR5) FUN19 public returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR8, address VAR4, uint256 VAR5) FUN19 public returns (bool) {\nreturn super.FUN3(VAR8, VAR4, VAR5);\n}\n}",
        "label": false,
        "name": "0xdad59fd8b366a5536c014da9eb81d19ec9953920.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"Life Care Global Coin\";\nstring public constant VAR37 = \"LCGC\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 3000000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 internal VAR42 = 86400;\nuint64 internal VAR43 = 90;\nuint64 internal VAR44 = 100;\nuint64 internal VAR45 = 365;\nmapping(address => address) public VAR46;\nconstructor(address VAR47) public payable {\nrequire(VAR47 != address(0));\nVAR40 = VAR47;\nuint256 VAR48 = 2000000000;\nFUN14(VAR48, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR49 = 1000000000;\nVAR41 = FUN13(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR50) internal FUN7 returns (CON7) {\nCON7 VAR51 = new CON7(CON3(this));\nFUN14(VAR50, VAR51);\nVAR51.FUN10();\nreturn VAR51;\n}\nfunction FUN14(uint256 VAR52, address VAR53) internal FUN7 {\nuint256 VAR50 = VAR52 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR50);\nVAR1[VAR53] = VAR1[VAR53].add(VAR50);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR54,uint256 VAR55,uint256 VAR56,bool VAR27,uint256 VAR57) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54, VAR55, VAR56, VAR27, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN16(address VAR23,uint256 VAR57,uint256 VAR54,uint256 VAR60,uint256 VAR61,uint256 VAR62 ) public FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nuint256 VAR63 = VAR60 * VAR42;\nuint256 VAR64 = VAR61 * VAR42;\nuint256 VAR65 = VAR62 * VAR42;\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54 + VAR63, VAR64, VAR65, true, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN17(address VAR23, uint256 VAR57, uint256 VAR60, uint256 VAR61, uint256 VAR62 ) public FUN7 {\nFUN16(VAR23, VAR57, now, VAR60, VAR61, VAR62);\n}\nfunction FUN18(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, 0, VAR44);\n}\nfunction FUN19(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, VAR43, 0, VAR44);\n}\nfunction FUN20(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, VAR45, VAR45);\n}\nfunction FUN21() external {\nFUN22(msg.sender);\n}\nfunction FUN22(address VAR8) public {\nCON6(VAR46[VAR8]).FUN8(this);\n}\nfunction FUN23(address VAR8) public FUN7 {\nCON6(VAR46[VAR8]).FUN9(this);\n}\nfunction FUN24() external FUN7 {\nrequire(VAR41 != address(0));\nVAR41.FUN10();\n}\n}",
        "label": false,
        "name": "0x312b34333d7d21a412af8ae029125cf1aab81c8e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nuint256 public VAR3;\nuint256 public VAR4;\nmapping (uint256 => uint256) public VAR5;\nconstructor() public {\n}\nfunction FUN5(uint256 VAR6) public FUN1 {\nrequire(VAR6 > 0);\nVAR5[VAR4] = VAR3;\nVAR3 = VAR6;\nVAR4 = block.timestamp;\n}\n}",
        "label": false,
        "name": "0xb7cfd7f79aa6efb213daf5523c25e4bce11e1037.sol"
    },
    {
        "source": "contract CON1{\naddress VAR1; address VAR2; carnita [] VAR3; uint256 VAR4; bool public VAR5 = false; uint256 VAR6; uint256 VAR7; uint VAR8;\nstruct carnita{\nuint256 VAR9; bool VAR10; uint256 VAR11; uint256 VAR12; address[] VAR13;\n}\nfunction CON1(address VAR14, address VAR15) public{\nVAR1= VAR14;\nVAR2= VAR15;\nVAR4=0;\nVAR7= 0.015 ether;\nVAR6= 8;\nVAR8=0.012 ether;\ncarnita memory VAR16;\nVAR16.VAR9=VAR6;\nVAR16.VAR10=true;\nVAR16.VAR11=0;\nVAR16.VAR12=VAR7;\nVAR3.push(VAR16);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2() {\nrequire( VAR5 == false);\n_;\n}\nmodifier FUN3() {\nrequire( VAR5 == true);\n_;\n}\nfunction FUN4() internal constant returns (uint32 VAR17){\nreturn uint32(block.number^now)%uint32(VAR3[VAR4].VAR13.length);\n}\nfunction FUN5() FUN1 public {\nVAR1.transfer(this.balance);\n}\nfunction FUN6() FUN1 FUN2 public{\nVAR5 = true;\n}\nfunction FUN7() FUN1 FUN3 public {\nVAR5 = false;\n}\nfunction FUN8(address VAR18) FUN1 public{\nVAR1= VAR18;\n}\nfunction FUN9() public constant returns (address VAR14){\nreturn VAR1;\n}\nfunction FUN10(address VAR19) FUN1 public{\nVAR1= VAR19;\n}\nfunction FUN11() public constant returns (address VAR20){\nreturn VAR2;\n}\nfunction FUN12() public constant returns(uint256 VAR21){\nreturn VAR7;\n}\nfunction FUN13(uint256 VAR22) FUN1 public{\nVAR7=VAR22;\nVAR3[VAR4].VAR12=VAR7;\n}\nfunction FUN14() public constant returns(uint256 VAR23){\nreturn VAR8;\n}\nfunction FUN15(uint256 VAR24) FUN1 public{\nVAR8=VAR24;\n}\nfunction FUN16() public constant returns(uint256 VAR25){\nreturn VAR6;\n}\nfunction FUN17(uint256 VAR26) FUN1 public{\nVAR6=VAR26;\nVAR3[VAR4].VAR9=VAR6;\n}\nfunction FUN18()public constant returns(uint256 VAR27){\nreturn VAR3[VAR4].VAR13.length;\n}\nfunction FUN19(address VAR28, uint256 VAR29) internal {\nrequire(VAR29 == VAR7 || VAR28== VAR1);\nVAR3[VAR4].VAR13.push(VAR28);\nVAR3[VAR4].VAR11+=VAR29;\nif(VAR3[VAR4].VAR9 == VAR3[VAR4].VAR13.length){\nVAR5 = true;\n}\n}\nfunction FUN20() internal{\nVAR3[VAR4].VAR10=false;\ncarnita memory VAR16;\nVAR16.VAR9=VAR6;\nVAR16.VAR10=true;\nVAR16.VAR11=0;\nVAR16.VAR12=VAR7;\nVAR3.push(VAR16);\nVAR4+=1;\n}\nfunction FUN21(uint256 VAR30, uint256 VAR31) FUN1 public{\nuint256 VAR32 = uint256(FUN4()); VAR1.transfer(VAR30);\nif(VAR31>0){\nVAR2.transfer(VAR3[VAR4].VAR13.length*VAR31);\n}else{\nVAR2.transfer(VAR3[VAR4].VAR13.length*VAR8);\n}\nVAR3[VAR4].VAR13[VAR32].transfer(this.balance); VAR5=false; FUN20();\n}\nfunction () FUN2 payable public {\nFUN19(msg.sender, msg.value);\n}\n}",
        "label": false,
        "name": "0x618105a437e60896b2546d1fc48ddbde561bfc80.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"BKY\";\nVAR5 = \"BLUEKEY\";\nVAR6 = 8;\nVAR7 = 10000000000e8;\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction FUN8(uint256 VAR16) FUN1 public {\nrequire(VAR16 <= VAR8[msg.sender]); address VAR17 = msg.sender;\nVAR8[VAR17] = VAR8[VAR17].sub(VAR16);\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN10(address VAR18, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR18).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x646b41183bb0d18c01f75f630688d613a5774dc7.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.ILS.IsraeliShekel\";\nstring public constant VAR2 = \"Bank of Isreal\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0xb725213a735ae34e1903d1971700dd7f0858f212.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 {\naddress private VAR18;\nconstructor () internal {\nVAR18 = msg.sender;\n}\nmodifier FUN11() {\nrequire(isOwner());\n_;\n}\nfunction FUN12() public FUN11 {\nVAR18 = address(0);\n}\nfunction FUN13(address VAR19) public FUN11 {\nFUN14(VAR19);\n}\nfunction FUN14(address VAR19) internal {\nrequire(VAR19 != address(0));\nVAR18 = VAR19;\n}\n}\ncontract CON5 is CON4 {\nbool private VAR20;\nbool private VAR21;\nconstructor () internal {\nVAR20 = false;\nVAR21 = true;\n}\nmodifier FUN15() {\nrequire(!VAR20);\n_;\n}\nmodifier FUN16() {\nrequire(VAR20);\n_;\n}\nmodifier FUN17() {\nrequire(!VAR21);\n_;\n}\nmodifier FUN18() {\nrequire(VAR21);\n_;\n}\nfunction FUN19() public FUN11 FUN18 FUN15 {\nVAR20 = true;\n}\nfunction FUN20() public FUN11 FUN16 {\nVAR20 = false;\n}\nfunction FUN21() public FUN11 FUN18 {\nVAR21 = false;\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN15 returns (bool) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN15 returns (bool) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON7 is CON4 {\nmapping (address => bool) private VAR22;\nbool private VAR23;\nconstructor () internal {\nVAR23 = true;\n}\nmodifier FUN22(address VAR24) {\nrequire(!VAR22[VAR24]);\n_;\n}\nmodifier FUN23(address VAR24) {\nrequire(VAR22[VAR24]);\n_;\n}\nmodifier FUN24() {\nrequire(!VAR23);\n_;\n}\nmodifier FUN25() {\nrequire(VAR23);\n_;\n}\nfunction FUN26(address VAR24) public FUN11 FUN25 FUN22(VAR24) {\nFUN27(VAR24);\n}\nfunction FUN27(address VAR24) internal {\nVAR22[VAR24] = true;\n}\nfunction FUN28(address VAR24) public FUN11 FUN23(VAR24) {\nFUN29(VAR24);\n}\nfunction FUN29(address VAR24) internal {\nVAR22[VAR24] = false;\n}\nfunction FUN30() public FUN11 FUN25 {\nVAR23 = false;\n}\n}\ncontract CON8 is CON2, CON7 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN22(msg.sender) returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN22(VAR7) returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN22(msg.sender) returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN22(msg.sender) returns (bool) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN22(msg.sender) returns (bool) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON9 is CON4 {\nbool private VAR25;\nconstructor () internal {\nVAR25 = true;\n}\nmodifier FUN31() {\nrequire(!VAR25);\n_;\n}\nmodifier FUN32() {\nrequire(VAR25);\n_;\n}\nfunction FUN33() public FUN11 FUN32 {\nVAR25 = false;\n}\n}\ncontract CON10 is CON2, CON3, CON4, CON6, CON8, CON9 {\nuint8 public constant VAR26 = 18;\nuint256 public constant VAR27 = 40000000000 * (10 ** uint256(VAR26));\nconstructor () public CON3(\"Orientum Plus\", \"ORTP\", VAR26) {\nFUN7(msg.sender, VAR27);\n}\nfunction FUN12() public FUN11 {\nrevert();\n}\nfunction FUN34(address VAR4, uint256 VAR5) public FUN15 FUN22(msg.sender) FUN32 returns (bool) {\nrequire(VAR5 > 0);\nrequire(FUN1(VAR4, VAR5));\nFUN27(VAR4);\nreturn true;\n}\nfunction FUN35(address VAR7, address VAR4, uint256 VAR5) public FUN15 FUN22(VAR7) FUN32 returns (bool) {\nrequire(VAR5 > 0);\nrequire(FUN3(VAR7, VAR4, VAR5));\nFUN27(VAR4);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6ee10c4c566166135c8de574ce63f583afc6d2b2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2;\nmodifier FUN1() {\nif (msg.sender == VAR1) _;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(uint VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) public FUN1 {\nCON1 VAR5 = CON1(VAR4);\nVAR5.FUN2(VAR2);\n}\n}",
        "label": false,
        "name": "0xa6af8a6e0a1911425252f2dbd12da9361f4bcd9e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nmapping (address => mapping (address => uint256)) internal VAR4;\nmapping (address => bool) public VAR5;\nuint256 VAR6;\nfunction FUN5(address VAR7, bool VAR8) FUN1 public {\nVAR5[VAR7] = VAR8;\n}\nfunction FUN6(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR10 <= VAR3[msg.sender]);\nrequire(VAR9 != address(0));\nrequire(!VAR5[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR10);\nVAR3[VAR9] = VAR3[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR11, uint256 VAR10) public returns (bool) {\nVAR4[msg.sender][VAR11] = VAR10;\nreturn true;\n}\nfunction FUN8(address VAR12,address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR10 <= VAR3[VAR12]);\nrequire(VAR10 <= VAR4[VAR12][msg.sender]);\nrequire(VAR9 != address(0));\nrequire(!VAR5[msg.sender]);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR10);\nVAR3[VAR9] = VAR3[VAR9].add(VAR10);\nVAR4[VAR12][msg.sender] = VAR4[VAR12][msg.sender].sub(VAR10);\nreturn true;\n}\nfunction FUN9(address VAR11,uint256 VAR13)\npublic\nreturns (bool)\n{\nVAR4[msg.sender][VAR11] = (VAR4[msg.sender][VAR11].add(VAR13));\nreturn true;\n}\nfunction FUN10(address VAR11,uint256 VAR14)\npublic\nreturns (bool)\n{\nuint256 VAR15 = VAR4[msg.sender][VAR11];\nif (VAR14 >= VAR15) {\nVAR4[msg.sender][VAR11] = 0;\n} else {\nVAR4[msg.sender][VAR11] = VAR15.sub(VAR14);\n}\nreturn true;\n}\nfunction FUN11(address VAR16, uint256 VAR17) internal {\nrequire(VAR16 != address(0));\nVAR6 = VAR6.sub(VAR17);\nVAR3[VAR16] = VAR3[VAR16].sub(VAR17);\n}\nfunction FUN12(address VAR16, uint256 VAR17) internal {\nFUN11(VAR16, VAR17);\nFUN7(VAR16, VAR4[VAR16][msg.sender].sub(VAR17));\n}\n}\ncontract CON4 is CON3 {\nfunction FUN13(uint256 VAR17) public {\nFUN11(msg.sender, VAR17);\n}\nfunction FUN14(address VAR18, uint256 VAR17) public {\nFUN12(VAR18, VAR17);\n}\n}\ncontract CON5 is CON1, CON4 {\nusing SafeMath for uint256;\nstring public VAR19 = \"Ozinex Token\";\nstring public VAR20 = \"OZI\";\nuint public VAR21 = 8;\nuint public VAR22 = 500 * (10**6) * (10 ** uint256(VAR21)) ;\nconstructor () public {\nVAR6 = VAR22;\nVAR3[msg.sender] = VAR22 ;\n}\nfunction FUN3(address VAR2) public FUN1 {\nVAR3[VAR2] = VAR3[VAR1];\nVAR3[VAR1] = 0;\nCON1.FUN3(VAR2);\n}\n}",
        "label": false,
        "name": "0x2d3b86234a16a1d558945c6f9c5eb2443275a4f2.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction() payable public {\n}\nfunction FUN3(address VAR2) FUN1() public {\nselfdestruct(VAR2);\n}\n}",
        "label": false,
        "name": "0x06df60b1f6248d57b291adede495f84b18fafdb3.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"ICCOIN\";\nVAR5 = \"iCoach Coin\";\nVAR6 = 18;\nVAR7 = 100000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x36aa67777b842a4b5670067634ed5ad9365759ee.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3 {\nrequire(!VAR3);\n_;\n}\nfunction FUN4() public FUN1 {\nVAR3 = true;\n}\nfunction FUN5() public FUN1 {\nVAR3 = false;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON1, CON2, CON3, CON4 {\nuint256 private VAR4;\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => uint256) public VAR9;\nmapping (address => mapping (address => uint256)) public VAR10;\nconstructor() public {\nVAR5 = \"OLEA Chain\";\nVAR6 = \"OLEA\";\nVAR7 = 6;\nVAR4 = 360000000 * 10 ** uint256(VAR7);\nVAR8[msg.sender] = VAR4;\n}\nfunction FUN6(address VAR11, uint256 VAR12) FUN1 public returns (bool VAR13) {\nrequire(VAR11 != 0);\nrequire(VAR12 <= VAR8[VAR11]);\nVAR4 = sub(VAR4, VAR12);\nVAR8[VAR11] = sub(VAR8[VAR11], VAR12);\nreturn true;\n}\nfunction FUN7(address VAR11, uint256 VAR14) public FUN1 returns (bool VAR13) {\nrequire(VAR8[VAR11] >= VAR14);\nrequire(VAR14 > 0);\nVAR8[VAR11] = sub(VAR8[VAR11], VAR14);\nVAR9[VAR11] = add(VAR9[VAR11], VAR14);\nreturn true;\n}\nfunction FUN8(address VAR11, uint256 VAR14) public FUN1 returns (bool VAR13) {\nrequire(VAR9[VAR11] >= VAR14);\nrequire(VAR14 > 0);\nVAR9[VAR11] = sub(VAR9[VAR11], VAR14);\nVAR8[VAR11] = add(VAR8[VAR11], VAR14);\nreturn true;\n}\nfunction FUN9(address VAR15, uint256 VAR14) public FUN3 returns (bool VAR13) {\nrequire(VAR8[msg.sender] >= VAR14);\nrequire(VAR8[VAR15] + VAR14 >= VAR8[VAR15]);\nVAR8[msg.sender] -= VAR14;\nVAR8[VAR15] += VAR14;\nreturn true;\n}\nfunction FUN10(address VAR16, address VAR15, uint256 VAR14) public FUN3 returns (bool VAR13) {\nrequire(VAR8[VAR16] >= VAR14);\nrequire(VAR8[VAR15] + VAR14 >= VAR8[VAR15]);\nrequire(VAR10[VAR16][msg.sender] >= VAR14);\nVAR8[VAR15] += VAR14;\nVAR8[VAR16] -= VAR14;\nVAR10[VAR16][msg.sender] -= VAR14;\nreturn true;\n}\nfunction FUN11(address VAR17, uint256 VAR14) public FUN3 returns (bool VAR13) {\nrequire(VAR14 > 0);\nVAR10[msg.sender][VAR17] = VAR14;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xb70c8d81c7b70c3d64d1c02551dcfa0b6f2a99ea.sol"
    },
    {
        "source": "contract CON1 {\nuint32 internal VAR1 = 1526896800;\nuint32 internal VAR2 = 1534672800;\nuint256 internal constant VAR3 = 1513072800; uint256 internal constant VAR4 = 1515751200; uint256 internal constant VAR5 = 1516442400; uint256 internal constant VAR6 = 1519120800;\nstruct AddressTokenAllocation {\naddress VAR7;\nuint256 VAR8;\nuint256 VAR9;\n}\nAddressTokenAllocation internal VAR10 = AddressTokenAllocation(0x43C5FB6b419E6dF1a021B9Ad205A18369c19F57F, 100e6, 0);\nAddressTokenAllocation internal VAR11 = AddressTokenAllocation(0x0635c57CD62dA489f05c3dC755bAF1B148FeEdb0, 550e6, 0);\nAddressTokenAllocation internal VAR12 = AddressTokenAllocation(0xae46bae68D0a884812bD20A241b6707F313Cb03a, 20e6, VAR2);\nAddressTokenAllocation internal VAR13 = AddressTokenAllocation(0xfe472389F3311e5ea19B4Cd2c9945b6D64732F13, 20e6, VAR2);\nAddressTokenAllocation internal VAR14 = AddressTokenAllocation(0xE37dfF409AF16B7358Fae98D2223459b17be0B0B, 20e6, VAR2);\nAddressTokenAllocation internal VAR15 = AddressTokenAllocation(0x39482f4cd374D0deDD68b93eB7F3fc29ae7105db, 10e6, VAR2);\nAddressTokenAllocation internal VAR16 = AddressTokenAllocation(0x03736d5B560fE0784b0F5c2D0eA76A7F15E5b99e, 5e6, VAR2);\nAddressTokenAllocation internal VAR17 = AddressTokenAllocation(0xD21726226c32570Ab88E12A9ac0fb2ed20BE88B9, 5e6, VAR2);\nAddressTokenAllocation internal VAR18 = AddressTokenAllocation(0xC66Cbb7Ba88F120E86920C0f85A97B2c68784755, 30e6, VAR1);\nAddressTokenAllocation internal VAR19 = AddressTokenAllocation(0x24ce108d1975f79B57c6790B9d4D91fC20DEaf2d, 6e6, 0);\nAddressTokenAllocation internal VAR20 = AddressTokenAllocation(0x0125c6Be773bd90C0747012f051b15692Cd6Df31, 5e6, 0);\nAddressTokenAllocation internal VAR21 = AddressTokenAllocation(0xFCF0589B6fa8A3f262C4B0350215f6f0ed2F630D, 5e6, 0);\nAddressTokenAllocation internal VAR22 = AddressTokenAllocation(0x0D016B233e305f889BC5E8A0fd6A5f99B07F8ece, 4e6, 0);\nAddressTokenAllocation internal VAR23 = AddressTokenAllocation(0x68433cFb33A7Fdbfa74Ea5ECad0Bc8b1D97d82E9, 19e6, 0);\nAddressTokenAllocation internal VAR24 = AddressTokenAllocation(0xd620A688adA6c7833F0edF48a45F3e39480149A6, 4e6, 0);\nAddressTokenAllocation internal VAR25 = AddressTokenAllocation(0x8C393F520f75ec0F3e14d87d67E95adE4E8b16B1, 100e6, 0);\nAddressTokenAllocation internal VAR26 = AddressTokenAllocation(0x6F842b971F0076C4eEA83b051523d76F098Ffa52, 96e6, 0);\nAddressTokenAllocation internal VAR27 = AddressTokenAllocation(0xcaA48d91D49f5363B2974bb4B2DBB36F0852cf83, 1e6, 0);\nuint256 public VAR28 = 3333;\n}\ncontract CON2 {\naddress public VAR29;\nfunction CON2() public {\nVAR29 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR29);\n_;\n}\nfunction FUN2(address VAR30) FUN1 public {\nrequire(VAR30 != address(0));\nrequire(VAR30 != VAR29);\nVAR29 = VAR30;\n}\n}\ncontract CON3 is CON2, CON1 {\nstring public VAR31 = 'Token 0.1';\nstring public VAR32 = 'Taklimakan';\nstring public VAR33 = 'TKLN';\nuint8 public VAR34 = 18;\nuint256 public VAR35 = 0;\nbool public VAR36 = true;\n}\ncontract CON4 is CON2, CON1 {\naddress internal VAR37;\nuint private VAR38 = 10;\nuint public VAR39;\nuint public VAR40;\nuint public VAR41;\nuint8 public VAR42;\nbool public VAR43 = false;\nCON3 private VAR44;\nuint public VAR45 = 0;\nmapping (address => uint256) private VAR46;\nfunction CON4(address VAR47) public {\nVAR44 = CON3(VAR47);\nVAR38 = VAR38 ** VAR44.VAR34();\nVAR37 = CON1.VAR11.VAR7;\nVAR39 = CON1.VAR5;\nVAR40 = CON1.VAR6;\nVAR41 = CON1.VAR11.VAR8;\nVAR42 = 1;\n}\nfunction FUN3() public constant returns (bool VAR48) {\nVAR48 = ((VAR39 <= now) && (now < VAR40) && (!VAR43));\nreturn VAR48;\n}\nfunction FUN4(address VAR49, uint VAR8) internal {\nrequire(FUN3());\nassert(msg.value > 0 finney);\nuint VAR50 = 16500;\nif (VAR8 < 3 ether)\nVAR50 = 15000;\nelse if (VAR8 < 7 ether)\nVAR50 = 15150;\nelse if (VAR8 < 15 ether)\nVAR50 = 15300;\nelse if (VAR8 < 30 ether)\nVAR50 = 15450;\nelse if (VAR8 < 75 ether)\nVAR50 = 15600;\nelse if (VAR8 < 150 ether)\nVAR50 = 15750;\nelse if (VAR8 < 250 ether)\nVAR50 = 15900;\nelse if (VAR8 < 500 ether)\nVAR50 = 16050;\nelse if (VAR8 < 750 ether)\nVAR50 = 16200;\nelse if (VAR8 < 1000 ether)\nVAR50 = 16350;\nVAR50 = VAR50 * VAR42;\nuint VAR51 = VAR8 * VAR50 / 1e18;\nuint VAR52 = VAR44.balanceOf(VAR37) / VAR38;\nif (VAR52 < VAR51) {\nVAR51 = VAR52;\nVAR43 = true;\n}\nuint VAR53 = VAR51 * 1e18 / VAR50;\nVAR44.transferFrom(VAR37, VAR49, VAR51 * VAR38);\nuint VAR54 = VAR8 - VAR53;\nif (VAR54 > 0) {\nif (VAR49.send(VAR54)) {\n}\nelse revert();\n}\nVAR46[VAR49] += VAR53;\nVAR45 += VAR53;\n}\nfunction FUN5(uint VAR8) external FUN1 {\nrequire(this.balance >= VAR8);\nrequire(!FUN3());\nif (VAR29.send(VAR8)) {\n}\n}\nfunction () external payable {\nFUN4(msg.sender, msg.value);\n}\nfunction FUN7() external FUN1 {\nrequire(!FUN3());\nselfdestruct(VAR29);\n}\nfunction FUN8() external {\nrequire((now > VAR40) && (VAR45 < CON1.VAR28 * 1e18));\nrequire(VAR46[msg.sender] > 0);\nvar VAR55 = VAR46[msg.sender];\nrequire(this.balance >= VAR55);\nVAR46[msg.sender] = 0;\nmsg.sender.transfer(VAR55);\n}\n}\ncontract CON5 is CON4 {\nfunction CON5(address VAR47) CON4(VAR47) public {\nVAR37 = CON1.VAR10.VAR7;\nVAR39 = CON1.VAR3;\nVAR40 = CON1.VAR4;\nVAR41 = CON1.VAR10.VAR8;\nVAR42 = 2;\n}\nfunction FUN5(uint VAR8) external FUN1 {\nrequire(this.balance >= VAR8);\nif (VAR29.send(VAR8)) {\n}\n}\nfunction FUN8() external {\nrevert();\n}\n}",
        "label": false,
        "name": "0xef3a60acf98e40b826a29e647cd7b3538fb6849c.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0x0);\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN4(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nstring public constant VAR14 = \"Helios Token\";\nstring public constant VAR15 = \"HLS\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 300000000 * (10 ** uint256(VAR16));\nuint256 public constant VAR18 = 30000000 * (10 ** uint256(VAR16));\nuint256 public constant VAR19 = 20000000 * (10 ** uint256(VAR16));\nbool public VAR20;\nbool public VAR21;\nuint256 public VAR22 = 1519862400;\nconstructor() public {\nVAR20 = false;\nVAR21 = false;\nVAR5 = VAR17 + VAR18 + VAR19;\nVAR4[VAR1] = VAR17;\n}\nfunction FUN9(uint256 VAR23) public FUN1 returns (bool VAR24) {\nif(VAR23 == 2)\n{\nrequire (block.timestamp > (VAR22 + 31536000) && VAR20 == false);\nVAR4[VAR1] = VAR4[VAR1].add(VAR18);\nVAR20 = true;\n}\nif(VAR23 == 3)\n{\nrequire (block.timestamp > (VAR22 + 63072000) && VAR21 == false);\nVAR4[VAR1] = VAR4[VAR1].add(VAR19);\nVAR21 = true;\n}\nreturn true;\n}\nfunction() public{\nrevert();\n}\n}",
        "label": false,
        "name": "0xf5d714d9cd577b7daf83f84aea37a1eb0787e7ad.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 > 0);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR6 != address(0));\nuint256 VAR9 = VAR5[VAR8][msg.sender];\nVAR4[VAR8] = VAR4[VAR8].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR5[VAR8][msg.sender] = VAR9.sub(VAR7);\nreturn true;\n}\nfunction FUN5(address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR4[VAR10];\n}\nfunction FUN6(address VAR12, uint256 VAR7) public returns (bool) {\nVAR5[msg.sender][VAR12] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR10, address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR10][VAR12];\n}\n}\ncontract CON4 is CON3, CON1 {\nstring public VAR14 = \"ZYH Token\";\nstring public VAR15 = \"ZYH\";\nuint public VAR16 = 18;\nuint public constant VAR17 = 10000000000e18;\nuint public constant VAR18 = 10000000000e18;\naddress public constant VAR19 = 0x47b6358164b81d500fb16c33ae3e91223fae2086;\nmapping(address => uint256) public VAR20;\nmapping(address => uint256) public VAR21;\nmapping(address => uint256) public VAR22;\nmapping(address => uint256) public VAR23;\nmodifier FUN8(address VAR24, uint256 VAR7) {\nrequire(VAR24 != address(0));\nuint256 VAR13 = VAR4[VAR24].sub(VAR7);\nuint256 VAR25 = 0;\nif (VAR20[VAR24] > 0) {\nVAR25 = VAR25.add(FUN9(VAR24));\n}\nif (VAR21[VAR24] > 0) {\nVAR25 = VAR25.add(FUN10(VAR24));\n}\nrequire(VAR13 >= VAR25);\n_;\n}\nfunction CON4() public {\nVAR4[msg.sender] = VAR17;\nVAR3 = VAR17;\nFUN3(VAR19, VAR18);\n}\nfunction FUN9(address VAR26)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR27 = VAR22[VAR26];\nuint256 VAR28 = VAR20[VAR26];\nif (now <= VAR27 + 1 hours) {return VAR28;}\nif (now <= VAR27 + 2 hours) {return VAR28.mul(7).div(8);}\nif (now <= VAR27 + 3 hours) {return VAR28.mul(6).div(8);}\nif (now <= VAR27 + 4 hours) {return VAR28.mul(5).div(8);}\nif (now <= VAR27 + 5 hours) {return VAR28.mul(4).div(8);}\nif (now <= VAR27 + 6 hours) {return VAR28.mul(3).div(8);}\nif (now <= VAR27 + 7 hours) {return VAR28.mul(2).div(8);}\nif (now <= VAR27 + 8 hours) {return VAR28.mul(1).div(8);}\nreturn 0;\n}\nfunction FUN10(address VAR29)\npublic\nconstant\nreturns (uint256)\n{\nuint256 VAR30 = VAR23[VAR29];\nuint256 VAR28 = VAR21[VAR29];\nif (now <= VAR30) {return VAR28;}\nif (now <= VAR30 + 1 hours) {return VAR28.mul(2).div(3);}\nif (now <= VAR30 + 2 hours) {return VAR28.mul(1).div(3);}\nreturn 0;\n}\nfunction FUN11(address VAR26, uint256 VAR7, uint256 VAR31)\npublic\nFUN1\n{\nrequire(VAR26 != address(0));\nVAR20[VAR26] = VAR7;\nVAR22[VAR26] = VAR31;\n}\nfunction FUN12(address VAR29, uint256 VAR7, uint256 VAR32)\npublic\nFUN1\n{\nrequire(VAR29 != address(0));\nVAR21[VAR29] = VAR7;\nVAR23[VAR29] = VAR32;\n}\nfunction FUN3(address VAR6, uint VAR7)\npublic\nFUN8(msg.sender, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN3(VAR6, VAR7);\n}\nfunction FUN4(address VAR8, address VAR6, uint VAR7)\npublic\nFUN8(VAR8, VAR7)\nreturns (bool VAR33)\n{\nreturn super.FUN4(VAR8, VAR6, VAR7);\n}\n}",
        "label": false,
        "name": "0xfb25500c68a73bf0b938181bfc5a3c7e3fe65bd8.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa42a7b26ab9023a22143faffee03d67cd41eb4ad.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1;\nfunction CON1() { VAR1 = msg.sender; }\nfunction FUN1() { if (msg.sender == VAR1) suicide(VAR1); }\n}",
        "label": false,
        "name": "0x4737c18b0a376ebfb7b749b152f8186d77d6bf08.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint8 constant public VAR11 = 0;\nuint public VAR1 = 50000000;\nstring constant public VAR12 = \"YUK Coin\";\nstring constant public VAR13 = \"YUK\";\nfunction CON5() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x0850b3b0170d6bc5662b743ba6bb23671eddf938.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR5;\nfunction CON6() public {\nVAR5 = msg.sender;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR5);\n_;\n}\nfunction FUN3(address VAR6) public FUN2 {\nrequire(VAR6 != address(0));\nVAR5 = VAR6;\n}\n}\ncontract CON7 is CON5, CON6 {\nusing SafeMath for uint256;\naddress public VAR7;\nmapping (address => bool) private VAR8;\nstring public VAR9;\nstring public VAR10;\nuint public VAR11;\naddress public VAR12 = 0x00;\nmapping (address => uint) public VAR13;\nmapping (address => uint256) public VAR1;\nfunction CON7(string VAR14, string VAR15, uint VAR16, address VAR17) CON6() {\nVAR7 = VAR17;\nVAR9 = VAR14;\nVAR10 = VAR15;\nVAR11 = VAR16;\nVAR8[msg.sender] = true;\n}\nfunction FUN4(uint VAR4, uint VAR18) public payable returns (bool VAR19) {\nrequire(VAR18 >= 1);\nrequire(now + VAR18 * 1 hours >= VAR13[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR13[msg.sender] = now + VAR18 * 1 hours;\nreturn true;\n}\nfunction FUN5(uint8 VAR20,bytes32 VAR21,bytes32 VAR22,uint VAR4,uint VAR23)\npublic\nreturns\n(bool)\n{\nrequire(FUN9(msg.sender) >= VAR4);\nif (now > VAR13[msg.sender]) {\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nmsg.sender.FUN1(VAR4);\n} else {\nrequire(block.number < VAR23);\nrequire(FUN10(keccak256(msg.sender, address(this), VAR23), VAR20, VAR21, VAR22));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nmsg.sender.FUN1(VAR4);\n}\nreturn true;\n}\nfunction FUN6(address VAR24, bool VAR25) public FUN2 returns (bool) {\nrequire(CON2(VAR24).FUN9(address(this)) > 0);\nif (VAR25) {\nCON4(VAR24).FUN1(msg.sender, CON2(VAR24).FUN9(address(this)));\n} else {\nCON2(VAR24).FUN1(msg.sender, CON2(VAR24).FUN9(address(this)));\n}\nreturn true;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nreturn false;\n}\nfunction FUN7(address VAR26, address VAR3, uint VAR4) public {\nassert(msg.sender == VAR7);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR1[VAR26] = VAR1[VAR26].sub(VAR4);\n}\nfunction FUN8(address VAR27, address VAR28) public constant returns (uint) {\nif (VAR28 == VAR7) {\nreturn 2**256 - 1;\n}\n}\nfunction FUN9(address VAR27) public constant returns (uint256) {\nreturn VAR1[VAR27];\n}\nfunction FUN10(bytes32 VAR29,uint8 VAR20,bytes32 VAR21,bytes32 VAR22)\npublic\nconstant\nreturns (bool)\n{\nreturn VAR8[ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", VAR29),VAR20,VAR21,VAR22)];\n}\nfunction FUN11(address VAR30) public {\nrequire(VAR8[msg.sender]);\nVAR8[VAR30] = true;\n}\nfunction FUN12(address VAR31, address VAR32, uint VAR33) public constant returns(bytes32) {\nreturn keccak256(VAR31, VAR32, VAR33);\n}\n}",
        "label": false,
        "name": "0x1294d23b74c103d0e6d9c8f98abe9383c7900735.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 {\nuint256 public VAR2;\n}\ncontract CON3 {\nusing SafeMath for uint256;\naddress public VAR3;\naddress public VAR4;\naddress constant VAR5 = 0x47c8F28e6056374aBA3DF0854306c2556B104601;\naddress constant VAR6 = 0x0000000000000000000000000000000000000001;\nCON1 constant VAR7 = CON1(0xBC7942054F77b82e8A71aCE170E4B00ebAe67eB6);\nCON2 constant VAR8 = CON2(0xae5D95379487d047101C4912BddC6942090E5D17);\nuint256 public VAR9;\nuint256 public VAR10;\naddress public VAR11;\nconstructor (address VAR12, address VAR13) public {\nVAR3 = VAR12;\nVAR4 = VAR13;\n}\nfunction () external payable {\nuint256 VAR14 = msg.value.div(100);\nuint256 VAR15 = VAR7.balanceOf(address(this));\nuint256 VAR16 = VAR15.div(VAR8.VAR2());\nif (VAR16 < VAR14) { if (VAR16 > 0) {\nVAR14 = VAR14.sub(VAR16);\nVAR7.transfer(VAR6, VAR15);\n}\nVAR5.transfer(VAR14);\n} else { VAR7.transfer(VAR6, VAR14.mul(VAR8.VAR2()));\n}\n}\nfunction FUN2(uint256 VAR17, uint256 VAR18) external {\nrequire(msg.sender != VAR11); require((msg.sender == VAR3) || (msg.sender == VAR4) || (msg.sender == VAR5));\nrequire(VAR17.add(VAR18) <= address(this).balance);\nVAR11 = msg.sender;\nif ((VAR9 == VAR17) && (VAR10 == VAR18)) { delete VAR9;\ndelete VAR10;\ndelete VAR11;\nif (VAR17 > 0) {\nVAR3.transfer(VAR17);\n}\nif (VAR18 > 0) {\nVAR4.transfer(VAR18);\n}\n} else {\nVAR9 = VAR17;\nVAR10 = VAR18;\n}\n}\n}",
        "label": false,
        "name": "0x07c488413477272629796ef4cf253712431b521a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 10000000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"SurfCoin\";\nstring constant public VAR14 = \"SURF\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xb10cd8f7d672c3b4d10588527a8388ea1a407f20.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN2(uint256 VAR4) public {\nFUN3(msg.sender, VAR4);\n}\nfunction FUN3(address VAR5, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR5]);\nVAR1[VAR5] = VAR1[VAR5].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON4 {\naddress public VAR6;\nfunction CON4() public {\nVAR6 = msg.sender;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR6);\n_;\n}\nfunction FUN5(address VAR7) public FUN4 {\nrequire(VAR7 != address(0));\nVAR6 = VAR7;\n}\n}\ncontract CON5 is CON1 {\n}\ncontract CON6 is CON5, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN6(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR8[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR4) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR4;\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON4 {\nbool public VAR14 = false;\nmodifier FUN10() {\nrequire(!VAR14);\n_;\n}\nfunction FUN11(address VAR3, uint256 VAR15) FUN4 FUN10 public returns (bool) {\nVAR2 = VAR2.add(VAR15);\nVAR1[VAR3] = VAR1[VAR3].add(VAR15);\nreturn true;\n}\nfunction FUN12() FUN4 FUN10 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON8 is CON7 {\nuint256 public VAR16;\nfunction CON8(uint256 VAR17) public {\nrequire(VAR17 > 0);\nVAR16 = VAR17;\n}\nfunction FUN11(address VAR3, uint256 VAR15) FUN4 FUN10 public returns (bool) {\nrequire(VAR2.add(VAR15) <= VAR16);\nreturn super.FUN11(VAR3, VAR15);\n}\n}\ncontract CON9 is CON4 {\nbool public VAR18 = false;\nmodifier FUN13() {\nrequire(!VAR18);\n_;\n}\nmodifier FUN14() {\nrequire(VAR18);\n_;\n}\nfunction FUN15() FUN4 FUN13 public {\nVAR18 = true;\n}\nfunction FUN16() FUN4 FUN14 public {\nVAR18 = false;\n}\n}\ncontract CON10 is CON6, CON9 {\nfunction FUN1(address VAR3, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN6(address VAR9, address VAR3, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN6(VAR9, VAR3, VAR4);\n}\nfunction FUN7(address VAR10, uint256 VAR4) public FUN13 returns (bool) {\nreturn super.FUN7(VAR10, VAR4);\n}\nfunction FUN8(address VAR10, uint VAR11) public FUN13 returns (bool VAR19) {\nreturn super.FUN8(VAR10, VAR11);\n}\nfunction FUN9(address VAR10, uint VAR12) public FUN13 returns (bool VAR19) {\nreturn super.FUN9(VAR10, VAR12);\n}\n}\ncontract CON11 is CON8, CON10, CON3 {\nuint public constant VAR20 = 700000000e18;\nstring public VAR21 = \"MERO Token\";\nstring public VAR22 = \"MERO\";\nuint8 public VAR23 = 18;\nconstructor() public CON8(VAR20) {\nFUN15();\n}\n}",
        "label": false,
        "name": "0xbf952ed8472a47cc6b5119cde96565553c187c30.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nrequire(VAR2 != address(0), \"Ownable: new VAR13 is the zero address\");\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN4(address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN5(address VAR8, uint256 VAR7) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN9(VAR9, VAR6, VAR7);\nFUN12(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR10) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN8(address VAR8, uint256 VAR11) public returns (bool) {\nFUN12(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN9(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN10(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR7);\n}\nfunction FUN12(address VAR13, address VAR8, uint256 VAR7) internal {\nrequire(VAR8 != address(0));\nrequire(VAR13 != address(0));\nVAR4[VAR13][VAR8] = VAR7;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON3, CON1 {\nfunction FUN13(uint256 VAR7) public FUN1 {\nFUN11(msg.sender, VAR7);\n}\n}\ncontract CON6 is CON5 {\nbool private VAR14;\nmapping(address => Lock) private VAR15;\nstruct Lock {\nbool VAR16;\nBatch[] VAR17;\n}\nstruct Batch {\nuint256 VAR18;\nuint256 VAR19;\n}\nfunction FUN14(address[] calldata VAR20, uint256[] calldata VAR21, uint256[] calldata VAR22) external FUN1 {\nrequire(!VAR14);\nrequire(VAR20.length == VAR21.length && VAR21.length == VAR22.length);\nfor (uint256 VAR23 = 0; VAR23 < VAR20.length; VAR23++) {\nrequire(balanceOf(VAR20[VAR23]) >= VAR21[VAR23]);\nif (!VAR15[VAR20[VAR23]].VAR16) {\nVAR15[VAR20[VAR23]].VAR16 = true;\n}\nVAR15[VAR20[VAR23]].VAR17.push(Batch(VAR21[VAR23], block.timestamp + VAR22[VAR23]));\nif (VAR15[VAR20[VAR23]].VAR17.length > 1) {\nassert(VAR15[VAR20[VAR23]].VAR17[VAR15[VAR20[VAR23]].VAR17.length - 1].VAR18< VAR15[VAR20[VAR23]].VAR17[VAR15[VAR20[VAR23]].VAR17.length - 2].VAR18&&VAR15[VAR20[VAR23]].VAR17[VAR15[VAR20[VAR23]].VAR17.length - 1].VAR19> VAR15[VAR20[VAR23]].VAR17[VAR15[VAR20[VAR23]].VAR17.length - 2].VAR19);\n}\n}\nVAR14 = true;\n}\nfunction FUN9(address VAR9, address VAR6, uint256 VAR7) internal {\nif (VAR15[VAR9].VAR16) {\nfor (uint256 VAR23 = 0; VAR23 < VAR15[VAR9].VAR17.length; VAR23++) {\nif (block.timestamp <= VAR15[VAR9].VAR17[VAR23].VAR19) {\nrequire(VAR7 <= balanceOf(VAR9).sub(VAR15[VAR9].VAR17[VAR23].VAR18));\nbreak;\n}\n}\n}\nsuper.FUN9(VAR9, VAR6, VAR7);\n}\n}\ncontract CON7 is CON6 {\nstring private VAR24 = \"Diamond Open Market\";\nstring private VAR25 = \"DOM\";\nuint8 private VAR26 = 18;\nuint256 public constant VAR27 = 6000000000 * (10 ** 18);\nconstructor(address VAR28) public {\nFUN10(VAR28, VAR27);\n}\nfunction FUN15(address VAR8, uint256 VAR18, bytes calldata VAR29) external returns (bool) {\nrequire(FUN5(VAR8, VAR18));\nCON4(VAR8).receiveApproval(msg.sender, VAR18, address(this), VAR29);\nreturn true;\n}\nfunction FUN16(address VAR30, address VAR28) external FUN1 {\nuint256 VAR18 = CON2(VAR30).balanceOf(address(this));\nCON2(VAR30).FUN4(VAR28, VAR18);\n}\n}",
        "label": false,
        "name": "0xc6e43ad19490c476012316d1dab988afc73720ef.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR12;\nconstructor () internal {\nFUN16(msg.sender);\n}\nmodifier FUN13() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN14(address VAR10) public FUN13 {\nFUN16(VAR10);\n}\nfunction FUN15() public {\nFUN17(msg.sender);\n}\nfunction FUN16(address VAR10) internal {\nVAR12.add(VAR10);\n}\nfunction FUN17(address VAR10) internal {\nVAR12.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nuint256 public VAR13;\nuint256 public VAR14;\nconstructor (uint256 VAR15) public {\nrequire(VAR15 > 0);\nVAR13 = VAR15;\n}\nfunction FUN18(address VAR4, uint256 VAR5) public FUN13 returns (bool) {\nrequire(VAR14.add(VAR5) <= VAR13);\nVAR14 = VAR14.add(VAR5);\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON3, CON5 {\nstring public constant VAR16 = \"ROOBEE\";\nstring public constant VAR17 = \"ROOBEE\";\nuint8 public constant VAR18 = 18;\nstruct FreezeParams {\nuint256 VAR19;\nuint256 VAR5;\nbool VAR20;\n}\nmapping (address => FreezeParams) private VAR21;\nconstructor () public CON5(5400000000 * 1e18) {\n}\nfunction FUN19(address VAR22, uint256 VAR23, uint256 VAR24, bool VAR25) public FUN13 returns (bool) {\nrequire(now < VAR24);\nFUN20(VAR22, VAR23, VAR24, VAR25);\nFUN18(VAR22, VAR23);\nreturn true;\n}\nfunction FUN20(address VAR4, uint256 VAR5, uint256 VAR26, bool VAR20) private {\nFreezeParams memory VAR27;\nVAR27 = VAR21[VAR4];\nif (VAR27.VAR19 == 0) {\nVAR27.VAR19 = VAR26;\nVAR27.VAR20 = VAR20;\n}\nVAR27.VAR5 = VAR27.VAR5.add(VAR5);\nVAR21[VAR4] = VAR27;\n}\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(getAvailableBalance(msg.sender) >= VAR5);\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(getAvailableBalance(VAR7) >= VAR5);\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN11(uint256 VAR5) public {\nrequire(getAvailableBalance(msg.sender) >= VAR5);\nsuper.FUN11(VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nrequire(getAvailableBalance(VAR7) >= VAR5);\nsuper.FUN12(VAR7, VAR5);\n}\nfunction FUN21(address VAR28, uint256 VAR23, string memory VAR29) public returns (bool VAR30) {\nFUN2(VAR28, VAR23);\nCON7(VAR28).approvalFallback(msg.sender,VAR23,address(this),VAR29);\nreturn true;\n}\n}\ncontract CON7 {\n}",
        "label": false,
        "name": "0xa31b1767e09f842ecfd4bc471fe44f830e3891aa.sol"
    },
    {
        "source": "{\"ClarityToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\\n\\n\\ncontract ERC20 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function balanceOf(address _who) public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n    public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n    public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n    public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\\n\\n\\n\\n\\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\\n\\n\\ncontract StandardToken is ERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\n\\n    uint256 private totalSupply_;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    \\n    function balanceOf(address _owner) public view returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n    \\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    \\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        require(_value \\u003c= balances[msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n    public\\n    returns (bool)\\n    {\\n        require(_value \\u003c= balances[_from]);\\n        require(_value \\u003c= allowed[_from][msg.sender]);\\n        require(_to != address(0));\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    \\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n    public\\n    returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n        allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    \\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n    public\\n    returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue \\u003e= oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    \\n    function _mint(address _account, uint256 _amount) internal {\\n        require(_account != 0);\\n        totalSupply_ = totalSupply_.add(_amount);\\n        balances[_account] = balances[_account].add(_amount);\\n        emit Transfer(address(0), _account, _amount);\\n    }\\n\\n    \\n    function _burn(address _account, uint256 _amount) internal {\\n        require(_account != 0);\\n        require(_amount \\u003c= balances[_account]);\\n\\n        totalSupply_ = totalSupply_.sub(_amount);\\n        balances[_account] = balances[_account].sub(_amount);\\n        emit Transfer(_account, address(0), _amount);\\n    }\\n\\n    \\n    function _burnFrom(address _account, uint256 _amount) internal {\\n        require(_amount \\u003c= allowed[_account][msg.sender]);\\n\\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n        // this function needs to emit an event with the updated approval.\\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\\n        _burn(_account, _amount);\\n    }\\n}\\n\\n// File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol\\n\\n\\ncontract BurnableToken is StandardToken {\\n\\n    event Burn(address indexed burner, uint256 value);\\n\\n    \\n    function burn(uint256 _value) public {\\n        _burn(msg.sender, _value);\\n    }\\n\\n    \\n    function burnFrom(address _from, uint256 _value) public {\\n        _burnFrom(_from, _value);\\n    }\\n\\n    \\n    function _burn(address _who, uint256 _value) internal {\\n        super._burn(_who, _value);\\n        emit Burn(_who, _value);\\n    }\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\n\\n\\ncontract Ownable {\\n    address public owner;\\n\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    \\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    \\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipRenounced(owner);\\n        owner = address(0);\\n    }\\n\\n    \\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    \\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0));\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\\n\\n\\ncontract HasNoEther is Ownable {\\n\\n    \\n    constructor() public payable {\\n        require(msg.value == 0);\\n    }\\n\\n    \\n    function() external {\\n    }\\n\\n    \\n    function reclaimEther() external onlyOwner {\\n        owner.transfer(address(this).balance);\\n    }\\n}\\n\\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\n\\n\\n\\n\\n// File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol\\n\\n\\ncontract CanReclaimToken is Ownable {\\n    using SafeERC20 for ERC20;\\n\\n    \\n    function reclaimToken(ERC20 _token) external onlyOwner {\\n        uint256 balance = _token.balanceOf(this);\\n        _token.safeTransfer(owner, balance);\\n    }\\n\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/HasNoTokens.sol\\n\\n\\ncontract HasNoTokens is CanReclaimToken {\\n\\n    \\n    function tokenFallback(\\n        address _from,\\n        uint256 _value,\\n        bytes _data\\n    )\\n    external\\n    pure\\n    {\\n        _from;\\n        _value;\\n        _data;\\n        revert();\\n    }\\n\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/HasNoContracts.sol\\n\\n\\ncontract HasNoContracts is Ownable {\\n\\n    \\n    function reclaimContract(address _contractAddr) external onlyOwner {\\n        Ownable contractInst = Ownable(_contractAddr);\\n        contractInst.transferOwnership(owner);\\n    }\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/NoOwner.sol\\n\\n\\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\\n}\\n\\n// File: contracts/ClarityToken.sol\\n\\ncontract ClarityToken is StandardToken, BurnableToken, NoOwner {\\n    string public constant name = \\\"Clarity Token\\\"; // solium-disable-line uppercase\\n    string public constant symbol = \\\"CLRTY\\\"; // solium-disable-line uppercase\\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\\n\\n    uint256 public constant INITIAL_SUPPLY = 240000000 * (10 ** uint256(decimals));\\n\\n    \\n    constructor() public {\\n        _mint(msg.sender, INITIAL_SUPPLY);\\n    }\\n}\"},\"UserPaymentAccount.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"ClarityToken.sol\\\";\\n\\ncontract UserPaymentAccount {\\n\\n    ClarityToken clarityToken;\\n    address controller;\\n    address paymentTarget;\\n    bool isLockedTransactions;\\n    bool isLockedReplenish;\\n\\n    mapping(string =\\u003e uint256) balances;\\n    mapping(address =\\u003e bool) public isOwner;\\n    mapping(address =\\u003e bool) public isOperator;\\n\\n    constructor(address _controller, address _clarityToken, address _paymentTarget, address _owner) public {\\n        clarityToken = ClarityToken(_clarityToken);\\n        controller = _controller;\\n        isOwner[_owner] = true;\\n        paymentTarget = _paymentTarget;\\n    }\\n\\n    modifier notNull(address _address) {\\n        require(_address != 0);\\n        _;\\n    }\\n\\n    function balanceOf(string _userId) public view returns (uint256 _balance) {\\n        _balance = balances[_userId];\\n    }\\n\\n    function replenish(string _toUserId, uint256 _amount) public returns (bool) {\\n        require(!isLockedReplenish);\\n        require(clarityToken.transferFrom(msg.sender, address(this), _amount));\\n        balances[_toUserId] += _amount;\\n        return true;\\n    }\\n\\n    function move(string _fromUserId, string _toUserId, uint256 _amount) public returns (bool) {\\n        require((msg.sender == controller \\u0026\\u0026 !isLockedTransactions) || isOwner[msg.sender]);\\n        return _move(_fromUserId, _toUserId, _amount);\\n    }\\n\\n    function _move(string _fromUserId, string _toUserId, uint256 _amount) internal returns (bool) {\\n        require(balances[_fromUserId] \\u003e= _amount);\\n        balances[_fromUserId] -= _amount;\\n        balances[_toUserId] += _amount;\\n        return true;\\n    }\\n\\n    function pay(string _fromUserId, uint256 _amount) public returns (bool) {\\n        require((msg.sender == controller \\u0026\\u0026 !isLockedTransactions) || isOwner[msg.sender]);\\n        require(balances[_fromUserId] \\u003e= _amount);\\n        require(clarityToken.transfer(paymentTarget, _amount));\\n        balances[_fromUserId] -= _amount;\\n        return true;\\n    }\\n\\n    function takeAllTokens() public returns (bool) {\\n        require(isOwner[msg.sender]);\\n        require(clarityToken.transfer(paymentTarget, clarityToken.balanceOf(address(this))));\\n        isLockedReplenish = true;\\n        isLockedTransactions = true;\\n        return true;\\n    }\\n\\n    function addOwner(address _owner) public notNull(_owner) returns (bool) {\\n        require(isOwner[msg.sender]);\\n        isOwner[_owner] = true;\\n        return true;\\n    }\\n\\n    function removeOwner(address _owner) public notNull(_owner) returns (bool) {\\n        require(msg.sender != _owner \\u0026\\u0026 isOwner[msg.sender]);\\n        isOwner[_owner] = false;\\n        return true;\\n    }\\n\\n    function lockTransactions() public returns (bool) {\\n        require(isOwner[msg.sender] || isOperator[msg.sender]);\\n        isLockedTransactions = true;\\n        return true;\\n    }\\n\\n    function unlockTransactions() public returns (bool) {\\n        require(isOwner[msg.sender] || isOperator[msg.sender]);\\n        isLockedTransactions = false;\\n        return true;\\n    }\\n\\n    function lockReplenish() public returns (bool) {\\n        require(isOwner[msg.sender]);\\n        isLockedReplenish = true;\\n        return true;\\n    }\\n\\n    function unlockReplenish() public returns (bool) {\\n        require(isOwner[msg.sender]);\\n        isLockedReplenish = false;\\n        return true;\\n    }\\n\\n    function addOperator(address _operator) public notNull(_operator) returns (bool) {\\n        require(isOwner[msg.sender]);\\n        isOperator[_operator] = true;\\n        return true;\\n    }\\n\\n    function removeOperator(address _operator) public notNull(_operator) returns (bool) {\\n        require(isOwner[msg.sender]);\\n        isOperator[_operator] = false;\\n        return true;\\n    }\\n\\n    function setController(address _controller) public notNull(_controller) returns (bool) {\\n        require(isOwner[msg.sender]);\\n        controller = _controller;\\n        return true;\\n    }\\n\\n    function setPaymentTarget(address _paymentTarget) public notNull(_paymentTarget) returns (bool) {\\n        require(isOwner[msg.sender]);\\n        paymentTarget = _paymentTarget;\\n        return true;\\n    }\\n\\n}\\n\"}}",
        "label": false,
        "name": "0xe8d1617a07325c9d83e7e12b859a32d9b823cbb6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"World Kungfu Association\";\nstring public constant VAR37 = \"WKA\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 10000000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 public VAR42 = 1544832000;\nuint64 public VAR43 = 7776000;\nuint64 public VAR44 = 8640000;\nmapping(address => address) public VAR45;\nconstructor(address VAR46) public payable {\nrequire(VAR46 != address(0));\nVAR40 = VAR46;\nuint256 VAR47 = 4750000000;\nFUN14(VAR47, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR48 = 5250000000;\nVAR41 = FUN13(VAR48);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR49) internal FUN7 returns (CON7) {\nCON7 VAR50 = new CON7(CON3(this));\nFUN14(VAR49, VAR50);\nVAR50.FUN10();\nreturn VAR50;\n}\nfunction FUN14(uint256 VAR51, address VAR52) internal FUN7 {\nuint256 VAR49 = VAR51 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR49);\nVAR1[VAR52] = VAR1[VAR52].add(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,uint256 VAR53) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR54 = VAR53 * 10**uint256(VAR38);\nif(VAR45[VAR23] == 0x0) {\nCON6 VAR55 = new CON6(VAR23, VAR24, VAR25, VAR26, VAR27, VAR14);\nVAR45[VAR23] = address(VAR55);\n}\nrequire(this.FUN2(VAR41, VAR45[VAR23], VAR54));\n}\nfunction FUN16(address VAR23, uint256 VAR53) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR54 = VAR53 * 10**uint256(VAR38);\nif(VAR45[VAR23] == 0x0) {\nCON6 VAR55 = new CON6(VAR23, VAR42 + VAR43, 0, VAR44, true, VAR14);\nVAR45[VAR23] = address(VAR55);\n}\nrequire(this.FUN2(VAR41, VAR45[VAR23], VAR54));\n}\nfunction FUN17() external {\nFUN18(msg.sender);\n}\nfunction FUN18(address VAR8) public {\nCON6(VAR45[VAR8]).FUN8(this);\n}\nfunction FUN19(address VAR8) public FUN7 {\nCON6(VAR45[VAR8]).FUN9(this);\n}\n}",
        "label": false,
        "name": "0xa020f57557b321a6964413fb9c03c5ab0700b6f0.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7, string memory VAR8, string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public {\nFUN1(msg.sender, VAR11, VAR12);\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xef731ab30bcba5bc16faef364f743121056a06e1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"CVL\";\nVAR5 = \"CVLERC20\";\nVAR6 = 18;\nVAR7 = 100000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x63cf21db6b7c1fb8a093589fb560b53998436923.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nstring public VAR6; uint8 public VAR7; string public VAR8;\nfunction CON4() public {\nVAR7 = 8;\nVAR2 = 100000000 * 10 ** uint(VAR7);\nVAR1[msg.sender] = VAR2;\nVAR6 = \"PG Game Token\";\nVAR8 = \"PGGame\";\n}\nfunction FUN2(address VAR9, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR9]);\nrequire(VAR4 <= VAR5[VAR9][msg.sender]);\nVAR1[VAR9] = VAR1[VAR9].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR9][msg.sender] = VAR5[VAR9][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR10, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR4;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xba1c83f511395d7e7536b0f3c414e638dc9e333e.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 100000000 * (10**10);\naddress public VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Dyneros\";\nstring constant public VAR14 = \"Dyner\";\nuint8 constant public VAR15 = 10;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xd4ec1572aa1e4e764532e0a887a979d6a80ae78e.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nassert((VAR3 >= VAR1) && (VAR3 >= VAR2));\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nassert(VAR1 >= VAR2);\nuint256 VAR3 = VAR1 - VAR2;\nreturn VAR3;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns(uint256) {\nuint256 VAR3 = VAR1 * VAR2;\nassert((VAR1 == 0)||(VAR3/VAR1 == VAR2));\nreturn VAR3;\n}\n}\ncontract CON2 is CON1{\naddress public VAR4 = \"0x1c82ee5b828455F870eb2998f2c9b6Cc2d52a5F6\";\naddress public VAR5; mapping (address => uint256) public VAR6;\nbool public VAR7; uint256 public constant VAR8 = 14000 ether; uint256 public constant VAR9 = 100 ether; uint256 public VAR10;\nmapping (address => uint256) public VAR11;\nmodifier FUN4() {\nrequire (msg.sender == VAR5);\n_;\n}\nfunction CON2() {\nVAR7 = false; VAR5 = msg.sender;\nVAR10 = 0;\n}\nfunction() payable {\nuint256 VAR12 = FUN1(VAR10, msg.value);\nrequire (msg.value >= VAR9); require (!VAR7); require (VAR12 <= VAR8);\nrequire (VAR6[msg.sender] == 1);\nVAR11[msg.sender] = FUN1(VAR11[msg.sender], msg.value);\nVAR10 = FUN1(VAR10, msg.value);\nVAR4.transfer(this.balance); }\nfunction FUN6(address VAR13) FUN4 {\nVAR6[VAR13] = 1;\n}\nfunction FUN7(address VAR13) FUN4 {\nVAR6[VAR13] = 0;\n}\nfunction FUN8() external FUN4 {\nrequire (!VAR7);\nVAR7 = true;\nVAR4.transfer(this.balance); }\n}",
        "label": false,
        "name": "0xee74792bd15d23a63e5357f599cbe1ec2f898bbc.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3 = 98000000 * (10 ** 18);\nstring private constant VAR4 = 'CON2'; string private constant VAR5 = 'DET'; uint8 private constant VAR6 = 18;\nconstructor () public {\nVAR1[msg.sender] = VAR3;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR8 <= VAR1[msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR1[VAR10]);\nrequire(VAR8 <= VAR2[VAR10][msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR8);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1e3fe98d1c89865b6b819bbfd532dadab3b34d2d.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3) public constant returns (uint256) { return VAR2[VAR3]; }\n}\ncontract CON2 {\naddress public VAR4;\nfunction CON2() {\nVAR4 = msg.sender;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR4);\n_;\n}\nfunction FUN3(address VAR5) FUN2 public {\nrequire(VAR5 != address(0));\nVAR4 = VAR5;\n}\n}\ncontract CON3 is CON2 {\nbool public VAR6 = false;\nmodifier FUN4() {\nrequire(!VAR6);\n_;\n}\nmodifier FUN5() {\nrequire(VAR6);\n_;\n}\nfunction FUN6() FUN2 FUN4 public {\nVAR6 = true;\n}\nfunction FUN7() FUN2 FUN5 public {\nVAR6 = false;\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nstring public constant VAR7 = \"XB Token\";\nstring public constant VAR8 = \"XB\";\nuint256 public constant VAR9 = 18;\naddress public VAR10;\nuint256 public constant VAR11 = 2640000 * (10**VAR9);\nuint256 public VAR12 = 1250;\nuint256 public VAR13 = 0;\nuint256 public VAR14;\nfunction CON4(address VAR15) public {\nrequire(VAR15 != 0x0);\nVAR10 = VAR15;\n}\nfunction () FUN4 public payable {\nFUN9(msg.sender);\n}\nfunction FUN9(address VAR16) FUN4 public payable {\nrequire(VAR16 != 0x0);\nuint256 VAR17 = msg.value;\nuint256 VAR18 = VAR17.mul(VAR12);\nrequire(VAR13 + VAR18 <= VAR11);\nVAR13 = VAR13.add(VAR18);\nVAR14 = VAR14.add(VAR17);\nFUN10(VAR16, VAR18);\nFUN11();\n}\nfunction FUN10(address VAR19, uint256 VAR20) internal returns (bool) {\nVAR1 = VAR1.add(VAR20);\nVAR2[VAR19] = VAR2[VAR19].add(VAR20);\nreturn true;\n}\nfunction FUN11() internal {\nVAR10.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x6669c10955f8f3a64025ae9793b9a92e777d628d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n}\ncontract CON3 is CON1, CON2 {\nconstructor () public {\n}\nfunction FUN1 (address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR5 = VAR9 [msg.sender];\nif (VAR5 < VAR3) return false;\nif (VAR3 > 0 && msg.sender != VAR2) {\nVAR9 [msg.sender] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN2 (address VAR6, address VAR2, uint256 VAR3)\npublic returns (bool VAR4) {\nuint256 VAR7 = VAR10 [VAR6][msg.sender];\nif (VAR7 < VAR3) return false;\nuint256 VAR5 = VAR9 [VAR6];\nif (VAR5 < VAR3) return false;\nVAR10 [VAR6][msg.sender] =\nsafeSub (VAR7, VAR3);\nif (VAR3 > 0 && VAR6 != VAR2) {\nVAR9 [VAR6] = safeSub (VAR5, VAR3);\nVAR9 [VAR2] = safeAdd (VAR9 [VAR2], VAR3);\n}\nreturn true;\n}\nfunction FUN3 (address VAR8, uint256 VAR3)\npublic returns (bool VAR4) {\nVAR10 [msg.sender][VAR8] = VAR3;\nreturn true;\n}\nmapping (address => uint256) internal VAR9;\nmapping (address => mapping (address => uint256)) internal VAR10;\n}\ncontract CON4 is CON3 {\nuint256 VAR11;\nconstructor (uint256 VAR12) public {\nVAR11 = VAR12;\nVAR9 [msg.sender] = VAR12;\n}\nfunction FUN3 (address VAR8, uint256 VAR13, uint256 VAR14)\npublic returns (bool VAR4) {\nif (allowance (msg.sender, VAR8) == VAR13)\nreturn FUN3 (VAR8, VAR14);\nelse return false;\n}\nfunction FUN4 (uint256 VAR3) public returns (bool VAR4) {\nif (VAR3 > VAR9 [msg.sender]) return false;\nelse if (VAR3 > 0) {\nVAR9 [msg.sender] = safeSub (VAR9 [msg.sender], VAR3);\nVAR11 = safeSub (VAR11, VAR3);\nreturn true;\n} else return true;\n}\n}",
        "label": false,
        "name": "0x9795a1cab6f4d1919371a68af10dcb861bf28d41.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nfunction FUN1 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nassert (VAR2 <= VAR1 - VAR3);\nreturn VAR2 + VAR3;\n}\nfunction FUN2 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nassert (VAR2 >= VAR3);\nreturn VAR2 - VAR3;\n}\nfunction FUN3 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nif (VAR3 == 0) return 0; assert (VAR2 <= VAR1 / VAR3);\nreturn VAR2 * VAR3;\n}\n}\ncontract CON3 is CON1, CON2 {\nfunction CON3 () {\n}\nfunction FUN4 (address VAR5) constant returns (uint256 VAR6) {\nreturn VAR15 [VAR5];\n}\nfunction FUN5 (address VAR7, uint256 VAR8) returns (bool VAR9) {\nuint256 VAR10 = VAR15 [msg.sender];\nif (VAR10 < VAR8) return false;\nif (VAR8 > 0 && msg.sender != VAR7) {\nVAR15 [msg.sender] = FUN2 (VAR10, VAR8);\nVAR15 [VAR7] = FUN1 (VAR15 [VAR7], VAR8);\n}\nreturn true;\n}\nfunction FUN6 (address VAR11, address VAR7, uint256 VAR8)\nreturns (bool VAR9) {\nuint256 VAR12 = VAR16 [VAR11][msg.sender];\nif (VAR12 < VAR8) return false;\nuint256 VAR10 = VAR15 [VAR11];\nif (VAR10 < VAR8) return false;\nVAR16 [VAR11][msg.sender] =\nFUN2 (VAR12, VAR8);\nif (VAR8 > 0 && VAR11 != VAR7) {\nVAR15 [VAR11] = FUN2 (VAR10, VAR8);\nVAR15 [VAR7] = FUN1 (VAR15 [VAR7], VAR8);\n}\nreturn true;\n}\nfunction FUN7 (address VAR13, uint256 VAR8) returns (bool VAR9) {\nVAR16 [msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN8 (address VAR5, address VAR13) constant\nreturns (uint256 VAR14) {\nreturn VAR16 [VAR5][VAR13];\n}\nmapping (address => uint256) VAR15;\nmapping (address => mapping (address => uint256)) private VAR16;\n}\ncontract CON4 is CON3 {\nuint constant VAR17 = 10000000000e18;\nfunction CON4 () {\nVAR25 = msg.sender;\nVAR15 [VAR25] = VAR17;\nVAR24 = VAR17;\n}\nfunction FUN9 () constant returns (string VAR18) {\nreturn \"Nuggets\";\n}\nfunction FUN10 () constant returns (string VAR18) {\nreturn \"NUG\";\n}\nfunction FUN11 () constant returns (uint8 VAR18) {\nreturn 18;\n}\nfunction FUN12 () constant returns (uint256 VAR19) {\nreturn VAR24;\n}\nfunction FUN5 (address VAR7, uint256 VAR8) returns (bool VAR9) {\nreturn VAR26 ? false : CON3.FUN5 (VAR7, VAR8);\n}\nfunction FUN6 (address VAR11, address VAR7, uint256 VAR8)\nreturns (bool VAR9) {\nreturn VAR26 ? false : CON3.FUN6 (VAR11, VAR7, VAR8);\n}\nfunction FUN7 (address VAR13, uint256 VAR20, uint256 VAR21)\nreturns (bool VAR9) {\nif (FUN8 (msg.sender, VAR13) == VAR20)\nreturn FUN7 (VAR13, VAR21);\nelse return false;\n}\nfunction FUN13 (uint256 VAR8) returns (bool VAR9) {\nuint256 VAR22 = VAR15 [msg.sender];\nif (VAR8 > VAR22) return false;\nelse if (VAR8 > 0) {\nVAR15 [msg.sender] = FUN2 (VAR22, VAR8);\nVAR24 = FUN2 (VAR24, VAR8);\nreturn true;\n} else return true;\n}\nfunction FUN14 (address VAR23) {\nrequire (msg.sender == VAR25);\nVAR25 = VAR23;\n}\nfunction FUN15 () {\nrequire (msg.sender == VAR25);\nif (!VAR26) {\nVAR26 = true;\nFreeze ();\n}\n}\nfunction FUN16 () {\nrequire (msg.sender == VAR25);\nif (VAR26) {\nVAR26 = false;\nUnfreeze ();\n}\n}\nuint256 VAR24;\naddress VAR25;\nbool VAR26;\n}",
        "label": false,
        "name": "0x245ef47d4d0505ecf3ac463f4d81f41ade8f1fd1.sol"
    },
    {
        "source": "contract CON1 {\naddress VAR1;\naddress VAR2;\naddress VAR3;\naddress VAR4;\nbool VAR5;\nbool VAR6;\nbool VAR7;\nmodifier FUN1 {\nif(msg.sender != VAR1) throw;\n_;\n}\nfunction CON1() {\nVAR1 = msg.sender;\nVAR5 = false;\nVAR6 = false;\nVAR7 = false;\n}\nfunction FUN2() payable {\nif(msg.value > VAR2.balance || VAR2 == 0x0){\nVAR2 = msg.sender;\nreturn;\n}\nif(msg.value > VAR3.balance || VAR3 == 0x0){\nVAR3 = msg.sender;\nreturn;\n}\nif(msg.value > VAR4.balance || VAR4 == 0x0){\nVAR4 = msg.sender;\nreturn;\n}\n}\nfunction FUN3(){\nif(msg.sender == VAR2){ VAR5 = !VAR5; }\n}\nfunction FUN4(){\nif(msg.sender == VAR3){ VAR6 = !VAR6; }\n}\nfunction FUN5(){\nif(msg.sender == VAR4){ VAR7 = !VAR7; }\n}\nfunction FUN6(address VAR8) FUN1 {\nif(VAR5 && VAR6 && VAR7){\nselfdestruct(VAR8);\n}\n}\nfunction FUN7() FUN1 {\nselfdestruct(0x0);\n}\n}",
        "label": false,
        "name": "0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmodifier FUN1() { require(msg.sender == VAR1); _; }\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nmodifier FUN3() { require(VAR3[msg.sender]); _; }\nfunction FUN4(address VAR4) FUN1 public {\nrequire(VAR4 != address(0));\nVAR3[VAR4] = true;\n}\nfunction FUN5(address VAR4) FUN1 public {\nrequire(VAR4 != address(0));\nVAR3[VAR4] = false;\n}\n}\ncontract CON3 is CON2 {\nstruct Picture {\nstring VAR5;\nuint32 VAR6;\nuint32 VAR7;\nuint32 VAR8;\nuint32 VAR9;\nstring VAR10;\nstring VAR11;\nstring VAR12;\n}\nstruct Segment {\nuint32 VAR13;\nuint32 VAR14;\nstring VAR5;\nstring VAR10;\nstring VAR15;\nstring VAR16;\n}\nmapping(bytes32 => Picture) public VAR17;\nmapping(bytes32 => mapping(uint32 => mapping(uint32 => Segment))) public VAR18;\nfunction CON3() public {\nFUN4(msg.sender);\nFUN4(0x209eba96c917871f78671a3ed3503ecc4144495c);\n}\nfunction FUN6(string VAR19, uint32 VAR20, uint32 VAR21, uint32 VAR22, uint32 VAR23, string VAR24, string VAR25, string VAR26) FUN3 public returns(bool VAR27) {\nbytes32 VAR28 = str_to_bytes32(VAR19);\nrequire(!(VAR17[VAR28].VAR6 > 0));\nrequire(VAR20 > 0 && VAR21 > 0 && VAR22 > 0 && VAR23 > 0);\nVAR17[VAR28] = Picture({VAR5: VAR19,VAR6: VAR20,VAR7: VAR21,VAR8: VAR22,VAR9: VAR23,VAR10: VAR24,VAR11: VAR25,VAR12: VAR26});\nreturn true;\n}\nfunction FUN7(string VAR29, uint32 VAR30, uint32 VAR31, string VAR19, string VAR24, string VAR32, string VAR33) FUN3 public returns(bool VAR27) {\nbytes32 VAR28 = str_to_bytes32(VAR29);\nrequire(VAR17[VAR28].VAR6 > 0);\nrequire(VAR30 > 0 && VAR31 > 0 && VAR30 <= VAR17[VAR28].VAR6 && VAR31 <= VAR17[VAR28].VAR7);\nrequire(!(VAR18[VAR28][VAR30][VAR31].VAR13 > 0));\nVAR18[VAR28][VAR30][VAR31] = Segment({VAR13: VAR30,VAR14: VAR31,VAR5: VAR19,VAR10: VAR24,VAR15: VAR32,VAR16: VAR33});\nreturn true;\n}\nfunction FUN8(string VAR29, uint32 VAR30, uint32 VAR31, string VAR32, string VAR33) FUN3 public returns(bool VAR27) {\nbytes32 VAR28 = str_to_bytes32(VAR29);\nrequire(VAR17[VAR28].VAR6 > 0);\nrequire(VAR30 > 0 && VAR31 > 0 && VAR30 <= VAR17[VAR28].VAR6 && VAR31 <= VAR17[VAR28].VAR7);\nrequire(VAR18[VAR28][VAR30][VAR31].VAR13 > 0);\nVAR18[VAR28][VAR30][VAR31].VAR15 = VAR32;\nVAR18[VAR28][VAR30][VAR31].VAR16 = VAR33;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x0b5828d786f397c73554c5b091aa9ea108fffc51.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nuint256 VAR3 = VAR1 * VAR2;\nFUN5(VAR1 == 0 || VAR3 / VAR1 == VAR2);\nreturn VAR3;\n}\nfunction FUN2(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nFUN5(VAR2 > 0);\nuint256 VAR3 = VAR1 / VAR2;\nFUN5(VAR1 == VAR2 * VAR3 + VAR1 % VAR2);\nreturn VAR3;\n}\nfunction FUN3(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nFUN5(VAR2 <= VAR1);\nreturn VAR1 - VAR2;\n}\nfunction FUN4(uint256 VAR1, uint256 VAR2) internal returns (uint256) {\nuint256 VAR3 = VAR1 + VAR2;\nFUN5(VAR3>=VAR1 && VAR3>=VAR2);\nreturn VAR3;\n}\nfunction FUN5(bool VAR4) internal {\nif (!VAR4) {\nthrow;\n}\n}\n}\ncontract CON2 is CON1{\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nuint256 public VAR8;\naddress public VAR9;\nmapping (address => uint256) public VAR10;\nmapping (address => uint256) public VAR11;\nmapping (address => mapping (address => uint256)) public VAR12;\nfunction CON2(uint256 VAR13,string VAR14,uint8 VAR15,string VAR16) {\nVAR10[msg.sender] = VAR13; VAR8 = VAR13; VAR5 = VAR14; VAR6 = VAR16; VAR7 = VAR15; VAR9 = msg.sender;\n}\nfunction FUN6(address VAR17, uint256 VAR18) {\nif (VAR17 == 0x0) throw; if (VAR18 <= 0) throw;\nif (VAR10[msg.sender] < VAR18) throw; if (VAR10[VAR17] + VAR18 < VAR10[VAR17]) throw; VAR10[msg.sender] = CON1.FUN3(VAR10[msg.sender], VAR18); VAR10[VAR17] = CON1.FUN4(VAR10[VAR17], VAR18); }\nfunction FUN7(address VAR19, uint256 VAR18)\nreturns (bool VAR20) {\nif (VAR18 <= 0) throw;\nVAR12[msg.sender][VAR19] = VAR18;\nreturn true;\n}\nfunction FUN8(address VAR21, address VAR17, uint256 VAR18) returns (bool VAR20) {\nif (VAR17 == 0x0) throw; if (VAR18 <= 0) throw;\nif (VAR10[VAR21] < VAR18) throw; if (VAR10[VAR17] + VAR18 < VAR10[VAR17]) throw; if (VAR18 > VAR12[VAR21][msg.sender]) throw; VAR10[VAR21] = CON1.FUN3(VAR10[VAR21], VAR18); VAR10[VAR17] = CON1.FUN4(VAR10[VAR17], VAR18); VAR12[VAR21][msg.sender] = CON1.FUN3(VAR12[VAR21][msg.sender], VAR18);\nreturn true;\n}\nfunction FUN9(uint256 VAR18) returns (bool VAR20) {\nif (VAR10[msg.sender] < VAR18) throw; if (VAR18 <= 0) throw;\nVAR10[msg.sender] = CON1.FUN3(VAR10[msg.sender], VAR18); VAR8 = CON1.FUN3(VAR8,VAR18);\nreturn true;\n}\nfunction FUN10(uint256 VAR18) returns (bool VAR20) {\nif (VAR10[msg.sender] < VAR18) throw; if (VAR18 <= 0) throw;\nVAR10[msg.sender] = CON1.FUN3(VAR10[msg.sender], VAR18); VAR11[msg.sender] = CON1.FUN4(VAR11[msg.sender], VAR18);\nreturn true;\n}\nfunction FUN11(uint256 VAR18) returns (bool VAR20) {\nif (VAR11[msg.sender] < VAR18) throw; if (VAR18 <= 0) throw;\nVAR11[msg.sender] = CON1.FUN3(VAR11[msg.sender], VAR18); VAR10[msg.sender] = CON1.FUN4(VAR10[msg.sender], VAR18);\nreturn true;\n}\nfunction FUN12(uint256 VAR22) {\nif(msg.sender != VAR9)throw;\nVAR9.FUN6(VAR22);\n}\nfunction() payable {\n}\n}",
        "label": false,
        "name": "0xf8edd282fe8d781a941176acf61a78434f5227b8.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa3d38c461965fd05c9ec2f33a28159e9b1b52864.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath_Connor for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2 {\nfunction FUN11(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN12(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON5 is CON2, CON3, CON4 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 21000000 * (10 ** uint256(VAR18));\nconstructor () public CON3(\"BitEthereum\", \"BITE\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0xf5e7ecb7f6011f35f7f0781922784467a149c405.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 {\naddress public VAR7;\nfunction CON4() {\nVAR7 = msg.sender;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction FUN4(address VAR8) FUN3 {\nif (VAR8 != address(0)) {\nVAR7 = VAR8;\n}\n}\n}\ncontract CON5 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR9;\nfunction FUN5(address VAR10, address VAR3, uint256 VAR4) returns (bool) {\nvar VAR11 = VAR9[VAR10][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR10] = VAR2[VAR10].sub(VAR4);\nVAR9[VAR10][msg.sender] = VAR11.sub(VAR4);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR4) returns (bool) {\nrequire((VAR4 == 0) || (VAR9[msg.sender][VAR12] == 0));\nVAR9[msg.sender][VAR12] = VAR4;\nreturn true;\n}\nfunction FUN7(address VAR5, address VAR12) constant returns (uint256 VAR13) {\nreturn VAR9[VAR5][VAR12];\n}\n}\ncontract CON6 is CON5, CON4\n{\nstring public VAR14 = \"Veritas Group Limited Equity Token\";\nstring public VAR15 = \"VGLE\";\nuint public VAR16 = 8;\nuint public VAR17 = 251;\nuint public VAR18 = 251;\nbool public VAR19 = true;\nbool public VAR20 = true;\nuint private VAR21 = 120*10**14;\nfunction () payable\n{\nFUN11(msg.sender);\n}\nfunction CON6()\n{\nVAR7 = msg.sender;\nVAR1 = VAR21;\nVAR2[VAR7] = VAR21;\n}\nfunction FUN4(address VAR8)\nFUN3\n{\naddress VAR22 = VAR7;\nVAR2[VAR8] = VAR2[VAR8].add(VAR2[VAR7]);\nVAR2[VAR7] = 0;\nsuper.FUN4(VAR8);\nOwnerTransfered(VAR22, VAR8);\n}\nfunction FUN9(uint VAR23)\nFUN3\n{\nrequire(VAR23 > 0);\nuint VAR24 = VAR17;\nVAR17 = VAR23;\nBuyRateChanged(VAR24, VAR23);\n}\nfunction FUN10(uint VAR23)\nFUN3\n{\nrequire(VAR23 > 0);\nuint VAR24 = VAR18;\nVAR18 = VAR23;\nSellRateChanged(VAR24, VAR23);\n}\nfunction FUN11(address VAR25)\nFUN19\npayable\n{\nrequire(VAR25 != 0x0);\nrequire(VAR25 != VAR7);\nrequire(msg.value > 0);\nuint VAR26 = msg.value;\nuint VAR27 = FUN15(VAR26);\nuint VAR28 = VAR27.mul(VAR17);\nVAR2[VAR25] = VAR2[VAR25].add(VAR28);\nVAR2[VAR7] = VAR2[VAR7].sub(VAR28);\nTokenPurchase(msg.sender, VAR25, VAR26, VAR28);\n}\nfunction FUN12(uint VAR29)\nFUN20\n{\nrequire(msg.sender != VAR7);\nrequire(msg.sender != 0x0);\nrequire(VAR29 > 0);\nrequire(VAR2[msg.sender] >= VAR29);\nVAR2[VAR7] = VAR2[VAR7].add(VAR29);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR29);\nuint VAR30 = FUN16(VAR29.div(VAR18));\nif (!msg.sender.send(VAR30))\nrevert();\nelse\nTokenSold(msg.sender, VAR29);\n}\nfunction FUN13()\nFUN3\n{\nVAR7.FUN1(this.VAR6);\n}\nfunction FUN14()\nFUN3\n{\nselfdestruct(VAR7);\n}\nfunction FUN15(uint VAR31) internal\nreturns (uint)\n{\nrequire(VAR31 > 0);\nreturn VAR31.div(1000000000000000000);\n}\nfunction FUN16(uint VAR31) internal\nreturns (uint)\n{\nrequire(VAR31 > 0);\nreturn VAR31.mul(1000000000000000000);\n}\nfunction FUN17()\nFUN3\n{ VAR19 = !VAR19; }\nfunction FUN18()\nFUN3\n{ VAR20 = !VAR20; }\nmodifier FUN19()\n{ require(VAR19); _; }\nmodifier FUN20()\n{ require(VAR20); _; }\n}",
        "label": false,
        "name": "0xeacc5ac1faf321506580a5e2c1e32b67a8709720.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN4(VAR7, VAR4, VAR5);\nFUN6(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN5(address VAR8, uint256 VAR5) internal {\nrequire(VAR8 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR8] = VAR1[VAR8].add(VAR5);\n}\nfunction FUN6(address VAR9, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR9 != address(0));\nVAR2[VAR9][VAR6] = VAR5;\n}\n}\ncontract CON3 is CON1 {\nstring private VAR10;\nstring private VAR11;\nuint8 private VAR12;\nconstructor (string memory VAR13, string memory VAR14, uint8 VAR15) public {\nVAR10 = VAR13;\nVAR11 = VAR14;\nVAR12 = VAR15;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 200000000 * (10 ** uint256(VAR16));\nconstructor () public CON3(\"DisciplineControl\", \"JKW\", VAR16) {\nFUN5(msg.sender, VAR17);\n}\n}",
        "label": false,
        "name": "0x7cc444e71c36ef6c39374ce2f2912e3ff5babdcd.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1() returns (uint) {\nreturn FUN2();\n}\nfunction FUN2() returns (uint) {\nreturn block.timestamp;\n}\nfunction FUN3() returns (uint) {\nreturn block.number;\n}\n}",
        "label": false,
        "name": "0x7421c18f8ea6245cf1242c335daf2659927014fa.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18; uint256 public VAR4;\nmapping (address => uint256) public VAR5; mapping (address => mapping (address => uint256)) public VAR6;\nfunction CON2(uint256 VAR7, string VAR8, string VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != 0x0);\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public {\nFUN1(msg.sender, VAR11, VAR12);\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes VAR16) public returns (bool VAR14) {\nif (FUN4(VAR15, VAR12)) {\nCON1(VAR15).receiveApproval(msg.sender, VAR12, this, VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x20a45f32d5521deb764170f692c76fdcb97cf443.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) public VAR1;\naddress VAR2;\nconstructor (uint256 VAR3 ) public {\nVAR1[msg.sender] = VAR3; VAR2 = msg.sender; }\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool VAR6) {\nrequire(msg.sender == VAR2); require(VAR1[msg.sender] >= VAR5); require(VAR1[VAR4] + VAR5 >= VAR1[VAR4]); VAR1[msg.sender] -= VAR5; VAR1[VAR4] += VAR5; return true;\n}\nfunction FUN2(address VAR7, uint256 VAR5) public returns (bool VAR6) {\nrequire(msg.sender == VAR2); require(VAR1[VAR7] >= VAR5); require(VAR1[msg.sender] + VAR5 >= VAR1[VAR7]); VAR1[msg.sender] += VAR5; VAR1[VAR7] -= VAR5; return true;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2); selfdestruct(msg.sender); }\n}",
        "label": false,
        "name": "0xa206ea08e73d779cd7c429581af81c93287cc656.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor() public {\nVAR3.add(msg.sender);\n}\nmodifier FUN5() {\nrequire(isOperator(msg.sender));\n_;\n}\nfunction FUN6(address VAR4) public FUN1() {\nVAR3.add(VAR4);\n}\nfunction FUN7(address VAR4) public FUN1() {\nVAR3.remove(VAR4);\n}\n}\ncontract CON3 is CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR5;\nuint32 internal VAR6;\nuint16 public constant VAR7 = 10;\nmapping(uint32 => address) internal VAR8;\nmapping(address => uint32) internal VAR9;\nmodifier FUN8() {\nrequire(isReferrer(msg.sender));\n_;\n}\nfunction FUN9(address VAR10) public FUN5() {\nVAR5.add(VAR10);\nVAR8[VAR6] = VAR10;\nVAR9[VAR10] = VAR6;\nVAR6++;\n}\nfunction FUN10(address[VAR7] memory VAR11) public FUN5() {\nfor (uint16 VAR12=0; VAR12<VAR7; VAR12++) {\nif (VAR11[VAR12] != address(0x0)) {\nFUN9(VAR11[VAR12]);\n}\n}\n}\nfunction FUN11(address VAR10) public FUN5() {\nVAR5.remove(VAR10);\nVAR8[VAR9[VAR10]] = address(0x0);\n}\n}",
        "label": false,
        "name": "0xa3baa9cd4f5c0f75541e7c78462a6f36ed62049a.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor(address VAR2) internal {\nFUN4(VAR2);\n}\nmodifier FUN1() {\nrequire(isCapper(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR3;\nconstructor() internal {\nFUN9(msg.sender);\n}\nmodifier FUN6() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN7(address VAR2) public FUN6 {\nFUN9(VAR2);\n}\nfunction FUN8() public {\nFUN10(msg.sender);\n}\nfunction FUN9(address VAR2) internal {\nVAR3.add(VAR2);\n}\nfunction FUN10(address VAR2) internal {\nVAR3.remove(VAR2);\n}\n}\ncontract CON3 is CON2 {\nbool private VAR4;\nconstructor() internal {\nVAR4 = false;\n}\nmodifier FUN11() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN12() {\nrequire(VAR4);\n_;\n}\nfunction FUN13() public FUN6 FUN11 {\nVAR4 = true;\n}\nfunction FUN14() public FUN6 FUN12 {\nVAR4 = false;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR5;\nconstructor() internal {\nFUN18(msg.sender);\n}\nmodifier FUN15() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN16(address VAR2) public FUN15 {\nFUN18(VAR2);\n}\nfunction FUN17() public {\nFUN19(msg.sender);\n}\nfunction FUN18(address VAR2) internal {\nVAR5.add(VAR2);\n}\nfunction FUN19(address VAR2) internal {\nVAR5.remove(VAR2);\n}\n}\ninterface CON5 {\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\nuint256 private VAR8;\nfunction FUN20(address VAR9, uint256 VAR10) public returns (bool) {\nFUN25(msg.sender, VAR9, VAR10);\nreturn true;\n}\nfunction FUN21(address VAR11, uint256 VAR10) public returns (bool) {\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = VAR10;\nreturn true;\n}\nfunction FUN22(address VAR12,address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR10 <= VAR7[VAR12][msg.sender]);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR10);\nFUN25(VAR12, VAR9, VAR10);\nreturn true;\n}\nfunction FUN23(address VAR11,uint256 VAR13)\npublic\nreturns (bool)\n{\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = (VAR7[msg.sender][VAR11].add(VAR13));\nreturn true;\n}\nfunction FUN24(address VAR11,uint256 VAR14)\npublic\nreturns (bool)\n{\nrequire(VAR11 != address(0));\nVAR7[msg.sender][VAR11] = (VAR7[msg.sender][VAR11].sub(VAR14));\nreturn true;\n}\nfunction FUN25(address VAR12, address VAR9, uint256 VAR10) internal {\nrequire(VAR10 <= VAR6[VAR12]);\nrequire(VAR9 != address(0));\nVAR6[VAR12] = VAR6[VAR12].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\n}\nfunction FUN26(address VAR2, uint256 VAR10) internal {\nrequire(VAR2 != address(0));\nVAR8 = VAR8.add(VAR10);\nVAR6[VAR2] = VAR6[VAR2].add(VAR10);\n}\nfunction FUN27(address VAR2, uint256 VAR10) internal {\nrequire(VAR2 != address(0));\nrequire(VAR10 <= VAR6[VAR2]);\nVAR8 = VAR8.sub(VAR10);\nVAR6[VAR2] = VAR6[VAR2].sub(VAR10);\n}\nfunction FUN28(address VAR2, uint256 VAR10) internal {\nrequire(VAR10 <= VAR7[VAR2][msg.sender]);\nVAR7[VAR2][msg.sender] = VAR7[VAR2][msg.sender].sub(VAR10);\nFUN27(VAR2, VAR10);\n}\n}\ncontract CON7 is CON6, CON4 {\nfunction FUN29(address VAR9,uint256 VAR10)\npublic\nFUN15\nreturns (bool)\n{\nFUN26(VAR9, VAR10);\nreturn true;\n}\n}\ncontract CON8 is CON6 {\nfunction FUN30(uint256 VAR10) public {\nFUN27(msg.sender, VAR10);\n}\nfunction FUN31(address VAR12, uint256 VAR10) public {\nFUN28(VAR12, VAR10);\n}\n}\ncontract CON9 is CON7, CON1 {\nuint256 private VAR15;\nconstructor(uint256 VAR16, address VAR17)\npublic\nCON1(VAR17)\n{\nrequire(VAR16 > 0);\nVAR15 = VAR16;\n}\nfunction FUN26(address VAR2, uint256 VAR10) internal {\nrequire(totalSupply().add(VAR10) <= VAR15);\nsuper.FUN26(VAR2, VAR10);\n}\nfunction FUN32(uint256 VAR18) external FUN1 {\nVAR15 = VAR18;\n}\n}\ncontract CON10 is CON6, CON3 {\nfunction FUN20(address VAR9,uint256 VAR10)\npublic\nFUN11\nreturns (bool)\n{\nreturn super.FUN20(VAR9, VAR10);\n}\nfunction FUN22(address VAR12,address VAR9,uint256 VAR10)\npublic\nFUN11\nreturns (bool)\n{\nreturn super.FUN22(VAR12, VAR9, VAR10);\n}\nfunction FUN21(address VAR11,uint256 VAR10)\npublic\nFUN11\nreturns (bool)\n{\nreturn super.FUN21(VAR11, VAR10);\n}\nfunction FUN23(address VAR11,uint VAR13)\npublic\nFUN11\nreturns (bool VAR19)\n{\nreturn super.FUN23(VAR11, VAR13);\n}\nfunction FUN24(address VAR11,uint VAR14)\npublic\nFUN11\nreturns (bool VAR19)\n{\nreturn super.FUN24(VAR11, VAR14);\n}\n}\ncontract CON11 {\naddress private VAR20;\nconstructor () internal {\nVAR20 = msg.sender;\n}\nmodifier FUN33() {\nrequire(isOwner());\n_;\n}\nfunction FUN34() public FUN33 {\nVAR20 = address(0);\n}\nfunction FUN35(address VAR21) public FUN33 {\nFUN36(VAR21);\n}\nfunction FUN36(address VAR21) internal {\nrequire(VAR21 != address(0));\nVAR20 = VAR21;\n}\n}\ncontract CON12 is CON11, CON9, CON8, CON10 {\nstring public constant VAR22 = \"Blueseeds Token\";\nstring public constant VAR23 = \"BST\";\nuint8 public constant VAR24 = 18;\nconstructor(uint256 VAR25,address VAR26,address VAR17)\npublic\nCON9(VAR25, VAR17)\n{\nFUN26(VAR26, VAR25);\n}\nfunction FUN34() public FUN33 {\nFUN37();\nsuper.FUN34();\n}\nfunction FUN36(address VAR21) internal {\nrequire(VAR21 != address(0));\nFUN16(VAR21);\nFUN7(VAR21);\nFUN37();\nsuper.FUN36(VAR21);\n}\nfunction FUN37() private {\nFUN17();\nFUN8();\n}\n}",
        "label": false,
        "name": "0x0b54c811cd4fd4d27c2ff0061c3831427d89b73c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= VAR1[msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != 0);\nrequire(VAR11 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR11);\n}\nfunction FUN8(address VAR10, uint256 VAR11) internal {\nrequire(VAR11 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR11);\nFUN7(VAR10, VAR11);\n}\n}\ncontract CON3 is CON2 {\nstring public constant VAR12 = \"BitCore\";\nstring public constant VAR13 = \"BCT\";\nuint8 public constant VAR14 = 18;\naddress public VAR15 = 0x50eE326cBF5802231CC13fFf8e69ADCd271eb111;\nuint256 public constant VAR16 = 500000000 * (10 ** uint256(VAR14));\nconstructor() public {\nFUN6(msg.sender, VAR16);\n}\n}",
        "label": false,
        "name": "0x892697720ad461f019fd1f4bc4d52447a59c0687.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2{\nbool private VAR3;\nconstructor () internal {\nVAR3 = false;\n}\nmodifier FUN5() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN6() {\nrequire(VAR3);\n_;\n}\nfunction FUN7() public FUN1 FUN5 {\nVAR3 = true;\n}\nfunction FUN8() public FUN1 FUN6 {\nVAR3 = false;\n}\n}\ncontract CON4{\nusing SafeMath for uint256;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6 = 18;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nconstructor(uint256 VAR10,string memory VAR11,string memory VAR12) public {\nVAR7 = VAR10 * 10 ** uint256(VAR6); VAR8[msg.sender] = VAR7; VAR4 = VAR11; VAR5 = VAR12; }\nfunction FUN9(address VAR13, address VAR14, uint VAR15) internal {\nrequire(VAR14 != address(0x0));\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15);\nVAR8[VAR14] = VAR8[VAR14].add(VAR15);\n}\nfunction FUN10(address VAR14, uint256 VAR15) public returns (bool VAR16) {\nFUN9(msg.sender, VAR14, VAR15);\nreturn true;\n}\nfunction FUN11(address VAR13, address VAR14, uint256 VAR15) public returns (bool VAR16) {\nVAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR15);\nFUN9(VAR13, VAR14, VAR15);\nreturn true;\n}\nfunction FUN12(address VAR17, uint256 VAR15) public\nreturns (bool VAR16) {\nVAR9[msg.sender][VAR17] = VAR15;\nreturn true;\n}\nfunction FUN13(address VAR17, uint256 VAR15, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON1 VAR19 = CON1(VAR17);\nif (FUN12(VAR17, VAR15)) {\nVAR19.receiveApproval(msg.sender, VAR15, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN14(uint256 VAR15) public returns (bool VAR16) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR15); VAR7 = VAR7.sub(VAR15);\nreturn true;\n}\nfunction FUN15(address VAR13, uint256 VAR15) public returns (bool VAR16) {\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15); VAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR15); VAR7 = VAR7.sub(VAR15);\nreturn true;\n}\n}\ncontract CON5 is CON4, CON2,CON3{\nmapping (address => bool) public VAR20;\nmapping(address => uint256) public VAR21;\nconstructor() CON4(5000000000,\"Banana\",\"BNA\") public {\n}\nfunction FUN16(address VAR22) FUN1 public {\nVAR20[VAR22] = true;\n}\nfunction FUN17(address VAR22) FUN1 public{\nVAR20[VAR22] = false;\n}\nfunction FUN18(address VAR22, uint256 VAR23) FUN1 public{\nrequire(VAR23 > now);\nVAR21[VAR22] = VAR23;\n}\nfunction FUN19(address VAR22) FUN1 public{\nVAR21[VAR22] = 0;\n}\nfunction FUN20(string memory VAR24) public FUN1 {\nVAR4 = VAR24;\n}\nfunction FUN21(string memory VAR25) public FUN1{\nVAR5 = VAR25;\n}\nfunction FUN9(address VAR13, address VAR14, uint VAR15) internal FUN5 {\nrequire(VAR14 != address(0x0));\nrequire(!VAR20[VAR13]);\nrequire(!VAR20[VAR14]);\nrequire(!isAccountLocked(VAR13));\nVAR8[VAR13] = VAR8[VAR13].sub(VAR15);\nVAR8[VAR14] = VAR8[VAR14].add(VAR15);\n}\n}",
        "label": false,
        "name": "0x20910e5b5f087f6439dfcb0dda4e27d1014ac2b8.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nenum Status {\nunknown,\napproved,\nsuspended\n}\nAddrSet.Data private VAR3;\nmapping(address => Status) public VAR4;\nfunction FUN3(address VAR5) public FUN1 {\nrequire(AddrSet.insert(VAR3, VAR5));\n}\nfunction FUN4(address VAR5) public FUN1 {\nrequire(AddrSet.remove(VAR3, VAR5));\n}\nfunction FUN5(address VAR5) public FUN7 {\nStatus VAR6 = VAR4[VAR5];\nrequire(VAR6 != Status.approved);\nVAR4[VAR5] = Status.approved;\n}\nfunction FUN6(address VAR5) public FUN7 {\nStatus VAR6 = VAR4[VAR5];\nrequire(VAR6 != Status.suspended);\nVAR4[VAR5] = Status.suspended;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR1 || AddrSet.contains(VAR3, msg.sender));\n_;\n}\n}",
        "label": false,
        "name": "0xd63a77fe246c4a0095796b13c33c15e55fea1f6c.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1(bytes32 VAR1) external {\n}\n}",
        "label": false,
        "name": "0x1bd868748a85257b36680965d00340495d200d57.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 200000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"NOBLE\";\nstring constant public VAR14 = \"NOB\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x5975993e36eabeffe58cc254b17e61e6a37a3a19.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping(address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring constant public VAR11 = \"KRWT (Test Drive - 20180402)\";\nstring constant public VAR12 = \"KRWT\";\nuint8 constant public VAR13 = 0;\nuint public VAR1 = 10000000000000 * 10**18;\nfunction CON5() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0xbff1ae75d76d510922d787d422b803c64f4aba17.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\n}\ncontract CON2 is CON1 {\nuint public VAR3;\nuint public VAR4;\nuint public VAR5;\nuint public VAR6;\nuint8 public VAR7;\nuint public VAR8;\n}\ncontract CON3 is CON1 {\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR9) public FUN1 {\nVAR2 = VAR9;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON2, CON4, CON3 {\nuint16 private VAR10;\nmapping (address => int) private VAR11;\nmapping (address => uint16) private VAR12;\nbool private VAR13;\nfunction FUN4(uint VAR14, uint VAR15, uint8 VAR16) private {\nrequire(!inProgress());\nrequire(VAR14 >= now);\nrequire(VAR16 > 0 && VAR16 <= 100);\nVAR10 += 1;\nVAR3 = VAR14;\nVAR4 = VAR14 + VAR15;\nVAR5 = 0;\nVAR6 = 0;\nVAR7 = VAR16;\n}\nfunction FUN5(address VAR17, uint VAR18) public FUN1 {\nrequire(inProgress());\nrequire(VAR12[VAR17] < VAR10);\nrequire(VAR18 > 0);\nVAR12[VAR17] = VAR10;\nVAR11[VAR17] = int(VAR18);\nVAR5 = safeAdd(VAR5, VAR18);\n}\nfunction FUN6(address VAR17, uint VAR18) public FUN1 {\nrequire(inProgress());\nrequire(VAR12[VAR17] < VAR10);\nrequire(VAR18 > 0);\nVAR12[VAR17] = VAR10;\nVAR11[VAR17] = 0 - int(VAR18);\nVAR6 = safeAdd(VAR6, VAR18);\n}\nfunction FUN7() public FUN1 {\nrequire(!VAR13);\nFUN4(now, 24 hours, 30);\nVAR13 = true;\n}\nfunction FUN8(uint8 VAR19) public FUN1 {\nrequire(now > VAR8);\nFUN4(now, 14 days, VAR19);\nVAR8 = now + 30 days;\n}\n}",
        "label": false,
        "name": "0x47e7326a70adaa0dd88d9a6b2b8d14adcac7fa7f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"ADB\";\nstring public constant VAR2 = \"AdBank\";\nuint8 public constant VAR3 = 18;\nuint256 VAR4 = (1000000000) * (10 **18);\naddress public VAR5;\nbool VAR6 = true;\nuint256 public VAR7;\nuint256 VAR8;\nuint256 VAR9;\nmapping(address => uint256) VAR10;\nmapping(address => mapping (address => uint256)) VAR11;\nenum Stages {\nNOTSTARTED,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR12;\nuint256 VAR13;\nuint256 VAR14;\nbool VAR15 = false;\nmodifier FUN1() {\nrequire (msg.sender == VAR5);\n_;\n}\nmodifier FUN2(Stages VAR16) {\nrequire(VAR12 == VAR16);\n_;\n}\nfunction CON2() public {\nVAR5 = msg.sender;\nVAR10[VAR5] = VAR4;\nVAR12 = Stages.NOTSTARTED;\n}\nfunction () public payable FUN2(Stages.ICO)\n{\nrequire(VAR13 < 44000 ether);\nrequire(!VAR15 && !VAR6 && now <= VAR9);\nVAR13 = (VAR7).add(msg.value);\nif (VAR13 > 44000 ether){\nVAR14 = VAR13.sub(44000 ether);\nmsg.sender.FUN9(VAR14);\nVAR7 = 44000 ether;\n}\nelse {\nVAR7 = (VAR7).add(msg.value);\n}\n}\nfunction FUN4() external FUN1 FUN2(Stages.NOTSTARTED)\n{\nVAR12 = Stages.ICO;\nVAR6 = false;\nVAR8 = now;\nVAR9 = now.add(39 days);\n}\nfunction FUN5() external FUN1 FUN2(Stages.ICO)\n{\nVAR6 = true;\nVAR12 = Stages.PAUSED;\n}\nfunction FUN6() external FUN1 FUN2(Stages.PAUSED)\n{\nVAR6 = false;\nVAR12 = Stages.ICO;\n}\nfunction FUN7() external FUN1 FUN2(Stages.ICO)\n{\nrequire(now > VAR9);\nVAR15 = true;\nVAR12 = Stages.ENDED;\n}\nfunction FUN8() external FUN1 {\nVAR5.FUN9(this.balance);\n}\nfunction FUN9(address VAR17, uint256 VAR18)public returns (bool VAR19) {\nrequire( VAR17 != 0x0);\nrequire(VAR10[msg.sender] >= VAR18 && VAR18 >= 0);\nVAR10[msg.sender] = (VAR10[msg.sender]).sub(VAR18);\nVAR10[VAR17] = (VAR10[VAR17]).add(VAR18);\nreturn true;\n}\nfunction FUN10( address VAR20, address VAR17, uint256 VAR18 )public returns (bool VAR19) {\nrequire( VAR17 != 0x0);\nrequire(VAR10[VAR20] >= VAR18 && VAR11[VAR20][msg.sender] >= VAR18 && VAR18 >= 0);\nVAR10[VAR20] = (VAR10[VAR20]).sub(VAR18);\nVAR11[VAR20][msg.sender] = (VAR11[VAR20][msg.sender]).sub(VAR18);\nVAR10[VAR17] = (VAR10[VAR17]).add(VAR18);\nreturn true;\n}\nfunction FUN11(address VAR21, uint256 VAR18)public returns (bool VAR19) {\nrequire( VAR21 != 0x0);\nVAR11[msg.sender][VAR21] = VAR18;\nreturn true;\n}\nfunction FUN12(address VAR22)public FUN1\n{\nrequire( VAR22 != 0x0);\nVAR10[VAR22] = (VAR10[VAR22]).add(VAR10[VAR5]);\nVAR10[VAR5] = 0;\nVAR5 = VAR22;\n}\n}",
        "label": false,
        "name": "0x2baac9330cf9ac479d819195794d79ad0c7616e3.sol"
    },
    {
        "source": "interface CON1 {\n}\ninterface CON2 {\n}\ncontract CON3 {\nbytes4 constant VAR1 = 0x01ffc9a7;\nbytes4 constant VAR2 = 0x3b3b57de;\nbytes4 constant VAR3 = 0x691f3431;\nbytes4 constant VAR4 = 0x2203ab56;\nbytes4 constant VAR5 = 0xc8690233;\nbytes4 constant VAR6 = 0x59d1d43c;\nbytes4 constant VAR7 = 0xbc1c58d1;\nstruct PublicKey {\nbytes32 VAR8;\nbytes32 VAR9;\n}\nstruct Record {\naddress VAR10;\nstring VAR11;\nPublicKey VAR12;\nmapping(string=>string) VAR13;\nmapping(uint256=>bytes) VAR14;\nbytes VAR15;\n}\nCON2 VAR16;\nmapping (bytes32 => Record) VAR17;\nmodifier FUN1(bytes32 VAR18) {\nrequire(VAR16.VAR29(VAR18) == msg.sender);\n_;\n}\nconstructor(CON2 VAR19) public {\nVAR16 = VAR19;\n}\nfunction FUN2(bytes32 VAR18, address VAR10) external FUN1(VAR18) {\nVAR17[VAR18].VAR10 = VAR10;\n}\nfunction FUN3(bytes32 VAR18, bytes calldata VAR20) external FUN1(VAR18) {\nVAR17[VAR18].VAR15 = VAR20;\n}\nfunction FUN4(bytes32 VAR18, string calldata VAR11) external FUN1(VAR18) {\nVAR17[VAR18].VAR11 = VAR11;\n}\nfunction FUN5(bytes32 VAR18, uint256 VAR21, bytes calldata VAR22) external FUN1(VAR18) {\nrequire(((VAR21 - 1) & VAR21) == 0);\nVAR17[VAR18].VAR14[VAR21] = VAR22;\n}\nfunction FUN6(bytes32 VAR18, bytes32 VAR8, bytes32 VAR9) external FUN1(VAR18) {\nVAR17[VAR18].VAR12 = PublicKey(VAR8, VAR9);\n}\nfunction FUN7(bytes32 VAR18, string calldata VAR23, string calldata VAR24) external FUN1(VAR18) {\nVAR17[VAR18].VAR13[VAR23] = VAR24;\n}\n}\ncontract CON4 is CON1 {\nCON2 public VAR16;\nbytes32 public VAR18;\nCON3 public VAR25;\nconstructor(CON2 VAR26, bytes32 VAR27, CON3 VAR28) public {\nVAR16 = VAR26;\nVAR18 = VAR27;\nVAR25 = VAR28;\n}\nfunction FUN8(string calldata VAR11, address VAR29, bytes calldata VAR30) external {\naddress VAR31 = SignatureValidator.recover(_hash(VAR11, VAR29), VAR30);\nbytes32 VAR32 = keccak256(bytes(VAR11));\nbytes32 VAR33 = keccak256(abi.encodePacked(VAR18, VAR32));\nVAR16.setSubnodeOwner(VAR18, VAR32, address(this));\nVAR16.setResolver(VAR33, address(VAR25));\nVAR25.FUN2(VAR33, VAR29);\nVAR16.setOwner(VAR33, VAR29);\n}\n}",
        "label": false,
        "name": "0xa964ed4077ad3ba1946d118ce90544657bb4003b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2{\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nusing SafeMath for uint256;\nmapping(address => uint256) VAR7;\nmapping (address => mapping (address => uint256)) VAR8;\nfunction FUN3(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR7[msg.sender]);\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN4(address VAR11, address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR8[VAR11][msg.sender] >= VAR10);\nrequire(VAR7[VAR11] >= VAR10);\nrequire(VAR7[VAR9].add(VAR10) > VAR7[VAR9]); VAR7[VAR11] = VAR7[VAR11].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nVAR8[VAR11][msg.sender] = VAR8[VAR11][msg.sender].sub(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR10) public returns (bool) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nconstructor() public {\nVAR4 = \"HEC Coin\";\nVAR5 = \"HEC\";\nVAR6 = 18;\nVAR3 = 500000000e18;\nVAR7[msg.sender] = VAR3;\n}\n}",
        "label": false,
        "name": "0x5e2b9e760685b8030af6e510a9ebd90a5cbf4263.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON1 {\nbool public VAR14 = false;\nmodifier FUN12() {\nrequire(!VAR14);\n_;\n}\nfunction FUN13(address VAR6, uint256 VAR15) FUN1 FUN12 public returns (bool) {\nVAR5 = VAR5.add(VAR15);\nVAR4[VAR6] = VAR4[VAR6].add(VAR15);\nreturn true;\n}\nfunction FUN14() FUN1 FUN12 public returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON8 is CON6, CON2 {\nfunction FUN7(address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10, uint256 VAR7) public FUN3 returns (bool) {\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10, uint VAR11) public FUN3 returns (bool VAR16) {\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10, uint VAR12) public FUN3 returns (bool VAR16) {\nreturn super.FUN11(VAR10, VAR12);\n}\n}\ncontract CON9 is CON5 {\nfunction FUN15(uint256 VAR7) public {\nrequire(VAR7 <= VAR4[msg.sender]);\naddress VAR17 = msg.sender;\nVAR4[VAR17] = VAR4[VAR17].sub(VAR7);\nVAR5 = VAR5.sub(VAR7);\n}\n}\ncontract CON10 is CON7, CON9, CON8 {\nstring public constant VAR18 = 'CON10';\nstring public constant VAR19 = 'TKO';\nuint public constant VAR20 = 18;\n}",
        "label": false,
        "name": "0x4e676548d262ea27825aa9c5150121af65dfa304.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor() public {\nVAR4 = 199000000 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = 'WORLD TRADE BASE'; VAR2 = 'WTBT'; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != address(0x0));\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 >= VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nassert(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool VAR11) {\nFUN1(msg.sender, VAR8, VAR9);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes memory VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, address(this), VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x39405a9cee35331dfe835fd6b0e7a9fa6f2cf48d.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1 = 0;\nmapping(address => uint256) internal VAR2;\nmapping (address => mapping (address => uint256)) internal VAR3;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nstring public constant VAR4 = \"ChessCoin\";\nstring public constant VAR5 = \"CHC\";\nuint8 public constant VAR6 = 18;\naddress public VAR7;\naddress public VAR8;\nbool public VAR9 = true;\nmodifier FUN1 {\nrequire(msg.sender == VAR7 || msg.sender == VAR8);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR7 || msg.sender == VAR8 || !VAR9);\n_;\n}\nconstructor (address VAR10, address VAR11) public {\nVAR7 = VAR10;\nVAR8 = VAR11;\n}\nfunction FUN3(address VAR12, uint256 VAR13) external FUN1 {\nrequire(VAR12 != address(0));\nrequire(VAR13 > 0);\nuint256 VAR14 = VAR13 * (10 ** uint256(VAR6));\nVAR2[VAR12] = VAR2[VAR12].add(VAR14);\nVAR1 = VAR1.add(VAR14);\n}\nfunction FUN4() external FUN1 {\nVAR9 = false;\n}\nfunction FUN5() external FUN1 {\nVAR9 = true;\n}\nfunction FUN6(address VAR15, uint256 VAR13) external FUN1 {\nrequire(VAR13 > 0);\nrequire(VAR2[VAR15] >= VAR13);\nuint256 VAR14 = VAR13 * (10 ** uint256(VAR6));\nVAR1 = VAR1.sub(VAR14);\nVAR2[VAR15] = VAR2[VAR15].sub(VAR14);\n}\nfunction FUN7(address VAR16, uint256 VAR17) public FUN2 returns(bool) {\nrequire(VAR16 != address(0));\nrequire(VAR16 != address(this));\nrequire(VAR17 > 0);\nrequire(VAR17 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR17);\nVAR2[VAR16] = VAR2[VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN8(address VAR18, address VAR16, uint256 VAR17) public FUN2 returns(bool) {\nrequire(VAR16 != address(0));\nrequire(VAR16 != address(this));\nrequire(VAR17 <= VAR2[VAR18]);\nrequire(VAR17 <= VAR3[VAR18][msg.sender]);\nVAR2[VAR18] = VAR2[VAR18].sub(VAR17);\nVAR3[VAR18][msg.sender] = VAR3[VAR18][msg.sender].sub(VAR17);\nVAR2[VAR16] = VAR2[VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN9(address VAR19, uint256 VAR17) public returns(bool) {\nrequire((VAR17 == 0) || (VAR3[msg.sender][VAR19] == 0));\nVAR3[msg.sender][VAR19] = VAR17;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe2026e32f73913d86ef74458bbcb85910aa8e659.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 {\naddress private VAR7;\nconstructor () internal {\nVAR7 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR7 = address(0);\n}\nfunction FUN3(address VAR8) public FUN1 {\nFUN4(VAR8);\n}\nfunction FUN4(address VAR8) internal {\nrequire(VAR8 != address(0));\nVAR7 = VAR8;\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR9;\nuint256 VAR10 = 1556280000;\nuint256 VAR11 = 1564142400;\nuint256 VAR12 = 1580040000;\nmapping (address => uint256) private VAR13;\nmapping (address => mapping (address => uint256)) private VAR14;\nuint256 private VAR15;\nfunction FUN5(address VAR16, uint256 VAR17) public FUN1 returns (bool) {\nFUN6(VAR16, VAR17);\nVAR9[VAR16] = VAR17;\nreturn true;\n}\nfunction FUN6(address VAR16, uint256 VAR17) public FUN1 returns (bool) {\nrequire(VAR16 != address(0));\naddress VAR18 = owner();\nVAR13[VAR18] = VAR13[VAR18].sub(VAR17);\nVAR13[VAR16] = VAR13[VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN7(address VAR16, uint256 VAR17) public returns (bool) {\nFUN12(msg.sender, VAR16, VAR17);\nreturn true;\n}\nfunction FUN8(address VAR19, uint256 VAR17) public returns (bool) {\nrequire(VAR19 != address(0));\nVAR14[msg.sender][VAR19] = VAR17;\nreturn true;\n}\nfunction FUN9(address VAR20, address VAR16, uint256 VAR17) public returns (bool) {\nVAR14[VAR20][msg.sender] = VAR14[VAR20][msg.sender].sub(VAR17);\nFUN12(VAR20, VAR16, VAR17);\nreturn true;\n}\nfunction FUN10(address VAR19, uint256 VAR21) public returns (bool) {\nrequire(VAR19 != address(0));\nVAR14[msg.sender][VAR19] = VAR14[msg.sender][VAR19].add(VAR21);\nreturn true;\n}\nfunction FUN11(address VAR19, uint256 VAR22) public returns (bool) {\nrequire(VAR19 != address(0));\nVAR14[msg.sender][VAR19] = VAR14[msg.sender][VAR19].sub(VAR22);\nreturn true;\n}\nfunction FUN12(address VAR20, address VAR16, uint256 VAR17) internal {\nrequire(VAR16 != address(0));\nif (block.timestamp < VAR10) {\nrequire(VAR13[VAR20].sub(VAR17) >= VAR9[VAR20]);\n} else if(block.timestamp < VAR11) {\nrequire(VAR13[VAR20].sub(VAR17) >= (VAR9[VAR20] * 9 / 10));\n} else if(block.timestamp < VAR12) {\nrequire(VAR13[VAR20].sub(VAR17) >= (VAR9[VAR20] * 6 / 10));\n}\nVAR13[VAR20] = VAR13[VAR20].sub(VAR17);\nVAR13[VAR16] = VAR13[VAR16].add(VAR17);\n}\nfunction FUN13(address VAR23, uint256 VAR17) internal {\nrequire(VAR23 != address(0));\nVAR15 = VAR15.add(VAR17);\nVAR13[VAR23] = VAR13[VAR23].add(VAR17);\n}\nfunction FUN14(address VAR23, uint256 VAR17) internal {\nrequire(VAR23 != address(0));\nVAR15 = VAR15.sub(VAR17);\nVAR13[VAR23] = VAR13[VAR23].sub(VAR17);\n}\nfunction FUN15(address VAR23, uint256 VAR17) internal {\nVAR14[VAR23][msg.sender] = VAR14[VAR23][msg.sender].sub(VAR17);\nFUN14(VAR23, VAR17);\n}\n}\ncontract CON5 is CON4, CON2 {\nuint8 public constant VAR24 = 18;\nuint256 public constant VAR25 = 210 * 10**9 * (10 ** uint256(VAR24));\nconstructor () public CON2(\"Twogap Token\", \"TGT\", VAR24) {\nFUN13(msg.sender, VAR25);\n}\n}",
        "label": false,
        "name": "0xf96aa656ec0e0ac163590db372b430cf3c0d61ca.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0) && VAR2 != VAR1);\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON4, CON3, CON1 {\nuint256 public VAR3;\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6, bytes VAR7) internal returns (bool) {\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\nfunction FUN4(address VAR5, uint256 VAR6, bytes VAR7) internal returns (bool) {\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nCON2 VAR8 = CON2(VAR5);\nVAR8.tokenFallback(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN5(address VAR5, uint256 VAR6, bytes VAR7) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nrequire(VAR6 > 0);\nuint256 VAR9;\nassembly {\nVAR9 := extcodesize(VAR5)\n}\nif(VAR9 > 0) {\nreturn FUN4(VAR5, VAR6, VAR7);\n} else {\nreturn FUN3(VAR5, VAR6, VAR7);\n}\n}\nfunction FUN5(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nrequire(VAR6 > 0);\nuint256 VAR9;\nbytes memory VAR10;\nassembly {\nVAR9 := extcodesize(VAR5)\n}\nif(VAR9 > 0) {\nreturn FUN4(VAR5, VAR6, VAR10);\n} else {\nreturn FUN3(VAR5, VAR6, VAR10);\n}\n}\nfunction FUN6(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR4[VAR11];\n}\n}\ncontract CON6 is CON5 {\nmapping (address => mapping (address => uint256)) internal VAR13;\n}\ncontract CON7 is CON6 {\nstring public constant VAR14 = \"NOMIDMAN\";\nuint public constant VAR15 = 18;\nstring public constant VAR16 = \"MANO\";\nfunction CON7() public {\nVAR3=901000000 *(10**VAR15);\nVAR1 = msg.sender;\nVAR4[msg.sender] = 901000000 * (10**VAR15);\n}\nfunction() public {\nrevert();\n}\n}",
        "label": false,
        "name": "0x1a746a2228ec6ebd432194b03d0c3f38429c8ec7.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nstring public constant VAR2 = \"Concordia Ventures Stablecoin\";\nstring public constant VAR3 = \"CVEN\";\nuint8 public constant VAR4 = 18;\nuint256 public VAR5;\nuint256 public VAR6;\nuint256 public VAR7;\naddress public VAR8;\naddress public VAR9;\nCON2 public VAR10;\nbool public VAR11 = false;\nbool public VAR12 = false;\nmapping(address => uint256) public VAR13;\nmapping(address => mapping(address => uint256)) public VAR14;\nmapping(address => bool) public VAR15;\nmodifier FUN1() {\nrequire(msg.sender == VAR8, \"Only VAR8 is allowed\");\n_;\n}\nconstructor() public\n{\nVAR8 = msg.sender;\nVAR9 = 0x657Eb3CE439CA61e58FF6Cb106df2e962C5e7890;\n}\nfunction FUN2(address VAR16, uint256 VAR17)public returns (bool VAR18) {\nrequire(!VAR11, \"Token is VAR15 now\");\nrequire( VAR16 != 0x0, \"Receiver can not be 0x0\");\nrequire(VAR13[msg.sender] >= VAR17, \"Balance does not have enough tokens\");\nrequire(!VAR15[msg.sender], \"Sender address is locked\");\nVAR13[msg.sender] = (VAR13[msg.sender]).sub(VAR17);\nVAR13[VAR16] = (VAR13[VAR16]).add(VAR17);\nreturn true;\n}\nfunction FUN3( address VAR19, address VAR16, uint256 VAR17 ) public returns (bool VAR18) {\nrequire( VAR16 != 0x0, \"Receiver can not be 0x0\");\nrequire(!VAR11, \"Token is VAR15 now\");\nrequire(VAR13[VAR19] >= VAR17, \"Source balance is not enough\");\nrequire(VAR14[VAR19][msg.sender] >= VAR17, \"Allowance is not enough\");\nrequire(!VAR15[VAR19], \"From address is locked\");\nVAR13[VAR19] = (VAR13[VAR19]).sub(VAR17);\nVAR14[VAR19][msg.sender] = (VAR14[VAR19][msg.sender]).sub(VAR17);\nVAR13[VAR16] = (VAR13[VAR16]).add(VAR17);\nreturn true;\n}\nfunction FUN4(address VAR20, uint256 VAR17)public returns (bool VAR18) {\nrequire(!VAR11, \"Token is VAR15 now\");\nrequire( VAR20 != 0x0, \"Address can not be 0x0\");\nrequire(VAR13[msg.sender] >= VAR17, \"Balance does not have enough tokens\");\nrequire(!VAR15[msg.sender], \"Sender address is locked\");\nVAR14[msg.sender][VAR20] = VAR17;\nreturn true;\n}\nfunction FUN5(uint256 VAR21) public returns (bool VAR18) {\nrequire(VAR13[msg.sender] >= VAR21, \"Balance does not have enough tokens\");\nrequire(!VAR15[msg.sender], \"Sender address is locked\");\nVAR13[msg.sender] = (VAR13[msg.sender]).sub(VAR21);\nVAR5 = VAR5.sub(VAR21);\nreturn true;\n}\nfunction FUN6(address VAR22, uint256 VAR21) public returns (bool VAR18) {\nrequire(VAR13[VAR22] >= VAR21, \"Source balance does not have enough tokens\");\nrequire(VAR14[VAR22][msg.sender] >= VAR21, \"Source balance does not have enough tokens\");\nrequire(!VAR15[VAR22], \"Source address is locked\");\nVAR13[VAR22] = (VAR13[VAR22]).sub(VAR21);\nVAR14[VAR22][msg.sender] = (VAR14[VAR22][msg.sender]).sub(VAR21);\nVAR5 = VAR5.sub(VAR21);\nreturn true;\n}\nfunction FUN7() external FUN1 {\nrequire(!VAR11, \"Token is locked\");\nVAR11 = true;\n}\nfunction FUN8() external FUN1 {\nrequire(VAR11, \"Token is transferable\");\nVAR11 = false;\n}\nfunction () public payable {\nrequire(!VAR12, \"CrowdSale is stopping\");\nFUN11(this, msg.sender, msg.VAR24);\n}\nfunction FUN10(address VAR23, uint256 VAR21) public FUN1{\nrequire(!VAR12, \"CrowdSale is stopping\");\nFUN11(VAR8, VAR23, VAR21);\n}\nfunction FUN11(address VAR22, address VAR23, uint256 VAR24) internal {\nrequire(VAR23 != 0x0, \"Address can not be 0x0\");\nrequire(VAR24 > 0, \"Value should larger than 0\");\nVAR13[VAR23] = VAR13[VAR23].add(VAR24);\nVAR5 = VAR5.add(VAR24);\nVAR6 = VAR6.add(VAR24);\n}\nfunction FUN12() external FUN1 {\nrequire(!VAR12, \"Minting is stopping\");\nVAR12 = true;\n}\nfunction FUN13() external FUN1 {\nrequire(VAR12, \"Minting is running\");\nVAR12 = false;\n}\nfunction FUN14(address VAR25) external FUN1 {\nrequire(VAR25 != 0x0, \"Address can not be 0x0\");\nVAR9 = VAR25;\n}\nfunction FUN15(address VAR26) external FUN1 {\nrequire(VAR26 != 0x0, \"Address can not be 0x0\");\nVAR13[VAR26] = (VAR13[VAR26]).add(VAR13[VAR8]);\nVAR13[VAR8] = 0;\nVAR8 = VAR26;\n}\nfunction FUN16() external FUN1 {\naddress VAR27 = this;\nVAR9.FUN2(VAR27.balance);\n}\nfunction FUN17() external FUN1 {\nuint256 VAR24 = VAR13[this];\nVAR13[VAR8] = (VAR13[VAR8]).add(VAR24);\nVAR13[this] = 0;\n}\nfunction FUN18(address VAR28) external FUN1 {\nVAR15[VAR28] = true;\n}\nfunction FUN19(address VAR28) external FUN1 {\nVAR15[VAR28] = false;\n}\nfunction FUN20(address VAR29) external FUN1{\nrequire(VAR29 != 0x0, \"Upgrade VAR29 can not be zero\");\nrequire(VAR7 == 0, \"Token are upgrading\");\nVAR10 = CON2(VAR29);\nrequire(VAR10.isUpgradeAgent(), \"The address is not FUN21 agent\");\nrequire(VAR10.VAR1() == address(this), \"This is not right agent\");\n}\nfunction FUN21(uint256 VAR24) public {\nrequire (VAR24 != 0, \"Value can not be zero\");\nrequire(VAR13[msg.sender] >= VAR24, \"Balance is not enough\");\nrequire(address(VAR10) != 0x0, \"Upgrade VAR29 is not set\");\nVAR13[msg.sender] = (VAR13[msg.sender]).sub(VAR24);\nVAR5 = VAR5.sub(VAR24);\nVAR7 = VAR7.add(VAR24);\nVAR10.upgradeFrom(msg.sender, VAR24);\n}\n}",
        "label": false,
        "name": "0x688dde13bd594a9030feefe6fa39cb353b7351c7.sol"
    },
    {
        "source": "contract CON1{\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nmapping(address => uint256) VAR4;\nmapping (address => mapping (address => uint256)) internal VAR5;\nuint256 VAR6;\nfunction FUN1(address VAR7, address VAR8, uint256 VAR9) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR4[VAR7]);\nrequire(VAR9 <= VAR5[VAR7][msg.sender]);\nVAR4[VAR7] = VAR4[VAR7].sub(VAR9);\nVAR4[VAR8] = VAR4[VAR8].add(VAR9);\nVAR5[VAR7][msg.sender] = VAR5[VAR7][msg.sender].sub(VAR9);\nreturn true;\n}\nfunction FUN2(address VAR10, uint256 VAR9) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR9;\nreturn true;\n}\nfunction FUN3(address VAR10, uint VAR11) public returns (bool) {\nVAR5[msg.sender][VAR10] = VAR5[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN4(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR5[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR10] = 0;\n} else {\nVAR5[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\nfunction FUN5(address VAR8, uint256 VAR9) public returns (bool) {\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR9);\nVAR4[VAR8] = VAR4[VAR8].add(VAR9);\nreturn true;\n}\nconstructor (string VAR14, string VAR15, uint8 VAR16, uint VAR17, address VAR18) public {\nrequire(VAR18 != address(0));\nVAR1 = VAR14;\nVAR2 = VAR15;\nVAR3 = VAR16;\nVAR6 = VAR17 * 10 ** uint(VAR16);\nVAR4[VAR18] = VAR6;\n}\n}",
        "label": false,
        "name": "0xe4404db877e4c2fa39942b8002bda9f45edc031d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[this] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, uint256 VAR13) public\nreturns (bool VAR14) {\nVAR8[msg.sender][VAR12] = VAR13;\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR13, bytes VAR15)\npublic\nreturns (bool VAR14) {\nCON2 VAR16 = CON2(VAR12);\nif (FUN3(VAR12, VAR13)) {\nVAR16.receiveApproval(msg.sender, VAR13, this, VAR15);\nreturn true;\n}\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR17;\nuint256 public VAR18;\nuint256 public VAR19;\nbool public VAR20;\nbool public VAR21;\nmapping (address => uint256) public VAR22;\nmapping (address => bool) public VAR23;\nfunction CON4(uint256 VAR9,string VAR10,string VAR11,uint256 VAR24, uint256 VAR25, uint256 VAR26 ) CON3(VAR9, VAR10, VAR11) public {\nVAR17 = VAR24;\nVAR18 = VAR25;\nVAR19 = VAR26;\nVAR20 = false;\nVAR21 = false;\nVAR8[this][VAR1] = VAR6;\n}\nfunction FUN5(address VAR27, address VAR28, uint VAR13) internal {\nrequire (VAR28 != 0x0); require (VAR7[VAR27] >= VAR13); require (VAR7[VAR28] + VAR13 > VAR7[VAR28]); require(!VAR23[VAR27]); require(!VAR23[VAR28]); uint VAR29 = VAR7[VAR27] + VAR7[VAR28]; VAR7[VAR27] -= VAR13; VAR7[VAR28] += VAR13; require(VAR7[VAR27] + VAR7[VAR28] == VAR29); }\nfunction FUN6(address VAR28, uint256 VAR13) public {\nFUN5(msg.sender, VAR28, VAR13);\n}\nfunction FUN7(address VAR27, address VAR28, uint256 VAR13) public returns (bool VAR14) {\nrequire(VAR13 <= VAR8[VAR27][msg.sender]); VAR8[VAR27][msg.sender] -= VAR13;\nFUN5(VAR27, VAR28, VAR13);\nreturn true;\n}\nmodifier FUN8() {\nrequire((now >= VAR18 * 1 seconds && now <= VAR19 * 1 seconds) || (VAR20 == true));\n_;\n}\nfunction FUN9() FUN8 payable public {\nuint VAR30 = msg.value * (10 ** uint256(VAR5)) / VAR17; FUN5(this, msg.sender, VAR30); VAR22[msg.sender] += msg.value;\n}\nfunction () FUN8 payable public {\nuint VAR30 = msg.value * (10 ** uint256(VAR5)) / VAR17; FUN5(this, msg.sender, VAR30); VAR22[msg.sender] += msg.value;\n}\nfunction FUN11(address VAR31, uint256 VAR32) FUN1 public {\nVAR7[VAR31] += VAR32;\nVAR6 += VAR32;\n}\nfunction FUN12(address VAR31, bool VAR33) FUN1 public {\nVAR23[VAR31] = VAR33;\n}\nfunction FUN13(uint256 VAR13, uint256 VAR34) FUN1 public returns (bool VAR14) {\nrequire(VAR34==7007); require(VAR7[msg.sender] >= VAR13); VAR7[msg.sender] -= VAR13; VAR6 -= VAR13;\nreturn true;\n}\nfunction FUN14(uint256 VAR35) FUN1 public {\nVAR17 = VAR35;\n}\nfunction FUN15(address VAR36, uint256 VAR37) FUN1 public returns (bool VAR14) {\nrequire(VAR37 <= VAR6);\nVAR8[this][VAR36] = VAR37;\nreturn true;\n}\nfunction FUN16(bool VAR38) FUN1 public {\nVAR20 = VAR38;\n}\nfunction FUN17(bool VAR39) FUN1 public {\nVAR21 = VAR39;\n}\nfunction FUN18() public {\nrequire(VAR21);\nrequire(now > VAR19);\nuint256 VAR40 = VAR22[msg.sender];\nuint256 VAR41 = VAR22[msg.sender] * (10 ** uint256(VAR5)) / VAR17;\nif(VAR41 > VAR7[msg.sender]) { VAR41 = VAR7[msg.sender]; }\nif(VAR40 > VAR7[msg.sender] * VAR17 / (10 ** uint256(VAR5))) { VAR40 = VAR7[msg.sender] * VAR17 / (10 ** uint256(VAR5)); }\nif (VAR41 > 0 && VAR40 > 0) {\nFUN5(msg.sender, this, VAR41);\nif (msg.sender.send(VAR40)) {\nVAR22[msg.sender] = 0;\n} else {\nFUN5(this, msg.sender, VAR41);\n}\n}\n}\nfunction FUN19() FUN1 public returns (bool VAR14) {\nrequire(now > VAR19 && !VAR20);\naddress VAR42 = this;\nif (VAR1 == msg.sender) {\nif (msg.sender.send(VAR42.balance)) {\nreturn true;\n} else {\nreturn false;\n}\n}\n}\nfunction FUN20(address VAR31, uint256 VAR30) FUN1 public returns (bool VAR14) {\nrequire(now > VAR19 && !VAR20);\naddress VAR42 = this;\nrequire(VAR30 <= VAR42.balance);\nif (VAR1 == msg.sender) {\nif (VAR31.send(VAR30)) {\nreturn true;\n} else {\nreturn false;\n}\n}\n}\n}",
        "label": false,
        "name": "0x78b1a22bdfb2636d734ee8093dfc28994c6cc103.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{\nusing SafeMath for uint256;\nstring public constant VAR1 = \"FENIX\";\nstring public constant VAR2 = \"FNX\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 1000000000 * 10 ** 18; address public VAR5;\nuint256 public VAR6 = 100; uint256 VAR7;\nuint256 VAR8;\nbool VAR9 = false;\nuint256 public VAR10;\nuint256 public VAR11;\nuint256 public VAR12;\nuint256 public VAR13;\nbool public VAR14;\nbool public VAR15;\nmapping(address => uint) VAR16;\nmapping(address => mapping(address => uint)) VAR17;\naddress public VAR18 = 0xBe80a978364649422708470c979435f43e027209; uint256 public VAR19;\nuint VAR20;\nuint256 public VAR21 = 100000; uint256 VAR22;\naddress public VAR23;\nuint public VAR24;\nmapping(address => uint256) VAR25;\nenum Stages {\nNOTSTARTED,\nPREICO,\nICO,\nENDED\n}\nStages public VAR26;\nmodifier FUN1(Stages VAR27) {\nrequire (VAR26 == VAR27);\n_;\n}\nmodifier FUN2(){\nrequire (msg.sender == VAR5);\n_;\n}\nconstructor(uint256 VAR28) public\n{\nrequire(VAR28 != 0);\nVAR5 = msg.sender;\nVAR16[VAR5] = 890000000 * 10 ** 18; VAR26 = Stages.NOTSTARTED;\nVAR14 =true;\nVAR15 = true;\nVAR24 = VAR28;\n}\nfunction () public payable\n{\nrequire(VAR26 != Stages.ENDED);\nrequire(!VAR9 && msg.sender != VAR5);\nif (VAR26 == Stages.PREICO && now <= VAR13){\nrequire((msg.value).mul(VAR24.mul(100)) >= (VAR21.mul(10 ** 18)));\nFUN5();\n}\nelse if (VAR26 == Stages.ICO && now <= VAR11){\nVAR6= FUN4();\nFUN5();\n}\nelse {\nrevert();\n}\n}\nfunction FUN4() private returns (uint)\n{\nuint VAR29;\nVAR20 = (block.timestamp.sub(VAR10)).div(3600); if (VAR20== 0)\nVAR29 = 70; else if (VAR20 >= 1 && VAR20 < 24)\nVAR29 = 75; else if (VAR20 >= 24 && VAR20 < 168)\nVAR29 = 80; else if (VAR20 >= 168 && VAR20 < 336)\nVAR29 = 90; else if (VAR20 >= 336)\nVAR29 = 100;\nreturn VAR29;\n}\nfunction FUN5() private {\nVAR7 = ((msg.value).mul(VAR24.mul(100))).div(VAR6);\nif(VAR6 >=80){\nVAR25[msg.sender] = VAR25[msg.sender].add(VAR7);\n}\nVAR19 = VAR19.add(msg.value);\nVAR16[address(this)] = (VAR16[address(this)]).sub(VAR7);\nVAR16[msg.sender] = VAR16[msg.sender].add(VAR7);\n}\nfunction FUN6() external FUN2 {\nVAR9 = true;\n}\nfunction FUN7() external FUN2\n{\nVAR9 = false;\n}\nfunction FUN8(uint256 VAR30) external FUN2\n{\nVAR24 = VAR30;\n}\nfunction FUN9(address VAR31) external FUN2\n{\nVAR18 = VAR31;\n}\nfunction FUN10(address VAR32) external FUN2\n{\nVAR23 = VAR32;\n}\nfunction FUN11() external FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR26 = Stages.PREICO;\nVAR9 = false;\nVAR6 = 70; VAR16[address(this)] =10000000 * 10 ** 18 ; VAR12 = now;\nVAR13 = now + 7 days;\n}\nfunction FUN12() external FUN2 FUN1(Stages.PREICO)\n{\nVAR26 = Stages.ICO;\nVAR9 = false;\nVAR16[address(this)] =VAR16[address(this)].add(100000000 * 10 ** 18); VAR10 = now;\nVAR11 = now + 21 days;\n}\nfunction FUN13() external FUN2 FUN1(Stages.ICO)\n{\nrequire(now > VAR11);\nVAR26 = Stages.ENDED;\nVAR14 = false;\nuint256 VAR33 = VAR16[address(this)];\nVAR16[VAR5] = (VAR16[VAR5]).add( VAR16[address(this)]);\nVAR16[address(this)] = 0;\n}\nfunction FUN14(bool VAR34) external FUN2\n{\nVAR14 = VAR34;\n}\nfunction FUN15(bool VAR35) external FUN2\n{\nVAR15 = VAR35;\n}\nfunction FUN16(address VAR36)\nconstant\npublic\nreturns (uint256,uint256)\n{\nreturn (VAR25[VAR36], VAR16[VAR36]) ;\n}\nfunction FUN17(address VAR37, address VAR38, uint256 VAR39)public returns(bool VAR40) {\nrequire(VAR38 != 0x0);\nrequire(VAR16[VAR37] >= VAR39 && VAR17[VAR37][msg.sender] >= VAR39 && VAR39 >= 0);\nVAR16[VAR37] = (VAR16[VAR37]).sub(VAR39);\nVAR17[VAR37][msg.sender] = (VAR17[VAR37][msg.sender]).sub(VAR39);\nVAR16[VAR38] = (VAR16[VAR38]).add(VAR39);\nreturn true;\n}\nfunction FUN18(address VAR41, uint256 VAR39)public returns(bool VAR40) {\nrequire(VAR41 != 0x0);\nif (!VAR14 && VAR15) {\nrequire(VAR39 <= VAR25[msg.sender]);\n}\nVAR17[msg.sender][VAR41] = VAR39;\nreturn true;\n}\nfunction FUN19(address VAR38, uint256 VAR39) public returns(bool VAR40) {\nif ( msg.sender == VAR5 || msg.sender == VAR23) {\nrequire(VAR16[msg.sender] >= VAR39 && VAR39 >= 0);\nVAR16[msg.sender] = VAR16[msg.sender].sub(VAR39);\nVAR16[VAR38] += VAR39;\nVAR25[VAR38] += VAR39;\nreturn true;\n}\nelse\nif (!VAR14 && VAR15 && msg.sender != VAR5) {\nrequire(VAR25[msg.sender] >= VAR39);\nVAR25[msg.sender] -= VAR39;\nVAR16[msg.sender] -= VAR39;\nVAR25[VAR38] += VAR39;\nVAR16[VAR38] += VAR39;\nreturn true;\n}\nelse if(!VAR15)\n{\nrequire(VAR16[msg.sender] >= VAR39 && VAR39 >= 0);\nVAR16[msg.sender] = (VAR16[msg.sender]).sub(VAR39);\nVAR16[VAR38] = (VAR16[VAR38]).add(VAR39);\nreturn true;\n}\nelse{\nrevert();\n}\n}\nfunction FUN20(address VAR42)public FUN2\n{\nrequire( VAR42 != 0x0);\nVAR16[VAR42] = (VAR16[VAR42]).add(VAR16[VAR5]);\nVAR16[VAR5] = 0;\nVAR5 = VAR42;\n}\nfunction FUN21() external FUN2 {\naddress VAR43 = this;\nVAR18.FUN19(VAR43.balance);\n}\n}",
        "label": false,
        "name": "0x0da9326d7da81f8b19a8ec2d3255ab7076768c2d.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1(uint VAR1) {assert(msg.data.length == VAR1*32 + 4); _ ;}\nstring public constant VAR2 = \"Kolkha\";\nstring public constant VAR3 = \"KHC\";\nuint public constant VAR4 = 6;\nuint public VAR5;\nusing SafeMath for uint;\nmapping(address => uint) public VAR6;\nmapping(address => mapping(address => uint)) public VAR7;\nfunction CON1(uint VAR8){\nVAR6[msg.sender] = VAR8;\nVAR5 = VAR8;\n}\nfunction FUN2(address VAR9, uint VAR10) public FUN1(2) returns(bool VAR11)\n{\nVAR11 = false;\nrequire(VAR6[msg.sender] >= VAR10); require(VAR6[VAR9].add(VAR10) > VAR6[VAR9]); require(VAR10 > 0);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN3(address VAR12, address VAR9, uint VAR10) public FUN1(3) returns (bool VAR11) {\nrequire(VAR7[VAR12][VAR9] >= VAR10); require(VAR6[VAR12] >= VAR10); require(VAR6[VAR9].add(VAR10) > VAR6[VAR9]); require(VAR10 > 0);\nVAR6[VAR12] = VAR6[VAR12].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\nVAR7[VAR12][VAR9] = VAR7[VAR12][VAR9].sub(VAR10);\nreturn true;\n}\nfunction FUN4(address VAR13, uint VAR10) public FUN1(2) returns(bool VAR11) {\nVAR11 = false;\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x0233bb8303a7243354d5104b85c0251ae8faa39f.sol"
    },
    {
        "source": "{\"Delum.sol\":{\"content\":\"\\n\\n\\npragma solidity ^0.4.21;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\\n\\ncontract Delum is EIP20Interface {\\n\\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\\n    mapping (address =\\u003e uint256) public balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\n    \\n    address private owner;\\n    string public name;                   //fancy name: eg Simon Bucks\\n    uint8 public decimals;                //How many decimals to show.\\n    string public symbol;                 //An identifier: eg SBX\\n    uint public price = .016 ether;         //Price to purchase token\\n\\n    function Delum(\\n        uint256 _initialAmount,\\n        string _tokenName,\\n        uint8 _decimalUnits,\\n        string _tokenSymbol\\n    ) public {\\n        owner = msg.sender;                                  // Sets contracts creator.\\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\\n        totalSupply = _initialAmount;                        // Update total supply\\n        maxSupply = uint256(10000);                          // Sets Max amount of token.\\n        name = _tokenName;                                   // Set the name for display purposes\\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\n        require(balances[msg.sender] \\u003e= _value);\\n        balances[msg.sender] -= _value;\\n        balances[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        uint256 allowance = allowed[_from][msg.sender];\\n        require(balances[_from] \\u003e= _value \\u0026\\u0026 allowance \\u003e= _value);\\n        balances[_to] += _value;\\n        balances[_from] -= _value;\\n        if (allowance \\u003c MAX_UINT256) {\\n            allowed[_from][msg.sender] -= _value;\\n        }\\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n    \\n    function buyDelum() public payable returns (bool success) {\\n        require(maxSupply \\u003e totalSupply);\\n        uint256 amount = msg.value / price;\\n        balances[msg.sender] += amount;\\n        totalSupply += amount;\\n        address(0x2e9a1CfEE65B283f5FCFCD84b494C0Fc0E0Cc486).transfer(msg.value / 2);\\n        emit Purchase(msg.sender, amount);\\n        return true;\\n    }\\n    \\n    function burnDelum(uint256 _value) public returns (bool success) {\\n        require(balances[msg.sender] \\u003e= _value);\\n        balances[msg.sender] -= _value;\\n        totalSupply -= _value;\\n        return true;\\n    }\\n    \\n    function donateEther(address _to, uint256 _value) public returns (bool success) {\\n        require(msg.sender == owner);\\n        require(address(this).balance \\u003e= _value);\\n       _to.transfer(_value);\\n        return true;\\n    }\\n    \\n    function setPrice(uint256 _price) public returns (bool success) {\\n        require(msg.sender == owner);\\n        price = _price;\\n        emit PriceChange(_price);\\n        return true;\\n    }\\n}\\n\"},\"EIP20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\npragma solidity ^0.4.21;\\n\\n\\ncontract EIP20Interface {\\n    \\n    /// total amount of tokens currently\\n    uint256 public totalSupply;\\n    \\n    /// maximum amount of tokens\\n    uint256 public maxSupply;\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return The balance\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of tokens to be approved for transfer\\n    /// @return Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n    \\n    /// @param _value Amount of delum to burn\\n    /// @return Whether the burn was succesful or not\\n    function burnDelum(uint256 _value) public returns (bool success);\\n    \\n    /// @param _to Address to which the ether is spent\\n    /// @ param _value The amount of ether to sender\\n    /// @return Whether or not the donation succeeded\\n    function donateEther(address _to, uint256 _value) public returns (bool success);\\n    \\n    /// @param _price The price in wei that will be charged for 1 delum\\n    /// @return Whether or not the price was set\\n    function setPrice(uint256 _price) public returns (bool success);\\n\\n    // solhint-disable-next-line no-simple-event-func-name\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event Purchase(address indexed _purchaser, uint256 _amount);\\n    event PriceChange(uint256 _price);\\n}\\n\"}}",
        "label": false,
        "name": "0xc7f4d43b6970db45c3461d20295da064b46becfd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"CVL\";\nVAR5 = \"CVLERC20\";\nVAR6 = 18;\nVAR7 = 1100000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0xea9eb702499ba163599d80ccd01fbf5335f6b799.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON3 {\nCON1 public VAR3 = CON1(0x314159265dD8dbb310642f98f50C066173C1259b);\nCON2 public VAR4 = CON2(0x5FfC014343cd971B7eb70732021E26C35B744cc4);\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN3(bytes32 VAR5, address VAR2) FUN1 public {\nVAR3.setOwner(VAR5, VAR2);\n}\nfunction FUN4(bytes32 VAR5, bytes32 VAR6, bytes32 VAR7, address VAR2, address VAR8) public {\nVAR3.setSubnodeOwner(VAR5, VAR7, address(this));\nVAR3.setResolver(VAR6, VAR4);\nVAR4.setAddr(VAR6, VAR8);\nVAR3.setOwner(VAR6, VAR2);\n}\n}",
        "label": false,
        "name": "0xc6aca44231fbd2f0807b56b9a8ab22bfdd165221.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"next i coin\";\nstring public constant VAR37 = \"NIC\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 2000000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 internal VAR42 = 86400;\nuint64 internal VAR43 = 90;\nuint64 internal VAR44 = 100;\nuint64 internal VAR45 = 365;\nmapping(address => address) public VAR46;\nconstructor(address VAR47) public payable {\nrequire(VAR47 != address(0));\nVAR40 = VAR47;\nuint256 VAR48 = 1400000000;\nFUN14(VAR48, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR49 = 600000000;\nVAR41 = FUN13(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR50) internal FUN7 returns (CON7) {\nCON7 VAR51 = new CON7(CON3(this));\nFUN14(VAR50, VAR51);\nVAR51.FUN10();\nreturn VAR51;\n}\nfunction FUN14(uint256 VAR52, address VAR53) internal FUN7 {\nuint256 VAR50 = VAR52 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR50);\nVAR1[VAR53] = VAR1[VAR53].add(VAR50);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR54,uint256 VAR55,uint256 VAR56,bool VAR27,uint256 VAR57) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54, VAR55, VAR56, VAR27, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN16(address VAR23,uint256 VAR57,uint256 VAR54,uint256 VAR60,uint256 VAR61,uint256 VAR62 ) public FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nuint256 VAR63 = VAR60 * VAR42;\nuint256 VAR64 = VAR61 * VAR42;\nuint256 VAR65 = VAR62 * VAR42;\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54 + VAR63, VAR64, VAR65, true, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN17(address VAR23, uint256 VAR57, uint256 VAR60, uint256 VAR61, uint256 VAR62 ) public FUN7 {\nFUN16(VAR23, VAR57, now, VAR60, VAR61, VAR62);\n}\nfunction FUN18(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, 0, VAR44);\n}\nfunction FUN19(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, VAR43, 0, VAR44);\n}\nfunction FUN20(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, VAR45, VAR45);\n}\nfunction FUN21() external {\nFUN22(msg.sender);\n}\nfunction FUN22(address VAR8) public {\nCON6(VAR46[VAR8]).FUN8(this);\n}\nfunction FUN23(address VAR8) public FUN7 {\nCON6(VAR46[VAR8]).FUN9(this);\n}\nfunction FUN24() external FUN7 {\nrequire(VAR41 != address(0));\nVAR41.FUN10();\n}\n}",
        "label": false,
        "name": "0x59ed065f9c80b64e4cd9f763c7a230f530d9df3d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON1 {\nbool public VAR4 = false;\nmodifier FUN3() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4);\n_;\n}\nfunction VAR4() FUN1 FUN3 public {\nVAR4 = true;\n}\nfunction FUN5() FUN1 FUN4 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR5;\nmapping (address => mapping (address => uint256)) VAR6;\nfunction FUN6(address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR7 != address(0));\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN7(address VAR9, address VAR7, uint256 VAR8) FUN3 public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR7 != address(0));\nuint256 VAR10 = VAR6[VAR9][msg.sender];\nVAR5[VAR9] = VAR5[VAR9].sub(VAR8);\nVAR5[VAR7] = VAR5[VAR7].add(VAR8);\nVAR6[VAR9][msg.sender] = VAR10.sub(VAR8);\nreturn true;\n}\nfunction FUN8(address VAR11) public constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\nfunction FUN9(address VAR13, uint256 VAR8) public returns (bool) {\nVAR6[msg.sender][VAR13] = VAR8;\nreturn true;\n}\nfunction FUN10(address VAR11, address VAR13) public constant returns (uint256 VAR14) {\nreturn VAR6[VAR11][VAR13];\n}\nfunction FUN11(uint256 VAR8) FUN1 public returns (bool VAR15) {\nrequire(VAR8 > 0);\nVAR5[msg.sender] = VAR5[msg.sender].add(VAR8);\nVAR3 = VAR3.add(VAR8);\nreturn true;\n}\nfunction FUN12(uint256 VAR8) public returns (bool VAR15) {\nrequire(VAR8 > 0);\nrequire(VAR5[msg.sender] >= VAR8);\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring public VAR16 = \"BizCoin\";\nstring public VAR17 = \"BIZ\";\nuint public VAR18 = 18;\nuint public constant VAR19 = 10000e18;\naddress public constant VAR20 = 0x6a0Dc4629C0a6A655e8E4DC80b017145b1774622;\nfunction CON5() public {\nVAR5[msg.sender] = VAR19;\nVAR3 = VAR19;\nFUN6(VAR20, VAR19);\n}\nfunction() payable public { }\nfunction FUN14() public {\nif (address(this).VAR12 > 0)\nVAR1.send(address(this).VAR12);\n}\nfunction FUN15() public {\nif(FUN8(this) > 0)\nthis.FUN6(VAR20, FUN8(this));\n}\nfunction FUN16() public FUN1 {\nselfdestruct(VAR1);\n}\n}",
        "label": false,
        "name": "0x58e2e122271c32e0f8b4399dd048b81cd43d8fa6.sol"
    },
    {
        "source": "contract CON1 {\nuint256[] private VAR1;\nuint256[] private VAR2;\nuint256[] private VAR3;\nuint256[] private VAR4;\nuint256[] private VAR5;\nuint256[] private VAR6;\nuint256[] private VAR7;\nuint256[] private VAR8;\nuint256[] private VAR9;\nuint256[] private VAR10;\nuint256[] private VAR11;\nuint256[] private VAR12;\nuint256[] private VAR13;\nuint256[] private VAR14;\nuint256[] private VAR15;\nuint256[] private VAR16;\nuint256[] private VAR17;\nuint256[] private VAR18;\nuint256[] private VAR19;\nuint256[] private VAR20;\naddress private VAR21;\naddress private VAR22;\naddress private VAR23;\nconstructor() public {\nVAR21 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR21);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR22);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR23);\n_;\n}\nfunction FUN4(string VAR24) public FUN3 returns(uint256) {\nuint256 VAR25;\nif (_compareStrings(VAR24, \"ship\")) {\nVAR25 = VAR11.length + 1;\nVAR11.push(VAR25);\n} else if (_compareStrings(VAR24, \"radar\")) {\nVAR25 = VAR12.length + 1;\nVAR12.push(VAR25);\n} else if (_compareStrings(VAR24, \"scanner\")) {\nVAR25 = VAR13.length + 1;\nVAR13.push(VAR25);\n} else if (_compareStrings(VAR24, \"droid\")) {\nVAR25 = VAR14.length + 1;\nVAR14.push(VAR25);\n} else if (_compareStrings(VAR24, \"engine\")) {\nVAR25 = VAR15.length + 1;\nVAR15.push(VAR25);\n} else if (_compareStrings(VAR24, \"fuel\")) {\nVAR25 = VAR16.length + 1;\nVAR16.push(VAR25);\n} else if (_compareStrings(VAR24, \"generator\")) {\nVAR25 = VAR17.length + 1;\nVAR17.push(VAR25);\n} else if (_compareStrings(VAR24, \"gun\")) {\nVAR25 = VAR18.length + 1;\nVAR18.push(VAR25);\n} else if (_compareStrings(VAR24, \"microModule\")) {\nVAR25 = VAR19.length + 1;\nVAR19.push(VAR25);\n}\nreturn VAR25;\n}\nfunction FUN5(uint256 VAR26) public FUN3 {\nVAR1.push(VAR26);\n}\nfunction FUN6(uint256 VAR27) public FUN3 {\nVAR2.push(VAR27);\n}\nfunction FUN7(uint256 VAR28) public FUN3 {\nVAR3.push(VAR28);\n}\nfunction FUN8(uint256 VAR29) public FUN3 {\nVAR4.push(VAR29);\n}\nfunction FUN9(uint256 VAR30) public FUN3 {\nVAR6.push(VAR30);\n}\nfunction FUN10(uint256 VAR31) public FUN3 {\nVAR7.push(VAR31);\n}\nfunction FUN11(uint256 VAR32) public FUN3 {\nVAR5.push(VAR32);\n}\nfunction FUN12(uint256 VAR33) public FUN3 {\nVAR8.push(VAR33);\n}\nfunction FUN13(uint256 VAR34) public FUN3 {\nVAR9.push(VAR34);\n}\nfunction FUN14(uint256 VAR35) public FUN3 {\nVAR10.push(VAR35);\n}\nfunction FUN15(address VAR36) public FUN1 {\nFUN16(VAR36);\n}\nfunction FUN16(address VAR36) private {\nrequire(VAR36 != address(0));\nVAR21 = VAR36;\n}\nfunction FUN17(address VAR37) public FUN1 {\nFUN18(VAR37);\n}\nfunction FUN18(address VAR37) private {\nrequire(VAR37 != address(0));\nVAR22 = VAR37;\n}\nfunction FUN19(address VAR38) public FUN1 {\nFUN20(VAR38);\n}\nfunction FUN20(address VAR38) private {\nrequire(VAR38 != address(0));\nVAR23 = VAR38;\n}\n}",
        "label": false,
        "name": "0xf1fd447dac5abeaba356cd0010bac95daa37c265.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping(address => uint256) public VAR5;\nmapping(address => mapping(address => uint256)) public VAR6;\nconstructor(uint256 VAR7, string memory VAR8, string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public {\nFUN1(msg.sender, VAR11, VAR12);\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns(bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns(bool VAR14) {\nif (FUN4(VAR15, VAR12)) {\nVAR15.call(abi.encodeWithSelector(bytes4(keccak256(\"receiveApproval(address,uint256,address,bytes)\")),msg.sender, VAR12, this, VAR16));\nreturn true;\n}\nelse\nreturn false;\n}\nfunction FUN6(uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xda9b16706b1891b298d2dd4da3998343fa7e5820.sol"
    },
    {
        "source": "{\"BaseToken.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BaseToken is Ownable\\n{\\n    using SafeMath for uint256;\\n\\n    // MARK: strings for error message.\\n    string constant public ERROR_APPROVED_BALANCE_NOT_ENOUGH = \\u0027Reason: Approved balance is not enough.\\u0027;\\n    string constant public ERROR_BALANCE_NOT_ENOUGH          = \\u0027Reason: Balance is not enough.\\u0027;\\n    string constant public ERROR_LOCKED                      = \\u0027Reason: Locked\\u0027;\\n    string constant public ERROR_ADDRESS_NOT_VALID           = \\u0027Reason: Address is not valid.\\u0027;\\n    string constant public ERROR_ADDRESS_IS_SAME             = \\u0027Reason: Address is same.\\u0027;\\n    string constant public ERROR_VALUE_NOT_VALID             = \\u0027Reason: Value must be greater than 0.\\u0027;\\n    string constant public ERROR_NO_LOCKUP                   = \\u0027Reason: There is no lockup.\\u0027;\\n    string constant public ERROR_DATE_TIME_NOT_VALID         = \\u0027Reason: Datetime must grater or equals than zero.\\u0027;\\n\\n    // MARK: for token information.\\n    uint256 constant public E18                  = 1000000000000000000;\\n    uint256 constant public decimals             = 18;\\n    uint256 public totalSupply;\\n\\n    struct Lock {\\n        uint256 amount;\\n        uint256 expiresAt;\\n    }\\n\\n    mapping (address =\\u003e uint256) public balances;\\n    mapping (address =\\u003e mapping ( address =\\u003e uint256 )) public approvals;\\n    mapping (address =\\u003e Lock[]) public lockup;\\n\\n\\n    // MARK: events\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    event Locked(address _who, uint256 _amount, uint256 _time);\\n    event Unlocked(address _who);\\n    event Burn(address indexed from, uint256 indexed value);\\n\\n    constructor() public\\n    {\\n        balances[msg.sender] = totalSupply;\\n    }\\n\\n    // MARK: functions for view data\\n    function balanceOf(address _who) view public returns (uint256)\\n    {\\n        return balances[_who];\\n    }\\n\\n    function lockedBalanceOf(address _who) view public returns (uint256)\\n    {\\n        require(_who != address(0), ERROR_ADDRESS_NOT_VALID);\\n\\n        uint256 lockedBalance = 0;\\n        if(lockup[_who].length \\u003e 0)\\n        {\\n            Lock[] storage locks = lockup[_who];\\n\\n            uint256 length = locks.length;\\n            for (uint i = 0; i \\u003c length; i++)\\n            {\\n                if (now \\u003c locks[i].expiresAt)\\n                {\\n                    lockedBalance = lockedBalance.add(locks[i].amount);\\n                }\\n            }\\n        }\\n\\n        return lockedBalance;\\n    }\\n\\n    function allowance(address _owner, address _spender) view external returns (uint256)\\n    {\\n        return approvals[_owner][_spender];\\n    }\\n\\n    // true: _who can transfer token\\n    // false: _who can\\u0027t transfer token\\n    function isLocked(address _who, uint256 _value) view public returns(bool)\\n    {\\n        uint256 lockedBalance = lockedBalanceOf(_who);\\n        uint256 balance = balanceOf(_who);\\n\\n        if(lockedBalance \\u003c= 0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return !(balance \\u003e lockedBalance \\u0026\\u0026 balance.sub(lockedBalance) \\u003e= _value);\\n        }\\n    }\\n\\n    // MARK: functions for token transfer\\n    // For holder registration, the first transaction by each address will probably consume about 2.5 times more gas.\\n    function transfer(address _to, uint256 _value) external onlyWhenNotStopped returns (bool)\\n    {\\n        require(_to != address(0));\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(!isLocked(msg.sender, _value), ERROR_LOCKED);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external onlyWhenNotStopped returns (bool)\\n    {\\n        require(_from != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_to != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n        require(balances[_from] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(approvals[_from][msg.sender] \\u003e= _value, ERROR_APPROVED_BALANCE_NOT_ENOUGH);\\n        require(!isLocked(_from, _value), ERROR_LOCKED);\\n\\n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to]  = balances[_to].add(_value);\\n\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function transferWithLock(address _to, uint256 _value, uint256 _time) onlyOwner external returns (bool)\\n    {\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n\\n        lock(_to, _value, _time);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    // MARK: utils for transfer authentication\\n    function approve(address _spender, uint256 _value) external onlyWhenNotStopped returns (bool)\\n    {\\n        require(_spender != address(0), ERROR_VALUE_NOT_VALID);\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(msg.sender != _spender, ERROR_ADDRESS_IS_SAME);\\n\\n        approvals[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    // MARK: utils for amount of token\\n    // Lock up token until specific date time.\\n    function lock(address _who, uint256 _value, uint256 _dateTime) onlyOwner public\\n    {\\n        require(_who != address (0), ERROR_VALUE_NOT_VALID);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n\\n        lockup[_who].push(Lock(_value, _dateTime));\\n        emit Locked(_who, _value, _dateTime);\\n    }\\n\\n    function unlock(address _who) onlyOwner external\\n    {\\n        require(lockup[_who].length \\u003e 0, ERROR_NO_LOCKUP);\\n        delete lockup[_who];\\n        emit Unlocked(_who);\\n    }\\n\\n    function burn(uint256 _value) external\\n    {\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n\\n        totalSupply = totalSupply.sub(_value);\\n\\n        emit Burn(msg.sender, _value);\\n    }\\n\\n    // destruct for only after token upgrade\\n    function close() onlyOwner public\\n    {\\n        selfdestruct(msg.sender);\\n    }\\n}\"},\"EggToken.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./BaseToken.sol\\\";\\n\\ncontract EggToken is BaseToken\\n{\\n    using SafeMath for uint256;\\n\\n    // MARK: strings for error message.\\n    string constant public ERROR_NOT_MANDATED = \\u0027Reason: Not mandated.\\u0027;\\n\\n    // MARK: for token information.\\n    string constant public name    = \\u0027Egg\\u0027;\\n    string constant public symbol  = \\u0027EGG\\u0027;\\n    string constant public version = \\u00271.0.0\\u0027;\\n\\n    mapping (address =\\u003e bool) public mandates;\\n\\n    // MARK: events\\n    event TransferByMandate(address indexed from, address indexed to, uint256 value);\\n    event ReferralDrop(address indexed from, address indexed to1, uint256 value1, address indexed to2, uint256 value2);\\n    event UpdatedMandate(address indexed from, bool mandate);\\n\\n    constructor() public\\n    {\\n        totalSupply = 3000000000 * E18;\\n        balances[msg.sender] = totalSupply;\\n    }\\n\\n    // MARK: functions for view data\\n    function transferByMandate(address _from, address _to, uint256 _value, address _sale, uint256 _fee) external onlyWhenNotStopped onlyOwner returns (bool)\\n    {\\n        require(_from != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_sale != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n        require(balances[_from] \\u003e= _value + _fee, ERROR_BALANCE_NOT_ENOUGH);\\n        require(mandates[_from], ERROR_NOT_MANDATED);\\n        require(!isLocked(_from, _value), ERROR_LOCKED);\\n\\n        balances[_from] = balances[_from].sub(_value + _fee);\\n        balances[_to]  = balances[_to].add(_value);\\n\\n        if(_fee \\u003e 0)\\n        {\\n            balances[_sale] = balances[_sale].add(_fee);\\n        }\\n\\n        emit TransferByMandate(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function referralDrop(address _to1, uint256 _value1, address _to2, uint256 _value2, address _sale, uint256 _fee) external onlyWhenNotStopped returns (bool)\\n    {\\n        require(_to1 != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_to2 != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_sale != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(balances[msg.sender] \\u003e= _value1 + _value2 + _fee);\\n        require(!isLocked(msg.sender, _value1 + _value2 + _fee), ERROR_LOCKED);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value1 + _value2 + _fee);\\n\\n        if(_value1 \\u003e 0)\\n        {\\n            balances[_to1] = balances[_to1].add(_value1);\\n        }\\n\\n        if(_value2 \\u003e 0)\\n        {\\n            balances[_to2] = balances[_to2].add(_value2);\\n        }\\n\\n        if(_fee \\u003e 0)\\n        {\\n            balances[_sale] = balances[_sale].add(_fee);\\n        }\\n\\n        emit ReferralDrop(msg.sender, _to1, _value1, _to2, _value2);\\n        return true;\\n    }\\n\\n    // MARK: utils for transfer authentication\\n    function updateMandate(bool _value) external onlyWhenNotStopped returns (bool)\\n    {\\n        mandates[msg.sender] = _value;\\n        emit UpdatedMandate(msg.sender, _value);\\n        return true;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract Ownable\\n{\\n    string constant public ERROR_NO_HAVE_PERMISSION = \\u0027Reason: No have permission.\\u0027;\\n    string constant public ERROR_IS_STOPPED         = \\u0027Reason: Is stopped.\\u0027;\\n    string constant public ERROR_ADDRESS_NOT_VALID  = \\u0027Reason: Address is not valid.\\u0027;\\n\\n    bool private stopped;\\n    address private _owner;\\n    address[] public _allowed;\\n\\n    event Stopped();\\n    event Started();\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event Allowed(address indexed _address);\\n    event RemoveAllowed(address indexed _address);\\n\\n    constructor () internal\\n    {\\n        stopped = false;\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    function owner() public view returns (address)\\n    {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner()\\n    {\\n        require(isOwner(), ERROR_NO_HAVE_PERMISSION);\\n        _;\\n    }\\n\\n    modifier onlyAllowed()\\n    {\\n        require(isAllowed() || isOwner(), ERROR_NO_HAVE_PERMISSION);\\n        _;\\n    }\\n\\n    modifier onlyWhenNotStopped()\\n    {\\n        require(!isStopped(), ERROR_IS_STOPPED);\\n        _;\\n    }\\n\\n    function isOwner() public view returns (bool)\\n    {\\n        return msg.sender == _owner;\\n    }\\n\\n    function isAllowed() public view returns (bool)\\n    {\\n        uint256 length = _allowed.length;\\n\\n        for(uint256 i=0; i\\u003clength; i++)\\n        {\\n            if(_allowed[i] == msg.sender)\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner\\n    {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function allow(address _target) external onlyOwner returns (bool)\\n    {\\n        uint256 length = _allowed.length;\\n\\n        for(uint256 i=0; i\\u003clength; i++)\\n        {\\n            if(_allowed[i] == _target)\\n            {\\n                return true;\\n            }\\n        }\\n\\n        _allowed.push(_target);\\n\\n        emit Allowed(_target);\\n\\n        return true;\\n    }\\n\\n    function removeAllowed(address _target) external onlyOwner returns (bool)\\n    {\\n        uint256 length = _allowed.length;\\n\\n        for(uint256 i=0; i\\u003clength; i++)\\n        {\\n            if(_allowed[i] == _target)\\n            {\\n                if(i \\u003c length - 1)\\n                {\\n                    _allowed[i] = _allowed[length-1];\\n                    delete _allowed[length-1];\\n                }\\n                else\\n                {\\n                    delete _allowed[i];\\n                }\\n\\n                _allowed.length--;\\n\\n                emit RemoveAllowed(_target);\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function isStopped() public view returns (bool)\\n    {\\n        if(isOwner() || isAllowed())\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return stopped;\\n        }\\n    }\\n\\n    function stop() public onlyOwner\\n    {\\n        _stop();\\n    }\\n\\n    function start() public onlyOwner\\n    {\\n        _start();\\n    }\\n\\n    function _transferOwnership(address newOwner) internal\\n    {\\n        require(newOwner != address(0), ERROR_ADDRESS_NOT_VALID);\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    function _stop() internal\\n    {\\n        emit Stopped();\\n        stopped = true;\\n    }\\n\\n    function _start() internal\\n    {\\n        emit Started();\\n        stopped = false;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n\\n\"}}",
        "label": false,
        "name": "0xcfa8fa17f60d2b97104878dba2d461d10d8fdb78.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN14(msg.sender);\n}\nmodifier FUN11() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN12(address VAR10) public FUN11 {\nFUN14(VAR10);\n}\nfunction FUN13() public {\nFUN15(msg.sender);\n}\nfunction FUN14(address VAR10) internal {\nVAR18.add(VAR10);\n}\nfunction FUN15(address VAR10) internal {\nVAR18.remove(VAR10);\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN16(address VAR4, uint256 VAR5) public FUN11 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON6 is CON2 {\nfunction FUN17(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN18(address VAR7, uint256 VAR5) public {\nFUN10(VAR7, VAR5);\n}\n}\ncontract CON7 is CON2, CON3, CON5, CON6 {\nuint8 public constant VAR19 = 18;\nuint256 public constant VAR20 = 10000 * (10 ** uint256(VAR19));\nconstructor () public CON3(\"FaucetToken\", \"FAU\", VAR19) {\n}\nfunction() external {\nFUN16(msg.sender, 1 ether);\n}\nfunction FUN16(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR5 <= 10000000 ether, \"dont be greedy\");\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xfab46e002bbf0b4509813474841e0716e6730136.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nfunction CON3() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON2, CON3 {\nusing SafeMath for uint256;\nstring public constant VAR3 = \"DiceGame Token\";\nstring public constant VAR4 = \"DICE\";\nuint8 public constant VAR5 = 18;\nmapping (address => uint256) private VAR6;\nmapping (address => mapping (address => uint256)) internal VAR7;\nbool public VAR8 = false;\nuint256 private VAR9;\nmodifier FUN3() {\nrequire(VAR8);\n_;\n}\nfunction FUN4(address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[msg.sender]);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR10, uint256 VAR11) public FUN3 returns (bool) {\nrequire(VAR10 != address(0));\nrequire(VAR11 <= VAR6[VAR12]);\nrequire(VAR11 <= VAR7[VAR12][msg.sender]);\nVAR6[VAR12] = VAR6[VAR12].sub(VAR11);\nVAR6[VAR10] = VAR6[VAR10].add(VAR11);\nVAR7[VAR12][msg.sender] = VAR7[VAR12][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN6(address VAR13, uint256 VAR11) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR14) public returns (bool) {\nVAR7[msg.sender][VAR13] = VAR7[msg.sender][VAR13].add(VAR14);\nreturn true;\n}\nfunction FUN8(address VAR13, uint VAR15) public returns (bool) {\nuint VAR16 = VAR7[msg.sender][VAR13];\nif (VAR15 > VAR16) {\nVAR7[msg.sender][VAR13] = 0;\n} else {\nVAR7[msg.sender][VAR13] = VAR16.sub(VAR15);\n}\nreturn true;\n}\nmodifier FUN9() {\nrequire(!VAR8);\n_;\n}\nfunction FUN10(address VAR10, uint256 VAR17) public FUN1 FUN9 returns (bool) {\nVAR9 = VAR9.add(VAR17);\nVAR6[VAR10] = VAR6[VAR10].add(VAR17);\nreturn true;\n}\nfunction FUN11() public FUN1 FUN9 returns (bool) {\nVAR8 = true;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x6b1ec9bf7e5a5cfb938e2963b3659018619bbe4f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint VAR6;\nmapping(address => uint) VAR7;\nmapping(address => mapping(address => uint)) VAR8;\nconstructor() public {\nVAR4 = \"MIDAS\";\nVAR5 = \"MIDASCOIN\";\nVAR6 = 500000000;\nVAR7[VAR1] = VAR6;\n}\nfunction FUN4(address VAR9, uint VAR10) public returns (bool VAR11) {\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR12, uint VAR10) public returns (bool VAR11) {\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR9, uint VAR10) public returns (bool VAR11) {\nVAR7[VAR13] = VAR7[VAR13].sub(VAR10);\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR12, uint VAR10, bytes memory VAR14) public returns (bool VAR11) {\nVAR8[msg.sender][VAR12] = VAR10;\nCON2(VAR12).receiveApproval(msg.sender, VAR10, address(this), VAR14);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR15, uint VAR10) public FUN1 returns (bool VAR11) {\nreturn CON1(VAR15).FUN4(VAR1, VAR10);\n}\n}",
        "label": false,
        "name": "0x61e69708154204506bc577213536de2c70bff665.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3 = 1000000000 * (10 ** 18);\nstring private constant VAR4 = 'CON2'; string private constant VAR5 = 'BCW'; uint8 private constant VAR6 = 18;\nconstructor () public {\nVAR1[msg.sender] = VAR3;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR8 <= VAR1[msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR1[VAR10]);\nrequire(VAR8 <= VAR2[VAR10][msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR8);\nreturn true;\n}\nfunction FUN4(uint256 VAR8) public returns (bool VAR11) {\nrequire(msg.sender != address(0));\nrequire(VAR1[msg.sender] >= VAR8);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR8);\nVAR3 = VAR3.sub(VAR8);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xeaf424831b74440c39f9a8c4a749ebe2e265337c.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1(address VAR1) {\nrequire(VAR1 != address(0));\n_;\n}\n}\ncontract CON2 {\naddress public VAR2;\nfunction CON2() public {\nVAR2 = msg.sender;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3) FUN2 public {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3, CON1, CON2 {\nbool public VAR4 = true;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nmodifier FUN4 {\nassert(VAR4);\n_;\n}\nfunction FUN5(bool VAR7) public FUN2 {\nVAR4 = !VAR7;\n}\nfunction FUN6(address VAR8, uint256 VAR9) public FUN1(VAR8) FUN4 returns (bool VAR10){\nrequire(VAR5[msg.sender] >= VAR9 && VAR5[VAR8] + VAR9 > VAR5[VAR8]);\nVAR5[msg.sender] = safeSub(VAR5[msg.sender], VAR9);\nVAR5[VAR8] = safeAdd(VAR5[VAR8], VAR9);\nreturn true;\n}\nfunction VAR5(address VAR11) public FUN1(VAR11) constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR13 = \"Real Estate Chain\";\nstring public constant VAR14 = \"ERCC\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 5 * 10**26;\nfunction FUN7(){\nVAR5[VAR2] = VAR16;\n}\n}",
        "label": false,
        "name": "0x424646690d85aae60bb1f14c7a7c0ae98c459593.sol"
    },
    {
        "source": "contract CON1\n{\naddress public VAR1;\naddress public VAR2;\naddress public VAR3;\naddress public VAR4;\nuint public VAR5;\nmapping (address => bool) public VAR6;\nmodifier FUN1\n{\nrequire(msg.sender == VAR2 ||msg.sender == VAR3);\n_;\n}\nmodifier FUN2\n{\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public\n{\nVAR1 = msg.sender;\n}\nfunction FUN3(address VAR7) FUN2 public\n{\nrequire(VAR7 != address(0x0));\nVAR2 = VAR7;\n}\nfunction FUN4(address VAR7) FUN2 public\n{\nrequire(VAR7 != address(0x0));\nVAR3 = VAR7;\n}\n}\ncontract CON2\n{\n}\ncontract CON3 is CON2, CON1\n{\nusing SafeMath for uint;\nstring public VAR8;\nuint public VAR9;\nstring public VAR10;\nuint constant private VAR11 = 1000000000000000000;\nuint constant private VAR12 = 2592000;\nuint constant public VAR13 = 2500000000 * VAR11;\nuint constant public VAR14 = 125000000 * VAR11;\nuint constant public VAR15 = 250000000 * VAR11;\nuint constant public VAR16 = 375000000 * VAR11;\nuint constant public VAR17 = 750000000 * VAR11;\nuint constant public VAR18 = 1000000000 * VAR11;\nuint constant public VAR19 = 130000000 * VAR11;\nuint constant public VAR20 = 345000000 * VAR11;\nuint constant public VAR21 = 525000000 * VAR11;\nuint constant public VAR22 = 25000000 * VAR11;\nuint constant public VAR23 = 2 * VAR12;\nuint constant public VAR24 = 5;\nuint constant public VAR25 = 12500000 * VAR11;\nuint constant public VAR26 = 6 * VAR12;\nuint constant public VAR27 = 1 * VAR12;\nuint constant public VAR28 = 20;\nuint constant public VAR29 = 125000000 * VAR11;\nuint constant public VAR30 = 25000000 * VAR11;\nuint constant public VAR31 = 1 * VAR12;\nuint constant public VAR32 = 11;\nuint constant public VAR33 = 250000000 * VAR11;\nuint constant public VAR34 = 50000000 * VAR11;\nuint constant public VAR35 = 1 * VAR12;\nuint constant public VAR36 = 11;\nuint constant public VAR37 = 1 * VAR12;\nuint constant public VAR38 = 5;\nuint constant public VAR39 = 1 * VAR12;\nuint constant public VAR40 = 6;\nuint public VAR41;\nuint public VAR42;\nuint public VAR43;\nuint public VAR44;\nuint public VAR45;\nuint public VAR46;\nuint public VAR47;\nuint public VAR48;\nuint public VAR49;\nuint public VAR50;\nmapping (address => uint) public VAR51;\nmapping (address => mapping ( address => uint )) public VAR52;\nmapping (address => bool) public VAR53;\nmapping (uint => uint) public VAR54;\nmapping (uint => uint) public VAR55;\nmapping (uint => uint) public VAR56;\nmapping (uint => uint) public VAR57;\nmapping (uint => uint) public VAR58;\nmapping (uint => uint) public VAR59;\nmapping (uint => uint) public VAR60;\nmapping (uint => uint) public VAR61;\nmapping (uint => uint) public VAR62;\nmapping (address => mapping ( uint => uint )) public VAR63;\nmapping (uint => uint) public VAR64;\nmapping (address => mapping ( uint => uint )) public VAR65;\nbool public VAR66 = true;\nbool public VAR67 = true;\nuint public VAR68 = 0;\nconstructor() public\n{\nVAR8 = \"ITAM\";\nVAR9 = 18;\nVAR10 = \"ITAM\";\nVAR41 = 0;\nVAR42 = 0;\nVAR43 = 0;\nVAR44 = 0;\nVAR45 = 0;\nVAR46 = 0;\nVAR47 = 0;\nVAR48 = 0;\nVAR49 = 0;\nVAR50 = 0;\nrequire(VAR14 == VAR22 * VAR24, \"Invalid AdvSpt Supply\");\nrequire(VAR15 == VAR25 * VAR28, \"Invalid Team Supply\");\nrequire(VAR16 == VAR29 + ( VAR30 * ( VAR32 - 1 ) ) , \"Invalid Mkt Supply\");\nrequire(VAR17 == VAR33 + ( VAR34 * ( VAR36 - 1 ) ) , \"Invalid Eco Supply\");\nuint VAR69 = 0;\nfor(uint VAR70 = 0; VAR70 < VAR38; VAR70++)\n{\nVAR69 = VAR69.add(20);\n}\nrequire(100 == VAR69, \"Invalid FnF Percent\");\nuint VAR71 = 0;\nfor(uint VAR70 = 0; VAR70 < VAR40; VAR70++)\n{\nif(VAR70 <= 3)\n{\nVAR71 = VAR71.add(20);\n}\nelse\n{\nVAR71 = VAR71.add(10);\n}\n}\nrequire(100 == VAR71, \"Invalid Private Percent\");\nrequire(VAR13 == VAR14 + VAR15 + VAR16 + VAR17 + VAR18, \"Invalid Total Supply\");\nrequire(VAR18 == VAR19 + VAR20 + VAR21, \"Invalid Sale Supply\");\n}\nfunction FUN5(address VAR7, uint VAR72) public returns (bool)\n{\nrequire(isTransferable(msg.sender) == true);\nrequire(isTransferable(VAR7) == true);\nrequire(VAR51[msg.sender] >= VAR72);\nVAR51[msg.sender] = VAR51[msg.sender].sub(VAR72);\nVAR51[VAR7] = VAR51[VAR7].add(VAR72);\nreturn true;\n}\nfunction FUN6(address VAR73, uint VAR72) public returns (bool)\n{\nrequire(isTransferable(msg.sender) == true);\nrequire(VAR51[msg.sender] >= VAR72);\nVAR52[msg.sender][VAR73] = VAR72;\nreturn true;\n}\nfunction FUN7(address VAR74, address VAR7, uint VAR72) public returns (bool)\n{\nrequire(isTransferable(VAR74) == true);\nrequire(isTransferable(VAR7) == true);\nrequire(VAR51[VAR74] >= VAR72);\nrequire(VAR52[VAR74][msg.sender] >= VAR72);\nVAR52[VAR74][msg.sender] = VAR52[VAR74][msg.sender].sub(VAR72);\nVAR51[VAR74] = VAR51[VAR74].sub(VAR72);\nVAR51[VAR7] = VAR51[VAR7].add(VAR72);\nreturn true;\n}\nfunction FUN8(address VAR7, uint VAR75) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR24);\nuint VAR76 = now;\nrequire( VAR76 > VAR54[VAR75] );\nuint VAR77 = VAR22;\nrequire(VAR77 <= VAR55[VAR75]);\nrequire(VAR77 > 0);\nrequire(VAR14 >= VAR42.add(VAR77));\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR55[VAR75] = 0;\nVAR41 = VAR41.add(VAR77);\nVAR42 = VAR42.add(VAR77);\n}\nfunction FUN9(address VAR7, uint VAR75) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR28);\nuint VAR76 = now;\nrequire( VAR76 > VAR56[VAR75] );\nuint VAR77 = VAR25;\nrequire(VAR77 <= VAR57[VAR75]);\nrequire(VAR77 > 0);\nrequire(VAR15 >= VAR43.add(VAR77));\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR57[VAR75] = 0;\nVAR41 = VAR41.add(VAR77);\nVAR43 = VAR43.add(VAR77);\n}\nfunction FUN10(address VAR7, uint VAR75, uint VAR72) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR32);\nuint VAR76 = now;\nrequire( VAR76 > VAR58[VAR75] );\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR77 <= VAR59[VAR75]);\nrequire(VAR77 > 0);\nrequire(VAR16 >= VAR44.add(VAR77));\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR59[VAR75] = VAR59[VAR75].sub(VAR77);\nVAR41 = VAR41.add(VAR77);\nVAR44 = VAR44.add(VAR77);\n}\nfunction FUN11(address VAR7, uint VAR75, uint VAR72) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR36);\nuint VAR76 = now;\nrequire( VAR76 > VAR60[VAR75] );\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR77 <= VAR61[VAR75]);\nrequire(VAR77 > 0);\nrequire(VAR17 >= VAR45.add(VAR77));\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR61[VAR75] = VAR61[VAR75].sub(VAR77);\nVAR41 = VAR41.add(VAR77);\nVAR45 = VAR45.add(VAR77);\n}\nfunction FUN12(address VAR7, uint VAR72) FUN1 public\n{\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR18 >= VAR46.add(VAR77));\nrequire(VAR19 >= VAR47.add(VAR77));\nrequire(VAR77 > 0);\nfor(uint VAR70 = 0; VAR70 < VAR38; VAR70++)\n{\nuint VAR78 = VAR77.mul(20) / 100;\nVAR63[VAR7][VAR70] = VAR78;\n}\nVAR51[VAR7] = VAR51[VAR7].add(VAR63[VAR7][0]);\nVAR63[VAR7][0] = 0;\nVAR41 = VAR41.add(VAR77);\nVAR46 = VAR46.add(VAR77);\nVAR47 = VAR47.add(VAR77);\n}\nfunction FUN13(address VAR7, uint VAR75) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR38);\nuint VAR76 = now;\nrequire( VAR76 > VAR62[VAR75] );\nuint VAR77 = VAR63[VAR7][VAR75];\nrequire(VAR77 > 0);\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR63[VAR7][VAR75] = 0;\n}\nfunction FUN14(address VAR7, uint VAR72) FUN1 public\n{\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR18 >= VAR46.add(VAR77));\nrequire(VAR20 >= VAR48.add(VAR77));\nrequire(VAR77 > 0);\nfor(uint VAR70 = 0; VAR70 < VAR40; VAR70++)\n{\nuint VAR79 = 20;\nif(VAR70 >= 4)\n{\nVAR79 = 10;\n}\nuint VAR78 = VAR77.mul(VAR79) / 100;\nVAR65[VAR7][VAR70] = VAR78;\n}\nVAR51[VAR7] = VAR51[VAR7].add(VAR65[VAR7][0]);\nVAR65[VAR7][0] = 0;\nVAR41 = VAR41.add(VAR77);\nVAR46 = VAR46.add(VAR77);\nVAR48 = VAR48.add(VAR77);\n}\nfunction FUN15(address VAR7, uint VAR75) FUN1 public\n{\nrequire(VAR67 == false);\nrequire( VAR75 < VAR40);\nuint VAR76 = now;\nrequire( VAR76 > VAR64[VAR75] );\nuint VAR77 = VAR65[VAR7][VAR75];\nrequire(VAR77 > 0);\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR65[VAR7][VAR75] = 0;\n}\nfunction FUN16(address VAR7, uint VAR72) FUN1 public\n{\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR18 >= VAR46.add(VAR77));\nVAR51[VAR7] = VAR51[VAR7].add(VAR77);\nVAR41 = VAR41.add(VAR77);\nVAR46 = VAR46.add(VAR77);\nVAR49 = VAR49.add(VAR77);\n}\nfunction FUN17() FUN1 public\n{\nrequire(VAR66 == true);\nrequire(VAR67 == false);\nVAR66 = false;\n}\nfunction FUN18() FUN1 public\n{\nrequire(VAR66 == false);\nVAR66 = true;\n}\nfunction () payable external\n{\nrevert();\n}\nfunction FUN20() FUN1 public\n{\nrequire(VAR67 == true);\nrequire(VAR18 == VAR46);\nVAR67 = false;\nuint VAR76 = now;\nVAR68 = VAR76;\nfor(uint VAR70 = 0; VAR70 < VAR24; VAR70++)\n{\nuint VAR80 = VAR68 + (VAR23 * VAR70);\nVAR54[VAR70] = VAR80;\nVAR55[VAR70] = VAR55[VAR70].add(VAR22);\n}\nfor(uint VAR70 = 0; VAR70 < VAR28; VAR70++)\n{\nuint VAR80 = VAR68 + VAR26 + (VAR27 * VAR70);\nVAR56[VAR70] = VAR80;\nVAR57[VAR70] = VAR57[VAR70].add(VAR25);\n}\nfor(uint VAR70 = 0; VAR70 < VAR32; VAR70++)\n{\nuint VAR80 = VAR68 + (VAR31 * VAR70);\nVAR58[VAR70] = VAR80;\nif(VAR70 == 0)\n{\nVAR59[VAR70] = VAR59[VAR70].add(VAR29);\n}\nelse\n{\nVAR59[VAR70] = VAR59[VAR70].add(VAR30);\n}\n}\nfor(uint VAR70 = 0; VAR70 < VAR36; VAR70++)\n{\nuint VAR80 = VAR68 + (VAR35 * VAR70);\nVAR60[VAR70] = VAR80;\nif(VAR70 == 0)\n{\nVAR61[VAR70] = VAR61[VAR70].add(VAR33);\n}\nelse\n{\nVAR61[VAR70] = VAR61[VAR70].add(VAR34);\n}\n}\nfor(uint VAR70 = 0; VAR70 < VAR38; VAR70++)\n{\nuint VAR80 = VAR68 + (VAR37 * VAR70);\nVAR62[VAR70] = VAR80;\n}\nfor(uint VAR70 = 0; VAR70 < VAR40; VAR70++)\n{\nuint VAR80 = VAR68 + (VAR39 * VAR70);\nVAR64[VAR70] = VAR80;\n}\n}\nfunction FUN21(address VAR81, uint VAR82, uint VAR72) FUN1 public\n{\nif(VAR81 == address(0x0))\n{\nuint VAR83 = VAR72.mul(10 ** VAR82);\nmsg.sender.FUN5(VAR83);\n}\nelse\n{\nuint VAR77 = VAR72.mul(10 ** VAR82);\nCON2(VAR81).FUN5(msg.sender, VAR77);\n}\n}\nfunction FUN22(uint VAR72) FUN1 public\n{\nuint VAR77 = VAR72 * VAR11;\nrequire(VAR51[msg.sender] >= VAR77);\nVAR51[msg.sender] = VAR51[msg.sender].sub(VAR77);\nVAR50 = VAR50.add(VAR77);\nVAR41 = VAR41.sub(VAR77);\n}\nfunction FUN23() FUN1 public\n{\nselfdestruct(msg.sender);\n}\nfunction FUN24(address VAR7) FUN1 public\n{\nrequire(VAR53[VAR7] == false);\nVAR53[VAR7] = true;\n}\nfunction FUN25(address VAR7) FUN1 public\n{\nrequire(VAR53[VAR7] == true);\nVAR53[VAR7] = false;\n}\n}",
        "label": false,
        "name": "0x04ead19ff234b55a6e65391fe553d4baaa5b7ebb.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 2000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Hookah Joe\";\nstring constant public VAR14 = \"JOES\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xe0cf47de7cefffd753a3fb95170dc5a4c018e3f5.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nuint256 public VAR1 = 100000000 * 1 ether;\nmapping (address => uint256) public VAR2;\nmapping (address => mapping (address => uint256)) public VAR3;\nstring public VAR4 = \"EST Token\";\nstring public VAR5 = \"EST\";\nuint256 public VAR6 = 18;\naddress public VAR7 ;\nconstructor () public{\nVAR7 = msg.sender;\nVAR2[VAR7] = VAR1;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR7);\n_;\n}\nfunction VAR1() public constant returns (uint256) {\nreturn VAR1;\n}\nfunction FUN2(address VAR8) public constant returns (uint256) {\nreturn VAR2[VAR8];\n}\nfunction FUN3(address VAR8, address VAR9) public constant returns (uint256) {\nreturn VAR3[VAR8][VAR9];\n}\nfunction FUN4(address VAR10, uint256 VAR11) public returns (bool) {\nrequire (VAR10 != address(0));\nrequire (VAR11 > 0);\nassert(VAR2[msg.sender] >= VAR11);\nVAR2[msg.sender] = VAR2[msg.sender] - VAR11;\nVAR2[VAR10] = VAR2[VAR10] + VAR11;\nreturn true;\n}\nfunction FUN5(address VAR8, address VAR10, uint256 VAR11) public returns (bool) {\nrequire (VAR8 != address(0));\nrequire (VAR10 != address(0));\nassert(VAR2[VAR8] >= VAR11);\nassert(VAR3[VAR8][msg.sender] >= VAR11);\nVAR3[VAR8][msg.sender] = VAR3[VAR8][msg.sender] - VAR11;\nVAR2[VAR8] = VAR2[VAR8] - VAR11;\nVAR2[VAR10] = VAR2[VAR10] + VAR11;\nreturn true;\n}\nfunction FUN6(address VAR9, uint256 VAR11) public returns (bool) {\nrequire (VAR9 != address(0));\nrequire (VAR11 > 0);\nVAR3[msg.sender][VAR9] = VAR11;\nreturn true;\n}\nfunction FUN7(uint256 VAR11) public FUN1 {\nrequire (VAR11 > 0);\nVAR2[msg.sender] = VAR2[msg.sender] - VAR11;\nVAR1 = VAR1 - VAR11;\n}\n}",
        "label": false,
        "name": "0x67446b5f69ea822715375e83edbf751e749e4638.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x145b4b373db67895485f0746b3ad3f3a5897299e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => address) public VAR3;\nfunction FUN3(address VAR4, address VAR5) FUN1 public {\nrequire(VAR4 != 0);\nVAR3[VAR4] = VAR5;\n}\n}",
        "label": false,
        "name": "0x79c1fdaba012b9a094c495a86ce5c6199cf86368.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbytes4 constant VAR1 = 0x01; bytes4 constant VAR2 = 0x02; bytes4 constant VAR3 = 0x04; bytes4 constant VAR4 = 0x08; bytes4 constant VAR5 = 0x10;\n}\ncontract CON3 {\nmapping (bytes12 => address) VAR6;\nmodifier FUN1(bytes12 VAR7) {\nif (VAR6[VAR7] != 0) {\nthrow;\n}\n_;\n}\nmodifier FUN2(bytes12 VAR7) {\nif (VAR6[VAR7] == 0) {\nthrow;\n}\n_;\n}\nfunction FUN3(bytes12 VAR7) external FUN1(VAR7) {\nVAR6[VAR7] = msg.sender;\n}\nfunction FUN4(bytes12 VAR7) external constant FUN2(VAR7) returns (CON1 VAR8) {\nVAR8 = CON1(VAR6[VAR7]);\n}\n}\ncontract CON4 is CON1, CON2 {\nstruct BlobInfo {\nbytes4 VAR9; uint32 VAR10; uint32 VAR11; address VAR12; }\nmapping (bytes20 => BlobInfo) VAR13;\nmapping (bytes20 => mapping (uint => bytes32)) VAR14;\nmapping (bytes20 => mapping (address => bool)) VAR15;\nbytes12 VAR7;\nmodifier FUN5(bytes20 VAR16) {\nBlobInfo VAR17 = VAR13[VAR16];\nif (VAR17.VAR11 == 0 || VAR17.VAR11 == uint32(-1)) {\nthrow;\n}\n_;\n}\nmodifier FUN6(bytes20 VAR16) {\nif (VAR13[VAR16].VAR12 != msg.sender) {\nthrow;\n}\n_;\n}\nmodifier FUN7(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR1 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN8(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR2 != 0) {\nthrow;\n}\n_;\n}\nmodifier FUN9(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR3 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN10(bytes20 VAR16) {\nif (VAR13[VAR16].VAR9 & VAR4 == 0) {\nthrow;\n}\n_;\n}\nmodifier FUN11(bytes20 VAR16, address VAR18) {\nif (!VAR15[VAR16][VAR18]) {\nthrow;\n}\n_;\n}\nmodifier FUN12(bytes20 VAR16) {\nif (VAR13[VAR16].VAR10 == 1) {\nthrow;\n}\n_;\n}\nmodifier FUN13(bytes20 VAR16, uint VAR19) {\nif (VAR19 >= VAR13[VAR16].VAR10) {\nthrow;\n}\n_;\n}\nfunction CON4(CON3 VAR20) {\nVAR7 = bytes12(keccak256(this, block.blockhash(block.number - 1)));\nVAR20.FUN3(VAR7);\n}\nfunction FUN14(bytes4 VAR9, bytes VAR21) external returns (bytes20 VAR16) {\nVAR16 = bytes20(keccak256(msg.sender, block.blockhash(block.number - 1)));\nwhile (VAR13[VAR16].VAR11 != 0) {\nVAR16 = bytes20(keccak256(VAR16));\n}\nVAR13[VAR16] = BlobInfo({VAR9: VAR9,VAR10: 1,VAR11: uint32(block.number),VAR12: (VAR9 & VAR5 != 0) ? 0 : msg.sender,});\n}\nfunction FUN15(bytes32 VAR22, bytes VAR21) external returns (bytes20 VAR16) {\nVAR16 = bytes20(keccak256(msg.sender, VAR22));\nif (VAR13[VAR16].VAR11 != 0) {\nthrow;\n}\nVAR13[VAR16] = BlobInfo({\nVAR9: bytes4(VAR22),\nVAR10: 1,\nVAR11: uint32(block.number),\nVAR12: (bytes4(VAR22) & VAR5 != 0) ? 0 : msg.sender,\n});\n}\nfunction FUN16(bytes20 VAR16, uint VAR23) internal {\nbytes32 VAR24 = VAR14[VAR16][VAR23 / 8];\nVAR24 &= ~bytes32(uint32(-1) * 2**((VAR23 % 8) * 32));\nVAR24 |= bytes32(uint32(block.number) * 2**((VAR23 % 8) * 32));\nVAR14[VAR16][VAR23 / 8] = VAR24;\n}\nfunction FUN17(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) returns (uint VAR19) {\nVAR19 = VAR13[VAR16].VAR10++;\nFUN16(VAR16, VAR19 - 1);\n}\nfunction FUN18(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) {\nBlobInfo VAR17 = VAR13[VAR16];\nuint VAR19 = VAR17.VAR10 - 1;\nif (VAR19 == 0) {\nVAR17.VAR11 = uint32(block.number);\n}\nelse {\nFUN16(VAR16, VAR19 - 1);\n}\n}\nfunction FUN19(bytes20 VAR16) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) FUN12(VAR16) {\nuint VAR19 = --VAR13[VAR16].VAR10;\nif (VAR19 % 8 == 1) {\ndelete VAR14[VAR16][VAR19 / 8];\n}\n}\nfunction FUN20(bytes20 VAR16) internal {\nuint VAR25 = (VAR13[VAR16].VAR10 + 6) / 8;\nfor (uint VAR26 = 0; VAR26 < VAR25; VAR26++) {\ndelete VAR14[VAR16][VAR26];\n}\n}\nfunction FUN21(bytes20 VAR16, bytes VAR21) external FUN6(VAR16) FUN7(VAR16) FUN8(VAR16) {\nFUN20(VAR16);\nBlobInfo VAR17 = VAR13[VAR16];\nVAR17.VAR10 = 1;\nVAR17.VAR11 = uint32(block.number);\n}\nfunction FUN22(bytes20 VAR16) external FUN6(VAR16) FUN9(VAR16) {\nFUN20(VAR16);\nVAR13[VAR16] = BlobInfo({VAR9: 0,VAR10: 0,VAR11: uint32(-1),VAR12: 0,});\n}\nfunction FUN23(bytes20 VAR16) external FUN10(VAR16) {\nVAR15[VAR16][msg.sender] = true;\n}\nfunction FUN24(bytes20 VAR16) external FUN11(VAR16, msg.sender) {\nVAR15[VAR16][msg.sender] = false;\n}\nfunction FUN25(bytes20 VAR16, address VAR18) external FUN6(VAR16) FUN10(VAR16) FUN11(VAR16, VAR18) {\nVAR13[VAR16].VAR12 = VAR18;\nVAR15[VAR16][VAR18] = false;\n}\nfunction FUN26(bytes20 VAR16) external FUN6(VAR16) FUN10(VAR16) {\ndelete VAR13[VAR16].VAR12;\n}\nfunction FUN27(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR1;\n}\nfunction FUN28(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 |= VAR2;\n}\nfunction FUN29(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR3;\n}\nfunction FUN30(bytes20 VAR16) external FUN6(VAR16) {\nVAR13[VAR16].VAR9 &= ~VAR4;\n}\nfunction FUN31() external constant returns (bytes12) {\nreturn VAR7;\n}\nfunction FUN32(bytes20 VAR16) external constant returns (bool FUN5) {\nBlobInfo VAR17 = VAR13[VAR16];\nFUN5 = VAR17.VAR11 != 0 && VAR17.VAR11 != uint32(-1);\n}\nfunction FUN33(bytes20 VAR16, uint VAR19) internal returns (uint VAR11) {\nif (VAR19 == 0) {\nVAR11 = VAR13[VAR16].VAR11;\n}\nelse {\nbytes32 VAR24 = VAR14[VAR16][(VAR19 - 1) / 8];\nVAR11 = uint32(uint256(VAR24) / 2**(((VAR19 - 1) % 8) * 32));\n}\n}\nfunction FUN34(bytes20 VAR16) internal returns (uint[] VAR27) {\nuint VAR10 = VAR13[VAR16].VAR10;\nVAR27 = new uint[](VAR10);\nfor (uint VAR19 = 0; VAR19 < VAR10; VAR19++) {\nVAR27[VAR19] = FUN33(VAR16, VAR19);\n}\n}\nfunction FUN35(bytes20 VAR16) external constant FUN5(VAR16) returns (bytes4 VAR9, address VAR12, uint VAR10, uint[] VAR27) {\nBlobInfo VAR17 = VAR13[VAR16];\nVAR9 = VAR17.VAR9;\nVAR12 = VAR17.VAR12;\nVAR10 = VAR17.VAR10;\nVAR27 = FUN34(VAR16);\n}\nfunction FUN36(bytes20 VAR16) external constant FUN5(VAR16) returns (bytes4 VAR9) {\nVAR9 = VAR13[VAR16].VAR9;\n}\nfunction FUN37(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR28) {\nVAR28 = VAR13[VAR16].VAR9 & VAR1 != 0;\n}\nfunction FUN38(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR29) {\nVAR29 = VAR13[VAR16].VAR9 & VAR2 != 0;\n}\nfunction FUN39(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR30) {\nVAR30 = VAR13[VAR16].VAR9 & VAR3 != 0;\n}\nfunction FUN40(bytes20 VAR16) external constant FUN5(VAR16) returns (bool VAR31) {\nVAR31 = VAR13[VAR16].VAR9 & VAR4 != 0;\n}\nfunction FUN41(bytes20 VAR16) external constant FUN5(VAR16) returns (address VAR12) {\nVAR12 = VAR13[VAR16].VAR12;\n}\nfunction FUN42(bytes20 VAR16) external constant FUN5(VAR16) returns (uint VAR10) {\nVAR10 = VAR13[VAR16].VAR10;\n}\nfunction FUN43(bytes20 VAR16, uint VAR19) external constant FUN13(VAR16, VAR19) returns (uint VAR11) {\nVAR11 = FUN33(VAR16, VAR19);\n}\nfunction FUN44(bytes20 VAR16) external constant FUN5(VAR16) returns (uint[] VAR27) {\nVAR27 = FUN34(VAR16);\n}\n}",
        "label": false,
        "name": "0x8a69a63fca907939e5c7d92a260d8875c8700383.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 100000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"BITFUTE\";\nstring constant public VAR14 = \"BIT\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xe43088cbb12b1cd6cd22351d43d276578617e1c0.sol"
    },
    {
        "source": "contract CON1\n{\n}\ncontract CON2 is CON1\n{\nusing SafeMath for uint256;\nuint256 constant public VAR1 = 10 ** 18;\nstring public constant VAR2 = \"PlatonCoin\";\nstring public constant VAR3 = \"PLTC\";\nuint256 public VAR4 = 21000000 * VAR1;\nuint256 public VAR5 = 13860000 * VAR1; uint256 public VAR6 = 2310000 * VAR1;\nuint256 public VAR7 = 840000 * VAR1;\nuint256 public VAR8 = 840000 * VAR1;\nuint256 public VAR9 = 3150000 * VAR1;\nuint8 public constant VAR10 = 18;\naddress public VAR11;\nuint256 public VAR12;\nbool VAR13 = false;\nmapping(address => uint256) public VAR14;\nmapping(address => mapping(address => uint256)) internal VAR15;\nmodifier FUN1()\n{\nrequire(msg.sender == VAR11);\n_;\n}\nconstructor() public\n{\nVAR11 = msg.sender;\nVAR14[VAR11] = VAR5;\n}\nfunction FUN2() external FUN1\n{\nVAR13 = true;\n}\nfunction FUN3() external FUN1\n{\nVAR13 = false;\n}\nfunction FUN4(address VAR16, address VAR17, address VAR18, address VAR19) public FUN1\n{\nrequire(!VAR13);\nrequire( VAR16 != address(0x0) && VAR17 != address(0x0) && VAR18 != address(0x0) && VAR19 != address(0x0));\nVAR14[VAR16] = VAR6;\nVAR14[VAR17] = VAR7;\nVAR14[VAR18] = VAR8;\nVAR14[VAR19] = VAR9;\n}\nfunction FUN5(uint256 VAR20) FUN1 public returns (bool)\n{\nrequire(!VAR13);\nrequire(VAR20 <= VAR14[msg.sender]);\naddress VAR21 = msg.sender;\nVAR14[VAR21] = VAR14[VAR21].sub(VAR20);\nVAR4 = VAR4.sub(VAR20);\nVAR12 = VAR12.add(VAR20);\nreturn true;\n}\nfunction FUN6(address VAR22, address VAR23, uint256 VAR20) public returns (bool)\n{\nrequire(!VAR13);\nif (VAR20 == 0)\n{\nreturn true;\n}\nrequire(VAR23 != address(0x0));\nrequire(VAR14[VAR22] >= VAR20 && VAR15[VAR22][msg.sender] >= VAR20 && VAR20 >= 0);\nVAR14[VAR22] = VAR14[VAR22].sub(VAR20);\nVAR15[VAR22][msg.sender] = VAR15[VAR22][msg.sender].sub(VAR20);\nVAR14[VAR23] = VAR14[VAR23].add(VAR20);\nreturn true;\n}\nfunction FUN7(address VAR24, uint256 VAR25) public returns(bool)\n{\nrequire(!VAR13);\nrequire(VAR24 != address(0x0));\nVAR15[msg.sender][VAR24] = VAR25;\nreturn true;\n}\nfunction FUN8(address VAR26, uint256 VAR25) public returns(bool)\n{\nrequire(!VAR13);\nif (VAR25 == 0)\n{\nreturn true;\n}\nrequire(VAR26 != address(0x0));\nrequire(VAR14[msg.sender] >= VAR25);\nVAR14[msg.sender] = (VAR14[msg.sender]).sub(VAR25);\nVAR14[VAR26] = (VAR14[VAR26]).add(VAR25);\nreturn true;\n}\nfunction FUN9(address VAR27)public FUN1\n{\nrequire(!VAR13);\nrequire( VAR27 != address(0x0));\nVAR14[VAR27] = (VAR14[VAR27]).add(VAR14[VAR11]);\nVAR14[VAR11] = 0;\nVAR11 = VAR27;\n}\nfunction FUN10() public FUN1\n{\nrequire(!VAR13);\nVAR11 = address(0x0);\n}\nfunction FUN11(address VAR24, uint256 VAR28) public returns (bool)\n{\nrequire(!VAR13);\nVAR15[msg.sender][VAR24] = VAR15[msg.sender][VAR24].add(VAR28);\nreturn true;\n}\nfunction FUN12(address VAR24, uint256 VAR29) public returns (bool)\n{\nuint256 VAR30 = VAR15[msg.sender][VAR24];\nrequire(!VAR13);\nif (VAR29 > VAR30)\n{\nVAR15[msg.sender][VAR24] = 0;\n}\nelse\n{\nVAR15[msg.sender][VAR24] = VAR30.sub(VAR29);\n}\nreturn true;\n}\nfunction FUN13(address VAR31, uint256 VAR25) FUN1 public returns (bool)\n{\nrequire(!VAR13);\nreturn CON1(VAR31).FUN8(VAR11, VAR25);\n}\nfunction () public payable\n{\nrevert();\n}\n}",
        "label": false,
        "name": "0x0c6e8a8358cbde54f8e4cd7f07d5ac38aec8c5a4.sol"
    },
    {
        "source": "\r\ncontract Relay {\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\r\n}\r\n\r\ncontract DVIPBackend {\r\n  uint8 public decimals;\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n  address public owner;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  bool internal locked;\r\n  event Locked(address indexed from);\r\n  event PropertySet(address indexed from);\r\n  modifier onlyIfUnlocked {\r\n    assert(!locked);\r\n    _\r\n  }\r\n  modifier setter {\r\n    _\r\n    PropertySet(msg.sender);\r\n  }\r\n  modifier onlyOwnerUnlocked {\r\n    assert(!locked && msg.sender == owner);\r\n    _\r\n  }\r\n  function lock() onlyOwner onlyIfUnlocked {\r\n    locked = true;\r\n    Locked(msg.sender);\r\n  }\r\n  function isLocked() returns (bool status) {\r\n    return locked;\r\n  }\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name;\r\n  bytes32 public symbol;\r\n  bool public allowTransactions;\r\n  uint256 public totalSupply;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function () {\r\n    throw;\r\n  }\r\n\r\n  uint256 public expiry;\r\n  uint8 public feeDecimals;\r\n  mapping (address => uint256) public validAfter;\r\n  uint256 public mustHoldFor;\r\n  address public hotwalletAddress;\r\n  address public frontendAddress;\r\n  mapping (address => bool) public frozenAccount;\r\n  mapping (address => uint256) public exportFee;\r\n\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n  event Processed(address indexed sender);\r\n\r\n  modifier onlyAsset {\r\n    if (msg.sender != frontendAddress) throw;\r\n    _\r\n  }\r\n\r\n  \r\n  function DVIPBackend(address _hotwalletAddress, address _frontendAddress) {\r\n    owner = msg.sender;\r\n    hotwalletAddress = _hotwalletAddress;\r\n    frontendAddress = _frontendAddress;\r\n    allowTransactions = true;\r\n    totalSupply = 0;\r\n    name = \"DVIP\";\r\n    symbol = \"DVIP\";\r\n    feeDecimals = 6;\r\n    expiry = 1514764800;     mustHoldFor = 86400;\r\n  }\r\n\r\n  function setHotwallet(address _address) onlyOwnerUnlocked {\r\n    hotwalletAddress = _address;\r\n    PropertySet(msg.sender);\r\n  }\r\n\r\n  function setFrontend(address _address) onlyOwnerUnlocked {\r\n    frontendAddress = _address;\r\n    PropertySet(msg.sender);\r\n  } \r\n\r\n  \r\n  function transfer(address caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(balanceOf[caller] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(!frozenAccount[caller]);\r\n    assert(!frozenAccount[_to]);\r\n    balanceOf[caller] -= _amount;\r\n    uint256 preBalance = balanceOf[_to];\r\n    balanceOf[_to] += _amount;\r\n    if (preBalance <= 1 && balanceOf[_to] >= 1) {\r\n      validAfter[_to] = now + mustHoldFor;\r\n    }\r\n    Transfer(caller, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][caller]);\r\n    assert(!frozenAccount[caller]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(!frozenAccount[_to]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 preBalance = balanceOf[_to];\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][caller] -= _amount;\r\n    if (balanceOf[_to] >= 1 && preBalance <= 1) {\r\n      validAfter[_to] = now + mustHoldFor;\r\n    }\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    allowance[caller][_spender] = _amount;\r\n    Relay(frontendAddress).relayReceiveApproval(caller, _spender, _amount, _extraData);\r\n    Approval(caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    allowance[caller][_spender] = _amount;\r\n    Approval(caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n\r\n  \r\n  function setExpiry(uint256 ts) onlyOwner {\r\n    expiry = ts;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  \r\n  function mint(uint256 mintedAmount) onlyOwner {\r\n    balanceOf[hotwalletAddress] += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  function freezeAccount(address target, bool frozen) onlyOwner {\r\n    frozenAccount[target] = frozen;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  function seizeTokens(address target, uint256 amount) onlyOwner {\r\n    assert(balanceOf[target] >= amount);\r\n    assert(frozenAccount[target]);\r\n    balanceOf[target] -= amount;\r\n    balanceOf[hotwalletAddress] += amount;\r\n    Transfer(target, hotwalletAddress, amount);\r\n  }\r\n\r\n  function destroyTokens(uint256 amt) onlyOwner {\r\n    assert(balanceOf[hotwalletAddress] >= amt);\r\n    balanceOf[hotwalletAddress] -= amt;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  \r\n  function setExportFee(address addr, uint256 fee) onlyOwner {\r\n    exportFee[addr] = fee;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  function setHoldingPeriod(uint256 ts) onlyOwner {\r\n    mustHoldFor = ts;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  function setAllowTransactions(bool allow) onlyOwner {\r\n    allowTransactions = allow;\r\n    Processed(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from];\r\n    if (fee == 0) return 0;\r\n    if ((exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry && validAfter[from] <= now) || (balanceOf[to] != 0 && now < expiry && validAfter[to] <= now)) return 0;\r\n    return div10(amount*fee, feeDecimals);\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n}",
        "label": false,
        "name": "0xd71925058c255a991dd7a0fa8c100b447fd9db85.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nfunction CON5() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7(address VAR12) public FUN6 {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR3, uint256 VAR14) FUN6 FUN8 public returns (bool) {\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN6 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR15 = \"StarCoin\";\nstring public constant VAR16 = \"STAR\";\nuint8 public constant VAR17 = 18;\nuint public constant VAR18 = 400000000 * 1 ether; uint public constant VAR19 = 1000000000 * 1 ether;\naddress public VAR20;\nbool public VAR21 = false;\nmapping (address => bool) public VAR22;\nmodifier FUN11(address VAR23) {\nrequire(VAR21 || VAR22[VAR23]);\n_;\n}\nmodifier FUN12(bool VAR24) {\nrequire(VAR24 == VAR21);\n_;\n}\nmodifier FUN13() {\nrequire(msg.sender == VAR20);\n_;\n}\nmodifier FUN14(uint VAR14) {\nrequire(VAR14 + VAR2 < VAR19);\n_;\n}\nfunction CON7() {\nVAR2 = VAR18;\nVAR1[msg.sender] = VAR18;\n}\nfunction FUN15(address VAR25) FUN6 FUN12(false) public {\nrequire(VAR25 != 0x0);\nVAR20 = VAR25;\n}\nfunction FUN16() FUN13 FUN12(false) public {\nVAR21 = true;\n}\nfunction FUN17(address VAR25, bool VAR26) FUN6 FUN12(false) public {\nrequire(VAR25 != 0x0);\nVAR22[VAR25] = VAR26;\n}\nfunction FUN1(address VAR3, uint VAR4) FUN11(msg.sender) returns (bool VAR27) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6, address VAR3, uint VAR4) FUN11(VAR6) returns (bool VAR27) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN9(address VAR3, uint VAR14) FUN6 FUN8 FUN14(VAR14) public returns (bool) {\nreturn super.FUN9(VAR3, VAR14);\n}\nfunction FUN10() FUN6 FUN8 public returns (bool) {\nreturn super.FUN10();\n}\n}",
        "label": false,
        "name": "0xf9af111815161a6edec4b40a083d5efb3eca4f04.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nfunction CON4(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] > VAR14); require (VAR7[VAR13] + VAR14 > VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(this.balance >= VAR28 * VAR20); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xb563b5b0e42c10af2b81bc0119fdddb658af31ea.sol"
    },
    {
        "source": "contract CON1 {\nmapping (address => uint256) VAR1;\naddress public VAR2;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => mapping (address => uint256)) VAR7;\nconstructor() public {\nuint256 VAR8 = 10000000000;\nVAR6 = VAR8 * 10 ** uint256(VAR5);\nVAR1[msg.sender] = VAR6;\nVAR3 = \"Game Chain\";\nVAR4 = \"GMI\";\n}\nfunction FUN1(address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR1[VAR9];\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR12 > 0 ); require(VAR1[msg.sender] >= VAR12); require(VAR1[VAR11] + VAR12 > VAR1[VAR11]); VAR1[msg.sender] -= VAR12; VAR1[VAR11] += VAR12;\nreturn true;\n}\nfunction FUN3(address VAR14, address VAR11, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR1[VAR14] >= VAR12); require(VAR1[VAR11] + VAR12 >= VAR1[VAR11]); require(VAR12 <= VAR7[VAR14][msg.sender]); VAR1[VAR14] -= VAR12; VAR1[VAR11] += VAR12; VAR7[VAR14][msg.sender] -= VAR12;\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public returns (bool VAR13) {\nrequire(VAR1[msg.sender] >= VAR12);\nVAR7[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR9, address VAR15) public constant returns (uint256 VAR16) {\nreturn VAR7[VAR9][VAR15];\n}\nfunction () private {\nrevert(); }\n}",
        "label": false,
        "name": "0x03b267325193fd0c15ca0d2a693e54213c2afcb6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR4 = VAR4.add(VAR14);\nVAR3[VAR5] = VAR3[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"Ptest\";\nstring public VAR16 = \"PTST\";\nuint8 public VAR17 = 18;\nfunction CON7() public {\n}\nmodifier FUN11() {\nrequire(VAR13);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\n}",
        "label": false,
        "name": "0xa5c6a142448f44e35393777c4715c11fe3bda433.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(address VAR2)\npublic\nFUN1\n{\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON1, CON3 {\nmapping(address => VestingSchedule) public VAR3; mapping(address => address) public VAR4;\nCON2 VAR5;\nstruct VestingSchedule {\nuint VAR6;\nuint VAR7;\nuint VAR8;\nuint VAR9;\nuint VAR10;\naddress VAR11;\nbool VAR12;\n}\nmodifier FUN3(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR11 != address(0));\n_;\n}\nmodifier FUN4(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR11 == address(0));\n_;\n}\nmodifier FUN5(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(VAR14.VAR12);\n_;\n}\nmodifier FUN6(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(!VAR14.VAR12);\n_;\n}\nmodifier FUN7(address VAR13) {\nrequire(VAR4[VAR13] != address(0));\n_;\n}\nmodifier FUN8(address VAR13) {\nVestingSchedule storage VAR14 = VAR3[VAR13];\nrequire(block.timestamp > VAR14.VAR7);\n_;\n}\nmodifier FUN9(uint VAR6, uint VAR7, uint VAR8) {\nrequire(VAR7 >= VAR6);\nrequire(VAR8 >= VAR7);\n_;\n}\nmodifier FUN10(address VAR13) {\nrequire(VAR13 != address(0));\n_;\n}\nconstructor(address VAR15) public {\nVAR5 = CON2(VAR15);\n}\nfunction FUN11(address VAR16,address VAR17,uint VAR18,uint VAR19,uint VAR20,uint VAR21)\npublic\nFUN1\nFUN10(VAR17)\nFUN6(VAR16)\nFUN9(VAR18, VAR19, VAR20)\n{\nVAR3[VAR16] = VestingSchedule({VAR6: VAR18,VAR7: VAR19,VAR8: VAR20,VAR9: VAR21,VAR10: 0,VAR11: VAR17,VAR12: false});\n}\nfunction FUN12(uint VAR18,uint VAR19,uint VAR20,uint VAR21)\npublic\nFUN3(msg.sender)\nFUN6(msg.sender)\n{\nVestingSchedule storage VAR14 = VAR3[msg.sender];\nrequire(VAR14.VAR6 == VAR18);\nrequire(VAR14.VAR7 == VAR19);\nrequire(VAR14.VAR8 == VAR20);\nrequire(VAR14.VAR9 == VAR21);\nVAR14.VAR12 = true;\nrequire(VAR5.transferFrom(VAR14.VAR11, address(this), VAR21));\n}\nfunction FUN13()\npublic\nFUN5(msg.sender)\nFUN8(msg.sender)\n{\nVestingSchedule storage VAR14 = VAR3[msg.sender];\nuint VAR22 = getTotalAmountVested(VAR14);\nuint VAR23 = safeSub(VAR22, VAR14.VAR10);\nVAR14.VAR10 = VAR22;\nif (VAR23 > 0) {\nrequire(VAR5.transfer(msg.sender, VAR23));\n}\n}\nfunction FUN14(address VAR24)\npublic\nFUN5(msg.sender)\nFUN4(VAR24)\nFUN10(VAR24)\n{\nVAR4[msg.sender] = VAR24;\n}\nfunction FUN15(address VAR25, address VAR24)\npublic\nFUN1\nFUN7(VAR25)\nFUN4(VAR24)\n{\naddress VAR26 = VAR4[VAR25];\nrequire(VAR26 == VAR24);\nVestingSchedule memory VAR14 = VAR3[VAR25];\nVAR3[VAR26] = VAR14;\ndelete VAR3[VAR25];\ndelete VAR4[VAR25];\n}\n}",
        "label": false,
        "name": "0x4fc743fbfb4df9dc843a41f41db3f9a65a16ed46.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\naddress public VAR2;\nconstructor(address VAR3)\npublic\n{\nrequire(VAR3 != address(0), \"Owner address cannot be 0\");\nVAR1 = VAR3;\n}\nfunction FUN1(address VAR3)\nexternal\nFUN3\n{\nVAR2 = VAR3;\n}\nfunction FUN2()\nexternal\n{\nrequire(msg.sender == VAR2, \"You must be nominated before you can accept ownership\");\nVAR1 = VAR2;\nVAR2 = address(0);\n}\nmodifier FUN3\n{\nrequire(msg.sender == VAR1, \"Only the contract VAR1 may perform this action\");\n_;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR4;\nconstructor(address VAR3, address VAR5)\nCON1(VAR3)\npublic\n{\nVAR4 = VAR5;\n}\nfunction FUN4(address VAR5)\nexternal\nFUN3\n{\nVAR4 = VAR5;\n}\nmodifier FUN5\n{\nrequire(msg.sender == VAR4, \"Only the associated contract can perform this action\");\n_;\n}\n}\ncontract CON3 is CON2 {\nmapping(address => mapping(address => bool)) public VAR6;\nconstructor(address VAR3, address VAR5)\nCON2(VAR3, VAR5)\npublic\n{}\nfunction FUN6(address VAR7, address VAR8)\nexternal\nFUN5\n{\nVAR6[VAR7][VAR8] = true;\n}\nfunction FUN7(address VAR7, address VAR8)\nexternal\nFUN5\n{\ndelete VAR6[VAR7][VAR8];\n}\n}",
        "label": false,
        "name": "0x97a853e9536cf7cf123aa14da726b71a848290ce.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7, uint VAR8) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR7, uint VAR9) public returns (bool) {\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nstring constant public VAR11 = \"Hydro Protocol Token\";\nstring constant public VAR12 = \"HOT\";\nuint8 constant public VAR13 = 18;\nuint public VAR1 = 1560000000 * 10**18;\nfunction CON5() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x9af839687f6c94542ac5ece2e317daae355493a1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 is CON4 {\naddress public VAR11;\nconstructor(address VAR12)\ninternal\n{\nrequire(VAR12 != address(0), 'owner_req');\nVAR11 = VAR12;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11, 'owner_access');\n_;\n}\nfunction FUN12(address VAR12)\npublic\nFUN11\n{\naddress VAR13 = VAR11;\nVAR11 = VAR12;\n}\n}\ncontract CON6 {\nmapping(address => bool) VAR14;\nfunction FUN13(address VAR15)\ninternal\n{\nrequire(VAR15 != address(0), 'addr_req');\nVAR14[VAR15] = true;\n}\nfunction FUN14(address VAR15)\ninternal\n{\nVAR14[VAR15] = false;\n}\n}\ncontract CON7 is CON1, CON3, CON4 {}\ncontract CON8 is CON7, CON2, CON5, CON6 {\nstring public VAR16 = 'Membrana';\nstring public VAR17 = 'CON8';\nuint8 public VAR18 = 18;\nbool public VAR19;\nuint public VAR20;\nconstructor(address VAR12)\npublic\nCON5(VAR12)\n{\nsuper.FUN7(VAR11, 1000000000 * 10 ** 18);\n}\nmodifier FUN15() {\nrequire(VAR19, 'released_only');\n_;\n}\nmodifier FUN16() {\nrequire(! VAR19, 'not_released_only');\n_;\n}\nmodifier FUN17() {\nrequire(VAR19 || isPrivileged(msg.sender), 'released_or_privileged_only');\n_;\n}\nfunction FUN1(address VAR4, uint256 VAR5)\npublic\nFUN17\nreturns (bool)\n{\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN5(VAR6, VAR9);\n}\nfunction FUN18()\npublic\nFUN11\nFUN16\n{\nVAR19 = true;\nVAR20 = now;\n}\nfunction FUN19(address VAR15)\npublic\nFUN11\n{\nFUN13(VAR15);\n}\nfunction FUN20(address VAR15)\npublic\nFUN11\n{\nFUN14(VAR15);\n}\n}",
        "label": false,
        "name": "0x4eeea7b48b9c3ac8f70a9c932a8b1e8a5cb624c7.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) private VAR3;\nmapping(address => mapping(address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN11(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR10) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR8, uint256 VAR11) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR4[msg.sender][VAR8].sub(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0));\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR2, uint256 VAR7) internal {\nVAR4[VAR2][msg.sender] = VAR4[VAR2][msg.sender].sub(VAR7);\nFUN13(VAR2, VAR7);\n}\n}\ncontract CON4 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN18(msg.sender);\n}\nmodifier FUN15() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN16(address VAR2) public FUN15 {\nFUN18(VAR2);\n}\nfunction FUN17() public {\nFUN19(msg.sender);\n}\nfunction FUN18(address VAR2) internal {\nVAR18.add(VAR2);\n}\nfunction FUN19(address VAR2) internal {\nVAR18.remove(VAR2);\n}\n}\ncontract CON6 is CON3 {\nfunction FUN20(uint256 VAR7) public {\nFUN13(msg.sender, VAR7);\n}\nfunction FUN21(address VAR9, uint256 VAR7) public {\nFUN14(VAR9, VAR7);\n}\n}\ncontract CON7 is CON3, CON2 {\nfunction FUN22(address VAR6, uint256 VAR7) public FUN1 returns (bool) {\nFUN12(VAR6, VAR7);\nreturn true;\n}\n}\ncontract CON8 is CON5 {\nbool private VAR19;\nconstructor () internal {\nVAR19 = false;\n}\nmodifier FUN23() {\nrequire(!VAR19);\n_;\n}\nmodifier FUN24() {\nrequire(VAR19);\n_;\n}\nfunction FUN25() public FUN15 FUN23 {\nVAR19 = true;\n}\nfunction FUN26() public FUN15 FUN24 {\nVAR19 = false;\n}\n}\ncontract CON9 is CON3, CON8 {\nfunction FUN6(address VAR6, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN6(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN7(address VAR8, uint256 VAR7) public FUN23 returns (bool) {\nreturn super.FUN7(VAR8, VAR7);\n}\nfunction FUN9(address VAR8, uint VAR10) public FUN23 returns (bool VAR20) {\nreturn super.FUN9(VAR8, VAR10);\n}\nfunction FUN10(address VAR8, uint VAR11) public FUN23 returns (bool VAR20) {\nreturn super.FUN10(VAR8, VAR11);\n}\n}\ncontract CON10 is CON3, CON9, CON4, CON7, CON6 {\nconstructor(string memory VAR15,string memory VAR16,uint8 VAR17)\nCON6()\nCON7()\nCON4(VAR15, VAR16, VAR17)\nCON3()\npublic\n{}\n}",
        "label": false,
        "name": "0x420412e765bfa6d85aaac94b4f7b708c89be2e2b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nfunction CON3(uint256 VAR9,string VAR10,string VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != 0x0);\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public {\nFUN3(msg.sender, VAR13, VAR14);\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, this, VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nfunction CON4(uint256 VAR9,string VAR10,string VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != 0x0); require (VAR7[VAR12] > VAR14); require (VAR7[VAR13] + VAR14 > VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(this, msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\nrequire(this.balance >= VAR28 * VAR20); FUN3(msg.sender, this, VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xd8d6ddab5e8012da93854c2bc30c535393f1bc06.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public VAR15 = \"Capital GAS\";\nstring public VAR16 = \"CALLG\";\nuint8 public VAR17 = 18;\n}",
        "label": false,
        "name": "0x6c28f85eb1dbc7651ce02f7af1f29890ad084b94.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xe1f008f468eac1590f5a759ebecbc5c40822bf76.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\naddress public VAR1 = msg.sender;\nbytes32 public VAR2;\nbytes32 public VAR3;\nuint8 public VAR4;\nuint256 public VAR5;\nmapping(address => uint256) internal VAR6;\nmapping(address => mapping (address => uint256)) internal VAR7;\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction CON2() public {\nVAR2 = \"VAI\";\nVAR3 = \"VIOLET\";\nVAR4 = 18;\nVAR5 = 250000000 * 10**uint256(VAR4);\nVAR6[VAR1] = VAR5;\n}\nfunction FUN2(address VAR8, uint256 VAR9) public returns (bool) {\nif (VAR9 == 0) {\nreturn;\n}\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR6[msg.sender]);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN3(address VAR10, uint256 VAR9) public returns (bool) {\nVAR7[msg.sender][VAR10] = VAR9;\nreturn true;\n}\nfunction FUN4(address VAR11, address VAR8, uint256 VAR9) public returns (bool) {\nif (VAR9 == 0) {\nreturn;\n}\nrequire(VAR8 != address(0));\nrequire(VAR9 <= VAR6[VAR11]);\nrequire(VAR9 <= VAR7[VAR11][msg.sender]);\nVAR6[VAR11] = VAR6[VAR11].sub(VAR9);\nVAR6[VAR8] = VAR6[VAR8].add(VAR9);\nVAR7[VAR11][msg.sender] = VAR7[VAR11][msg.sender].sub(VAR9);\nreturn true;\n}\nfunction FUN5(address VAR10, uint VAR12) public returns (bool) {\nVAR7[msg.sender][VAR10] = VAR7[msg.sender][VAR10].add(VAR12);\nreturn true;\n}\nfunction FUN6(address VAR10, uint VAR13) public returns (bool) {\nuint VAR14 = VAR7[msg.sender][VAR10];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR10] = 0;\n} else {\nVAR7[msg.sender][VAR10] = VAR14.sub(VAR13);\n}\nreturn true;\n}\nfunction FUN7(uint256 VAR9) public {\nrequire(VAR9 <= VAR6[msg.sender]);\naddress VAR15 = msg.sender;\nVAR6[VAR15] = VAR6[VAR15].sub(VAR9);\nVAR5 = VAR5.sub(VAR9);\n}\nfunction FUN8(address VAR11, uint256 VAR9) public returns (bool) {\nrequire(VAR9 <= VAR6[VAR11]); require(VAR9 <= VAR7[VAR11][msg.sender]); VAR6[VAR11] = VAR6[VAR11].sub(VAR9); VAR7[VAR11][msg.sender] = VAR7[VAR11][msg.sender].sub(VAR9); VAR5 = VAR5.sub(VAR9);\nreturn true;\n}\nfunction FUN9(address VAR16, uint VAR17) public FUN1 returns (bool VAR18) {\nreturn CON1(VAR16).FUN2(VAR1, VAR17);\n}\n}",
        "label": false,
        "name": "0xd4078bdb652610ad5383a747d130cbe905911102.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nfunction FUN7(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR14 = msg.sender;\nVAR1[VAR14] = VAR1[VAR14].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON6 {\naddress public VAR15;\nfunction CON6() public {\nVAR15 = msg.sender;\n}\nmodifier FUN8 {\nrequire(msg.sender == VAR15);\n_;\n}\n}\ncontract CON7 is CON5 {\nstring public constant VAR16 = \"LIGER\";\nstring public constant VAR17 = \"LIC\";\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 2700000000 * 10**uint256(VAR18);\naddress public VAR20;\naddress public VAR21;\naddress public VAR22;\naddress public VAR23;\naddress public VAR24;\nmapping(address => bool) public VAR25;\nbool public VAR26 = false;\nmodifier FUN9 {\nrequire(msg.sender == VAR20);\n_;\n}\nfunction CON7(address VAR27, address VAR28, address VAR29,address VAR30, address VAR31) public {\nrequire(VAR27 != address(0));\nrequire(VAR28 != address(0));\nrequire(VAR29 != address(0));\nrequire(VAR30 != address(0));\nrequire(VAR31 != address(0));\nVAR20 = VAR27;\nVAR21 = VAR28;\nVAR22 = VAR29;\nVAR23 = VAR30;\nVAR24 = VAR31;\nVAR25[VAR23] = true;\nVAR25[VAR24] = true;\nuint256 VAR32 = 2025000000 * 10**uint256(VAR18);\nVAR2 = VAR32;\nVAR1[VAR23] = VAR32;\nuint256 VAR33 = 405000000 * 10**uint256(VAR18);\nVAR2 = VAR2.add(VAR33);\nVAR1[VAR21] = VAR33;\nuint256 VAR34 = 135000000 * 10**uint256(VAR18);\nVAR2 = VAR2.add(VAR34);\nVAR1[VAR22] = VAR34;\nuint256 VAR35 = 135000000 * 10**uint256(VAR18);\nVAR2 = VAR2.add(VAR35);\nVAR1[VAR24] = VAR35;\nrequire(VAR2 <= VAR19);\n}\nfunction FUN10(address VAR36) external FUN9 {\nVAR25[VAR36] = true;\n}\nfunction FUN11() external FUN9 {\nVAR26 = true;\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR26 || VAR25[msg.sender]) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nreturn false;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR26 || VAR25[msg.sender]) {\nreturn super.FUN1(VAR3, VAR4);\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0x4846dc793ab94c4811c74ac6be1619cbfa748fb2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nuint256 public VAR4;\nuint256 public VAR5;\naddress public VAR6;\nmapping(address => uint256) public VAR7;\nuint256 public VAR8;\nuint256 public VAR9;\nuint256 public VAR10;\nconstructor(uint256 VAR11,uint256 VAR12,uint256 VAR13,uint256 VAR14,address VAR15) public {\nrequire(VAR12 > VAR11);\nrequire(VAR13 > 0);\nrequire(VAR14 > VAR13);\nrequire(VAR15 != address(0));\nVAR4 = VAR11;\nVAR5 = VAR12;\nVAR9 = VAR13;\nVAR10 = VAR14;\nVAR6 = VAR15;\n}\nfunction () external payable {\nFUN8(msg.sender);\n}\nfunction FUN8(address VAR16) public FUN3 payable {\nrequire(VAR16 != address(0));\nrequire(validPurchase());\nuint256 VAR17 = msg.value;\nVAR8 = VAR8.add(VAR17);\nVAR7[VAR16] = VAR7[VAR16].add(VAR17);\nFUN9();\n}\nfunction FUN9() internal {\nVAR6.transfer(msg.value);\n}\n}",
        "label": false,
        "name": "0x2e7a03f0b5a406a5d052511dd0710f4b440db733.sol"
    },
    {
        "source": "contract CON1{\nstring VAR1 = \"Persona 1\";\nstring VAR2 = \"Persona 2\";\nuint VAR3 = now;\nfunction FUN1(string VAR4, string VAR5){\nVAR3 = now;\nVAR1 = VAR4;\nVAR2 = VAR5;\n}\nfunction FUN2() constant returns(string, string, uint){\nreturn (VAR1, VAR2, VAR3) ;\n}\n}",
        "label": false,
        "name": "0xd2fb71fbd065157b70268eb13a6d7f8f11e10857.sol"
    },
    {
        "source": "{\"EIP20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\npragma solidity ^0.5.9;\\n\\n\\ncontract EIP20Interface {\\n    \\n    /// total amount of tokens\\n    uint256 public totalSupply;\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return The balance\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of tokens to be approved for transfer\\n    /// @return Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n\\n    // solhint-disable-next-line no-simple-event-func-name\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\"},\"Pulse.sol\":{\"content\":\"\\n\\n\\npragma solidity ^0.5.9;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\\n\\ncontract Pulse is EIP20Interface {\\n\\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\\n    mapping (address =\\u003e uint256) public balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\n    \\n    string public name;                   //fancy name: eg Simon Bucks\\n    uint8 public decimals;                //How many decimals to show.\\n    string public symbol;                 //An identifier: eg SBX\\n\\n    constructor (\\n        uint256 _initialAmount,\\n        //string _tokenName,\\n        uint8 _decimalUnits\\n        //string _tokenSymbol\\n    ) public {\\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\\n        totalSupply = _initialAmount;                        // Update total supply\\n        name = \\\"Pulse\\\";                                 // Set the name for display purposes\\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\\n        symbol = \\\"PUL\\\";                               // Set the symbol for display purposes\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\n        require(balances[msg.sender] \\u003e= _value);\\n        balances[msg.sender] -= _value;\\n        balances[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        uint256 allowance = allowed[_from][msg.sender];\\n        require(balances[_from] \\u003e= _value \\u0026\\u0026 allowance \\u003e= _value);\\n        balances[_to] += _value;\\n        balances[_from] -= _value;\\n        if (allowance \\u003c MAX_UINT256) {\\n            allowed[_from][msg.sender] -= _value;\\n        }\\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n}\"}}",
        "label": false,
        "name": "0xbbf0ae14af89b4f602ce47f157c8ed622b0bb7c1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x37d7c7d3da65c029fe48ed4e4bb75c54e9420509.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new owner is the zero address\");\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN5(address VAR3, uint256 VAR4) public FUN1 {\nCON1(VAR3).transfer(owner(), VAR4);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR5;\nconstructor() internal {\nFUN9(msg.sender);\n}\nmodifier FUN6() {\nrequire(isOperator(msg.sender));\n_;\n}\nfunction FUN7(address VAR6) public FUN6 {\nFUN9(VAR6);\n}\nfunction FUN8() public {\nFUN10(msg.sender);\n}\nfunction FUN9(address VAR6) internal {\nVAR5.add(VAR6);\n}\nfunction FUN10(address VAR6) internal {\nVAR5.remove(VAR6);\n}\n}\ncontract CON5 is CON4, CON3 {\nusing SafeMath for uint256;\nstruct Contributor {\nuint256 VAR7;\nuint256 VAR4;\nbool VAR8;\n}\nuint256 private VAR9;\nuint256 private VAR10;\naddress[] private VAR11;\nmapping(address => Contributor) private VAR12;\nconstructor() public {}\nfunction FUN11(address VAR6, uint256 VAR7, uint256 VAR4) public FUN6 {\nif (!VAR12[VAR6].VAR8) {\nVAR11.push(VAR6);\nVAR12[VAR6].VAR8 = true;\n}\nVAR12[VAR6].VAR7 = VAR12[VAR6].VAR7.add(VAR7);\nVAR12[VAR6].VAR4 = VAR12[VAR6].VAR4.add(VAR4);\nVAR10 = VAR10.add(VAR7);\nVAR9 = VAR9.add(VAR4);\n}\nfunction FUN12(address VAR6) public FUN1 {\nFUN10(VAR6);\n}\n}",
        "label": false,
        "name": "0xa2b5ceb15354343c6f7a1569ac250cdd9b0634ba.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nmapping(address => mapping(address => uint)) private VAR2;\nmapping(address => mapping(address => uint)) private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5, uint VAR6) public {\nassert(VAR4 != address(0));\nassert(VAR5 != uint256(0));\nassert(VAR6 != uint(0));\nassert(VAR2[msg.sender][VAR4] == 0);\nVAR2[msg.sender][VAR4] = VAR5;\nVAR3[msg.sender][VAR4] = VAR6;\nCON2 VAR7 = CON2(VAR4);\nassert(VAR7.transferFrom(msg.sender, this, VAR5) == true);\n}\nfunction FUN2(address VAR4) public {\nassert(VAR4 != address(0));\nassert(VAR2[msg.sender][VAR4] > 0);\nassert(now >= VAR3[msg.sender][VAR4]);\nCON2 VAR7 = CON2(VAR4);\nuint256 VAR5 = VAR2[msg.sender][VAR4];\ndelete VAR2[msg.sender][VAR4];\ndelete VAR3[msg.sender][VAR4];\nassert(VAR7.transfer(msg.sender, VAR5) == true);\n}\n}",
        "label": false,
        "name": "0xe5b340f7e4b11eae96d7047e8bc9322f96093402.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON2 {\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5, CON1 {\nbool public VAR13 = false;\nmodifier FUN8() {\nrequire(!VAR13);\n_;\n}\nfunction FUN9(address VAR5, uint256 VAR14) FUN1 FUN8 public returns (bool) {\nVAR3 = VAR3.add(VAR14);\nVAR4[VAR5] = VAR4[VAR5].add(VAR14);\nreturn true;\n}\nfunction FUN10() FUN1 FUN8 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON1 {\nbool public VAR15 = false;\nmodifier FUN11() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN12() {\nrequire(VAR15);\n_;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR15 = true;\n}\nfunction FUN14() FUN1 FUN12 public {\nVAR15 = false;\n}\n}\ncontract CON8 is CON5, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN11 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN11 returns (bool VAR16) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR11) public FUN11 returns (bool VAR16) {\nreturn super.FUN7(VAR9, VAR11);\n}\n}\ncontract CON9 is CON8, CON6 {\nstring public constant VAR17 = \"TOKEN\";\nstring public constant VAR18 = \"TON\";\nuint8 public constant VAR19 = 18;\nfunction CON9(address VAR20) public {\nFUN13();\nVAR1 = VAR20;\n}\n}",
        "label": false,
        "name": "0x2a2a21b9ab81dc5b29b4e1256fa2c00105bc073d.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nstring public constant VAR1 = 'CON2';\nuint256 public constant VAR2 = 6;\nstring public constant VAR3 = 'TRST';\nstring public constant VAR4 = 'TRST1.0';\nuint256 private constant VAR5 = 100000000 * (10 ** VAR2);\nmapping (address => uint256) public VAR6; mapping (address => mapping (address => uint256)) public VAR7;\nstring public VAR8 = \"\";\naddress public VAR9;\nmodifier FUN1 {\nif (msg.sender != VAR9) {\nthrow;\n}\n_;\n}\nfunction CON2(address VAR10) {\nif (VAR10 == 0) throw;\nVAR9 = VAR10;\nVAR6[msg.sender] = VAR5;\n}\nfunction FUN2() constant returns (uint256) {\nreturn VAR5;\n}\nfunction FUN3(address VAR11, uint256 VAR12) public returns (bool) {\nif (VAR6[msg.sender] >= VAR12) {\nVAR6[msg.sender] -= VAR12;\nVAR6[VAR11] += VAR12;\nreturn true;\n}\nreturn false;\n}\nfunction FUN4(address VAR13, address VAR11, uint256 VAR12) public returns (bool) {\nif (VAR6[VAR13] >= VAR12 && VAR7[VAR13][msg.sender] >= VAR12) {\nVAR6[VAR13] -= VAR12;\nVAR7[VAR13][msg.sender] -= VAR12;\nVAR6[VAR11] += VAR12;\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR14) constant public returns (uint256) {\nreturn VAR6[VAR14];\n}\nfunction FUN6(address VAR15, uint256 VAR12) public returns (bool) {\nVAR7[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR16, uint256 VAR17) public returns(bool) {\nif (VAR7[msg.sender][VAR15] != VAR16) {\nreturn false;\n}\nreturn FUN6(VAR15, VAR17);\n}\nfunction FUN8(address VAR14, address VAR15) constant public returns (uint256 VAR18) {\nreturn VAR7[VAR14][VAR15];\n}\nfunction FUN9(string VAR19) FUN1 public {\nVAR8 = VAR19;\n}\nfunction FUN10(address VAR20) FUN1 public {\nVAR9 = VAR20;\n}\n}",
        "label": false,
        "name": "0xcb94be6f13a1182e4a4b6140cb7bf2025d28e41b.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nif (msg.sender != VAR1) throw;\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON1, CON2 {\nstring public constant VAR3 = 'ERC20';\nstring public constant VAR4 = 'Zeus Shield Coin';\nstring public constant VAR5 = 'ZSC';\nuint8 public constant VAR6 = 18;\nuint public VAR7 = 0;\nbool public VAR8 = false;\nuint256 public VAR9 = 0;\naddress public VAR10 = 0;\nuint256 VAR11 = 0;\nmapping (address => uint256) VAR12;\nmapping(address => mapping (address => uint256)) VAR13;\nmapping (address => bool) public VAR14;\nmapping (address => uint[3]) public VAR15;\nuint[3] public VAR16;\nfunction CON4()\n{\n}\nfunction ()\n{\nthrow; }\nfunction FUN4()\nconstant\nreturns (uint256)\n{\nreturn VAR11;\n}\nfunction FUN5(address VAR17)\nconstant\nreturns (uint256)\n{\nreturn VAR12[VAR17];\n}\nfunction FUN6(address VAR18, uint256 VAR19)\nreturns (bool VAR20)\n{\nif (!VAR8) return false;\nif (VAR19 <= 0) return false;\nif (FUN15(msg.sender, VAR19)) return false;\nif (VAR12[msg.sender] >= VAR19&& VAR12[VAR18] + VAR19 > VAR12[VAR18]) {\nVAR12[msg.sender] -= VAR19;\nVAR12[VAR18] += VAR19;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN7(address VAR21, address VAR18, uint256 VAR19)\nreturns (bool VAR20)\n{\nif (!VAR8) return false;\nif (VAR19 <= 0) return false;\nif (FUN15(VAR21, VAR19)) return false;\nif (VAR12[VAR21] >= VAR19&& VAR13[VAR21][msg.sender] >= VAR19&& VAR12[VAR18] + VAR19 > VAR12[VAR18]) {\nVAR12[VAR21] -= VAR19;\nVAR13[VAR21][msg.sender] -= VAR19;\nVAR12[VAR18] += VAR19;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction FUN8(address VAR22, uint256 VAR19)\nreturns (bool VAR20)\n{\nVAR13[msg.sender][VAR22] = VAR19;\nreturn true;\n}\nfunction FUN9(address VAR17, address VAR22)\nconstant\nreturns (uint256 VAR23)\n{\nreturn VAR13[VAR17][VAR22];\n}\nfunction FUN10(address VAR24)\npublic\nFUN1\n{\nif (!VAR8) throw;\nif (VAR10 != 0) throw;\nVAR10 = VAR24;\n}\nfunction FUN11(uint256 VAR25)\npublic\n{\nif (!VAR8) throw;\nif (VAR10 == 0) throw;\nif (VAR25 == 0) throw;\nif (VAR25 > VAR12[msg.sender]) throw;\nVAR12[msg.sender] -= VAR25;\nVAR11 -= VAR25;\nVAR9 += VAR25;\nCON3(VAR10).migrateFrom(msg.sender, VAR25);\n}\nfunction FUN12(address VAR26, address VAR27)\npublic\nFUN1\n{\nif (!VAR8) {\nVAR11 = 6100 * 1000 * 1000 * 10**18;\nVAR12[VAR26] = 3111 * 1000 * 1000 * 10**18;\nVAR12[VAR27] = 2074 * 1000 * 1000 * 10**18;\nFUN14();\nVAR8 = true;\nVAR7 = now;\nVAR16[0] = VAR7 + 6 * 30 days;\nVAR16[1] = VAR7 + 12 * 30 days;\nVAR16[2] = VAR7 + 24 * 30 days;\n}\n}\nfunction FUN13(address VAR28, uint VAR29)\npublic\nFUN1\n{\nVAR14[VAR28] = true;\nVAR15[VAR28][0] = VAR29; VAR15[VAR28][1] = VAR29 * 80 / 100; VAR15[VAR28][2] = VAR29 * 50 / 100; }\nfunction FUN14()\ninternal\n{\nuint VAR30 = 91500 * 1000 * 10**18;\nVAR12[0xCDc5BDEFC6Fddc66E73250fCc2F08339e091dDA3] = VAR30; VAR12[0x8b47D27b085a661E6306Ac27A932a8c0b1C11b84] = VAR30; VAR12[0x825f4977DB4cd48aFa51f8c2c9807Ee89120daB7] = VAR30; VAR12[0xcDf5D7049e61b2F50642DF4cb5a005b1b4A5cfc2] = VAR30; VAR12[0xab0461FB41326a960d3a2Fe2328DD9A65916181d] = VAR30; VAR12[0xd2A131F16e4339B2523ca90431322f559ABC4C3d] = VAR30; VAR12[0xCcB4d663E6b05AAda0e373e382628B9214932Fff] = VAR30; VAR12[0x60284720542Ff343afCA6a6DBc542901942260f2] = VAR30; VAR12[0xcb6d0e199081A489f45c73D1D22F6de58596a99C] = VAR30; VAR12[0x928D99333C57D31DB917B4c67D4d8a033F2143A7] = VAR30;\nFUN13(\"0xCDc5BDEFC6Fddc66E73250fCc2F08339e091dDA3\", VAR30);\nFUN13(\"0x8b47D27b085a661E6306Ac27A932a8c0b1C11b84\", VAR30);\nFUN13(\"0x825f4977DB4cd48aFa51f8c2c9807Ee89120daB7\", VAR30);\nFUN13(\"0xcDf5D7049e61b2F50642DF4cb5a005b1b4A5cfc2\", VAR30);\nFUN13(\"0xab0461FB41326a960d3a2Fe2328DD9A65916181d\", VAR30);\nFUN13(\"0xd2A131F16e4339B2523ca90431322f559ABC4C3d\", VAR30);\nFUN13(\"0xCcB4d663E6b05AAda0e373e382628B9214932Fff\", VAR30);\nFUN13(\"0x60284720542Ff343afCA6a6DBc542901942260f2\", VAR30);\nFUN13(\"0xcb6d0e199081A489f45c73D1D22F6de58596a99C\", VAR30);\nFUN13(\"0x928D99333C57D31DB917B4c67D4d8a033F2143A7\", VAR30);\n}\nfunction FUN15(address VAR21, uint256 VAR25)\ninternal\nreturns (bool VAR20)\n{\nif (VAR14[VAR21]) {\nif (now < VAR16[0]) {\nif (VAR12[VAR21] - VAR25 < VAR15[VAR21][0])\nreturn true;\n} else if (now >= VAR16[0] && now < VAR16[1]) {\nif (VAR12[VAR21] - VAR25 < VAR15[VAR21][1])\nreturn true;\n} else if (now >= VAR16[1] && now < VAR16[2]) {\nif (VAR12[VAR21]- VAR25 < VAR15[VAR21][2])\nreturn true;\n} else {\nVAR14[VAR21] = false;\n}\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0x7a41e0517a5eca4fdbc7fbeba4d4c47b9ff6dc63.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint;\nmapping(address => uint) public VAR1;\nmapping(address => uint) public VAR2;\nmapping(address => uint) public VAR3;\nmapping(address => uint) public VAR4;\nuint public VAR5 = 1 hours;\nuint public VAR6 = 0;\naddress public VAR7 = 0x7DF0AB219B7e1488F521e9EEE0DDAcf608C90AB9;\nuint VAR8 = 10;\nmodifier FUN1() {\nrequire(VAR1[msg.sender] > 0, \"Address not found\");\n_;\n}\nmodifier FUN2() {\nrequire(now >= VAR2[msg.sender].add(VAR5), \"Too fast VAR9 request\");\n_;\n}\nfunction FUN3() FUN1 FUN2 internal {\nif ((VAR1[msg.sender].mul(2)) <= VAR4[msg.sender]) {\nVAR1[msg.sender] = 0;\nVAR2[msg.sender] = 0;\nVAR3[msg.sender] = 0;\n} else {\nuint VAR9 = payoutAmount();\nVAR3[msg.sender] = VAR3[msg.sender].add(VAR9);\nVAR4[msg.sender] = VAR4[msg.sender].add(VAR9);\nmsg.sender.transfer(VAR9);\n}\n}\nfunction FUN4() private {\nif (msg.value > 0) {\nif (VAR1[msg.sender] == 0) {\nVAR6 += 1;\n}\nif (VAR1[msg.sender] > 0 && now > VAR2[msg.sender].add(VAR5)) {\nFUN3();\nVAR3[msg.sender] = 0;\n}\nVAR1[msg.sender] = VAR1[msg.sender].add(msg.value);\nVAR2[msg.sender] = now;\nVAR7.transfer(msg.value.mul(VAR8).div(100));\n} else {\nFUN3();\n}\n}\nfunction() external payable {\nFUN4();\n}\n}",
        "label": false,
        "name": "0xee6854929ce78fb7c5453e63ee2ff76f780677a9.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3{\nusing SafeMath for uint;\nenum JobStatus { Open, inProgress, Completed, Cancelled }\nstruct Job{\nstring VAR1; address VAR2; uint VAR3; address VAR4; JobStatus VAR5; uint VAR6; uint VAR7; uint VAR8; uint VAR9; address VAR10; bool VAR11; uint VAR12; mapping(address => uint) VAR13; address[] VAR14; uint VAR15; }\nJob[] public VAR16;\nmapping(address => uint[]) public VAR17; mapping(address => uint[]) public VAR18;\nCON2 public VAR19;\nuint public VAR20 = 0;\naddress public VAR21;\nconstructor(address VAR22, address VAR23) public{\nVAR19 = CON2(VAR22);\nVAR21 = VAR23;\n}\nmodifier FUN1{\nrequire(msg.sender == VAR21);\n_;\n}\nfunction FUN2(string VAR24, uint VAR25, uint VAR26) public {\nrequire(VAR25 > 0);\nrequire(VAR26 > 0);\naddress[] memory VAR27;\nuint VAR28 = VAR25.sub(VAR25.mul(1).div(50));\nJob memory VAR29 = Job(VAR24, msg.sender, VAR28, 0x0, JobStatus.Open, VAR26, 0, 0, 0, 0x0, false, 0, VAR27, 0);\nVAR16.push(VAR29);\nVAR17[msg.sender].push(VAR20);\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR25);\nVAR20++;\nVAR19.transferFrom(msg.sender, address(this), VAR25);\n}\nfunction FUN3(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(msg.sender != VAR31.VAR2);\nrequire(msg.sender != VAR31.VAR10);\nrequire(VAR31.VAR5 == JobStatus.Open);\nVAR31.VAR4 = msg.sender;\nVAR31.VAR5 = JobStatus.inProgress;\nVAR18[msg.sender].push(VAR30);\n}\nfunction FUN4(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(msg.sender != VAR31.VAR2);\nrequire(msg.sender != VAR31.VAR4);\nVAR31.VAR10 = msg.sender;\n}\nfunction FUN5(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nif(msg.sender != VAR21){\nrequire(VAR31.VAR2 == msg.sender);\nrequire(VAR31.VAR4 == 0x0);\nrequire(VAR31.VAR5 == JobStatus.Open);\n}\nVAR31.VAR5 = JobStatus.Cancelled;\nuint VAR32 = VAR31.VAR3;\nVAR19.transfer(VAR31.VAR2, VAR32);\n}\nfunction FUN6(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(VAR31.VAR4 == msg.sender);\nuint VAR33 = VAR31.VAR8;\nrequire(VAR33 > 0);\nVAR31.VAR8 = 0;\nVAR19.transfer(msg.sender, VAR33);\n}\nfunction FUN7(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nif(msg.sender != VAR21){\nrequire(VAR31.VAR2 == msg.sender);\nrequire(VAR31.VAR11 == true);\n}\nrequire(VAR31.VAR6 > VAR31.VAR7);\nuint VAR34 = VAR31.VAR3.div(VAR31.VAR6);\nVAR31.VAR8 = VAR31.VAR8 + VAR34;\nVAR31.VAR9 = VAR31.VAR9 + VAR34;\nVAR31.VAR7++;\nif(VAR31.VAR6 == VAR31.VAR7){\nVAR31.VAR5 = JobStatus.Completed;\n}\n}\nfunction FUN8(uint VAR30, uint VAR35) public {\nrequire(VAR30 >= 0);\nrequire(VAR35 > 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(msg.sender == VAR31.VAR2);\naddress VAR10 = VAR31.VAR10;\nrequire(VAR19.allowance(VAR31.VAR2, address(this)) >= VAR35);\nVAR19.transferFrom(VAR31.VAR2, VAR10, VAR35);\n}\nfunction FUN9(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(msg.sender == VAR31.VAR10);\nVAR31.VAR11 = true;\n}\nfunction FUN10(uint VAR30) public {\nrequire(VAR30 >= 0);\nJob storage VAR31 = VAR16[VAR30];\nrequire(msg.sender == VAR31.VAR4);\nVAR31.VAR11 = false;\n}\nfunction FUN11(address VAR36, uint VAR37) public {\nrequire(VAR36 != 0x0);\nrequire(VAR37 > 0);\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR37);\nVAR19.transferFrom(msg.sender, VAR36, VAR37);\n}\nfunction FUN12(uint VAR30, uint VAR37) public {\nrequire(VAR30 >= 0);\nrequire(VAR37 > 0);\nJob storage VAR31 = VAR16[VAR30];\nif(VAR31.VAR13[msg.sender] == 0){\nVAR31.VAR14.push(msg.sender);\n}\nVAR31.VAR13[msg.sender] = VAR31.VAR13[msg.sender] + VAR37;\nVAR31.VAR12 = VAR31.VAR12 + VAR37;\nrequire(VAR19.allowance(msg.sender, address(this)) >= VAR37);\nVAR19.transferFrom(msg.sender, address(this), VAR37);\n}\nfunction FUN13(address VAR38, uint VAR37) public FUN1 {\nrequire(VAR38 != 0x0);\nrequire(VAR37 > 0);\nrequire(VAR19.balanceOf(address(this)) >= VAR37);\nVAR19.transfer(VAR38, VAR37);\n}\n}",
        "label": false,
        "name": "0xfa1909f6fe2120e3aa4a63883776250ba5042b60.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN6(address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN7(address VAR8, uint256 VAR7) public returns (bool) {\nFUN14(msg.sender, VAR8, VAR7);\nreturn true;\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nFUN11(VAR9, VAR6, VAR7);\nFUN14(VAR9, msg.sender, VAR4[VAR9][msg.sender].sub(VAR7));\nreturn true;\n}\nfunction FUN9(address VAR8, uint256 VAR10) public returns (bool) {\nFUN14(msg.sender, VAR8, VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN10(address VAR8, uint256 VAR11) public returns (bool) {\nFUN14(msg.sender, VAR8, VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN11(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR6 != address(0), \"ERC20: FUN6 VAR6 the zero address\");\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0), \"ERC20: FUN16 VAR6 the zero address\");\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR2] = VAR3[VAR2].add(VAR7);\n}\nfunction FUN13(address VAR2, uint256 VAR7) internal {\nrequire(VAR2 != address(0), \"ERC20: FUN26 VAR9 the zero address\");\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR2] = VAR3[VAR2].sub(VAR7);\n}\nfunction FUN14(address VAR12, address VAR8, uint256 VAR7) internal {\nrequire(VAR12 != address(0), \"ERC20: FUN7 VAR9 the zero address\");\nrequire(VAR8 != address(0), \"ERC20: FUN7 VAR6 the zero address\");\nVAR4[VAR12][VAR8] = VAR7;\n}\nfunction FUN15(address VAR2, uint256 VAR7) internal {\nFUN13(VAR2, VAR7);\nFUN14(VAR2, msg.sender, VAR4[VAR2][msg.sender].sub(VAR7));\n}\n}\ncontract CON4 is CON3, CON2 {\nfunction FUN16(address VAR6, uint256 VAR7) public FUN1 returns (bool) {\nFUN12(VAR6, VAR7);\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nuint256 private VAR13;\nconstructor (uint256 VAR14) public {\nrequire(VAR14 > 0, \"ERC20Capped: VAR14 is 0\");\nVAR13 = VAR14;\n}\nfunction FUN12(address VAR2, uint256 VAR7) internal {\nrequire(totalSupply().add(VAR7) <= VAR13, \"ERC20Capped: VAR14 exceeded\");\nsuper.FUN12(VAR2, VAR7);\n}\n}\ncontract CON6 {\nusing Roles for Roles.Role;\nRoles.Role private VAR15;\nconstructor () internal {\nFUN20(msg.sender);\n}\nmodifier FUN17() {\nrequire(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n_;\n}\nfunction FUN18(address VAR2) public FUN17 {\nFUN20(VAR2);\n}\nfunction FUN19() public {\nFUN21(msg.sender);\n}\nfunction FUN20(address VAR2) internal {\nVAR15.add(VAR2);\n}\nfunction FUN21(address VAR2) internal {\nVAR15.remove(VAR2);\n}\n}\ncontract CON7 is CON6 {\nbool private VAR16;\nconstructor () internal {\nVAR16 = false;\n}\nmodifier FUN22() {\nrequire(!VAR16, \"Pausable: paused\");\n_;\n}\nmodifier FUN23() {\nrequire(VAR16, \"Pausable: not paused\");\n_;\n}\nfunction FUN24() public FUN17 FUN22 {\nVAR16 = true;\n}\nfunction FUN25() public FUN17 FUN23 {\nVAR16 = false;\n}\n}\ncontract CON8 is CON3, CON7 {\nfunction FUN6(address VAR6, uint256 VAR7) public FUN22 returns (bool) {\nreturn super.FUN6(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public FUN22 returns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN7(address VAR8, uint256 VAR7) public FUN22 returns (bool) {\nreturn super.FUN7(VAR8, VAR7);\n}\nfunction FUN9(address VAR8, uint VAR10) public FUN22 returns (bool) {\nreturn super.FUN9(VAR8, VAR10);\n}\nfunction FUN10(address VAR8, uint VAR11) public FUN22 returns (bool) {\nreturn super.FUN10(VAR8, VAR11);\n}\n}\ncontract CON9 is CON3 {\nfunction FUN26(uint256 VAR7) public {\nFUN13(msg.sender, VAR7);\n}\nfunction FUN27(address VAR9, uint256 VAR7) public {\nFUN15(VAR9, VAR7);\n}\n}\ncontract CON10 is CON1 {\nstring private VAR17;\nstring private VAR18;\nuint8 private VAR19;\nconstructor (string memory VAR20, string memory VAR21, uint8 VAR22) public {\nVAR17 = VAR20;\nVAR18 = VAR21;\nVAR19 = VAR22;\n}\n}\ncontract CON11 is CON8, CON9, CON5, CON10 {\nconstructor(uint256 VAR14, address VAR23, uint256 VAR24) public CON5(VAR14) CON10(\"MikeTangoBravo19\", \"MTB19\", 18) {\nFUN16(VAR23, VAR24);\n}\n}",
        "label": false,
        "name": "0x87ab739464881af0011052d4ca0b0d657e8c3b48.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nconstructor () public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1) {\nrevert();\n}\n_;\n}\nmodifier FUN2 {\nassert(0x0 != msg.sender);\n_;\n}\nfunction FUN3(address VAR2) FUN1 FUN2 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON3 is CON2 {\nbool public VAR3 = false;\nmodifier FUN4() {\nassert(!VAR3);\n_;\n}\nmodifier FUN5() {\nassert(VAR3);\n_;\n}\nfunction FUN6() FUN1 FUN4 public returns (bool) {\nVAR3 = true;\nreturn true;\n}\nfunction FUN7() FUN1 FUN5 public returns (bool) {\nVAR3 = false;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction FUN8(address VAR10, uint256 VAR11) FUN4 public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN9(address VAR13, address VAR10, uint256 VAR11) FUN4 public returns (bool VAR12) {\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nVAR8[VAR13] = VAR8[VAR13].sub(VAR11);\nVAR9[VAR13][msg.sender] = VAR9[VAR13][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN10(address VAR14, uint256 VAR11) public returns (bool VAR12) {\nrequire(address(0) != VAR14);\nVAR9[msg.sender][VAR14] = VAR11;\nreturn true;\n}\n}\ncontract CON5 is CON4 {\nconstructor (uint256 VAR15, string VAR16, string VAR17, uint8 VAR18) public {\nVAR7 = VAR15 * 10 ** uint256(VAR18);\nVAR4 = VAR16;\nVAR5 = VAR17;\nVAR6 = VAR18;\nVAR8[msg.sender] = VAR7;\n}\n}",
        "label": false,
        "name": "0x87d6aa53b430d170a77726ba468fb1b26f8c917c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbool public VAR1;\nconstructor() public {\nVAR1 = CON1(0x2BD2326c993DFaeF84f696526064FF22eba5b362).forked();\n}\nfunction FUN1(address VAR2, address VAR3) public payable {\nif (VAR1) {\nVAR2.transfer(msg.value);\nreturn;\n}\nVAR3.transfer(msg.value);\nreturn;\n}\n}",
        "label": false,
        "name": "0x352e504813b9e0b30f9ca70efc27a52d298f6697.sol"
    },
    {
        "source": "contract CON1 {\nmapping (uint256 => bytes) public VAR1;\nstring public constant VAR2 = \"abcdEfg\";\nstring public constant VAR3 = \"a2g\";\nuint8 public constant VAR4 = 0;\nstring public constant VAR5 = \"Fit in the words here!Fit in the words here!Fit in the words here!Fit in the words here!\";\nmapping (address => uint256) private VAR6;\nmapping (address => uint256) private VAR7;\nuint256 private VAR8 = 1000;\nuint256 private VAR9 = 0;\nconstructor() public {\nVAR6[msg.sender] = VAR8;\n}\nfunction () public {\nFUN2();\n}\nfunction FUN2() internal {\nVAR9 ++;\nVAR7[msg.sender] ++;\nVAR1[VAR9] = abi.encodePacked(msg.sender, msg.data);\n}\nfunction FUN3(address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR11 + VAR7[msg.sender] <= VAR6[msg.sender]);\nrequire(VAR10 != address(0));\nVAR6[msg.sender] = VAR6[msg.sender] - VAR11;\nVAR6[VAR10] = VAR6[VAR10] + VAR11;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x129bc997c3448515d36c83382eaae2454b0884b6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.BRL.BrazilianReal\";\nstring public constant VAR2 = \"BANCO CENTRAL DO BRASIL\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x3a04ec1fa433f66230db1a8448e7d9b88988854c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor () internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON3 {\nbool private VAR12;\nconstructor () internal {\nVAR12 = false;\n}\nmodifier FUN15() {\nrequire(!VAR12);\n_;\n}\nmodifier FUN16() {\nrequire(VAR12);\n_;\n}\nfunction FUN17() public FUN10 FUN15 {\nVAR12 = true;\n}\nfunction FUN18() public FUN10 FUN16 {\nVAR12 = false;\n}\n}\ncontract CON5 is CON2, CON4 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN15 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN15 returns (bool VAR13) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN15 returns (bool VAR13) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON6 is CON1 {\nstring private VAR14;\nstring private VAR15;\nuint8 private VAR16;\nconstructor (string memory VAR17, string memory VAR18, uint8 VAR19) public {\nVAR14 = VAR17;\nVAR15 = VAR18;\nVAR16 = VAR19;\n}\n}\ncontract CON7 is CON2, CON6, CON5 {\nconstructor(string memory VAR17,string memory VAR18,uint8 VAR19,uint256 VAR20)\nCON6(VAR17, VAR18, VAR19)\nCON5()\nCON2()\npublic\n{\nrequire(VAR20 > 0, \"totalSupply has VAR4 be greater than 0\");\nFUN7(msg.sender, VAR20.mul(10 ** uint256(VAR19)));\n}\n}",
        "label": false,
        "name": "0x420167d87d35c3a249b32ef6225872fbd9ab85d2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nstruct EscrowElement {\nbool VAR3;\naddress VAR4;\naddress VAR5;\nuint256 VAR6;\n}\naddress public VAR7;\nCON2 public VAR8;\nmapping (bytes20 => EscrowElement) public VAR9;\nuint256 public VAR10;\nuint256 public VAR11;\nfunction CON4(address VAR12){\nVAR7 = VAR12;\nVAR8 = CON2(VAR12);\nVAR10 = 1;\nVAR11 = 25;\n}\nfunction FUN5(bytes20 VAR13, address VAR14, uint256 VAR6) public returns (bool) {\nrequire(VAR14 != address(0));\nrequire(VAR9[VAR13].VAR3 != true);\nVAR8.transferFrom(msg.sender, address(this), VAR6);\nEscrowElement memory VAR15 = EscrowElement(true, msg.sender, VAR14, VAR6);\nVAR9[VAR13] = VAR15;\nreturn true;\n}\nfunction FUN6(bytes20 VAR13, address VAR16) FUN1 returns (bool) {\nrequire(VAR16 != address(0));\nrequire(VAR9[VAR13].VAR3 == true);\nEscrowElement storage VAR15 = VAR9[VAR13];\nuint256 VAR17 = VAR15.VAR6.mul(VAR10).div(VAR11);\nuint256 VAR6 = VAR15.VAR6.sub(VAR17);\nVAR8.transfer(VAR15.VAR5, VAR6);\nVAR8.transfer(VAR16, VAR17);\nEscrowElement memory VAR18 = VAR15;\ndelete VAR9[VAR13];\nreturn true;\n}\nfunction FUN7(bytes20 VAR13) FUN1 returns (bool) {\nEscrowElement storage VAR15 = VAR9[VAR13];\nVAR8.transfer(VAR15.VAR4, VAR15.VAR6);\nEscrowElement memory VAR18 = VAR15;\ndelete VAR9[VAR13];\nreturn true;\n}\nfunction FUN8(address VAR5, uint256 VAR6) FUN1 returns (bool){\nrequire(VAR5 != address(0));\nrequire(VAR6 > 0);\nVAR8.transfer(VAR5, VAR6);\nreturn true;\n}\nfunction FUN9(address VAR12) FUN1 returns (bool){\nrequire(VAR12 != address(0));\nVAR7 = VAR12;\nVAR8 = CON2(VAR12);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xf3b5589684aa48ee7f559c58bc66ac74b95ca319.sol"
    },
    {
        "source": "contract CON1 {\nfunction FUN1() public {\nHive2.FUN1();\n}\nfunction FUN2() public {\nselfdestruct(msg.sender);\n}\n}",
        "label": false,
        "name": "0xb03e9255f4aff415f458a399eb22d965ee5fd729.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0) && VAR2 != VAR1);\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress VAR3;\n}\ncontract CON3 {\n}\ncontract CON4 {\n}\ncontract CON5 {\n}\ncontract CON6 is CON5, CON4, CON2 {\nuint256 public VAR4;\nusing SafeMath for uint256;\nmapping(address => uint256) VAR5;\nfunction FUN3(address VAR6, uint256 VAR7, bytes VAR8) internal returns (bool) {\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR7, bytes VAR8) internal returns (bool) {\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nCON3 VAR9 = CON3(VAR6);\nVAR9.tokenFallback(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR7, bytes VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[msg.sender]);\nrequire(VAR7 > 0);\nuint256 VAR10;\nassembly {\nVAR10 := extcodesize(VAR6)\n}\nif(VAR10 > 0) {\nreturn FUN4(VAR6, VAR7, VAR8);\n} else {\nreturn FUN3(VAR6, VAR7, VAR8);\n}\n}\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR5[msg.sender]);\nrequire(VAR7 > 0);\nuint256 VAR10;\nbytes memory VAR11;\nassembly {\nVAR10 := extcodesize(VAR6)\n}\nif(VAR10 > 0) {\nreturn FUN4(VAR6, VAR7, VAR11);\n} else {\nreturn FUN3(VAR6, VAR7, VAR11);\n}\n}\nfunction FUN6(address VAR12) public constant returns (uint256 VAR13) {\nreturn VAR5[VAR12];\n}\n}\ncontract CON7 is CON6 {\nmapping (address => mapping (address => uint256)) internal VAR14;\n}\ncontract CON8 is CON7 {\nstring public constant VAR15 = \"AIRSTAYZ\";\nuint public constant VAR16 = 18;\nstring public constant VAR17 = \"STAY\";\nfunction CON8() public {\nVAR4=155000000 *(10**VAR16);\nVAR1 = msg.sender;\nVAR3 = 0xb5AB0c087b9228D584CD4363E3d000187FE69C51;\nVAR5[msg.sender] = 150350000 * (10**VAR16);\nVAR5[VAR3] = 4650000 * (10**VAR16);\n}\nfunction() public {\nrevert();\n}\n}",
        "label": false,
        "name": "0x86a80daf8d1a85c09f02c80c0f3e85ee41bbca0c.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nCON1 public VAR1 = CON1(0xdd974D5C2e2928deA5F71b9825b8b646686BD200);\nuint public VAR2;\nmapping (address=>uint) VAR3;\nconstructor(CON1 VAR4) public {\nVAR1 = VAR4;\n}\nfunction FUN1(uint VAR5, string memory VAR6, uint64 VAR7) public {\nVAR6;\nrequire(VAR1.transferFrom(msg.sender, address(this), VAR5));\nVAR3[msg.sender] += VAR5;\n++VAR2;\n}\nfunction FUN2(uint VAR5) public {\nrequire(VAR3[msg.sender] >= VAR5);\nVAR3[msg.sender] -= VAR5;\nrequire(VAR1.transfer(msg.sender, VAR5));\n}\n}",
        "label": false,
        "name": "0x980358360409b1cc913a916bc0bf6f52f775242a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON4 is CON3 {\nfunction FUN4(uint256 VAR6) public {\nrequire(VAR6 <= VAR3[msg.sender]);\naddress VAR7 = msg.sender;\nVAR3[VAR7] = VAR3[VAR7].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON5 is CON2 {\n}\ncontract CON6 is CON5, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR9]);\nrequire(VAR6 <= VAR8[VAR9][msg.sender]);\nVAR3[VAR9] = VAR3[VAR9].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN6(address VAR10, uint256 VAR6) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR6;\nreturn true;\n}\nfunction FUN7(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN8(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON1 {\naddress public VAR14;\nbool VAR15;\nbool public VAR16 = false;\nfunction FUN9(address VAR17) external {\nrequire(VAR17 != address(0));\nrequire(VAR15 == false);\nVAR14 = VAR17;\nVAR15 = true;\n}\nmodifier FUN10() {\nif(msg.sender != VAR14) {\nrequire(!VAR16);\n}\n_;\n}\nmodifier FUN11() {\nrequire(VAR16);\n_;\n}\nfunction FUN12() FUN1 FUN10 public {\nVAR16 = true;\n}\nfunction FUN13() FUN1 FUN11 public {\nVAR16 = false;\n}\n}\ncontract CON8 is CON6, CON7 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\nfunction FUN6(address VAR10, uint256 VAR6) public FUN10 returns (bool) {\nreturn super.FUN6(VAR10, VAR6);\n}\nfunction FUN7(address VAR10, uint VAR11) public FUN10 returns (bool VAR18) {\nreturn super.FUN7(VAR10, VAR11);\n}\nfunction FUN8(address VAR10, uint VAR12) public FUN10 returns (bool VAR18) {\nreturn super.FUN8(VAR10, VAR12);\n}\n}\ncontract CON9 is CON6, CON1 {\nmapping (address => bool) public VAR19;\nfunction FUN14(address VAR20) public FUN1 {\nVAR19[VAR20] = true;\n}\nfunction FUN15(address VAR20) public FUN1 {\nVAR19[VAR20] = false;\n}\nmodifier FUN16(address VAR21) {\nrequire(!VAR19[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN16(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN16(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON10 is CON6, CON1 {\nmapping (address => uint) public VAR22;\nfunction FUN17(address VAR20, uint VAR23) public FUN1 {\nuint VAR24;\nVAR24 = now + (VAR23 * 1 days);\nVAR22[VAR20] = VAR24;\n}\nfunction FUN18(address VAR20) public FUN1 {\nVAR22[VAR20] = now;\n}\nmodifier FUN19(address VAR21) {\nrequire(now >= VAR22[VAR21]);\n_;\n}\nfunction FUN3(address VAR5, uint256 VAR6) public FUN19(msg.sender) returns (bool VAR18) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN5(address VAR9, address VAR5, uint256 VAR6) public FUN19(VAR9) returns (bool VAR18) {\nreturn super.FUN5(VAR9, VAR5, VAR6);\n}\n}\ncontract CON11 is CON10, CON9, CON8, CON4 {\nstring public constant VAR25 = \"SmartPayCoin\";\nstring public constant VAR26 = \"SPC\";\nuint public constant VAR27 = 18;\nuint public constant VAR28 = 200000000 * (10 ** VAR27);\nconstructor() public {\nVAR4 = VAR28;\nVAR3[msg.sender] = VAR4;\n}\n}",
        "label": false,
        "name": "0x8fc918368f312ba045495fe67e133a43c67b4bab.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON5 is CON2, CON4, CON1 {\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"AFR\";\nVAR5 = \"Afercoin\";\nVAR6 = 18;\nVAR7 = 1000000000000000000000000000;\nVAR8[0xC49119cc979d96aFD16246BACb197f6511Bee068] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = safeSub(VAR8[msg.sender], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = safeSub(VAR8[VAR14], VAR11);\nVAR9[VAR14][msg.sender] = safeSub(VAR9[VAR14][msg.sender], VAR11);\nVAR8[VAR10] = safeAdd(VAR8[VAR10], VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON3(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON2(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x780005ce3ab898bb402c124b4f71ff084d550111.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\naddress internal VAR22;\nconstructor(address VAR23,uint256 VAR24,uint256 VAR25,uint256 VAR26,bool VAR27,address VAR28)\npublic\n{\nrequire(VAR23 != address(0));\nrequire(VAR25 <= VAR26);\nVAR15 = VAR23;\nVAR19 = VAR27;\nVAR18 = VAR26;\nVAR16 = VAR24.add(VAR25);\nVAR17 = VAR24;\nVAR22 = VAR28;\n}\nfunction FUN8(CON1 VAR29) public {\nuint256 VAR30 = releasableAmount(VAR29);\nrequire(VAR30 > 0);\nVAR20[VAR29] = VAR20[VAR29].add(VAR30);\nVAR29.safeTransfer(VAR15, VAR30);\n}\nfunction FUN9(CON1 VAR29) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR29]);\nuint256 VAR31 = VAR29.balanceOf(this);\nuint256 VAR30 = releasableAmount(VAR29);\nuint256 VAR32 = VAR31.sub(VAR30);\nVAR21[VAR29] = true;\nVAR29.safeTransfer(VAR22, VAR32);\n}\n}\ncontract CON7 {\nusing SafeERC20 for CON3;\nCON3 public VAR29;\nconstructor(CON3 VAR33) public {\nVAR29 = VAR33;\n}\nfunction FUN10() public {\nuint256 VAR34 = VAR29.balanceOf(this);\nrequire(VAR34 > 0);\nVAR29.FUN3(VAR29, VAR34);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR4) public {\nrequire(VAR4 > 0);\nrequire(VAR4 <= VAR1[msg.sender]);\naddress VAR35 = msg.sender;\nVAR1[VAR35] = VAR1[VAR35].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON9 is CON8, CON5 {\nstring public constant VAR36 = \"COOP WORLD INVEST\";\nstring public constant VAR37 = \"CWI\";\nuint8 public constant VAR38 = 18;\nuint256 public constant VAR39 = 5500000000 * 10**uint256(VAR38);\naddress public VAR40;\nCON7 public VAR41;\nuint64 internal VAR42 = 86400;\nuint64 internal VAR43 = 90;\nuint64 internal VAR44 = 100;\nuint64 internal VAR45 = 365;\nmapping(address => address) public VAR46;\nconstructor(address VAR47) public payable {\nrequire(VAR47 != address(0));\nVAR40 = VAR47;\nuint256 VAR48 = 5500000000;\nFUN14(VAR48, VAR40);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN12() external FUN7 {\nrequire(VAR41 == address(0));\nuint256 VAR49 = 0;\nVAR41 = FUN13(VAR49);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN13(uint256 VAR50) internal FUN7 returns (CON7) {\nCON7 VAR51 = new CON7(CON3(this));\nFUN14(VAR50, VAR51);\nVAR51.FUN10();\nreturn VAR51;\n}\nfunction FUN14(uint256 VAR52, address VAR53) internal FUN7 {\nuint256 VAR50 = VAR52 * 10**uint256(VAR38);\nVAR2 = VAR2.add(VAR50);\nVAR1[VAR53] = VAR1[VAR53].add(VAR50);\nrequire(VAR2 <= VAR39);\n}\nfunction FUN15(address VAR23,uint256 VAR54,uint256 VAR55,uint256 VAR56,bool VAR27,uint256 VAR57) external FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54, VAR55, VAR56, VAR27, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN16(address VAR23,uint256 VAR57,uint256 VAR54,uint256 VAR60,uint256 VAR61,uint256 VAR62 ) public FUN7 {\nrequire(VAR23 != address(0));\nuint256 VAR58 = VAR57 * 10**uint256(VAR38);\nuint256 VAR63 = VAR60 * VAR42;\nuint256 VAR64 = VAR61 * VAR42;\nuint256 VAR65 = VAR62 * VAR42;\nif(VAR46[VAR23] == 0x0) {\nCON6 VAR59 = new CON6(VAR23, VAR54 + VAR63, VAR64, VAR65, true, VAR14);\nVAR46[VAR23] = address(VAR59);\n}\nrequire(this.FUN2(VAR41, VAR46[VAR23], VAR58));\n}\nfunction FUN17(address VAR23, uint256 VAR57, uint256 VAR60, uint256 VAR61, uint256 VAR62 ) public FUN7 {\nFUN16(VAR23, VAR57, now, VAR60, VAR61, VAR62);\n}\nfunction FUN18(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, 0, VAR44);\n}\nfunction FUN19(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, VAR43, 0, VAR44);\n}\nfunction FUN20(address VAR23, uint256 VAR57) external FUN7 {\nFUN17(VAR23, VAR57, 0, VAR45, VAR45);\n}\nfunction FUN21() external {\nFUN22(msg.sender);\n}\nfunction FUN22(address VAR8) public {\nCON6(VAR46[VAR8]).FUN8(this);\n}\nfunction FUN23(address VAR8) public FUN7 {\nCON6(VAR46[VAR8]).FUN9(this);\n}\nfunction FUN24() external FUN7 {\nrequire(VAR41 != address(0));\nVAR41.FUN10();\n}\n}",
        "label": false,
        "name": "0x651455a972659c7399b563005894628ac41c3750.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON5 {\naddress public VAR15;\nmodifier FUN14(address VAR16) {\nrequire(VAR16 != address(0));\n_;\n}\nmodifier FUN15() {\nrequire(msg.sender == VAR15);\n_;\n}\nconstructor(address VAR17, address VAR16) public FUN14(VAR16) {\nrequire(VAR17 != address(0));\nVAR11 = VAR17;\nVAR15 = VAR16;\n}\nfunction FUN16(address VAR16) public FUN6 FUN14(VAR16) {\nVAR15 = VAR16;\n}\n}\ncontract CON8 is CON6, CON7 {\nbool public VAR18;\naddress public VAR19;\nmodifier FUN11() {\nrequire(msg.sender == VAR15 || (VAR19 != address(0) && msg.sender == VAR19));\n_;\n}\nmodifier FUN17(address VAR6) {\nrequire(VAR6 == VAR15 || !VAR18);\n_;\n}\nconstructor (address VAR17, address VAR16) CON7(VAR17, VAR16) public {\nVAR18 = true;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public FUN17(msg.sender) returns (bool) {\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public FUN17(VAR6) returns (bool) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN18(address VAR20) public FUN15 {\nrequire(VAR20 != address(0));\nVAR19 = VAR20;\n}\nfunction FUN19(bool VAR21) public FUN6 {\nVAR18 = VAR21;\n}\n}",
        "label": false,
        "name": "0xa9422a3e6fb02edc3b3188e70e348d77a06d67c6.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1{\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\naddress payable public VAR5;\nmapping (address => uint256) public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor (uint256 VAR9,string memory VAR10,uint8 VAR11,string memory VAR12) public{\nVAR6[msg.sender] = VAR9; VAR4 = VAR9; VAR1 = VAR10; VAR2 = VAR12; VAR3 = VAR11; VAR5 = msg.sender;\n}\nfunction FUN1(address VAR13, uint256 VAR14) public\nreturns (bool VAR15){\nrequire (VAR13 != address(0x0)); require (VAR14 > 0) ;\nrequire (VAR6[msg.sender] >= VAR14) ; require (VAR6[VAR13] + VAR14 >= VAR6[VAR13]) ; VAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR14); VAR6[VAR13] = CON1.safeAdd(VAR6[VAR13], VAR14); return true;\n}\nfunction FUN2(address VAR16, uint256 VAR14) public\nreturns (bool VAR15) {\nrequire(VAR14 > 0) ;\nVAR8[msg.sender][VAR16] = VAR14;\nreturn true;\n}\nfunction FUN3(address VAR17, address VAR13, uint256 VAR14)public returns (bool VAR15) {\nrequire (VAR13 != address(0x0)) ; require (VAR14 > 0) ;\nrequire (VAR6[VAR17] >= VAR14) ; require (VAR6[VAR13] + VAR14 >= VAR6[VAR13]) ; require (VAR14 <= VAR8[VAR17][msg.sender]) ; VAR6[VAR17] = CON1.safeSub(VAR6[VAR17], VAR14); VAR6[VAR13] = CON1.safeAdd(VAR6[VAR13], VAR14); VAR8[VAR17][msg.sender] = CON1.safeSub(VAR8[VAR17][msg.sender], VAR14);\nreturn true;\n}\nfunction FUN4(uint256 VAR14)public returns (bool VAR15) {\nrequire (VAR6[msg.sender] >= VAR14) ; require (VAR14 > 0) ;\nVAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR14); VAR4 = CON1.safeSub(VAR4,VAR14);\nreturn true;\n}\nfunction FUN5(uint256 VAR14)public returns (bool VAR15) {\nrequire (VAR6[msg.sender] >= VAR14) ; require (VAR14 > 0) ;\nVAR6[msg.sender] = CON1.safeSub(VAR6[msg.sender], VAR14); VAR7[msg.sender] = CON1.safeAdd(VAR7[msg.sender], VAR14);\nreturn true;\n}\nfunction FUN6(uint256 VAR14)public returns (bool VAR15) {\nrequire (VAR7[msg.sender] >= VAR14) ; require (VAR14 > 0) ;\nVAR7[msg.sender] = CON1.safeSub(VAR7[msg.sender], VAR14); VAR6[msg.sender] = CON1.safeAdd(VAR6[msg.sender], VAR14);\nreturn true;\n}\nfunction FUN7(uint256 VAR18) public {\nrequire(msg.sender == VAR5);\nVAR5.FUN1(VAR18);\n}\nfunction() external payable {\n}\n}",
        "label": false,
        "name": "0x66ffaace6abfc6916b105eb79774bcd5402fcbb2.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nuint public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender == VAR1) _;\n}\nfunction FUN2(uint VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3(address VAR4) public FUN1 {\nCON1 VAR5 = CON1(VAR4);\nVAR5.FUN2(VAR2);\n}\n}",
        "label": false,
        "name": "0x95ddaae7a52a39743b78f1e3ac47ac835c8d35f1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 9900000000000000000000000000;\nVAR6 = 9900000000000000000000000000;\nVAR3 = \"FZend Blockchain\";\nVAR4 = \"FZB\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd0d5dab67e8470b785b9c19b11d831a3b07d3709.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nconstructor(string VAR4, string VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR7;\nuint256 VAR8;\nfunction FUN1(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR7[msg.sender]);\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nreturn true;\n}\n}\ncontract CON5 is CON2, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction FUN2(address VAR12,address VAR9,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR9 != address(0));\nrequire(VAR10 <= VAR7[VAR12]);\nrequire(VAR10 <= VAR11[VAR12][msg.sender]);\nVAR7[VAR12] = VAR7[VAR12].sub(VAR10);\nVAR7[VAR9] = VAR7[VAR9].add(VAR10);\nVAR11[VAR12][msg.sender] = VAR11[VAR12][msg.sender].sub(VAR10);\nreturn true;\n}\nfunction FUN3(address VAR13, uint256 VAR10) public returns (bool) {\nVAR11[msg.sender][VAR13] = VAR10;\nreturn true;\n}\n}\ncontract CON6 is CON4 {\n}\ncontract CON7 is CON5 {\nbool public VAR14 = false;\nmodifier FUN4() {\nrequire(!VAR14);\n_;\n}\nfunction FUN5() public FUN4 returns (bool) {\nVAR14 = true;\nreturn true;\n}\n}\ncontract CON8 is CON6, CON5,CON7 {\n}\ncontract CON9 is CON8 {\nstring public VAR1 = 'Behavior Value Ecosystem';\nstring public VAR2 = 'BVES';\nuint8 public VAR3 = 8;\nuint256 public VAR15 = 210000000000000000;\nconstructor() public {\nVAR8 = VAR15;\nVAR7[msg.sender] = VAR15;\n}\n}",
        "label": false,
        "name": "0x7ec1a31b22674afcb6a58d703ca9d54fc6606010.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nuint public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nstring public VAR4;\nstring public VAR5;\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint)) VAR7;\nmodifier FUN1(uint VAR8) {\nassert(msg.data.length == VAR8 + 4);\n_;\n}\nfunction FUN2(address VAR9, uint VAR10) public FUN1(2*32) {\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 > 0);\nVAR6[msg.sender] = VAR6[msg.sender].sub(VAR10);\nVAR6[VAR9] = VAR6[VAR9].add(VAR10);\n}\nfunction FUN3(address VAR11, address VAR12, uint VAR10) public {\nrequire(VAR6[VAR11] >= VAR10 && VAR7[VAR11][msg.sender] >= VAR10 && VAR10 > 0);\nVAR6[VAR12] = VAR6[VAR12].add(VAR10);\nVAR6[VAR11] = VAR6[VAR11].sub(VAR10);\nVAR7[VAR11][msg.sender] = VAR7[VAR11][msg.sender].sub(VAR10);\n}\nfunction FUN4(address VAR13, uint VAR10) public {\nVAR7[msg.sender][VAR13] = VAR10;\n}\n}\ncontract CON2 is CON1 {\nconstructor() public {\nVAR1 = 200000000000000000000000000;\nVAR2 = \"Blockchain Invest Platform Token\";\nVAR3 = 18;\nVAR4 = \"BIP\";\nVAR5 = \"2.0\";\nVAR6[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x311118596fe611e3ffe0be3b616f60e891c6877e.sol"
    },
    {
        "source": "{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\n\\n\"},\"DividendDistributingToken.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\nimport \\\"./LoanEscrow.sol\\\";\\n\\n\\ncontract DividendDistributingToken is ERC20, LoanEscrow {\\n  using SafeMath for uint256;\\n\\n  uint256 public constant POINTS_PER_DAI = uint256(10) ** 32;\\n\\n  uint256 public pointsPerToken = 0;\\n  mapping(address =\\u003e uint256) public credits;\\n  mapping(address =\\u003e uint256) public lastPointsPerToken;\\n\\n  event DividendsCollected(address indexed collector, uint256 amount);\\n  event DividendsDeposited(address indexed depositor, uint256 amount);\\n\\n  function collectOwedDividends(address _account) public {\\n    creditAccount(_account);\\n\\n    uint256 _dai = credits[_account].div(POINTS_PER_DAI);\\n    credits[_account] = 0;\\n\\n    pull(_account, _dai, false);\\n    emit DividendsCollected(_account, _dai);\\n  }\\n\\n  function depositDividends() public {  // dividends\\n    uint256 amount = dai.allowance(msg.sender, address(this));\\n\\n    uint256 fee = amount.div(100);\\n    dai.safeTransferFrom(msg.sender, blockimmo(), fee);\\n\\n    deposit(msg.sender, amount.sub(fee));\\n\\n    // partially tokenized properties store the \\\"non-tokenized\\\" part in `this` contract, dividends not disrupted\\n    uint256 issued = totalSupply().sub(unissued());\\n    pointsPerToken = pointsPerToken.add(amount.sub(fee).mul(POINTS_PER_DAI).div(issued));\\n\\n    emit DividendsDeposited(msg.sender, amount);\\n  }\\n\\n  function unissued() public view returns (uint256) {\\n    return balanceOf(address(this));\\n  }\\n\\n  function creditAccount(address _account) internal {\\n    uint256 amount = balanceOf(_account).mul(pointsPerToken.sub(lastPointsPerToken[_account]));\\n\\n    uint256 _credits = credits[_account].add(amount);\\n    if (credits[_account] != _credits)\\n      credits[_account] = _credits;\\n\\n    if (lastPointsPerToken[_account] != pointsPerToken)\\n      lastPointsPerToken[_account] = pointsPerToken;\\n  }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    \\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    \\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    \\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    \\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    \\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    \\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    \\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    \\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    \\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    \\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    \\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    \\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    \\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"LoanEscrow.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\ncontract MoneyMarketInterface {\\n  function getSupplyBalance(address account, address asset) public view returns (uint);\\n  function supply(address asset, uint amount) public returns (uint);\\n  function withdraw(address asset, uint requestedAmount) public returns (uint);\\n}\\n\\ncontract LoanEscrow is Pausable {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // configurable to any ERC20 (i.e. xCHF)\\n  IERC20 public dai = IERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);  // 0x9Ad61E35f8309aF944136283157FABCc5AD371E5  // 0xB4272071eCAdd69d933AdcD19cA99fe80664fc08\\n  MoneyMarketInterface public moneyMarket = MoneyMarketInterface(0x3FDA67f7583380E67ef93072294a7fAc882FD7E7);  // 0x6732c278C58FC90542cce498981844A073D693d7\\n\\n  event Deposited(address indexed from, uint256 daiAmount);\\n  event InterestWithdrawn(address indexed to, uint256 daiAmount);\\n  event Pulled(address indexed to, uint256 daiAmount);\\n\\n  mapping(address =\\u003e uint256) public deposits;\\n  mapping(address =\\u003e uint256) public pulls;\\n  uint256 public deposited;\\n  uint256 public pulled;\\n\\n  modifier onlyBlockimmo() {\\n    require(msg.sender == blockimmo(), \\\"onlyBlockimmo\\\");\\n    _;\\n  }\\n\\n  function blockimmo() public view returns (address);\\n\\n  function withdrawInterest() public onlyBlockimmo {\\n    uint256 amountInterest = moneyMarket.getSupplyBalance(address(this), address(dai)).add(dai.balanceOf(address(this))).add(pulled).sub(deposited);\\n    require(amountInterest \\u003e 0, \\\"no interest\\\");\\n\\n    uint256 errorCode = (amountInterest \\u003e dai.balanceOf(address(this))) ? moneyMarket.withdraw(address(dai), amountInterest.sub(dai.balanceOf(address(this)))) : 0;\\n    require(errorCode == 0, \\\"withdraw failed\\\");\\n\\n    dai.safeTransfer(msg.sender, amountInterest);\\n    emit InterestWithdrawn(msg.sender, amountInterest);\\n  }\\n\\n  function withdrawMoneyMarket(uint256 _amountDai) public onlyBlockimmo {\\n    uint256 errorCode = moneyMarket.withdraw(address(dai), _amountDai);\\n    require(errorCode == 0, \\\"withdraw failed\\\");\\n  }\\n\\n  function deposit(address _from, uint256 _amountDai) internal {\\n    require(_from != address(0) \\u0026\\u0026 _amountDai \\u003e 0, \\\"invalid parameter(s)\\\");\\n\\n    dai.safeTransferFrom(msg.sender, address(this), _amountDai);\\n\\n    if (!paused()) {\\n      dai.safeApprove(address(moneyMarket), _amountDai);\\n\\n      uint256 errorCode = moneyMarket.supply(address(dai), _amountDai);\\n      require(errorCode == 0, \\\"supply failed\\\");\\n      require(dai.allowance(address(this), address(moneyMarket)) == 0, \\\"allowance not fully consumed by moneyMarket\\\");\\n    }\\n\\n    deposits[_from] = deposits[_from].add(_amountDai);\\n    deposited = deposited.add(_amountDai);\\n    emit Deposited(_from, _amountDai);\\n  }\\n\\n  function pull(address _to, uint256 _amountDai, bool _refund) internal {\\n    require(_to != address(0) \\u0026\\u0026 _amountDai \\u003e 0, \\\"invalid parameter(s)\\\");\\n\\n    uint256 errorCode = (_amountDai \\u003e dai.balanceOf(address(this))) ? moneyMarket.withdraw(address(dai), _amountDai.sub(dai.balanceOf(address(this)))) : 0;\\n    require(errorCode == 0, \\\"withdraw failed\\\");\\n\\n    if (_refund) {\\n      deposits[_to] = deposits[_to].sub(_amountDai);\\n      deposited = deposited.sub(_amountDai);\\n    } else {\\n      pulls[_to] = pulls[_to].add(_amountDai);\\n      pulled = pulled.add(_amountDai);\\n    }\\n\\n    dai.safeTransfer(_to, _amountDai);\\n    emit Pulled(_to, _amountDai);\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    \\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    \\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    \\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    \\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    \\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    \\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./PauserRole.sol\\\";\\n\\n\\ncontract Pausable is PauserRole {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    \\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    \\n    modifier whenNotPaused() {\\n        require(!_paused);\\n        _;\\n    }\\n\\n    \\n    modifier whenPaused() {\\n        require(_paused);\\n        _;\\n    }\\n\\n    \\n    function pause() public onlyPauser whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    \\n    function unpause() public onlyPauser whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"},\"PauserRole.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract PauserRole {\\n    using Roles for Roles.Role;\\n\\n    event PauserAdded(address indexed account);\\n    event PauserRemoved(address indexed account);\\n\\n    Roles.Role private _pausers;\\n\\n    constructor () internal {\\n        _addPauser(msg.sender);\\n    }\\n\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender));\\n        _;\\n    }\\n\\n    function isPauser(address account) public view returns (bool) {\\n        return _pausers.has(account);\\n    }\\n\\n    function addPauser(address account) public onlyPauser {\\n        _addPauser(account);\\n    }\\n\\n    function renouncePauser() public {\\n        _removePauser(msg.sender);\\n    }\\n\\n    function _addPauser(address account) internal {\\n        _pausers.add(account);\\n        emit PauserAdded(account);\\n    }\\n\\n    function _removePauser(address account) internal {\\n        _pausers.remove(account);\\n        emit PauserRemoved(account);\\n    }\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\n\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\n\\n\"},\"TokenizedProperty.sol\":{\"content\":\"\\n\\npragma solidity 0.5.7;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\n\\nimport \\\"./DividendDistributingToken.sol\\\";\\n\\ncontract LandRegistryInterface {\\n  function getProperty(string memory _eGrid) public view returns (address property);\\n}\\n\\ncontract LandRegistryProxyInterface {\\n  function owner() public view returns (address);\\n  function landRegistry() public view returns (LandRegistryInterface);\\n}\\n\\ncontract WhitelistInterface {\\n  function checkRole(address _operator, string memory _permission) public view;\\n}\\n\\ncontract WhitelistProxyInterface {\\n  function whitelist() public view returns (WhitelistInterface);\\n}\\n\\n\\ncontract TokenizedProperty is DividendDistributingToken, ERC20Detailed, Ownable {\\n  LandRegistryProxyInterface public registryProxy = LandRegistryProxyInterface(0xe72AD2A335AE18e6C7cdb6dAEB64b0330883CD56);  // 0x0f5Ea0A652E851678Ebf77B69484bFcD31F9459B;\\n  WhitelistProxyInterface public whitelistProxy = WhitelistProxyInterface(0x7223b032180CDb06Be7a3D634B1E10032111F367);  // 0xEC8bE1A5630364292E56D01129E8ee8A9578d7D8;\\n\\n  uint256 public constant NUM_TOKENS = 1000000;\\n\\n  modifier isValid() {\\n    LandRegistryInterface registry = LandRegistryInterface(registryProxy.landRegistry());\\n    require(registry.getProperty(name()) == address(this), \\\"invalid TokenizedProperty\\\");\\n    _;\\n  }\\n\\n  modifier onlyBlockimmo() {\\n    require(msg.sender == blockimmo(), \\\"onlyBlockimmo\\\");\\n    _;\\n  }\\n\\n  constructor(string memory _eGrid, string memory _grundstuck) public ERC20Detailed(_eGrid, _grundstuck, 18) {\\n    uint256 totalSupply = NUM_TOKENS.mul(uint256(10) ** decimals());\\n    _mint(msg.sender, totalSupply);\\n\\n    _approve(address(this), blockimmo(), ~uint256(0));  // enable blockimmo to issue `unissued` tokens in the future\\n  }\\n\\n  function blockimmo() public view returns (address) {\\n    return registryProxy.owner();\\n  }\\n\\n  function burn(uint256 _value) public isValid {  // buyback\\n    creditAccount(msg.sender);\\n    _burn(msg.sender, _value);\\n  }\\n\\n  function mint(address _to, uint256 _value) public isValid onlyBlockimmo returns (bool) {  // equity dilution\\n    creditAccount(_to);\\n    _mint(_to, _value);\\n    return true;\\n  }\\n\\n  function _transfer(address _from, address _to, uint256 _value) internal isValid {\\n    whitelistProxy.whitelist().checkRole(_to, \\\"authorized\\\");\\n\\n    creditAccount(_from);  // required for dividends...\\n    creditAccount(_to);\\n\\n    super._transfer(_from, _to, _value);\\n  }\\n}\\n\"}}",
        "label": false,
        "name": "0x9c3e7e016389661473ac64f4c37f5f7f2955e499.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR2 = false;\nmodifier FUN2() {\nrequire(!VAR2);\n_;\n}\nmodifier FUN3() {\nrequire(VAR2);\n_;\n}\nfunction FUN4() FUN1 FUN2 public {\nVAR2 = true;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR2 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN6(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN7(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN8(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN9(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN6(address VAR5,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN6(VAR5, VAR6);\n}\nfunction FUN7(address VAR8,address VAR5,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN7(VAR8, VAR5, VAR6);\n}\nfunction FUN8(address VAR9,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN8(VAR9, VAR6);\n}\nfunction FUN9(address VAR9,uint VAR10) public FUN2 returns (bool VAR13)\n{\nreturn super.FUN9(VAR9, VAR10);\n}\nfunction FUN10(address VAR9,uint VAR11) public FUN2 returns (bool VAR13)\n{\nreturn super.FUN10(VAR9, VAR11);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR6) public {\nFUN12(msg.sender, VAR6);\n}\nfunction FUN12(address VAR14, uint256 VAR6) internal {\nrequire(VAR6 <= VAR3[VAR14]);\nVAR3[VAR14] = VAR3[VAR14].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON9 is CON7 {\nbool public VAR15 = false;\nmodifier FUN13() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN14() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN15() FUN1 FUN13 public returns (bool) {\nVAR15 = true;\nreturn true;\n}\n}\ncontract CON10 is CON9, CON8 {\nusing SafeMath for uint256;\nstring public VAR16 = \"VIONcoin\";\nstring public VAR17 = \"VION\";\nuint256 constant public VAR18 = 18;\nuint256 constant VAR19 = 10**VAR18;\nuint256 public constant VAR20 = 570000000*VAR19; address public VAR21;\nmodifier FUN16() {\nrequire(msg.sender == VAR21);\n_;\n}\nconstructor() public {\nFUN4();\n}\nfunction FUN17(address VAR22) public FUN1{\nVAR21 = VAR22;\n}\nfunction FUN18(address VAR5, uint256 VAR23) FUN16 FUN13 public returns (bool) {\nrequire(VAR3[VAR5].add(VAR23) != 0);\nrequire(VAR3[VAR5].add(VAR23) > VAR3[VAR5]);\nrequire(VAR4 <= VAR20);\nVAR4 = VAR4.add(VAR23);\nVAR3[VAR5] = VAR3[VAR5].add(VAR23);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x29cf5c78268225d4c2b7cbb85b02dcf697ae920a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3;\nuint256 public VAR4;\nmapping(address => uint256) public VAR5;\nfunction CON4() public{\nVAR1 = \"Special Drawing Right\";\nVAR2 = \"SDR\";\nVAR3 = 2;\nVAR4 = 1000000000 * 10 ** uint(VAR3);\nVAR5[msg.sender] = VAR4;\n}\nfunction FUN1(address VAR6, uint256 VAR7, bytes VAR8, string VAR9) public returns (bool VAR10) {\nif (isContract(VAR6)) {\nif (balanceOf(msg.sender) < VAR7)\nrevert();\nVAR5[msg.sender] = balanceOf(msg.sender).sub(VAR7);\nVAR5[VAR6] = balanceOf(VAR6).add(VAR7);\nassert(VAR6.call.value(0)(bytes4(keccak256(VAR9)), msg.sender, VAR7, VAR8));\nreturn true;\n} else {\nreturn FUN2(VAR6, VAR7, VAR8);\n}\n}\nfunction FUN1(address VAR6, uint256 VAR7, bytes VAR8) public returns (bool VAR10) {\nif (isContract(VAR6)) {\nreturn FUN3(VAR6, VAR7, VAR8);\n} else {\nreturn FUN2(VAR6, VAR7, VAR8);\n}\n}\nfunction FUN1(address VAR6, uint256 VAR7) public returns (bool VAR10) {\nbytes memory VAR11;\nif (isContract(VAR6)) {\nreturn FUN3(VAR6, VAR7, VAR11);\n} else {\nreturn FUN2(VAR6, VAR7, VAR11);\n}\n}\nfunction FUN2(address VAR6, uint256 VAR7, bytes VAR8) private returns (bool VAR10) {\nif (balanceOf(msg.sender) < VAR7)\nrevert();\nVAR5[msg.sender] = balanceOf(msg.sender).sub(VAR7);\nVAR5[VAR6] = balanceOf(VAR6).add(VAR7);\nreturn true;\n}\nfunction FUN3(address VAR6, uint256 VAR7, bytes VAR8) private returns (bool VAR10) {\nif (balanceOf(msg.sender) < VAR7) {\nrevert();\n}\nVAR5[msg.sender] = balanceOf(msg.sender).sub(VAR7);\nVAR5[VAR6] = balanceOf(VAR6).add(VAR7);\nCON3 VAR12 = CON3(VAR6);\nVAR12.tokenFallback(msg.sender, VAR7, VAR8);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x8abb673ea728e3006dd44df0f96e2964b59e4cb2.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\naddress public VAR1;\nfunction CON1() public {VAR1 = msg.sender;}\nfunction FUN2(address VAR2) public FUN1 {\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping(address => bool) public VAR3;\nmodifier FUN3 {\nrequire(VAR3[msg.sender]);\n_;\n}\nfunction FUN4(address VAR4, bool VAR5) public FUN1 {\nVAR3[VAR4] = VAR5;\n}\n}\ncontract CON3 is CON2 {\nmapping(bytes32 => uint) VAR6;\nmapping(bytes32 => string) VAR7;\nmapping(bytes32 => address) VAR8;\nmapping(bytes32 => bytes) VAR9;\nmapping(bytes32 => bool) VAR10;\nmapping(bytes32 => int) VAR11;\nfunction FUN5(bytes32 VAR12, uint VAR13) FUN3 external {\nVAR6[VAR12] = VAR13;\n}\nfunction FUN6(bytes32 VAR12, string VAR13) FUN3 external {\nVAR7[VAR12] = VAR13;\n}\nfunction FUN7(bytes32 VAR12, address VAR13) FUN3 external {\nVAR8[VAR12] = VAR13;\n}\nfunction FUN8(bytes32 VAR12, bytes VAR13) FUN3 external {\nVAR9[VAR12] = VAR13;\n}\nfunction FUN9(bytes32 VAR12, bool VAR13) FUN3 external {\nVAR10[VAR12] = VAR13;\n}\nfunction FUN10(bytes32 VAR12, int VAR13) FUN3 external {\nVAR11[VAR12] = VAR13;\n}\nfunction FUN11(bytes32 VAR12) FUN3 external {\ndelete VAR6[VAR12];\n}\nfunction FUN12(bytes32 VAR12) FUN3 external {\ndelete VAR7[VAR12];\n}\nfunction FUN13(bytes32 VAR12) FUN3 external {\ndelete VAR8[VAR12];\n}\nfunction FUN14(bytes32 VAR12) FUN3 external {\ndelete VAR9[VAR12];\n}\nfunction FUN15(bytes32 VAR12) FUN3 external {\ndelete VAR10[VAR12];\n}\nfunction FUN16(bytes32 VAR12) FUN3 external {\ndelete VAR11[VAR12];\n}\n}",
        "label": false,
        "name": "0x0821d33c50d2d2d1381b5dfca34900bacad909a7.sol"
    },
    {
        "source": "contract CON1 {\nuint256 constant private VAR1 =\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nfunction FUN1 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nrequire (VAR2 <= VAR1 - VAR3);\nreturn VAR2 + VAR3;\n}\nfunction FUN2 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nrequire(VAR2 >= VAR3);\nreturn VAR2 - VAR3;\n}\nfunction FUN3 (uint256 VAR2, uint256 VAR3)\nconstant internal\nreturns (uint256 VAR4) {\nif (VAR3 == 0) return 0; require (VAR2 <= VAR1 / VAR3);\nreturn VAR2 * VAR3;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\naddress VAR5;\nfunction CON3 () {\n}\nfunction FUN4 (address VAR6) constant returns (uint256 VAR7) {\nreturn VAR15 [VAR6];\n}\nfunction FUN5 (address VAR8, uint256 VAR9) returns (bool VAR10) {\nuint256 VAR11 = FUN13();\nif (VAR15 [msg.sender] < VAR9) return false;\nif (VAR9 > VAR11 && msg.sender != VAR8) {\nVAR15 [msg.sender] = FUN2 (VAR15 [msg.sender], VAR9);\nVAR15 [VAR8] = FUN1 (VAR15 [VAR8], FUN2(VAR9, VAR11));\nFUN14(VAR11);\n}\nreturn true;\n}\nfunction FUN6 (address VAR12, address VAR8, uint256 VAR9)\nreturns (bool VAR10) {\nuint256 VAR11 = FUN13();\nif (VAR16 [VAR12][msg.sender] < VAR9) return false;\nif (VAR15 [VAR12] < VAR9) return false;\nVAR16 [VAR12][msg.sender] =\nFUN2 (VAR16 [VAR12][msg.sender], VAR9);\nif (VAR9 > VAR11 && VAR12 != VAR8) {\nVAR15 [VAR12] = FUN2 (VAR15 [VAR12], VAR9);\nVAR15 [VAR8] = FUN1 (VAR15 [VAR8], FUN2(VAR9, VAR11));\nFUN14(VAR11);\n}\nreturn true;\n}\nfunction FUN7 (address VAR13, uint256 VAR9) returns (bool VAR10) {\nVAR16 [msg.sender][VAR13] = VAR9;\nreturn true;\n}\nfunction FUN8 (address VAR6, address VAR13) constant\nreturns (uint256 VAR14) {\nreturn VAR16 [VAR6][VAR13];\n}\nmapping (address => uint256) VAR15;\nmapping (address => mapping (address => uint256)) VAR16;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR17 = 200000000e6;\naddress VAR18;\nuint256 VAR19;\nfunction CON4 (address VAR20) {\nVAR19 = VAR17;\nVAR15 [msg.sender] = VAR17;\nVAR18 = msg.sender;\nVAR5 = VAR20;\n}\nfunction FUN9 () constant returns (string FUN9) {\nreturn \"PRG\";\n}\nfunction FUN10 () constant returns (string FUN10) {\nreturn \"PRG\";\n}\nfunction FUN11 () constant returns (uint8 FUN11) {\nreturn 6;\n}\nfunction FUN12 () constant returns (uint256 VAR21) {\nreturn VAR19;\n}\nfunction FUN5 (address VAR8, uint256 VAR9) returns (bool VAR10) {\nreturn CON3.FUN5 (VAR8, VAR9);\n}\nfunction FUN6 (address VAR12, address VAR8, uint256 VAR9)\nreturns (bool VAR10) {\nreturn CON3.FUN6 (VAR12, VAR8, VAR9);\n}\nfunction FUN13 () constant returns (uint256) {\nreturn FUN1(FUN3(VAR19, 5)/1e11, 25000);\n}\nfunction FUN14(uint256 VAR11) internal returns (bool) {\nuint256 VAR22 = VAR11/2;\nuint256 VAR23 = FUN2(VAR11, VAR22);\nVAR15 [VAR5] = FUN1 (VAR15 [VAR5], VAR23);\nVAR19 = FUN2 (VAR19, VAR22);\nreturn true;\n}\nfunction FUN7 (address VAR13, uint256 VAR24, uint256 VAR25)\nreturns (bool VAR10) {\nif (FUN8 (msg.sender, VAR13) == VAR24)\nreturn FUN7 (VAR13, VAR25);\nelse return false;\n}\nfunction FUN15 (uint256 VAR9) returns (bool VAR10) {\nif (VAR9 > VAR15 [msg.sender]) return false;\nelse if (VAR9 > 0) {\nVAR15 [msg.sender] = FUN2 (VAR15 [msg.sender], VAR9);\nVAR19 = FUN2 (VAR19, VAR9);\nreturn true;\n} else return true;\n}\nfunction FUN16 (address VAR26) {\nrequire (msg.sender == VAR18);\nVAR18 = VAR26;\n}\nfunction FUN17 (address VAR27) {\nrequire (msg.sender == VAR18);\nVAR5 = VAR27;\n}\n}",
        "label": false,
        "name": "0x7728dfef5abd468669eb7f9b48a7f70a501ed29d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON3;\nCON3 public VAR3;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nconstructor(uint256 VAR7, address VAR8, CON3 VAR9) public {\nrequire(VAR7 > 0);\nrequire(VAR8 != address(0));\nrequire(VAR9 != address(0));\nVAR5 = VAR7;\nVAR4 = VAR8;\nVAR3 = VAR9;\n}\nfunction () external payable {\nFUN6(msg.sender);\n}\nfunction FUN6(address VAR10) public payable {\nuint256 VAR11 = msg.value;\nFUN7(VAR10, VAR11);\nuint256 VAR12 = _getTokenAmount(VAR11);\nVAR6 = VAR6.add(VAR11);\nFUN10(VAR10, VAR12);\nFUN11(VAR10, VAR11);\nFUN12();\nFUN8(VAR10, VAR11);\n}\nfunction FUN7(address VAR10,uint256 VAR13)\ninternal\n{\nrequire(VAR10 != address(0));\nrequire(VAR13 != 0);\n}\nfunction FUN8(address VAR10,uint256 VAR13)\ninternal\n{\n}\nfunction FUN9(address VAR10,uint256 VAR14)\ninternal\n{\nVAR3.safeTransfer(VAR10, VAR14);\n}\nfunction FUN10(address VAR10,uint256 VAR14)\ninternal\n{\nFUN9(VAR10, VAR14);\n}\nfunction FUN11(address VAR10,uint256 VAR13)\ninternal\n{\n}\nfunction FUN12() internal {\nVAR4.FUN16(msg.value);\n}\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nuint256 public VAR15;\nuint256 public VAR16;\nmodifier FUN13 {\nrequire(block.timestamp >= VAR15 && block.timestamp <= VAR16);\n_;\n}\nconstructor(uint256 VAR17, uint256 VAR18) public {\nrequire(VAR17 >= block.timestamp);\nrequire(VAR18 >= VAR17);\nVAR15 = VAR17;\nVAR16 = VAR18;\n}\nfunction FUN7(address VAR10,uint256 VAR13)\ninternal\nFUN13\n{\nsuper.FUN7(VAR10, VAR13);\n}\n}\ncontract CON6 is CON1, CON5 {\nusing SafeMath for uint256;\nbool public VAR19 = false;\nfunction FUN14() public FUN1 {\nrequire(!VAR19);\nrequire(hasClosed());\nFUN15();\nVAR19 = true;\n}\nfunction FUN15() internal {\n}\n}\ncontract CON7 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR20;\nuint256 internal VAR21;\nfunction FUN16(address VAR22, uint256 VAR23) public returns (bool) {\nrequire(VAR23 <= VAR20[msg.sender]);\nrequire(VAR22 != address(0));\nVAR20[msg.sender] = VAR20[msg.sender].sub(VAR23);\nVAR20[VAR22] = VAR20[VAR22].add(VAR23);\nreturn true;\n}\n}\ncontract CON8 is CON3, CON7 {\nmapping (address => mapping (address => uint256)) internal VAR24;\nfunction FUN17(address VAR25,address VAR22,uint256 VAR23)\npublic\nreturns (bool)\n{\nrequire(VAR23 <= VAR20[VAR25]);\nrequire(VAR23 <= VAR24[VAR25][msg.sender]);\nrequire(VAR22 != address(0));\nVAR20[VAR25] = VAR20[VAR25].sub(VAR23);\nVAR20[VAR22] = VAR20[VAR22].add(VAR23);\nVAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].sub(VAR23);\nreturn true;\n}\nfunction FUN18(address VAR26, uint256 VAR23) public returns (bool) {\nVAR24[msg.sender][VAR26] = VAR23;\nreturn true;\n}\nfunction FUN19(address VAR26,uint256 VAR27)\npublic\nreturns (bool)\n{\nVAR24[msg.sender][VAR26] = (VAR24[msg.sender][VAR26].add(VAR27));\nreturn true;\n}\nfunction FUN20(address VAR26,uint256 VAR28)\npublic\nreturns (bool)\n{\nuint256 VAR29 = VAR24[msg.sender][VAR26];\nif (VAR28 >= VAR29) {\nVAR24[msg.sender][VAR26] = 0;\n} else {\nVAR24[msg.sender][VAR26] = VAR29.sub(VAR28);\n}\nreturn true;\n}\n}\ncontract CON9 is CON8, CON1 {\nbool public VAR30 = false;\nmodifier FUN21() {\nrequire(!VAR30);\n_;\n}\nmodifier FUN22() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN23(address VAR22,uint256 VAR31)\npublic\nFUN22\nFUN21\nreturns (bool)\n{\nVAR21 = VAR21.add(VAR31);\nVAR20[VAR22] = VAR20[VAR22].add(VAR31);\nreturn true;\n}\nfunction FUN24() public FUN1 FUN21 returns (bool) {\nVAR30 = true;\nreturn true;\n}\n}\ncontract CON10 is CON4 {\nfunction FUN9(address VAR10,uint256 VAR14)\ninternal\n{\nrequire(CON9(address(VAR3)).FUN23(VAR10, VAR14));\n}\n}\ncontract CON11 is CON1 {\nbool public VAR32 = false;\nmodifier FUN25() {\nrequire(!VAR32);\n_;\n}\nmodifier FUN26() {\nrequire(VAR32);\n_;\n}\nfunction FUN27() public FUN1 FUN25 {\nVAR32 = true;\n}\nfunction FUN28() public FUN1 FUN26 {\nVAR32 = false;\n}\n}\ncontract CON12 {\n}\ncontract CON13 is CON8, CON11 {\nfunction FUN16(address VAR22,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN16(VAR22, VAR23);\n}\nfunction FUN17(address VAR25,address VAR22,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN17(VAR25, VAR22, VAR23);\n}\nfunction FUN18(address VAR26,uint256 VAR23)\npublic\nFUN25\nreturns (bool)\n{\nreturn super.FUN18(VAR26, VAR23);\n}\nfunction FUN19(address VAR26,uint VAR27)\npublic\nFUN25\nreturns (bool VAR33)\n{\nreturn super.FUN19(VAR26, VAR27);\n}\nfunction FUN20(address VAR26,uint VAR28)\npublic\nFUN25\nreturns (bool VAR33)\n{\nreturn super.FUN20(VAR26, VAR28);\n}\n}\ncontract CON14 is CON13, CON9 {\nstring public constant VAR34 = \"Realty Returns Token\";\nstring public constant VAR35 = \"RRT\";\nuint8 public constant VAR36 = 18;\nconstructor() public {\nFUN27();\n}\n}\ncontract CON15 is CON1 {\nusing SafeMath for uint;\nuint256 public VAR37;\nuint256 public VAR38;\nuint256 public VAR39;\nuint256 public VAR40;\nuint256 public VAR41;\nmapping (address => uint256) public VAR42;\nCON3 public VAR43;\nconstructor\n(CON3 VAR9,uint256 VAR44,uint256 VAR45,uint256 VAR46)\npublic\n{\nrequire(VAR9 != address(0));\nVAR43 = CON3(VAR9);\nVAR37 = VAR44;\nVAR38 = VAR45;\nVAR41 = VAR46;\n}\nfunction FUN29(address VAR47, uint256 VAR48)\nexternal\nFUN1\nreturns(bool)\n{\nrequire(VAR42[VAR47] == 0 && VAR47 != address(0));\nVAR40 = VAR40.add(VAR48);\nrequire(VAR40 <= VAR41);\nVAR42[VAR47] = VAR48;\nreturn true;\n}\nfunction FUN30() external {\nrequire(VAR43 != address(0));\nassert(now >= VAR37);\nif (VAR39 == 0) {\nVAR39 = VAR43.balanceOf(this);\n}\nuint256 VAR49 = VAR42[msg.sender];\nVAR42[msg.sender] = 0;\nrequire(VAR43.FUN16(msg.sender, VAR49));\n}\nfunction FUN31() public FUN1 {\nrequire(now >= VAR38);\nuint256 VAR50 = VAR43.balanceOf(this);\nif (VAR50 > 0) {\nVAR43.FUN16(msg.sender, VAR50);\n}\nselfdestruct(VAR1);\n}\n}\ncontract CON16 is CON6, CON10, CON11 {\nuint256 constant public VAR51 = 240000000e18; uint256 constant public VAR52 = 120000000e18; uint256 constant public VAR53 = 120000000e18; uint256 constant public VAR54 = 530000000e18;\nuint256 constant public VAR55 = 190000000e18; uint256 public VAR56 = 1321580e18;\naddress public VAR57;\naddress public VAR58;\naddress public VAR59;\naddress public VAR60;\naddress public VAR61;\nuint256 public VAR62;\naddress public VAR63;\nconstructor\n(uint256 VAR17,uint256 VAR18,CON14 VAR9,uint256 VAR7,address VAR8,address VAR64,address VAR65)\npublic\nCON6()\nCON4(VAR7, VAR8, VAR9)\nCON5(VAR17, VAR18)\n{\nrequire(VAR64 != address(0));\nVAR57 = VAR64;\nVAR63 = VAR65;\nrequire(CON14(VAR3).VAR32());\n}\nfunction FUN32(uint256 VAR66) external FUN1 {\nrequire(VAR66 != 0);\nVAR5 = VAR66;\n}\nfunction FUN33(uint256 VAR67) external FUN1 {\nrequire(VAR67 != 0);\nVAR56 = VAR67;\n}\nfunction FUN34(address VAR68, uint256 VAR69)\npublic\nFUN1\n{\nrequire(VAR68 != address(0));\nrequire(VAR3.totalSupply().add(VAR69) <= VAR55);\nFUN9(VAR68, VAR69);\n}\nfunction FUN35\n(address VAR70,address VAR71,address VAR72)\npublic\nFUN1\n{\nrequire(VAR58 == address(0x0) && VAR59 == address(0x0) && VAR60 == address(0x0));\nrequire(VAR70 != address(0x0) && VAR71 != address(0x0) && VAR72 != address(0x0));\nVAR58 = VAR70;\nVAR59 = VAR71;\nVAR60 = VAR72;\n}\nfunction FUN7(address VAR10, uint256 VAR13)\ninternal\nFUN25\n{\nrequire(VAR10 != address(0));\nrequire(VAR3.totalSupply() < VAR55);\n}\nfunction FUN12() internal {\nuint256 VAR73 = msg.value.div(100);\nuint256 VAR74 = msg.value.sub(VAR73);\nVAR63.FUN16(VAR73);\nVAR4.FUN16(VAR74);\n}\nfunction FUN15() internal {\nrequire(VAR58 != address(0) && VAR59 != address(0) && VAR60 != address(0));\nif (VAR55 > VAR3.totalSupply()) {\nuint256 VAR75 = VAR55.sub(VAR3.totalSupply());\nFUN9(VAR4, VAR75);\n}\nFUN9(VAR57, VAR51);\nFUN9(VAR58, VAR52);\nFUN9(VAR59, VAR53);\nFUN9(VAR60, VAR54);\nCON14(VAR3).FUN24();\nCON14(VAR3).FUN28();\nsuper.FUN15();\n}\n}",
        "label": false,
        "name": "0x69e13a17e5cb5377b924cd84a1a57365117b690b.sol"
    },
    {
        "source": "contract CON1{\nfunction FUN1(address VAR1, bytes32 VAR2) public\n{\n}\n}",
        "label": false,
        "name": "0x5f525907032d5e6b4c6d855ee3ae6a0cdf90a3da.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\nfunction CON2() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2 {\nCON3 public VAR3;\nconstructor(address VAR4) public {\nVAR3 = CON3(VAR4);\n}\nmodifier FUN3(string VAR5) {\nrequire(hasRole(msg.sender, VAR5), \"Access denied: missing role\");\n_;\n}\nmodifier FUN4() {\nrequire(\nmsg.sender == VAR1 || hasRole(msg.sender, roleAdmin()), \"Access denied: missing role\");\n_;\n}\nfunction FUN5(address VAR4) public FUN4 {\nVAR3 = CON3(VAR4);\n}\n}\ncontract CON5 is CON4 {\nmapping(address => address) VAR6;\nfunction FUN6(address VAR7, address VAR8) public FUN3(roleAddressAliaser()) {\nrequire(VAR6[VAR7] == address(0), \"oldAddr is already aliased to another address\");\nrequire(VAR6[VAR8] == address(0), \"newAddr is already aliased to another address\");\nrequire(VAR7 != VAR8, \"oldAddr and VAR8 must be different\");\nFUN7(VAR7, VAR8);\n}\nfunction FUN7(address VAR7, address VAR8) public FUN3(roleAddressAliaser()) {\nVAR6[VAR8] = VAR7;\n}\nfunction FUN8(address VAR9) public FUN3(roleAddressAliaser()) {\nFUN7(0, VAR9);\n}\n}\ncontract CON6 is CON4, CON5, CON1 {\nstring constant VAR10 = \"claims__admin\";\nstring constant VAR11 = \"claims__issuer\";\nstring constant VAR12 = \"claims__address_aliaser\";\nstruct Claim {\nbytes VAR13;\nbytes32 VAR14;\n}\nmapping(address => mapping(bytes32 => Claim)) internal VAR15;\nmapping(address => bool) internal VAR16;\nconstructor(address VAR4) CON4(VAR4) public {}\nfunction FUN9(address VAR17, bytes32 VAR18, bytes VAR13, bytes32 VAR14) public FUN3(VAR11) {\naddress VAR19 = resolveAddress(VAR17);\nVAR15[VAR19][VAR18].VAR13 = VAR13;\nVAR15[VAR19][VAR18].VAR14 = VAR14;\nVAR16[VAR19] = true;\n}\nfunction FUN10(address VAR17, bytes32 VAR18) public {\nrequire(hasRole(msg.sender, VAR11) || msg.sender == VAR17, \"Access denied: missing role\");\naddress VAR19 = resolveAddress(VAR17);\ndelete VAR15[VAR19][VAR18];\n}\nfunction FUN6(address VAR7, address VAR8) public FUN3(VAR12) {\nrequire(!VAR16[VAR8], \"newAddr already has claims\");\nsuper.FUN6(VAR7, VAR8);\n}\nfunction FUN11(address VAR17, bytes32 VAR18, bytes32 VAR20) public {\nrevert();\n}\nfunction FUN12(bytes32 VAR18, bytes32 VAR20) public {\nrevert();\n}\nfunction FUN13(address VAR21, address VAR17, bytes32 VAR18) public {\nrequire(hasRole(VAR21, VAR11), \"Issuer not recognized\");\nFUN10(VAR17, VAR18);\n}\n}",
        "label": false,
        "name": "0xe1aba037795a93f1796d6d730f9d9d66bb82db1a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 {\nstring public constant VAR3 = \"Parsec Credits\";\nstring public constant VAR4 = \"PRSC\";\nuint8 public VAR5 = 6;\nuint256 public VAR6 = 30856775800;\nuint256 public VAR7;\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nfunction CON3() public {\nVAR7 = VAR6 * 10 ** uint256(VAR5);\nVAR8[msg.sender] = VAR7;\n}\nfunction FUN3(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != 0x0);\nrequire(VAR8[VAR10] >= VAR12);\nrequire(VAR8[VAR11] + VAR12 > VAR8[VAR11]);\nuint VAR13 = VAR8[VAR10] + VAR8[VAR11];\nVAR8[VAR10] -= VAR12;\nVAR8[VAR11] += VAR12;\nassert(VAR8[VAR10] + VAR8[VAR11] == VAR13);\n}\nfunction FUN4(address VAR11, uint256 VAR12) public {\nFUN3(msg.sender, VAR11, VAR12);\n}\nfunction FUN5(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR9[VAR10][msg.sender]);\nVAR9[VAR10][msg.sender] -= VAR12;\nFUN3(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN6(address VAR15, uint256 VAR12) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR12, bytes VAR16) public returns (bool VAR14) {\nCON2 VAR17 = CON2(VAR15);\nif (FUN6(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, this, VAR16);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR8[msg.sender] >= VAR12);\nVAR8[msg.sender] -= VAR12;\nVAR7 -= VAR12;\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR8[VAR10] >= VAR12);\nrequire(VAR12 <= VAR9[VAR10][msg.sender]);\nVAR8[VAR10] -= VAR12;\nVAR9[VAR10][msg.sender] -= VAR12;\nVAR7 -= VAR12;\nreturn true;\n}\n}\ncontract CON4 is CON1 {\nusing SafeMath for uint256;\nuint256 public constant VAR18 = 287.348 ether;\nuint256 public constant VAR19 = 1887.348 ether;\nuint256 public constant VAR20 = 0.5 ether;\nuint256 public constant VAR21 = 1516795200; uint256 public constant VAR22 = 1517400000;\nuint256 public constant VAR23 = 1516881600; uint256 public constant VAR24 = 1516968000;\nuint256 public constant VAR25 = 1519128000;\nuint256 public constant VAR26 = 1525176000; uint256 public constant VAR27 = 1527854400;\nuint256 public constant VAR28 = 3549000000000000;\nuint256 public constant VAR29 = 1690000000000;\nuint256 public constant VAR30 = 50 ether;\nuint256 public VAR31;\nuint256 public VAR32;\nuint256 public VAR33;\nuint256 public VAR34;\nbool public VAR35 = false;\nbool public VAR36 = false;\nbool public VAR37 = false;\nbool public VAR38 = false;\nbool public VAR39 = false;\nbool public VAR40 = false;\nbool public VAR41 = false;\nbool public VAR42 = false;\nbool public VAR43 = false;\nbool public VAR44 = false;\nmapping (address => uint256) public VAR8;\nmapping (address => uint256) public VAR45;\nmapping (address => uint256) public VAR46;\nCON3 private VAR47;\nfunction CON4 (address VAR48) public {\nVAR47 = CON3(VAR48);\n}\nfunction () public payable {\nrequire(VAR38);\nrequire(now >= VAR21);\nrequire(now < VAR22);\nrequire(msg.VAR52 >= VAR20);\nif (now >= VAR21 && now < VAR23) {\nrequire(VAR46[msg.sender] == msg.VAR52);\nrequire(VAR8[msg.sender] == 0);\n} else if (now >= VAR23 && now < VAR24) {\nrequire(VAR46[msg.sender] != 0);\n}\nrequire(VAR31.add(msg.VAR52) <= VAR19);\nFUN25(msg.sender, msg.VAR52);\nFUN28(msg.sender, msg.VAR52);\n}\nfunction FUN11() external FUN1 {\nrequire(!VAR39);\nFUN27(0x2C66aDd04950eE3235fd3EC6BcB2577c88d804E4, 0.5 ether);\nFUN27(0x008e2E5FC70a2bccB5857AE8591119B3B63fdbc2, 0.5 ether);\nFUN27(0x0330cc41bDd33f820d92C2df591CD2A5cB99f792, 0.5 ether);\nFUN27(0x0756ea3a926399c3da2d5bfc520b711bdadfd0b9, 0.5 ether);\nFUN27(0x08c93a267832a8997a46f13b12faa2821d16a472, 0.5 ether);\nFUN27(0x0B58dAeAB6D292B5B8A836643023F43E4D0d9b78, 0.5 ether);\nFUN27(0x0b73f53885581caf26141b4bb5f8c192af611921, 0.5 ether);\nFUN27(0x0be30C8338C76Cc3EF92734863B0A898d8C8fef4, 0.5 ether);\nFUN27(0x0fb6829D5543F173d6bba244c2E21CB60544B7fA, 0.5 ether);\nFUN27(0x0fccb03ceb56e683fbcf0229c950d666def66d1d, 0.5 ether);\nFUN27(0x1578416c880a0F282bAc17c692b2A80b4336D29B, 0.5 ether);\nFUN27(0x16fc89d92592b88bc459e19717eEDD51732CfCA1, 0.5 ether);\nFUN27(0x183feBd8828a9ac6c70C0e27FbF441b93004fC05, 0.5 ether);\nFUN27(0x1A9D4a4DBb3Fb0750107406f4A7c9379DB42f7B3, 0.5 ether);\nFUN27(0x1bB95a9c7d50B9b270a604674f4Ed35265087c40, 0.5 ether);\nFUN27(0x1bf032d01bab6cd4a2d67ec251f5c3f09728a7e3, 0.5 ether);\nFUN27(0x1C1f687165F982Fcd4672B4319AB966256B57b2e, 0.5 ether);\nFUN27(0x1E2B069ca94e0232A04A4D1317e120f903D41c3A, 0.5 ether);\nFUN27(0x21F23Bb7299Caa26D854DDC38E134E49997471Dd, 0.5 ether);\nFUN27(0x23437833ebf735cdaf526c2a2c24f57ca4726358, 0.5 ether);\nFUN27(0x2389Ce4eFB2805Fd047C59Fa8991EA9c8361A9a0, 0.5 ether);\nFUN27(0x248dd8D2b7991d94860c44A5F99fc1483964FBBf, 0.5 ether);\nFUN27(0x257D66c42623c108060a66e4ddE5c3813691Ef38, 0.5 ether);\nFUN27(0x26D6F116a16efD1f8361c5Da90AEA4B26b564004, 0.5 ether);\nFUN27(0x272899d5b1451B09De35161B11722C95E34f06A9, 0.5 ether);\nFUN27(0x29F436906826a7d7Ef0B35292b4f285050108082, 0.5 ether);\nFUN27(0x2A8Be3303C83e5E9699a8b4B70976577BFedeC71, 0.5 ether);\nFUN27(0x2C351d47CE2737982D1E25FB6dfa30265913aEAa, 0.5 ether);\nFUN27(0x3cf2fC2cc45EACf1B6495Bf2AA69fbFC0d4b4a30, 0.5 ether);\nFUN27(0x3Cf5f48Dd9bec4Eff46Ee1E2B9e64b2892B5E64F, 0.5 ether);\nFUN27(0x3D86C8A928E9595114e01bb0539bdD69e9EfDF3B, 0.5 ether);\nFUN27(0x3e825763457fd92a6cb46f5ee0b4969089997da8, 0.5 ether);\nFUN27(0x3F4351eb6b1dd9a84890C1C89F4D4419Eb88f1Af, 0.5 ether);\nFUN27(0x459cc576ac8332f52ee93cb88228416a872bebd6, 0.5 ether);\nFUN27(0x45c556aff90d5fe6e91d24874a8036693cec18d0, 0.5 ether);\nFUN27(0x47449fa838794e665A648FA3e47208a7cd105c9D, 0.5 ether);\nFUN27(0x50405fB11735160056DBc40b92a09B4215501481, 0.5 ether);\nFUN27(0x51DD5Ef09cF73312BADe4C6BA8e03d647730Ecc3, 0.5 ether);\nFUN27(0x546A4F1eD47e853Ba119f55A20CbFeaa40ab70E6, 0.5 ether);\nFUN27(0x549022ad5cd11816eb7ce6ea15ae61c1fb4edb8a, 0.5 ether);\nFUN27(0x5abDC3cB826fC0277D642c9FB52FA76FE3ABb4E7, 0.5 ether);\nFUN27(0x5b65dfa08283e024c4ad09b5ea7212c539cb9dbf, 0.5 ether);\nFUN27(0x5cC69E09cA05004e5aDCdbE8C8Aac4D16A4651ed, 0.5 ether);\nFUN27(0x60a5550D1e43b63b3164F78F2D186bDb7D393C90, 0.5 ether);\nFUN27(0x6111d340C833661840ec4c11e84a79a67bE8acCD, 0.5 ether);\nFUN27(0x61E140a78Ec39d373C182bf3eD23cBc1AC86023b, 0.5 ether);\nFUN27(0x62f12F6C3AD04DFACB10ae05fB54f1E997b0133e, 0.5 ether);\nFUN27(0x65276d60Ab36879a6BD88F040D350cd60630FD03, 0.5 ether);\nFUN27(0x66B993F856d6175D11B98Be2cBc79EB1888B72f7, 0.5 ether);\nFUN27(0x6806408fd066ccddceaecc0a6c6fbbdb2ae8259c, 0.5 ether);\nFUN27(0x6918a5b07c2f79a4b272bb7653a43438ca96cd3f, 0.5 ether);\nFUN27(0x697DE67DB7d462480418814831d52DA25917A12E, 0.5 ether);\nVAR39 = true;\n}\nfunction FUN12() external FUN1 {\nrequire(!VAR40);\nFUN27(0x6A35d29D8F63E4D8A8E5418Be9342A48c4C8eF07, 0.5 ether);\nFUN27(0x6b2a80FB3C8Eca5144E6F129a447b9D06224a402, 0.5 ether);\nFUN27(0x6b8ebca41389689e8875af541a2fa4328ac49917, 0.5 ether);\nFUN27(0x6c3Db34C768Ab1E67E2a7E973B7a83651657660b, 0.5 ether);\nFUN27(0x7018564dCe2c68417DFa7678541DfA0040Ca0c54, 0.5 ether);\nFUN27(0x708faa43f5824d271466c119148728467f66e233, 0.5 ether);\nFUN27(0x71526410C961727a89155D6a32Bb75f9a9d755F5, 0.5 ether);\nFUN27(0x746B426D0B8e272Ef7402db7CE0FD01C2B1c4aDE, 0.5 ether);\nFUN27(0x762C73603f5456c4ad729b3B46464269bcD7C212, 0.5 ether);\nFUN27(0x7a0D19955bBf6cff0D86F6e72355A8AFf3c0d74F, 0.5 ether);\nFUN27(0x7Cf017bDe8af2DfC67cb3f1b16943A0620eA1B54, 0.5 ether);\nFUN27(0x807bAf9e22F4e1E7A5Fcf4B5721ba54666d71421, 0.5 ether);\nFUN27(0x810f1C65f9C7c566E14a1E8ECA7b36b78C6da3A8, 0.5 ether);\nFUN27(0x871a314d75BdF106420B9e08314e776d2746E0Eb, 0.5 ether);\nFUN27(0x88Cf04474CFD3b9Bc4110FfC2980Bc56feBF0465, 0.5 ether);\nFUN27(0x8914316B6505b39e706a208A8E91ab8F79eFA7Cf, 0.5 ether);\nFUN27(0x8b104344F397aFC33Ee55C743a0FbD7d956201cD, 0.5 ether);\nFUN27(0x8Bd5306d0c08Eaa2D9AabaED62297A8AB42db1de, 0.5 ether);\nFUN27(0x8Be1843532E5eE0142420fe627a097a0E0681e97, 0.5 ether);\nFUN27(0x8c269040283c4112198bc59120ad2bcd70e6b387, 0.5 ether);\nFUN27(0x8E14437E18B1091B369c6ff6ecCa73D648aCA3bd, 0.5 ether);\nFUN27(0x8Fc9040b8B9305458716e90F83D9b656a07ae7e6, 0.5 ether);\nFUN27(0x906d9e4D0E028FE85625d06268A437Bb58753301, 0.5 ether);\nFUN27(0x91Fe65df20b13CA260990e096d4EBDbD64f7b399, 0.5 ether);\nFUN27(0x92cBbf4A87953975c39EaA2bF70deDEbC356358b, 0.5 ether);\nFUN27(0x95D4914d4f08732A169367674A8BE026c02c5B44, 0.5 ether);\nFUN27(0x985116bBCcEE828d439c4F6F9233016bf1e95669, 0.5 ether);\nFUN27(0x9976cF5617F5E4022CdC887A7A0a68E8eE5dBA22, 0.5 ether);\nFUN27(0x9A7379c8aF6765aa267d338A20D197DD1544bF9b, 0.5 ether);\nFUN27(0x9DEFB6A85680E11b6aD8AD4095e51464bB4C0C66, 0.5 ether);\nFUN27(0xA02896e448A35DeD03C48c2986A545779ed87edd, 0.5 ether);\nFUN27(0xa460A24F606d4ABba5041B162E06D42aD6f09157, 0.5 ether);\nFUN27(0xaB91cF12f8e133C7B1C849d87997dca895cE0BCB, 0.5 ether);\nFUN27(0xac935E0dD7F90851E0c6EE641cd30B800e35f7A8, 0.5 ether);\nFUN27(0xae41F73635b6F5F9556Cd3B0d3970aDA5Fb0C1b5, 0.5 ether);\nFUN27(0xB16fE19652ceDf4Ba2568b4886CeE29D4e0617B0, 0.5 ether);\nFUN27(0xB2F19E5457404dCaCd2d6344592e5a657DFcA27b, 0.5 ether);\nFUN27(0xB33cc3147d70Ce2aF31B2B90411BD6333EeA0EA7, 0.5 ether);\nFUN27(0xb49a6DD81a847f3A704D0C11C6e1a7C65C47d215, 0.5 ether);\nFUN27(0xb75312cdfBee6B6104a7161E27dbd48bb253E186, 0.5 ether);\nFUN27(0xB87e73ad25086C43a16fE5f9589Ff265F8A3A9Eb, 0.5 ether);\nFUN27(0xc12549d486e20835960Fb3A44ba67fD353B1C48a, 0.5 ether);\nFUN27(0xc4Eab1eAaCbf628F0f9Aee4B7375bDE18dd173C4, 0.5 ether);\nFUN27(0xc8B15B3189b8C6e90ff330CBA190153fF0A9997e, 0.5 ether);\nFUN27(0xCb033bE278d7bD297a2b1Cc6201113480daC579F, 0.5 ether);\nFUN27(0xCb570fE877CA6B7dE030afaf9483f58F774df135, 0.5 ether);\nFUN27(0xcD4929fdDC83Aca93cD4a75bD12780DaDF51870b, 0.5 ether);\nFUN27(0xcdc22860Ff346ead18ECA5E30f0d302a95F33A19, 0.5 ether);\nFUN27(0xD26BA3C03fBC1EA352b5F77B2c1F2881d03D1e2F, 0.5 ether);\nFUN27(0xd454ED303748Bb5a433388F9508433ba5d507030, 0.5 ether);\nFUN27(0xd4d1197fed5F9f3679497Df3604147087B85Ce39, 0.5 ether);\nFUN27(0xd83F072142C802A6fA3921d6512B25a7c1A216b1, 0.5 ether);\nVAR40 = true;\n}\nfunction FUN13() external FUN1 {\nrequire(!VAR41);\nFUN27(0xd9b4cb7bf6a04f545c4c0e32d4570f16cbb3be56, 0.5 ether);\nFUN27(0xDCfe2F26c4c47741851e0201a91FB3b8b6452C81, 0.5 ether);\nFUN27(0xDf1734032A21Fc9F59E6aCE263b65E4c2bE29861, 0.5 ether);\nFUN27(0xDFEa4bE32b1f777d82a6389a0d4F399569c46202, 0.5 ether);\nFUN27(0xE18C42Ecb41d125FB21C61B9A18857A361aFC645, 0.5 ether);\nFUN27(0xE3e29044291E4f2678c8C1859849a3126B95C2a4, 0.5 ether);\nFUN27(0xE4B55adb4eCe93f4F53B3a18561BA876dbA3A2cb, 0.5 ether);\nFUN27(0xe96D559283cE2AFC3C79981dA4717bFfFAE69777, 0.5 ether);\nFUN27(0xEA7F1b3e36eD60257D79a65d8BA2b305d31cEEE7, 0.5 ether);\nFUN27(0xeaf61945762fa3408bfe286da7ea64bd212abfbf, 0.5 ether);\nFUN27(0xeC7715afA5Fd2833693Bfc3521EF5197716A65b0, 0.5 ether);\nFUN27(0xee15AD84321176b2644d0894f28db22621c12b74, 0.5 ether);\nFUN27(0xF05538779A8Ab41741e73a9650CE9B9FE1F3DEc7, 0.5 ether);\nFUN27(0xF0c106d282648da9690Cd611F4654fF0e78DEf18, 0.5 ether);\nFUN27(0xF132D556c8d065264A36d239b11Ad4Ad3d9f8f6e, 0.5 ether);\nFUN27(0xAac34A6B597240B1fAEBaEbeD762F0ecbe02fe18, 0.5 ether);\nFUN27(0xaae16c984ca5245E6AC3c646c1Fb3A9695d2f412, 0.5 ether);\nFUN27(0xfc575d7064ad46804b28ddc4fce90860addaa256, 0.5 ether);\nFUN27(0x4df33f230b862941c92585078eb549a7747c47bd, 0.51 ether);\nFUN27(0xaaF1Df7c351c71aD1Df94DB11Ec87b65F5e72531, 0.51 ether);\nFUN27(0x5C3E4c34f8a12AFBF1b9d85dfc83953c310e4645, 0.6 ether);\nFUN27(0x6580B24104BCAf1ba4171d6bB3B2F1D31a96C549, 0.6 ether);\nFUN27(0x0F3B2d5e7C51700aC0986fCe669aB3c69601499a, 0.7 ether);\nFUN27(0x0b74911659bfc903d978ea57a70ea00fab893aa2, 0.75 ether);\nFUN27(0x45cAa6B0a1d9Db9227DC3D883e31132Ef08F1980, 0.75 ether);\nFUN27(0xAcC0F848404e484D6fEB8Bef3bc53DF1a80CB94A, 0.75 ether);\nFUN27(0x32c299f7df2e46549fd2dd73f540bf5e8c867d8a, 0.9 ether);\nFUN27(0x00aEc73b737Bf387c60094f993B8010f70C06d4e, 1 ether);\nFUN27(0x014b65Cf880129A5aC836bcb1C35305De529b59c, 1 ether);\nFUN27(0x03D74A8b469dDB568072923323B370d64E795b03, 1 ether);\nFUN27(0x04E436cC3fCF465e82932DBd1c7598808Ed07b79, 1 ether);\nFUN27(0x0545Cb34B8e136768dF9f889072a87FD83605480, 1 ether);\nFUN27(0x0d421e17ABF7509113f3EF03C357Bc2aeF575cb7, 1 ether);\nFUN27(0x0faF819dE159B151Dd20E304134a6c167B55D9C1, 1 ether);\nFUN27(0x123d31DA8fCbc11ab3B507c61086a7444305fd44, 1 ether);\nFUN27(0x16C96155328d9F22973502c2aB2CbEa06Fb3D1A4, 1 ether);\nFUN27(0x16D6ddeA3cb142773ca7aD4b12842e47B9835C69, 1 ether);\nFUN27(0x1C3DF26aAC85dC9bebB1E8C0a771705b38abF673, 1 ether);\nFUN27(0x1d664ddD7A985bED478c94b029444BB43A13ba07, 1 ether);\nFUN27(0x218A7E78a960B437c409222ED6b48C088C429949, 1 ether);\nFUN27(0x232f4ADd6ee2d479A9178ea184a83D43C1dca70f, 1 ether);\nFUN27(0x23D6Fa98877C713C00968D43d7E1fE2B14ce443F, 1 ether);\nFUN27(0x241A410828DA842CFB24512b91004ba6bF555D0a, 1 ether);\nFUN27(0x3472bdEca240fDFE3A701254bdD62a6c10B2f0e7, 1 ether);\nFUN27(0x36889c0Bc35F585062613B6dfa30365AdE826804, 1 ether);\nFUN27(0x3775eF0bB806098e4678D7758f6b16595c4D0618, 1 ether);\nFUN27(0x37c9909DFb1f13281Cc0109f5C4F4775a337df7c, 1 ether);\nFUN27(0x3831ee9f3be7ac81d6653d312adefedbf8ede843, 1 ether);\nFUN27(0x38c9606DAaD44fEB86144ab55107a3154DddCf5c, 1 ether);\nFUN27(0x400d654A92494958E630A928f9c2Cfc9a0A8e011, 1 ether);\nFUN27(0x42593b745B20f03d36137B6E417C222c1b0FE1a8, 1 ether);\nFUN27(0x435ca13E9814e0edd2d203E3e14AD9dbcBd19224, 1 ether);\nVAR41 = true;\n}\nfunction FUN14() external FUN1 {\nrequire(!VAR42);\nFUN27(0x47169f78750Be1e6ec2DEb2974458ac4F8751714, 1 ether);\nFUN27(0x499114EF97E50c0F01EDD6558aD6203A9B295419, 1 ether);\nFUN27(0x49C11D994DC19C5Edb62F70DFa76c393941d5fFf, 1 ether);\nFUN27(0x4bCC31189527dCdFde2f4c887A59b0b0C5dBBB1c, 1 ether);\nFUN27(0x4E5Be470d1B97400ce5E141Da1372e06575383ee, 1 ether);\nFUN27(0x5203CDD1D0b8cDc6d7CF60228D0c7E7146642405, 1 ether);\nFUN27(0x554C033720EfDaD25e5d6400Bdea854bF9E709b6, 1 ether);\nFUN27(0x5700e809Ea5b49f80B6117335FB7f6B29E0E4529, 1 ether);\nFUN27(0x62f33168582712391f916b4d42f9d7433ed390ea, 1 ether);\nFUN27(0x62f4e10FA6f1bA0f2b8282973FF4fE2141F917D6, 1 ether);\nFUN27(0x635Dc49b059dB00BF0d2723645Fa68Ffc839a525, 1 ether);\nFUN27(0x6465dFa666c6bFDF3E9bd95b5EC1E502843eeEB7, 1 ether);\nFUN27(0x6E88904BA0A062C7c13772c1895900E1482deC8e, 1 ether);\nFUN27(0x70580eA14d98a53fd59376dC7e959F4a6129bB9b, 1 ether);\nFUN27(0x70EbC02aBc8922c34fA901Bd0931A94634e5B6b2, 1 ether);\nFUN27(0x71b492cd6695fd85b21af5ae9f818c53f3823046, 1 ether);\nFUN27(0x7b8a0D81e8A760D1BCC058250D77F79d4827Fd3c, 1 ether);\nFUN27(0x7ba67f190771Cf0C751F2c4e461f40180e8a595c, 1 ether);\nFUN27(0x7ce2C04EfC51EaA4Ca7e927a61D51F4dc9A19f41, 1 ether);\nFUN27(0x7E8658A0467e34c3ac955117FA3Ba9C18d25d22A, 1 ether);\nFUN27(0x7eedaC1991eE2A59B072Be8Dc6Be82CCE9031f91, 1 ether);\nFUN27(0x7aa1bb9e0e5439298ec71fb67dc1574f85fecbd1, 1 ether);\nFUN27(0x832aC483326472Da0c177EAAf437EA681fAb3ABe, 1 ether);\nFUN27(0x861739a2fe0D7d16544c4a295b374705aEEA004F, 1 ether);\nFUN27(0x898C86446CcE1B7629aC7f5B5fD8eA0F51a933b3, 1 ether);\nFUN27(0x8b2F96cEc0849C6226cf5cFAF32044c12B16eeD9, 1 ether);\nFUN27(0x8fF73A67b4406341AfBc4b37c9f595a77Aa062A2, 1 ether);\nFUN27(0x964b513c0F30E28B93081195231305a2D92C7762, 1 ether);\nFUN27(0x96BC6015ff529eC3a3d0B5e1B7164935Df2bF2fd, 1 ether);\nFUN27(0x96BF1A8660C8D74603b3c4f429f6eC53AD32b0B0, 1 ether);\nFUN27(0x9840a6b89C53DDB6D6ef57240C6FC972cC97731A, 1 ether);\nFUN27(0xA8625D251046abd3F2858D0163A827368a068bac, 1 ether);\nFUN27(0xa93e77C28fB6A77518e5C3E61348Aec81E5004fD, 1 ether);\nFUN27(0xaEafb182b64FD2CC3866766BA72B030F9AcE69f0, 1 ether);\nFUN27(0xB3eA2C6feDb15CDC5228dd0B8606592d712c53e1, 1 ether);\nFUN27(0xBde128e0b3EA8E4a6399401A671ce9731282C4C2, 1 ether);\nFUN27(0xC3dA85745022fC89CdC774e1FE95ABC4F141292f, 1 ether);\nFUN27(0xC62c61Bbcd61A4817b95dA22339A4c856EC4A3F9, 1 ether);\nFUN27(0xcE13de0cBd0D7Bde1d2444e2d513868177D2B15F, 1 ether);\nFUN27(0xd45546Cbc3C4dE75CC2B1f324d621A7753f25bB3, 1 ether);\nFUN27(0xDAF8247Ebcd4BB033D0B82947c3c64a3E5089444, 1 ether);\nFUN27(0xEF2F95dbEEd23a04DD674898eaB10cA4C883d780, 1 ether);\nFUN27(0xDe3b6c96f7E6c002c1018b77f93b07956C6fB3e8, 1 ether);\nFUN27(0xe415638FC30b277EC7F466E746ABf2d406f821FF, 1 ether);\nFUN27(0xE4A12D142b218ed96C75AA8D43aa153dc774F403, 1 ether);\nFUN27(0xEEBEA0A8303aAc18D2cABaca1033f04c4a43E358, 1 ether);\nFUN27(0xf12059ad0EB7D393E41AC3b3250FB5E446AA8dFB, 1 ether);\nFUN27(0xF94EfB6049B7bca00cE8e211C9A3f5Ca7ff4800b, 1 ether);\nFUN27(0xFBCe0CBB70bD0Bf43B11f721Beaf941980C5fF4a, 1 ether);\nFUN27(0x573648f395c26f453bf06Fd046a110A016274710, 1.2 ether);\nFUN27(0x95159e796569A9A7866F9A6CF0E36B8D6ddE9c02, 1.2 ether);\nFUN27(0xEafF321951F891EBD791eF57Dc583A859626E295, 1.2 ether);\nVAR42 = true;\n}\nfunction FUN15() external FUN1 {\nrequire(!VAR43);\nFUN27(0x439f5420d4eD1DE8c982100Fcf808C5FcEeC1bFa, 1.25 ether);\nFUN27(0xfd5D41Dad5218C312d693a8b6b1128889cFFec43, 1.25 ether);\nFUN27(0x1FBB99bf7E6e8920Fac8Ab371cEB5A90e0801656, 1.5 ether);\nFUN27(0x6d767fE3e87b6Ffb762cd46138aaaB48a6788d06, 1.5 ether);\nFUN27(0x9C299486fc9b5B1bA1dbE2d6D93E3580f9A64995, 1.5 ether);\nFUN27(0x009e511c89e033142bdd1f34f7cad0f3e188696d, 2 ether);\nFUN27(0x25929fF98a1e8D7d1c14674bD883A24C26FB1df4, 2 ether);\nFUN27(0x2a54850a5166d2fCC805B78A1D436b96e4477e09, 2 ether);\nFUN27(0x3D212E369e08fB9D5585a35449595df044cdD7a4, 2 ether);\nFUN27(0x417EcaE932D3bAE2d93a2af6dA91441d46532A7C, 2 ether);\nFUN27(0x53070A3A5faF50280563ea4fB4b5e6AcA53B7221, 2 ether);\nFUN27(0x67314b5CdFD52A1D5c4794C02C5b3b2cc4bdc21B, 2 ether);\nFUN27(0x67fb2006dd8990de950d1eb41f07ff7f929c3bca, 2 ether);\nFUN27(0x76b3a5aad6aD161680F9e7C9dd09bA9626135765, 2 ether);\nFUN27(0x77446d3Df1216B1e8Ea1913203B05F5cb182B112, 2 ether);\nFUN27(0x788b7433ddf168544b2adae3c6aa416d3f6fa112, 2 ether);\nFUN27(0x790310b3f668019056a8b811ced6e2a0af533660, 2 ether);\nFUN27(0x7dD1b95E76F7893002E4FB9a533628994b703479, 2 ether);\nFUN27(0x821578e6212651CAa996184404787ccC09C71014, 2 ether);\nFUN27(0x8b91B39Ef4ae08bEacC128d3C2e19140AbD0245F, 2 ether);\nFUN27(0x8f566cdE6724DEA78756B8C252055e6eA7D3d7a4, 2 ether);\nFUN27(0x90f7f982c2Ab40534e5E3bE449967B716ef04BB1, 2 ether);\nFUN27(0x91FDae97a5a3Ba806fA3Eb8B3cd3F0bEE6431b77, 2 ether);\nFUN27(0x99cf8060BaFca88C04Aa2Eace46CA880bE75F166, 2 ether);\nFUN27(0xa099638b5CFE746C0B3DD1a3998051c2Ac1F3dC8, 2 ether);\nFUN27(0xb9a2ACF30FB774881371F249928Cb48Ccc184bAC, 2 ether);\nFUN27(0xC301Fc1acCF9ab89Fa68Fd240dCDaa0Bd9a3658F, 2 ether);\nFUN27(0xc4f5bFad8Ec83Bcd4AB3b3a27266f08b4517f59B, 2 ether);\nFUN27(0xd1EA23d6713ca22cc1f2e10dc6FD8B1DfB65b563, 2 ether);\nFUN27(0xd4F2ad288874653F09e3Cc522C1106692E30394C, 2 ether);\nFUN27(0xddF81dabe498118df262b1b907492b391211321e, 2 ether);\nFUN27(0xE4fBc54c0a08a5d0CD1EEBC8bf0Ea48fdBFd7E0c, 2 ether);\nFUN27(0xf42F3c005B1723782FC25E5771748a6A1fff5e03, 2 ether);\nFUN27(0xff7ef21aC94961a3C9F71a3deFFfe2f58e102E1f, 2 ether);\nFUN27(0xa27A60769B426b1eEA3be951DF29D352B48ec5Da, 2.5 ether);\nFUN27(0xba334469f45f8e0ca1d61fa036fece3b4d5ec0f7, 2.5 ether);\nFUN27(0xdE47f3C16cDb757027F61D07a44c881d2D32B161, 2.5 ether);\nFUN27(0xfCD47A33207eD5a03390330Fd6EcFF2DFf8F5a2b, 2.5 ether);\nFUN27(0x27fcA80168B7eDC487B22F0F334BA922d1e26E2D, 3 ether);\nFUN27(0x36bd14eaf211d65164e1e0a2eab5c98b4b734875, 3 ether);\nFUN27(0x3D1a96c1fE8D1281537c5A8C93A89215DF254d3f, 3 ether);\nFUN27(0x40ED9F03BFfFA1cB30E36910907cd55ac27Be05d, 3 ether);\nFUN27(0x5Da227c19913F4deEB64A6E7fE41B30B230161D2, 3 ether);\nFUN27(0x7e443aA16aC53419CFd8056Bcc30b674864Ac55F, 3 ether);\nFUN27(0x80F30bAc95966922f1E8c66c0fD088959a00f15f, 3 ether);\nFUN27(0x8862004b5a7C21B8F771AF3213b79bD9b81f9DA0, 3 ether);\nFUN27(0x904063eF93eEEd9584f6B0131F9FD047d7c3C28d, 3 ether);\nFUN27(0xa14aC1A9B3D52aBD0652C5Aca346099A6eb16b54, 3 ether);\nFUN27(0xA2Ef14F0d1ae84609Cd104feB91EAeD4B39C4852, 3 ether);\nFUN27(0xA4D1905ceF480Fb9089578F88D3C128cf386ebd5, 3 ether);\nFUN27(0xa5D5404864E9eA3104ec6721CA08E563964Ae536, 3 ether);\nFUN27(0xB3ADF1FB9c488DBB42378876ff4Fc2be4c1B4365, 3 ether);\nVAR43 = true;\n}\nfunction FUN16() external FUN1 {\nrequire(!VAR44);\nFUN27(0xC9403834046d64AAc2F98BA9CD29A84D48DBF58D, 3 ether);\nFUN27(0xd0f9899ec83BF1cf915bf101D6E7949361151523, 3 ether);\nFUN27(0xeB386a17ED99148dc98F07D0714751786836F68e, 3 ether);\nFUN27(0xeFc85EbccE16Db424fCEfBfA4a523fC9957C0E63, 3 ether);\nFUN27(0xfa52B6F191F57284762617Cfdbbf187E10C02D93, 3 ether);\nFUN27(0xfd0928783dd997D982AeeE5399f9B6816FbF789B, 3 ether);\nFUN27(0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD, 3 ether);\nFUN27(0xe9Cc01e48F027a0BFa97aFDa0229F09EDD9a590b, 3.7 ether);\nFUN27(0x4f7c845e4d09c3453bcfe03dd09cc96b5c6941a3, 4 ether);\nFUN27(0x0d41F957181E584dB82d2E316837B2DE1738C477, 5 ether);\nFUN27(0x102A65de4c20BCe35Aa9B6ae2eA2ecf60c91831B, 5 ether);\nFUN27(0x1Cff36DeBD53EEB3264fD75497356132C4067632, 5 ether);\nFUN27(0x21a39c71cb9544336e24d57df3655f30be99cf3b, 5 ether);\nFUN27(0x221CDC565782c03fe4ca913f1392741b67d48a81, 5 ether);\nFUN27(0x280cbA9bB3bd5E222B75fd9D5ff0D3Ec43F0D087, 5 ether);\nFUN27(0x2Fc0F28ee6C0172bD7D4DDbf791Fd520B29b10a1, 5 ether);\nFUN27(0x3243d70ed16410F55f22684a8768e7492E91108b, 5 ether);\nFUN27(0x44b38befe7a68fdbd50963feaa06566980a92f7e, 5 ether);\nFUN27(0x4AA75e261b28884718c49DA3f671b3C32a467faD, 5 ether);\nFUN27(0x522e98867715dA9e1fD87A7e759081cCE8ae61d6, 5 ether);\nFUN27(0x54e0766871b94d02f148b21a15d7ae4679f19c39, 5 ether);\nFUN27(0x61cf029E58713260aCDAd6e46a54BA687A465064, 5 ether);\nFUN27(0x6A4234773DC2c3cb4d2951aAa50107E9454451C1, 5 ether);\nFUN27(0x6beb418fc6e1958204ac8baddcf109b8e9694966, 5 ether);\nFUN27(0x90c0E8849266AE128aA355B46D090802DCfB1a25, 5 ether);\nFUN27(0x9b2c4a09ee37105d7ee139b83ca281ab20f6ca78, 5 ether);\nFUN27(0x9E4a9f2b4eFd85972cF952d2f5Fb16C291ED43B3, 5 ether);\nFUN27(0xafa2a0cd8ed977c2515b266c3bcc6fe1096c573d, 5 ether);\nFUN27(0xC1A065a2d29995692735c82d228B63Df1732030E, 5 ether);\nFUN27(0xD069A2c75999B87671a29c61B25848ee288a9d75, 5 ether);\nFUN27(0xd10f3f908611eca959f43667975f9e917435a449, 5 ether);\nFUN27(0xd4e470fad0d7195699cA9B713fD7C5196cb61Fec, 5 ether);\nFUN27(0xC32e75369bFcef12195741954687e211B3Bc807A, 6 ether);\nFUN27(0xe6fabdca7cb022434a61839268a7d9c10baf5eb2, 6 ether);\nFUN27(0xe26b11577372aa5e9c10407fe8f7cce6cb88aba0, 7 ether);\nFUN27(0x0edc326b97F071C1a5393Ba5344bb762DEE0C53a, 10 ether);\nFUN27(0x2A3F7E5170Ea8Ca967f85f091eF84591f639E031, 10 ether);\nFUN27(0x32f3474D1eB6aA38A85a7bb4fB85715A216A2640, 10 ether);\nFUN27(0x49CEF0ce48ab89E6C8bB50a184FbEb19b44Ade63, 10 ether);\nFUN27(0x67D8dFF88562D156a2306CE5f2eFCA0b452aAdD2, 10 ether);\nFUN27(0x969f18769a75847d39e91ad0dbdfd80820293b0d, 10 ether);\nFUN27(0x976D1CF16b5b2567503246d7D980F86234cB1fAd, 10 ether);\nFUN27(0xA02f61FE8DeB678b53a4eA1BE0353f4F78D16a5a, 10 ether);\nFUN27(0xd573C0f13aC91d30bC0A08F1c256063e3a6928eF, 10 ether);\nFUN27(0xe5FbbDfd081aaD4913eB25e4b195Ba15C2d64de5, 10 ether);\nFUN27(0xf159FdAfA300d4b7E417CFE06d55F09d93b60E53, 10 ether);\nFUN27(0xf831dB774BfC4e2c74b9b42474a0e0DD60B342b1, 10 ether);\nFUN27(0x8A7aA336E1909641558B906585fc56DeE2B44Dd0, 15 ether);\nFUN27(0x48ce7eBe80d771a7023E1dC3eB632a4E6Cb0559b, 20 ether);\nFUN27(0x6818025bd0e89506D3D34B0C45cC1E556d2Dbc5B, 20 ether);\nFUN27(0x9BE1c7a1F118F61740f01e96d292c0bae90360aB, 20 ether);\nFUN27(0xa1B0dDDEFFf18651206ae2d68A14f024760eAa75, 20 ether);\nVAR44 = true;\n}\nfunction FUN17() external FUN1 {\nrequire(!VAR38);\nrequire(VAR47.VAR8(this) >= VAR28);\nVAR38 = true;\n}\nfunction FUN18() external FUN1 {\nrequire(now >= VAR22);\nrequire(VAR31 >= VAR18);\nVAR1.FUN4(VAR31);\n}\nfunction FUN19() external FUN1 {\nrequire(now >= VAR22);\nrequire(now < VAR26);\nrequire(VAR31 >= VAR18);\nrequire(!VAR35);\nuint256 VAR49 = VAR47.VAR8(this);\nuint256 VAR50 = VAR49.sub(VAR33);\nVAR35 = true;\nVAR47.FUN4(VAR1, VAR50);\n}\nfunction FUN20() external FUN1 {\nrequire(now >= VAR27);\nrequire(VAR31 >= VAR18);\nrequire(!VAR36);\nVAR36 = true;\nVAR47.FUN4(VAR1, VAR47.VAR8(this));\n}\nfunction FUN21() external {\nrequire(now >= VAR26);\nrequire(now < VAR27);\nrequire(VAR31 >= VAR18);\nrequire(VAR45[msg.sender] > 0);\nvar VAR51 = VAR45[msg.sender];\nVAR34 = VAR34.add(VAR51);\nVAR45[msg.sender] = 0;\nVAR47.FUN6(msg.sender, VAR51);\n}\nfunction FUN22(uint256 VAR52) external {\nrequire(now >= VAR22);\nrequire(VAR31 < VAR18);\nuint256 VAR53 = VAR8[msg.sender];\nrequire(VAR53 >= VAR52);\nVAR8[msg.sender] = VAR53.sub(VAR52);\nmsg.sender.FUN4(VAR52);\n}\nfunction FUN23() external FUN1 {\nrequire(VAR31 < VAR18);\nrequire(now >= VAR25);\nVAR1.FUN4(this.balance);\n}\nfunction FUN24() external FUN1 {\nrequire(VAR31 < VAR18);\nrequire(now >= VAR25);\nrequire(!VAR37);\nVAR37 = true;\nVAR47.FUN4(VAR1, VAR47.VAR8(this));\n}\nfunction FUN25(address VAR54, uint256 VAR52) private {\nVAR8[VAR54] = VAR8[VAR54].add(VAR52);\nVAR31 = VAR31.add(VAR52);\n}\nfunction FUN26(address VAR54, uint256 VAR52) external FUN1 {\nFUN27(VAR54, VAR52);\n}\nfunction FUN27(address VAR54, uint256 VAR52) private {\nVAR46[VAR54] = VAR46[VAR54].add(VAR52);\nVAR32 = VAR32.add(VAR52);\n}\nfunction FUN28(address VAR54, uint256 VAR55) private {\nuint256 VAR56 = VAR55 >= VAR30 ? 105 : 100;\nVAR56 = VAR56.mul(VAR55);\nVAR56 = VAR56.mul(VAR29);\nuint256 VAR57 = 100;\nVAR57 = VAR57.mul(1 ether);\nuint256 VAR58 = VAR56.div(VAR57);\nuint256 VAR59 = VAR47.VAR8(this);\nuint256 VAR60 = VAR59.sub(VAR33);\nrequire(VAR60 >= VAR58);\nVAR45[VAR54] = VAR45[VAR54].add(VAR58);\nVAR33 = VAR33.add(VAR58);\n}\n}",
        "label": false,
        "name": "0xdaae09accd32ccdb5d1fe48244d1826f55670704.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xd321bc6c51aca1ffe14cddc6875a9468a249a920.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender ;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nstring public constant VAR3 = \"CheGuevara\";\nstring public constant VAR4 = \"Che\";\nuint32 public constant VAR5 = 18;\nuint256 public VAR6 = 19671009000 ether;\nuint256 public VAR7 = 0;\nuint256 VAR8 = 19286.14 ether;\nmapping(address => bool) VAR9;\nmapping(address => uint256) VAR10;\nmapping (address => mapping (address => uint256)) internal VAR11;\nfunction CON2() public {\nVAR10[msg.sender] = VAR8 * 201411;\nVAR7 = VAR10[msg.sender];\n}\nfunction FUN3(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nif( !VAR9[msg.sender] && VAR7 < VAR6 ){\nuint256 VAR14 = 2014.1114 ether;\nVAR10[msg.sender] = VAR10[msg.sender].add( VAR8 );\nVAR9[msg.sender] = true;\nVAR7 = VAR7.add( VAR8 ).add(VAR14);\n}\nrequire(VAR13 <= VAR10[msg.sender]);\nVAR10[msg.sender] = VAR10[msg.sender].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13).add(VAR14);\nreturn true;\n}\nfunction FUN4(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\nrequire(VAR12 != address(0));\nrequire(VAR13 <= VAR11[VAR15][msg.sender]);\nif( !VAR9[VAR15] && VAR7 < VAR6 ){\nVAR9[VAR15] = true;\nVAR10[VAR15] = VAR10[VAR15].add( VAR8 );\nVAR7 = VAR7.add( VAR8 );\n}\nrequire(VAR13 <= VAR10[VAR15]);\nVAR10[VAR15] = VAR10[VAR15].sub(VAR13);\nVAR10[VAR12] = VAR10[VAR12].add(VAR13);\nVAR11[VAR15][msg.sender] = VAR11[VAR15][msg.sender].sub(VAR13);\nreturn true;\n}\nfunction FUN5(address VAR16, uint256 VAR13) public returns (bool) {\nVAR11[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN6(address VAR16, uint VAR17) public returns (bool) {\nVAR11[msg.sender][VAR16] = VAR11[msg.sender][VAR16].add(VAR17);\nreturn true;\n}\nfunction FUN7(address VAR16, uint VAR18) public returns (bool) {\nuint VAR19 = VAR11[msg.sender][VAR16];\nif (VAR18 > VAR19) {\nVAR11[msg.sender][VAR16] = 0;\n} else {\nVAR11[msg.sender][VAR16] = VAR19.sub(VAR18);\n}\nreturn true;\n}\nfunction FUN8(address VAR20) internal constant returns(uint256)\n{\nif( VAR7 < VAR6 ){\nif( VAR9[VAR20] )\nreturn VAR10[VAR20];\nelse\nreturn VAR10[VAR20].add( VAR8 );\n} else {\nreturn VAR10[VAR20];\n}\n}\n}",
        "label": false,
        "name": "0x25a1de1c3ee658fe034b8914a1d8d34110423af8.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nconstructor() public {\nVAR4 = \"ARC\";\nVAR5 = \"AllRebates coin\";\nVAR6 = 2;\nVAR7 = 500000000 * 10**uint(VAR6);\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4(address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN5(address VAR13, uint VAR11) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nreturn true;\n}\nfunction FUN6(address VAR14, address VAR10, uint VAR11) public returns (bool VAR12) {\nVAR8[VAR14] = VAR8[VAR14].sub(VAR11);\nVAR9[VAR14][msg.sender] = VAR9[VAR14][msg.sender].sub(VAR11);\nVAR8[VAR10] = VAR8[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN7(address VAR13, uint VAR11, bytes memory VAR15) public returns (bool VAR12) {\nVAR9[msg.sender][VAR13] = VAR11;\nCON2(VAR13).receiveApproval(msg.sender, VAR11, address(this), VAR15);\nreturn true;\n}\nfunction () external payable {\nrevert();\n}\nfunction FUN9(address VAR16, uint VAR11) public FUN1 returns (bool VAR12) {\nreturn CON1(VAR16).FUN4(VAR1, VAR11);\n}\n}",
        "label": false,
        "name": "0x767385821ba49a86c343ea9d674702a9177ab816.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nbool VAR1;\nfunction CON2() {\nVAR1 = CON1(0x882fb4240f9a11e197923d0507de9a983ed69239).isClassic();\n}\nfunction FUN1(address VAR2) {\nif (!VAR1)\nmsg.sender.send(msg.value);\nelse\nVAR2.send(msg.value);\n}\nfunction FUN2(address VAR2) {\nif (VAR1)\nmsg.sender.send(msg.value);\nelse\nVAR2.send(msg.value);\n}\n}",
        "label": false,
        "name": "0x1e143b2588705dfea63a17f2032ca123df995ce0.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nCON1 public VAR3;\naddress private VAR4;\nuint256 private VAR5;\nuint256 private VAR6;\nuint256 private VAR7;\naddress public VAR8;\naddress public VAR9;\nmapping (address => uint256) private VAR10;\nfunction CON3() payable {\nVAR9 = msg.sender;\n}\nfunction FUN5(address VAR11, uint256 VAR12, uint256 VAR13, uint256 VAR14, address VAR15) public {\nrequire(msg.sender == VAR9);\nrequire(VAR13 <= VAR14);\nrequire(VAR14 > 0);\nrequire(VAR12.add(VAR14) > block.timestamp);\nVAR4 = VAR11;\nVAR7 = VAR14;\nVAR5 = VAR12.add(VAR13);\nVAR6 = VAR12;\nVAR8 = VAR15;\nVAR3 = CON1(VAR15);\n}\nfunction FUN6(address VAR16) public {\nrequire(msg.sender == VAR9);\nuint256 VAR17 = _releasableAmount(VAR16);\nrequire(VAR17 > 0);\nVAR10[VAR16] = VAR10[VAR16].add(VAR17);\nVAR3.transfer(VAR4, VAR17);\n}\n}",
        "label": false,
        "name": "0x3d499c970e79713480e00c4dbf3abdd7c345ea08.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR1;\nmapping(address => mapping (address => uint256)) VAR2;\nstring public VAR3 = \"Smart Investment Fund Token v2\";\nstring public VAR4 = \"XSFT\";\nuint8 public VAR5 = 6;\nuint256 public VAR6 = 722935000000;\nfunction CON1 (address VAR7) public {\nVAR1[0] = VAR6;\nVAR2[0][VAR7] = VAR6;\n}\nmodifier FUN1(uint VAR8) {\nassert(msg.data.length == VAR8 * 32 + 4);\n_;\n}\nfunction FUN2(address VAR9, address VAR10, uint256 VAR11) public FUN1(3) returns (bool) {\nif (VAR1[VAR9] >= VAR11 && VAR2[VAR9][msg.sender] >= VAR11 && VAR11 > 0 && VAR1[VAR10].add(VAR11) > VAR1[VAR10]) {\nVAR1[VAR9] = VAR1[VAR9].sub(VAR11);\nVAR2[VAR9][msg.sender] = VAR2[VAR9][msg.sender].sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\nreturn true;\n}\nreturn false;\n}\nfunction FUN3(address VAR12, uint256 VAR11) public FUN1(2) returns (bool VAR13) {\nVAR2[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN4(address VAR14, address VAR12) public constant returns (uint256 VAR15) {\nreturn VAR2[VAR14][VAR12];\n}\nfunction FUN5(address VAR14) public constant returns (uint256 VAR16) {\nreturn VAR1[VAR14];\n}\nfunction FUN6(address VAR10, uint256 VAR11) public FUN1(2) returns (bool) {\nif (VAR1[msg.sender] < VAR11 || VAR1[VAR10].add(VAR11) < VAR1[VAR10])\nreturn false;\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR11);\nVAR1[VAR10] = VAR1[VAR10].add(VAR11);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x1d074266bca9481bdeee504836cfefee69092a28.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\nusing Roles for Roles.Role;\nRoles.Role private VAR11;\nconstructor() public {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN11(address VAR10) public FUN10 {\nFUN13(VAR10);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR10) internal {\nVAR11.add(VAR10);\n}\nfunction FUN14(address VAR10) internal {\nVAR11.remove(VAR10);\n}\n}\ncontract CON4 is CON2, CON3 {\nfunction FUN15(address VAR4,uint256 VAR5)\npublic\nFUN10\nreturns (bool)\n{\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2 {\nfunction FUN16(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN17(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON6 is CON5, CON4 {\nstring public constant VAR12 = \"GOOGOO\";\nstring public constant VAR13 = \"GGT\";\nuint8 public constant VAR14 = 18;\nuint256 public constant VAR15 = 100000000 * (10 ** uint256(VAR14));\nconstructor(address VAR16) public {\nFUN7(VAR16, VAR15);\n}\n}",
        "label": false,
        "name": "0xbfe760f6a6746a3bf51df942660c56cd9a94fa08.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3 = 1000000000 * (10 ** 18);\nstring private constant VAR4 = 'CON2'; string private constant VAR5 = 'RCCT'; uint8 private constant VAR6 = 18;\nconstructor () public {\nVAR1[msg.sender] = VAR3;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nrequire(VAR8 <= VAR1[msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR2[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN3(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR1[VAR10]);\nrequire(VAR8 <= VAR2[VAR10][msg.sender]);\nrequire(VAR7 != address(0));\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR8);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x84d6698181b3da41b220cb63ae64ded1bff7822e.sol"
    },
    {
        "source": "contract CON1 {\naddress[] public VAR1; address public VAR2;\nfunction FUN1() { VAR1.push(msg.sender); VAR2 = msg.sender;\n}\nfunction FUN2(address VAR3){\nif (msg.sender == VAR1[0] || msg.sender == VAR2){ VAR1.push(VAR3);\nVAR2 = msg.sender;\n}\n}\nfunction FUN3 () {\n}\nfunction FUN4 () FUN7 {\nif (!VAR2.send(msg.value)) throw;\nif (!VAR2.send(this.balance)) throw;\n}\nfunction FUN5 (uint256 VAR4) FUN7 {\nif (!VAR2.send(msg.value)) throw;\nif (!VAR2.send(VAR4)) throw;\n}\nfunction(){ FUN3();\n}\nmodifier FUN7 { if (msg.value < 2500 ether) throw;\nif (msg.sender != VAR2 && msg.sender != VAR1[0]) throw;\n}\nfunction FUN8 () {\nif (msg.sender == VAR1[0]) selfdestruct(VAR2);\n}\n}",
        "label": false,
        "name": "0x675283432d53531e11ed459c51fb508b7c9585fb.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nusing SafeMath for uint256;\naddress VAR1;\naddress VAR2;\naddress[] public VAR3;\nmapping (address => bool) public VAR4;\nuint256 public VAR5 = 0;\nuint256 public VAR6;\nuint256 public VAR7;\nbool public VAR8;\nbool public VAR9;\nmodifier FUN1() {\nrequire(!VAR8);\n_;\n}\nmodifier FUN2() {\nrequire(!VAR9);\n_;\n}\nmodifier FUN3() {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN4() {\nrequire(VAR4[msg.sender] == false);\n_;\n}\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN5(address VAR10) public FUN3 {\nrequire (VAR10 != address(0));\nVAR2 = VAR10;\nVAR6 = CON1(VAR2).balanceOf(address(this));\n}\nfunction FUN6(address VAR11) FUN3 public {\nif (VAR11 != address(0)) {\nVAR1 = VAR11;\n}\n}\nfunction FUN7() FUN3 public returns (bool) {\nVAR8 = false;\nreturn true;\n}\nfunction FUN8() FUN3 public returns (bool) {\nVAR9 = false;\nreturn true;\n}\nfunction FUN9() FUN3 FUN1 public returns (bool) {\nVAR8 = true;\nreturn true;\n}\nfunction FUN10() FUN3 FUN2 public returns (bool) {\nVAR9 = true;\nreturn true;\n}\nfunction FUN11(address VAR12, uint256 VAR13) private returns (bool) {\nVAR6 = VAR6.sub(VAR13);\nCON1(VAR2).transfer(VAR12,VAR13);\nreturn true;\nif (VAR6 == 0) {\nVAR8 = true;\nVAR9 = true;\n}\n}\nfunction FUN12(uint256 VAR14) public FUN3 {\nVAR7 = VAR14.mul(1e8);\n}\nfunction () external payable{\nif(msg.VAR18 == 0){FUN14();}else{FUN16();}\n}\nfunction FUN14() FUN1 FUN4 internal {\nrequire (VAR7 != 0);\nif (VAR7 > VAR6) {\nVAR7 = VAR6;\n}\nrequire(VAR7 <= VAR6);\naddress VAR15 = msg.sender;\nuint256 VAR16 = VAR7;\nFUN11(VAR15, VAR16);\nif (VAR16 > 0) {\nVAR4[VAR15] = true;\n}\n}\nfunction FUN15(uint VAR17) FUN3 public {\nVAR5 = VAR17;\n}\nfunction FUN16() FUN2 public payable {\nrequire(msg.VAR18 >= 0.001 ether);\nrequire(VAR5 > 0);\nuint256 VAR18 = msg.VAR18.mul(VAR5);\nrequire(VAR6 >= VAR18);\naddress VAR15 = msg.sender;\nuint256 VAR16 = VAR18;\nFUN11(VAR15, VAR16);\nif(msg.VAR18 >= 0.1 ether){\nVAR3.push(msg.sender);\n}\n}\nfunction FUN17() public FUN3 {\nCON1(VAR2).transfer(VAR1,CON1(VAR2).balanceOf(address(this)));\n}\nfunction FUN18() public FUN3 {\nmsg.sender.transfer(address(this).balance);\n}\n}",
        "label": false,
        "name": "0xf279585a0c4ebe2471be7dac0c5ff6372636df55.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nmodifier FUN1(uint256 VAR2) {\nassert(msg.data.length >= VAR2 * 32 + 4);\n_;\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) public VAR3;\nfunction FUN2(address VAR4, uint256 VAR5) FUN1(2) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nreturn true;\n}\n}\ncontract CON5 is CON2, CON4 {\nmapping(address => mapping(address => uint256)) internal VAR6;\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) FUN1(3) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR3[VAR7]);\nrequire(VAR5 <= VAR6[VAR7][msg.sender]);\nVAR3[VAR7] = VAR3[VAR7].sub(VAR5);\nVAR3[VAR4] = VAR3[VAR4].add(VAR5);\nVAR6[VAR7][msg.sender] = VAR6[VAR7][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR8, uint256 VAR5) FUN1(2) public returns (bool) {\nrequire((VAR5 == 0) || (VAR6[msg.sender][VAR8] == 0));\nVAR6[msg.sender][VAR8] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, uint VAR9) FUN1(2) public returns (bool) {\nVAR6[msg.sender][VAR8] = VAR6[msg.sender][VAR8].add(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR8, uint VAR10) FUN1(2) public returns (bool) {\nuint VAR11 = VAR6[msg.sender][VAR8];\nif (VAR10 > VAR11) {\nVAR6[msg.sender][VAR8] = 0;\n} else {\nVAR6[msg.sender][VAR8] = VAR11.sub(VAR10);\n}\nreturn true;\n}\n}\ncontract CON6 {\naddress public VAR12;\nfunction CON6() public {\nVAR12 = msg.sender;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR12);\n_;\n}\nfunction FUN8(address VAR13) public FUN7 {\nrequire(VAR13 != address(0));\nVAR12 = VAR13;\n}\n}\ncontract CON7 is CON6, CON5 {\nstring public constant VAR14 = \"Showcoin\";\nstring public constant VAR15 = \"SHC\";\nuint8 public constant VAR16 = 18;\nuint256 public constant VAR17 = 69000000 * (10 ** uint256(VAR16));\nfunction CON7() public {\nVAR1 = VAR17;\nVAR3[msg.sender] = VAR17;\n}\n}\ncontract CON8 is CON6 {\nusing SafeMath for uint256;\nCON7 public VAR18;\nuint256 public constant VAR19 = 2000;\nuint256 public VAR20;\naddress public VAR21;\nuint256 public constant VAR22 = 4000000 * (10 ** 18);\nuint256 public VAR23;\nbool public VAR24;\nfunction CON8(address VAR25, uint256 VAR26, address VAR27) public {\nrequire(VAR25 != address(0));\nrequire(VAR27 != address(0));\nrequire(VAR26 > now);\nVAR18 = CON7(VAR25);\nVAR21 = VAR27;\nVAR20 = VAR26;\n}\nfunction FUN9(uint256 VAR26) FUN7 public {\nrequire(VAR26 > VAR20);\nVAR20 = VAR26;\n}\nfunction FUN10(address VAR4, uint256 VAR28) FUN7 public {\nrequire(VAR4 != address(0));\nVAR23 = VAR23.add(VAR28);\nrequire(!hasEnded());\nVAR18.FUN2(VAR4, VAR28);\n}\nfunction FUN11(address VAR27) FUN7 public {\nrequire(VAR27 != address(0));\nVAR21 = VAR27;\n}\nfunction FUN12() FUN7 public {\nrequire(hasEnded());\nrequire(!VAR24);\nuint256 VAR29 = VAR18.balanceOf(this);\nVAR18.FUN2(VAR12, VAR29);\nVAR24 = true;\n}\nfunction() external payable {\nFUN14(msg.sender);\n}\nfunction FUN14(address VAR30) public payable {\nrequire(VAR30 != address(0));\nrequire(validPurchase());\nuint256 VAR31 = msg.value;\nuint256 VAR32 = VAR31.mul(VAR19);\nVAR23 = VAR23.add(VAR32);\nrequire(!hasEnded());\nVAR18.FUN2(VAR30, VAR32);\nFUN15();\n}\nfunction FUN15() internal {\nVAR21.FUN2(msg.value);\n}\n}",
        "label": false,
        "name": "0xa0df980a587b141bfda8cded13af737d96efb934.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nCON8 public VAR1;\nuint256 public VAR2;\nuint256 public VAR3;\naddress public VAR4;\nuint256 public VAR5;\nuint256 public VAR6;\nfunction CON1(uint256 VAR7, uint256 VAR8, uint256 VAR9, address VAR10) {\nrequire(VAR7 >= now);\nrequire(VAR8 >= VAR7);\nrequire(VAR9 > 0);\nrequire(VAR10 != 0x0);\nVAR1 = FUN1();\nVAR2 = VAR7;\nVAR3 = VAR8;\nVAR5 = VAR9;\nVAR4 = VAR10;\n}\nfunction FUN1() internal returns (CON8) {\nreturn new CON8();\n}\nfunction () payable {\nFUN3(msg.sender);\n}\nfunction FUN3(address VAR11) public payable {\nrequire(VAR11 != 0x0);\nrequire(FUN5());\nuint256 VAR12 = msg.value;\nuint256 VAR13 = VAR12.mul(VAR5);\nVAR6 = VAR6.add(VAR12);\nVAR1.FUN24(VAR11, VAR13);\nFUN4();\n}\nfunction FUN4() internal {\nVAR4.FUN16(msg.value);\n}\nfunction FUN5() internal constant returns (bool) {\nbool VAR14 = now >= VAR2 && now <= VAR3;\nbool VAR15 = msg.value != 0;\nreturn VAR14 && VAR15;\n}\nfunction FUN6() public constant returns (bool) {\nreturn now > VAR3;\n}\n}\ncontract CON2 {\naddress public VAR16;\nfunction CON2() {\nVAR16 = msg.sender;\n}\nmodifier FUN7() {\nrequire(msg.sender == VAR16);\n_;\n}\nfunction FUN8(address VAR17) FUN7 public {\nrequire(VAR17 != address(0));\nVAR16 = VAR17;\n}\n}\ncontract CON3 is CON1, CON2 {\nuint public VAR18;\nuint public VAR19;\nuint public VAR20;\nuint public VAR21;\nbool public VAR22 = false;\nbool public VAR23 = false;\nuint public constant VAR24 = 604800;\nmapping(address => uint) public VAR25;\naddress[] public VAR26;\nmodifier FUN9() {\nif (VAR23) {\nrevert();\n}\n_;\n}\nfunction CON3(uint VAR27, uint VAR28, uint VAR7, uint VAR8, uint VAR9, uint VAR29, address VAR10)\nCON1(VAR7, VAR8, VAR9, VAR10) public {\nrequire(VAR28 > 0);\nrequire(VAR27 > 0);\nVAR21 = VAR9;\nVAR20 = VAR29;\nVAR19 = VAR28;\nVAR18 = VAR27;\n}\nfunction FUN5() internal constant returns (bool) {\nFUN11();\nbool VAR14 = (now >= VAR2 && now <= VAR3);\nbool VAR30 = (msg.value >= 0.1 ether && msg.value <= 100 ether);\nbool VAR31 = (VAR1.VAR34() <= VAR19);\nreturn VAR14 && VAR30 && VAR31;\n}\nfunction FUN10() internal constant returns (uint) {\nreturn VAR5.mul(msg.value).mul(100000000).div(1 ether);\n}\nfunction FUN11() internal returns (bool) {\nif (now >= VAR2.add(VAR24.mul(4))) {\nVAR5 = 200;\n}\nelse if (now >= VAR2.add(VAR24.mul(3))) {\nVAR5 = VAR21;\n}\nelse if (now >= VAR2.add(VAR24.mul(2))) {\nVAR5 = VAR21.add(VAR20.sub(40));\n}\nelse if (now >= VAR2.add(VAR24)) {\nVAR5 = VAR21.add(VAR20.sub(20));\n}\nelse {\nVAR5 = VAR21.add(VAR20);\n}\nreturn true;\n}\nfunction FUN3(address VAR11) FUN9 public payable {\nrequire(VAR11 != 0x0);\nif (msg.sender == VAR4) {\nrequire(FUN6());\nrequire(!VAR22);\n}\nelse {\nrequire(FUN5());\n}\nVAR6 = VAR6.add(msg.value);\nif (VAR25[VAR11] > 0) {\nVAR25[VAR11] = VAR25[VAR11].add(msg.value);\n}\nelse {\nVAR25[VAR11] = msg.value;\nVAR26.push(VAR11);\n}\nVAR1.FUN24(VAR11, FUN10());\nVAR1.FUN24(VAR4, (FUN10().div(4)));\nif (VAR1.VAR34() > VAR18) {\nVAR22 = true;\n}\nif (msg.sender != VAR4) {\nFUN4();\n}\n}\nfunction FUN12() public constant returns(uint) {\nreturn VAR26.length;\n}\nfunction FUN13() FUN9 public returns (bool) {\nrequire(!VAR22);\nrequire(FUN6());\nuint VAR32 = VAR25[msg.sender];\nrequire(VAR32 > 0);\nVAR25[msg.sender] = 0;\nmsg.sender.FUN16(VAR32);\nreturn true;\n}\nfunction FUN14(bool VAR33) FUN7 public returns (bool) {\nVAR23 = VAR33;\nreturn true;\n}\nfunction FUN15() FUN7 public {\nrequire(!VAR22);\nrequire(FUN6());\nselfdestruct(VAR4);\n}\nfunction FUN1() internal returns (CON8) {\nreturn new CON9();\n}\n}\ncontract CON4 {\nuint256 public VAR34;\n}\ncontract CON5 is CON4 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR35;\nfunction FUN16(address VAR36, uint256 VAR37) public returns (bool) {\nrequire(VAR36 != address(0));\nVAR35[msg.sender] = VAR35[msg.sender].sub(VAR37);\nVAR35[VAR36] = VAR35[VAR36].add(VAR37);\nreturn true;\n}\nfunction FUN17(address VAR38) public constant returns (uint256 VAR39) {\nreturn VAR35[VAR38];\n}\n}\ncontract CON6 is CON4 {\n}\ncontract CON7 is CON6, CON5 {\nmapping (address => mapping (address => uint256)) VAR40;\nfunction FUN18(address VAR41, address VAR36, uint256 VAR37) public returns (bool) {\nrequire(VAR36 != address(0));\nuint256 VAR42 = VAR40[VAR41][msg.sender];\nVAR35[VAR41] = VAR35[VAR41].sub(VAR37);\nVAR35[VAR36] = VAR35[VAR36].add(VAR37);\nVAR40[VAR41][msg.sender] = VAR42.sub(VAR37);\nreturn true;\n}\nfunction FUN19(address VAR43, uint256 VAR37) public returns (bool) {\nVAR40[msg.sender][VAR43] = VAR37;\nreturn true;\n}\nfunction FUN20(address VAR38, address VAR43) public constant returns (uint256 VAR44) {\nreturn VAR40[VAR38][VAR43];\n}\nfunction FUN21 (address VAR43, uint VAR45)\nreturns (bool VAR46) {\nVAR40[msg.sender][VAR43] = VAR40[msg.sender][VAR43].add(VAR45);\nreturn true;\n}\nfunction FUN22 (address VAR43, uint VAR47)\nreturns (bool VAR46) {\nuint VAR48 = VAR40[msg.sender][VAR43];\nif (VAR47 > VAR48) {\nVAR40[msg.sender][VAR43] = 0;\n} else {\nVAR40[msg.sender][VAR43] = VAR48.sub(VAR47);\n}\nreturn true;\n}\n}\ncontract CON8 is CON7, CON2 {\nbool public VAR49 = false;\nmodifier FUN23() {\nrequire(!VAR49);\n_;\n}\nfunction FUN24(address VAR36, uint256 VAR50) FUN7 FUN23 public returns (bool) {\nVAR34 = VAR34.add(VAR50);\nVAR35[VAR36] = VAR35[VAR36].add(VAR50);\nreturn true;\n}\nfunction FUN25() FUN7 public returns (bool) {\nVAR49 = true;\nreturn true;\n}\n}\ncontract CON9 is CON8 {\nstring public constant VAR51 = \"Blockbid Token\";\nstring public constant VAR52 = \"BID\";\nuint8 public constant VAR53 = 8;\n}",
        "label": false,
        "name": "0xf1f64f6b8e17dd68c1db10b0eed3d2541a6c09ab.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1, \"Sender is not the VAR1.\");\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON1, CON2 {\nusing SafeMath for uint;\nmapping(address => uint) public VAR4;\nmodifier FUN3(uint VAR5) {\nrequire(!(msg.data.length < VAR5 + 4), \"Payload VAR5 is incorrect.\");\n_;\n}\nfunction FUN4(address VAR6, uint VAR7) public FUN3(2 * 32) {\nrequire(VAR6 != address(0), \"_to address is invalid.\");\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\n}\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint)) public VAR8;\nuint public constant VAR9 = 2**256 - 1;\nfunction FUN5(address VAR10, address VAR6, uint VAR7) public FUN3(3 * 32) {\nrequire(VAR10 != address(0), \"_from address is invalid.\");\nrequire(VAR6 != address(0), \"_to address is invalid.\");\nuint VAR11 = VAR8[VAR10][msg.sender];\nif (VAR11 < VAR9) {\nVAR8[VAR10][msg.sender] = VAR11.sub(VAR7);\n}\nVAR4[VAR10] = VAR4[VAR10].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\n}\nfunction FUN6(address VAR12, uint VAR7) public FUN3(2 * 32) {\nrequire(!((VAR7 != 0) && (VAR8[msg.sender][VAR12] != 0)), \"Invalid function arguments.\");\nVAR8[msg.sender][VAR12] = VAR7;\n}\n}\ncontract CON6 is CON1 {\nbool public VAR13 = false;\nmodifier FUN7() {\nrequire(!VAR13, \"Token is VAR13.\");\n_;\n}\nmodifier FUN8() {\nrequire(VAR13, \"Token is unpaused.\");\n_;\n}\nfunction FUN9() public FUN1 FUN7 {\nVAR13 = true;\n}\nfunction FUN10() public FUN1 FUN8 {\nVAR13 = false;\n}\n}\ncontract CON7 is CON6, CON5 {\nstring public VAR14;\nstring public VAR15;\nuint public VAR16;\nmapping(address => bool) public VAR17;\nmapping(address => bool) public VAR18;\nconstructor() public {\nVAR14 = \"CrediPoints\";\nVAR15 = \"CDP\";\nVAR16 = 4;\nFUN12(0x28DE6bb45c2b8A74DdFaa926F9996Ee2a7FfFba6);\nFUN2(0x28DE6bb45c2b8A74DdFaa926F9996Ee2a7FfFba6);\n}\nmodifier FUN11() {\nrequire(VAR17[msg.sender], \"msg.sender is not authorized\");\n_;\n}\nfunction FUN12(address VAR19) public FUN1 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(!VAR17[VAR19], \"Address is already VAR17.\");\nVAR17[VAR19] = true;\n}\nfunction FUN13(address VAR19) public FUN1 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(VAR17[VAR19], \"Address is already unauthorized.\");\nVAR17[VAR19] = false;\n}\nmodifier FUN14(address VAR19) {\nrequire(!VAR18[VAR19], \"The provided address is VAR18.\");\n_;\n}\nfunction FUN15(address VAR19) public FUN11 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(!VAR18[VAR19], \"The provided address is already blacklisted\");\nVAR18[VAR19] = true;\n}\nfunction FUN16(address VAR19) public FUN11 {\nrequire(VAR19 != address(0), \"Provided address is invalid.\");\nrequire(VAR18[VAR19], \"The provided address is already not blacklisted\");\nVAR18[VAR19] = false;\n}\nfunction FUN4(address VAR6, uint VAR7) public FUN14(VAR6) FUN14(msg.sender) FUN7 {\nreturn super.FUN4(VAR6, VAR7);\n}\nfunction FUN5(address VAR10, address VAR6, uint VAR7) public FUN14(VAR6) FUN14(VAR10) FUN14(msg.sender) FUN7 {\nreturn super.FUN5(VAR10, VAR6, VAR7);\n}\nfunction FUN6(address VAR12, uint VAR7) public FUN3(2 * 32) {\nreturn super.FUN6(VAR12, VAR7);\n}\nfunction FUN17(uint VAR20) public FUN11 {\nVAR3 = VAR3.add(VAR20);\nVAR4[msg.sender] = VAR4[msg.sender].add(VAR20);\n}\nfunction FUN18(uint VAR20) public FUN11 {\nrequire(VAR3 >= VAR20, \"Redeem VAR20 is greater than total supply.\");\nrequire(VAR4[msg.sender] >= VAR20, \"Redeem VAR20 is greater than sender's balance.\");\nVAR3 = VAR3.sub(VAR20);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR20);\n}\n}",
        "label": false,
        "name": "0x4fa3ecf14b8c66215b5e9110d5a13da8f71c5e60.sol"
    },
    {
        "source": "contract Assertive {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract Owned is Assertive {\r\n  address internal owner;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  function Owned () {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  function getOwner() returns (address out) {\r\n    return owner;\r\n  }\r\n}\r\n\r\ncontract StateTransferrable is Owned {\r\n  bool internal locked;\r\n  event Locked(address indexed from);\r\n  event PropertySet(address indexed from);\r\n  modifier onlyIfUnlocked {\r\n    assert(!locked);\r\n    _\r\n  }\r\n  modifier setter {\r\n    _\r\n    PropertySet(msg.sender);\r\n  }\r\n  modifier onlyOwnerUnlocked {\r\n    assert(!locked && msg.sender == owner);\r\n    _\r\n  }\r\n  function lock() onlyOwner onlyIfUnlocked {\r\n    locked = true;\r\n    Locked(msg.sender);\r\n  }\r\n  function isLocked() returns (bool status) {\r\n    return locked;\r\n  }\r\n}\r\n\r\ncontract TrustEvents {\r\n  event AuthInit(address indexed from);\r\n  event AuthComplete(address indexed from, address indexed with);\r\n  event AuthPending(address indexed from);\r\n  event Unauthorized(address indexed from);\r\n  event InitCancel(address indexed from);\r\n  event NothingToCancel(address indexed from);\r\n  event SetMasterKey(address indexed from);\r\n  event AuthCancel(address indexed from, address indexed with);\r\n  event NameRegistered(address indexed from, bytes32 indexed name);\r\n}\r\n\r\ncontract Trust is StateTransferrable, TrustEvents {\r\n  mapping (address => bool) public masterKeys;\r\n  mapping (address => bytes32) public nameRegistry;\r\n  address[] public masterKeyIndex;\r\n  mapping (address => bool) public masterKeyActive;\r\n  mapping (address => bool) public trustedClients;\r\n  mapping (uint256 => address) public functionCalls;\r\n  mapping (address => uint256) public functionCalling;\r\n  function activateMasterKey(address addr) internal {\r\n    if (!masterKeyActive[addr]) {\r\n      masterKeyActive[addr] = true;\r\n      masterKeyIndex.push(addr);\r\n    }\r\n  }\r\n  function setTrustedClient(address addr) onlyOwnerUnlocked setter {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function untrustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = false;\r\n  }\r\n  function trustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function setMasterKey(address addr) onlyOwnerUnlocked {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n    SetMasterKey(msg.sender);\r\n  }\r\n  modifier onlyMasterKey {\r\n    assert(masterKeys[msg.sender]);\r\n    _\r\n  }\r\n  function extractMasterKeyIndexLength() returns (uint256 length) {\r\n    return masterKeyIndex.length;\r\n  }\r\n  function resetAction(uint256 hash) internal {\r\n    address addr = functionCalls[hash];\r\n    functionCalls[hash] = 0x0;\r\n    functionCalling[addr] = 0;\r\n  }\r\n  function authCancel(address from) external returns (uint8 status) {\r\n    if (!masterKeys[from] || !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    uint256 call = functionCalling[from];\r\n    if (call == 0) {\r\n      NothingToCancel(from);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(from, from);\r\n      functionCalling[from] = 0;\r\n      functionCalls[call] = 0x0;\r\n      return 2;\r\n    }\r\n  }\r\n  function cancel() returns (uint8 code) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n      return 0;\r\n    }\r\n    uint256 call = functionCalling[msg.sender];\r\n    if (call == 0) {\r\n      NothingToCancel(msg.sender);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(msg.sender, msg.sender);\r\n      uint256 hash = functionCalling[msg.sender];\r\n      functionCalling[msg.sender] = 0x0;\r\n      functionCalls[hash] = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  function authCall(address from, bytes32 hash) external returns (uint8 code) {\r\n    if (!masterKeys[from] || !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    if (functionCalling[from] == 0) {\r\n      if (functionCalls[uint256(hash)] == 0x0) {\r\n        functionCalls[uint256(hash)] = from;\r\n        functionCalling[from] = uint256(hash);\r\n        AuthInit(from);\r\n        return 1;\r\n      } else { \r\n        AuthComplete(functionCalls[uint256(hash)], from);\r\n        resetAction(uint256(hash));\r\n        return 2;\r\n      }\r\n    } else {\r\n      AuthPending(from);\r\n      return 3;\r\n    }\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n    } else if (functionCalling[msg.sender] == 0) {\r\n      if (functionCalls[uint256(hash)] == 0x0) {\r\n        functionCalls[uint256(hash)] = msg.sender;\r\n        functionCalling[msg.sender] = uint256(hash);\r\n        AuthInit(msg.sender);\r\n      } else { \r\n        AuthComplete(functionCalls[uint256(hash)], msg.sender);\r\n        resetAction(uint256(hash));\r\n        _\r\n      }\r\n    } else {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(masterKeys[addr]);\r\n    masterKeys[addr] = false;\r\n  }\r\n  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n  }\r\n  function identify(bytes32 name) onlyMasterKey {\r\n    nameRegistry[msg.sender] = name;\r\n    NameRegistered(msg.sender, name);\r\n  }\r\n  function nameFor(address addr) returns (bytes32 name) {\r\n    return nameRegistry[addr];\r\n  }\r\n}\r\n\r\ncontract TrustClient is StateTransferrable, TrustEvents {\r\n  address public trustAddress;\r\n  function setTrust(address addr) setter onlyOwnerUnlocked {\r\n    trustAddress = addr;\r\n  }\r\n  function nameFor(address addr) constant returns (bytes32 name) {\r\n    return Trust(trustAddress).nameFor(addr);\r\n  }\r\n  function cancel() returns (uint8 status) {\r\n    assert(trustAddress != address(0x0));\r\n    uint8 code = Trust(trustAddress).authCancel(msg.sender);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) NothingToCancel(msg.sender);\r\n    else if (code == 2) AuthCancel(msg.sender, msg.sender);\r\n    return code;\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    assert(trustAddress != address(0x0));\r\n    address current = Trust(trustAddress).functionCalls(uint256(hash));\r\n    uint8 code = Trust(trustAddress).authCall(msg.sender, hash);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) AuthInit(msg.sender);\r\n    else if (code == 2) {\r\n      AuthComplete(current, msg.sender);\r\n      _\r\n    }\r\n    else if (code == 3) {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n}\r\ncontract Relay {\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\r\n}\r\ncontract TokenBase is Owned {\r\n    bytes32 public standard = 'Token 0.1';\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    bool public allowTransactions;\r\n\r\n    event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract Precision {\r\n  uint8 public decimals;\r\n}\r\ncontract Token is TokenBase, Precision {}\r\ncontract Util {\r\n  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a *= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function max(uint256 a, uint256 b) internal returns (uint256 res) {\r\n    if (a >= b) return a;\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\ncontract DVIP is Token, StateTransferrable, TrustClient, Util {\r\n\r\n  uint256 public totalSupply;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n  address public oversightAddress;\r\n  uint256 public expiry;\r\n\r\n  uint256 public treasuryBalance;\r\n\r\n  bool public isActive;\r\n  mapping (address => uint256) public exportFee;\r\n  address[] public exportFeeIndex;\r\n  mapping (address => bool) exportFeeActive;\r\n\r\n  mapping (address => uint256) public importFee;\r\n  address[] public importFeeIndex;\r\n  mapping (address => bool) importFeeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DVIP() {\r\n    isActive = true;\r\n    treasuryBalance = 0;\r\n    totalSupply = 0;\r\n    name = \"DVIP\";\r\n    symbol = \"DVIP\";\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n    expiry = 1514764800;   }\r\n\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n \r\n  \r\n  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(balanceOf[msg.sender] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(msg.sender);\r\n    activateAccount(_to);\r\n    balanceOf[msg.sender] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else balanceOf[_to] += _amount;\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][msg.sender]);\r\n    balanceOf[_from] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(msg.sender);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    spender.receiveApproval(msg.sender, _amount, this, _extraData);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n\r\n  \r\n  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {\r\n    expiry = ts;\r\n  }\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    treasuryBalance += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= destroyAmount);\r\n    treasuryBalance -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n  }\r\n\r\n  \r\n  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    assert(allow != allowTransactions);\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    treasuryBalance += amount;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from] + importFee[to];\r\n    if (fee == 0) return 0;\r\n    uint256 amountHeld;\r\n    bool discounted = true;\r\n    uint256 oneDVIPUnit;\r\n    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[from];\r\n    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[to];\r\n    } else discounted = false;\r\n    if (discounted) {\r\n      oneDVIPUnit = pow10(1, decimals);\r\n      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;\r\n      uint256 remaining = oneDVIPUnit - amountHeld;\r\n      return div10(amount*fee*remaining, decimals*2);\r\n    }\r\n    return div10(amount*fee, decimals);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() constant returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n\r\n  function activateExportFeeChargeRecord(address addr) internal {\r\n    if (!exportFeeActive[addr]) {\r\n      exportFeeActive[addr] = true;\r\n      exportFeeIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateImportFeeChargeRecord(address addr) internal {\r\n    if (!importFeeActive[addr]) {\r\n\r\n\r\n    }\r\n  }\r\n  function extractImportFeeChargeLength() returns (uint256 length) {\r\n    return importFeeIndex.length;\r\n  }\r\n\r\n  function extractExportFeeChargeLength() returns (uint256 length) {\r\n    return exportFeeIndex.length;\r\n  }\r\n}\r\n\r\n\r\ncontract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {\r\n\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name;\r\n  bytes32 public symbol;\r\n\r\n  bool public allowTransactions;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  uint256 public totalSupply;\r\n\r\n  address public hotWalletAddress;\r\n  address public assetAddress;\r\n  address public oversightAddress;\r\n  address public membershipAddress;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n\r\n  bool public isActive;\r\n  uint256 public treasuryBalance;\r\n\r\n  mapping (address => uint256) public feeCharge;\r\n  address[] public feeChargeIndex;\r\n  mapping (address => bool) feeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {\r\n    isActive = true;\r\n    name = tokenName;\r\n    symbol = tokenSymbol;\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n   modifier onlyAsset {\r\n    assert(msg.sender == assetAddress);\r\n    _\r\n   }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n    hotWalletAddress = addr;\r\n  }\r\n\r\n  \r\n  function setAsset(address addr) onlyOwnerUnlocked setter {\r\n    assetAddress = addr;\r\n  }\r\n\r\n  \r\n  function setMembership(address addr) onlyOwnerUnlocked setter {\r\n    membershipAddress = addr;\r\n  }\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(balanceOf[_caller] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(_caller);\r\n    activateAccount(_to);\r\n    balanceOf[_caller] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else {\r\n        uint256 fee = feeFor(_caller, _to, _amount);\r\n        balanceOf[_to] += _amount - fee;\r\n        treasuryBalance += fee;\r\n    }\r\n    Transfer(_caller, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][_caller]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 fee = feeFor(_from, _to, _amount);\r\n    balanceOf[_to] += _amount - fee;\r\n    treasuryBalance += fee;\r\n    allowance[_from][_caller] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(_caller);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[hotWalletAddress] >= destroyAmount);\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    if (allow == allowTransactions) throw;\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    balanceOf[hotWalletAddress] += amount;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {\r\n    if (membershipAddress == address(0x0)) return 0;\r\n    return DVIP(membershipAddress).feeFor(a, b, amount);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {\r\n\r\n   address public backendContract;\r\n\r\n   \r\n   function DCAsset(address _backendContract) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   function standard() constant returns (bytes32 std) {\r\n     return DCAssetBackend(backendContract).standard();\r\n   }\r\n\r\n   function name() constant returns (bytes32 nm) {\r\n     return DCAssetBackend(backendContract).name();\r\n   }\r\n\r\n   function symbol() constant returns (bytes32 sym) {\r\n     return DCAssetBackend(backendContract).symbol();\r\n   }\r\n\r\n   function decimals() constant returns (uint8 precision) {\r\n     return DCAssetBackend(backendContract).decimals();\r\n   }\r\n  \r\n   function allowance(address from, address to) constant returns (uint256 res) {\r\n     return DCAssetBackend(backendContract).allowance(from, to);\r\n   }\r\n\r\n\r\n   \r\n\r\n\r\n   \r\n   function setBackend(address _backendContract) multisig(sha3(msg.data)) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   \r\n\r\n   \r\n   function balanceOf(address _address) constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).balanceOf(_address);\r\n   }\r\n\r\n   \r\n   function totalSupply() constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).totalSupply();\r\n   }\r\n\r\n  \r\n   function transfer(address _to, uint256 _amount) returns (bool success)  {\r\n      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;\r\n      Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approve(address _spender, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;\r\n      Transfer(_from, _to, _amount);\r\n      return true;\r\n  }\r\n\r\n  \r\n  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {\r\n      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);\r\n  }\r\n\r\n  \r\n\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n     assert(msg.sender == backendContract);\r\n     TokenRecipient spender = TokenRecipient(_spender);\r\n     spender.receiveApproval(_caller, _amount, this, _extraData);\r\n     return true;\r\n  }\r\n\r\n}",
        "label": false,
        "name": "0x3da62e9f68ee89fe8cedf8719755c679e596829c.sol"
    },
    {
        "source": "contract CON1{\nbool public VAR1=true;\nbool public VAR2;\nbool public VAR3=true;\nuint256 public VAR4;\nuint256 public VAR5;\nuint256 public constant VAR6=5000;\nuint256 public VAR7;\nuint256 public constant VAR8 = 25000 ether;\nuint256 public constant VAR9 = 75000 ether;\nuint256 public VAR10=12500 ether;\nuint256 public constant VAR11 = 12500 ether;\nmapping (address => uint256) VAR12;\nmapping (address => bool) VAR13;\nmapping (address => uint256) VAR14;\nstruct Member\n{\naddress VAR15;\nuint VAR16;\nuint VAR17;\n}\nMember[] public VAR18;\nstring public constant VAR19 = \"DXF - Decentralized eXperience Friends\";\nstring public constant VAR20 = \"DXF\";\nuint8 public constant VAR21 = 18;\naddress public VAR22;\naddress public VAR23;\nmodifier FUN1()\n{\nif (msg.sender!=VAR22) throw;\n_;\n}\nfunction CON1()\n{\nVAR22 = msg.sender;\nVAR4=now;\nVAR23=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; VAR18.push(Member(0,0,0));\n}\nfunction ()\n{\nthrow;\n}\nfunction FUN3() payable external\n{\nif (now>VAR4+365 days) throw;\nif (!VAR1) throw;\nif (VAR13[msg.sender]) throw;\nif (msg.value < 10 ether) throw;\nif (msg.value > (VAR9 - VAR7)) throw;\nif (msg.value > (10000 ether - VAR12[msg.sender])) throw;\nif (VAR12[msg.sender]==0)\n{\nVAR14[msg.sender]=VAR18.length;\nVAR18.push(Member(msg.sender,now,msg.value));\n}\nelse\n{\nVAR18[VAR14[msg.sender]].VAR17+=msg.value;\n}\nif (VAR18.length>VAR6) throw;\nif (VAR23==0) throw;\nif (!VAR23.send(msg.value)) throw;\nuint VAR24 = msg.value;\nVAR7 += VAR24;\nif ( (VAR9-VAR7) < VAR10 ) throw;\nVAR12[msg.sender] += VAR24;\n}\nfunction FUN4(address VAR25) returns (bool)\n{\nif (VAR3) throw;\nif (VAR12[VAR25]!=0) throw;\nif (VAR12[msg.sender]!=0)\n{\nuint VAR26 = VAR12[msg.sender];\nVAR12[msg.sender] = 0;\nVAR12[VAR25]=VAR26;\nif (VAR13[msg.sender])\n{\nVAR13[VAR25]=true;\nVAR13[msg.sender]=false;\n}\nVAR18[VAR14[msg.sender]].VAR15=VAR25;\nVAR14[VAR25]=VAR14[msg.sender];\nVAR14[msg.sender]=0;\nreturn true;\n}\nelse\n{\nreturn false;\n}\n}\nfunction FUN5(address VAR27, address VAR28, uint256 VAR29)\nFUN1\n{\nif (VAR27==0) throw;\nif (VAR27!=VAR28) throw;\nif (VAR12[VAR27]!=0) throw;\nif (VAR29==0) throw;\nuint VAR30=VAR29+(VAR29/3);\nVAR7+=VAR30;\nif (VAR30>VAR10) throw;\nVAR10-=VAR30;\nVAR12[VAR27]+=VAR30;\nVAR14[VAR27]=VAR18.length;\nVAR18.push(Member(VAR27,now,VAR29));\nVAR13[VAR27]=true;\n}\nfunction FUN6(uint VAR31)\npayable\nFUN1\n{\naddress VAR32=VAR18[VAR31].VAR15;\nif (VAR32==0) throw;\nuint VAR33=msg.value;\nif (VAR13[VAR32])\n{\nVAR33+=VAR33/3;\nVAR10+=VAR33;\n}\nif (VAR33>VAR12[VAR32]) throw;\nVAR12[VAR32]-=VAR33;\nVAR7-=VAR33;\nif (VAR12[VAR32]==0)\n{\ndelete VAR18[VAR31];\nVAR13[VAR32]=false;\nVAR14[VAR32]=0;\n}\nif (!VAR32.send(msg.value))\n{\n}\n}\nfunction FUN7(address VAR34, address VAR35)\nFUN1\n{\nif (VAR34!=VAR35) throw;\nif (VAR34==0) throw;\nVAR22=VAR34;\n}\nfunction FUN8()\nFUN1\n{\nVAR5=now;\nVAR1=false;\nif (VAR7<VAR8)\n{\nVAR2=true;\n}\nelse\n{\nif(!VAR22.send(this.balance)) throw;\n}\n}\nfunction FUN9()\nFUN1\n{\nVAR3=false;\n}\nfunction FUN10()\nFUN1\n{\nVAR3=true;\n}\nfunction FUN11() external constant returns (uint256)\n{\nreturn VAR7;\n}\nfunction FUN12(address VAR36) external constant returns (uint256)\n{\nreturn VAR12[VAR36];\n}\nfunction FUN13(address VAR36) external constant returns (bool VAR37, uint VAR38, uint VAR39)\n{\nVAR37=VAR13[VAR36];\nVAR38=VAR12[VAR36]/(1 ether);\nVAR39=1000*VAR12[VAR36]/VAR7;\n}\n}",
        "label": false,
        "name": "0x72a68fb6d91ed8dc47b564e088e518c6d4a6ff44.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nmapping (address => bool) internal VAR3;\nmapping (address => bool) internal VAR4;\nfunction FUN3(address VAR5) FUN8 public {\nVAR4[VAR5] = true;\n}\nfunction FUN4(address VAR6) FUN8 public {\nrequire(VAR4[VAR6]);\ndelete VAR4[VAR6];\n}\nfunction FUN5(address VAR7) FUN8 public {\nif (!VAR3[VAR7]) {\nVAR3[VAR7] = true;\n}\n}\nfunction FUN6(address VAR8) constant public returns (bool VAR9) {\nreturn msg.sender == VAR1 || VAR4[VAR8] == true;\n}\nfunction FUN7(address VAR8) constant public returns (bool VAR10) {\nreturn VAR3[VAR8] == true;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR1 || VAR4[msg.sender]);\n_;\n}\n}",
        "label": false,
        "name": "0x56ba2109449a8dd1074e97d4033bf3ea5f0e7ae8.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public constant VAR18 = 999999 * (10 ** 18);\nconstructor () public CON2(\"CreateMyCoin\", \"COIN\", 18) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0xda7bf696953ce9a74f5fbf79ce3f99572dede591.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON2 {\nfunction FUN10(uint256 VAR5) public {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN11(address VAR7, uint256 VAR5) public {\nFUN9(VAR7, VAR5);\n}\n}\ncontract CON4 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON5 {\nusing Roles for Roles.Role;\nRoles.Role private VAR17;\nconstructor () internal {\nFUN15(msg.sender);\n}\nmodifier FUN12() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN13(address VAR10) public FUN12 {\nFUN15(VAR10);\n}\nfunction FUN14() public {\nFUN16(msg.sender);\n}\nfunction FUN15(address VAR10) internal {\nVAR17.add(VAR10);\n}\nfunction FUN16(address VAR10) internal {\nVAR17.remove(VAR10);\n}\n}\ncontract CON6 is CON2, CON5 {\nfunction FUN17(address VAR4, uint256 VAR5) public FUN12 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON7 {\nusing Roles for Roles.Role;\nRoles.Role private VAR18;\nconstructor () internal {\nFUN21(msg.sender);\n}\nmodifier FUN18() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN19(address VAR10) public FUN18 {\nFUN21(VAR10);\n}\nfunction FUN20() public {\nFUN22(msg.sender);\n}\nfunction FUN21(address VAR10) internal {\nVAR18.add(VAR10);\n}\nfunction FUN22(address VAR10) internal {\nVAR18.remove(VAR10);\n}\n}\ncontract CON8 is CON7 {\nbool private VAR19;\nconstructor () internal {\nVAR19 = false;\n}\nmodifier FUN23() {\nrequire(!VAR19);\n_;\n}\nmodifier FUN24() {\nrequire(VAR19);\n_;\n}\nfunction FUN25() public FUN18 FUN23 {\nVAR19 = true;\n}\nfunction FUN26() public FUN18 FUN24 {\nVAR19 = false;\n}\n}\ncontract CON9 is CON2, CON8 {\nfunction FUN1(address VAR4, uint256 VAR5) public FUN23 returns (bool) {\nreturn super.FUN1(VAR4, VAR5);\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public FUN23 returns (bool) {\nreturn super.FUN3(VAR7, VAR4, VAR5);\n}\nfunction FUN2(address VAR6, uint256 VAR5) public FUN23 returns (bool) {\nreturn super.FUN2(VAR6, VAR5);\n}\nfunction FUN4(address VAR6, uint VAR8) public FUN23 returns (bool VAR20) {\nreturn super.FUN4(VAR6, VAR8);\n}\nfunction FUN5(address VAR6, uint VAR9) public FUN23 returns (bool VAR20) {\nreturn super.FUN5(VAR6, VAR9);\n}\n}\ncontract CON10 is CON2, CON3, CON4, CON6, CON9 {\nstring private VAR11 = \"SDR\";\nstring private VAR12 = \"SDR\";\nuint8 private VAR13 = 18;\nconstructor() CON4(VAR11, VAR12, VAR13) public {\n}\nfunction FUN10(uint256 VAR5) public FUN23 {\nFUN8(msg.sender, VAR5);\n}\nfunction FUN11(address VAR7, uint256 VAR5) public FUN23 {\nFUN9(VAR7, VAR5);\n}\nfunction FUN17(address VAR4, uint256 VAR5) public FUN12 FUN23 returns (bool) {\nFUN7(VAR4, VAR5);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x189fdb81e99c9c1a442a7e4b9cf4a389ca7878b7.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 private VAR1;\nmapping(bytes32 => uint256) private VAR2;\nmapping(bytes32 => uint256[]) private VAR3;\nmapping(bytes32 => string) private VAR4;\nmapping(bytes32 => address) private VAR5;\nmapping(bytes32 => bytes) private VAR6;\nmapping(bytes32 => bool) private VAR7;\nmapping(bytes32 => int256) private VAR8;\naddress private VAR9;\naddress private VAR10;\nmapping(address => uint256) private VAR11;\nconstructor() public {\nVAR9 = msg.sender;\nVAR1 = CON1(0x504c53cBd44B68001Ec8A2728679c07BB78283f0);\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR9);\n_;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR10);\n_;\n}\nfunction FUN3() public FUN1 {\nFUN8(1, 'Titanium Ranger Hull', 200, 2, 0.000018 ether);\nFUN8(2, 'Platinum Ranger Hull', 400, 4, 0.45 ether);\nFUN8(3, 'Adamantium Ranger Hull', 600, 7, 0.9 ether);\n}\nfunction FUN4(address VAR12, uint256 VAR13) public FUN2 {\nVAR11[VAR12] += VAR13;\n}\nfunction FUN5(address VAR14) public FUN2 returns(uint256) {\nuint256 VAR15 = VAR11[VAR14];\nVAR11[VAR14] = 0;\nreturn VAR15;\n}\nfunction FUN6(uint256 VAR16, address VAR17, string VAR18, string VAR19) public FUN2 returns(uint256) {\nuint256 VAR20 = VAR1.addItem(VAR18);\nVAR2[_b3(VAR19, VAR20)] = VAR16;\nVAR5[_b4(VAR18, VAR20)] = VAR17;\nreturn VAR16;\n}\nfunction FUN7() public FUN1 {\nselfdestruct(0xd135377eB20666725D518c967F23e168045Ee11F);\n}\nfunction FUN8(uint256 VAR21, string VAR22, uint256 VAR23, uint256 VAR24, uint256 VAR25) public FUN1 {\nVAR1.FUN8(VAR21);\nVAR4[_b1(\"ships\", VAR21, \"name\")] = VAR22;\nVAR2[_b1(\"ships\", VAR21, \"hp\")] = VAR23;\nVAR2[_b1(\"ships\", VAR21, \"block\")] = VAR24;\nVAR2[_b1(\"ships\", VAR21, \"price\")] = VAR25;\n}\nfunction FUN9(string VAR26, uint256 VAR16, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) private {\nVAR4[_b1(VAR26, VAR16, \"name\")] = VAR22;\nVAR2[_b1(VAR26, VAR16, \"value\")] = VAR27;\nVAR2[_b1(VAR26, VAR16, \"price\")] = VAR25;\nVAR2[_b1(VAR26, VAR16, \"durability\")] = VAR28;\n}\nfunction FUN10(uint256 VAR29, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN10(VAR29);\nFUN9(\"radars\", VAR29, VAR22, VAR27, VAR25, VAR28);\n}\nfunction FUN11(uint256 VAR30, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN11(VAR30);\nFUN9(\"scanners\", VAR30, VAR22, VAR27, VAR25, VAR28);\n}\nfunction FUN12(uint256 VAR31, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN12(VAR31);\nFUN9(\"droids\", VAR31, VAR22, VAR27, VAR25, VAR28);\n}\nfunction FUN13(uint256 VAR32, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN13(VAR32);\nFUN9(\"fuels\", VAR32, VAR22, VAR27, VAR25, VAR28);\n}\nfunction FUN14(uint256 VAR33, string VAR22, uint256 VAR27, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN14(VAR33);\nFUN9(\"generators\", VAR33, VAR22, VAR27, VAR25, VAR28);\n}\nfunction FUN15(uint256 VAR34, string VAR22, uint256 VAR35, uint256 VAR36, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN15(VAR34);\nVAR4[_b1(\"engines\", VAR34, \"name\")] = VAR22;\nVAR2[_b1(\"engines\", VAR34, \"speed\")] = VAR35;\nVAR2[_b1(\"engines\", VAR34, \"giper\")] = VAR36;\nVAR2[_b1(\"engines\", VAR34, \"price\")] = VAR25;\nVAR2[_b1(\"engines\", VAR34, \"durability\")] = VAR28;\n}\nfunction FUN16(uint256 VAR37, string VAR22, uint256 VAR38, uint256 VAR39, uint256 VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR25, uint256 VAR28) public FUN1 {\nVAR1.FUN16(VAR37);\nVAR4[_b1(\"guns\", VAR37, \"name\")] = VAR22;\nVAR2[_b1(\"guns\", VAR37, \"min\")] = VAR38;\nVAR2[_b1(\"guns\", VAR37, \"max\")] = VAR39;\nVAR2[_b1(\"guns\", VAR37, \"radius\")] = VAR40;\nVAR2[_b1(\"guns\", VAR37, \"recharge\")] = VAR41;\nVAR2[_b1(\"guns\", VAR37, \"ability\")] = VAR42;\nVAR2[_b1(\"guns\", VAR37, \"price\")] = VAR25;\nVAR2[_b1(\"guns\", VAR37, \"durability\")] = VAR28;\n}\nfunction FUN17(uint256 VAR43, string VAR22, uint256 VAR26, uint256 VAR44, uint256 VAR45, uint256 VAR46, uint256 VAR25) public FUN1 {\nVAR1.FUN17(VAR43);\nVAR4[_b1(\"microModules\", VAR43, \"name\")] = VAR22;\nVAR2[_b1(\"microModules\", VAR43, \"itemType\")] = VAR26;\nVAR2[_b1(\"microModules\", VAR43, \"bonusType\")] = VAR44;\nVAR2[_b1(\"microModules\", VAR43, \"bonus\")] = VAR45;\nVAR2[_b1(\"microModules\", VAR43, \"level\")] = VAR46;\nVAR2[_b1(\"microModules\", VAR43, \"price\")] = VAR25;\n}\nfunction FUN18(uint256 VAR47, string VAR22, uint256 VAR26, uint256 VAR44, uint256 VAR45) public FUN1 {\nVAR1.FUN18(VAR47);\nVAR4[_b1(\"artefacts\", VAR47, \"name\")] = VAR22;\nVAR2[_b1(\"artefacts\", VAR47, \"itemType\")] = VAR26;\nVAR2[_b1(\"artefacts\", VAR47, \"bonusType\")] = VAR44;\nVAR2[_b1(\"artefacts\", VAR47, \"bonus\")] = VAR45;\n}\nfunction FUN19(string VAR26, uint256 VAR48, uint256 VAR49) public FUN2 {\nVAR2[_b1(VAR26, VAR48, \"price\")] = VAR49;\n}\nfunction FUN20(address VAR50) public FUN1 {\nFUN21(VAR50);\n}\nfunction FUN21(address VAR50) private {\nrequire(VAR50 != address(0));\nVAR9 = VAR50;\n}\nfunction FUN22(address VAR51) public FUN1 {\nFUN23(VAR51);\n}\nfunction FUN23(address VAR51) private {\nrequire(VAR51 != address(0));\nVAR10 = VAR51;\n}\n}",
        "label": false,
        "name": "0x5e415bd4946679c083a22f7369dd20317a2881a1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2, CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nfunction FUN3(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3, CON4 {\nmapping (address => mapping (address => uint256)) VAR7;\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR7[VAR8][msg.sender] >= VAR6);\nrequire(VAR4[VAR8] >= VAR6);\nrequire(VAR4[VAR5].add(VAR6) > VAR4[VAR5]); VAR4[VAR8] = VAR4[VAR8].sub(VAR6);\nVAR4[VAR5] = VAR4[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR6) public returns (bool) {\nrequire((VAR6 == 0) || (VAR7[msg.sender][VAR9] == 0));\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN6 (address VAR9, uint VAR10) public returns (bool VAR11) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR7[msg.sender][VAR9];\nif (VAR12 > VAR13) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR14 = false;\naddress public VAR15;\nmodifier FUN8() {\nrequire(!VAR14 || msg.sender == VAR15);\n_;\n}\nmodifier FUN9() {\nrequire(VAR14);\n_;\n}\nfunction FUN10() public FUN1 FUN8 {\nVAR14 = true;\n}\nfunction FUN11() public FUN1 FUN9 {\nVAR14 = false;\n}\n}\ncontract CON7 is CON6 {\nfunction FUN3(address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN3(VAR5, VAR6);\n}\nfunction FUN4(address VAR8, address VAR5, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN4(VAR8, VAR5, VAR6);\n}\nfunction FUN5(address VAR9, uint256 VAR6) public FUN8 returns (bool) {\nreturn super.FUN5(VAR9, VAR6);\n}\nfunction FUN6(address VAR9, uint VAR10) public FUN8 returns (bool VAR11) {\nreturn super.FUN6(VAR9, VAR10);\n}\nfunction FUN7(address VAR9, uint VAR12) public FUN8 returns (bool VAR11) {\nreturn super.FUN7(VAR9, VAR12);\n}\n}\ncontract CON8 is CON7 {\nstring public VAR16;\nstring public VAR17;\nuint8 public VAR18;\nconstructor() public {\nVAR16 = \"Electronic Energy Coin\";\nVAR17 = \"E2C\";\nVAR18 = 18;\nVAR3 = 131636363e18;\nVAR15 = 0x6784520Ac7fbfad578ABb5575d333A3f8739A5af;\nVAR4[msg.sender] = VAR3;\n}\n}",
        "label": false,
        "name": "0x08ceed1e8db59acbb687a5752f0a7db815cfda5e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nstruct Record {\nuint VAR2;\nuint VAR3;\n}\nmapping (bytes32 => Record) private VAR4;\nmodifier FUN1 {\nrequire(VAR1 == msg.sender, \"Unauthorized: only owner\");\n_; }\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN2(bytes32 VAR5) public FUN1 {\nRecord memory VAR6 = Record(block.timestamp, block.number);\nVAR4[VAR5] = VAR6;\n}\nfunction FUN3(address VAR7) public FUN1{\nVAR1 = VAR7;\n}\n}",
        "label": false,
        "name": "0xcb21dd5a4d8c2cc7ab7b86e0b8ad477b3b1dc819.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14); VAR7[msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14); require(VAR14 <= VAR8[VAR12][msg.sender]); VAR7[VAR12] -= VAR14; VAR8[VAR12][msg.sender] -= VAR14; VAR6 -= VAR14;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN10(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN11(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN12(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN13() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN14(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0x05316c4bbf2521bb529ca47dd66212d34ed1f6a3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2)public FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2,CON1 {\nusing SafeMath for uint256;\nstring public VAR3;\nstring public VAR4;\nuint256 public VAR5;\nuint256 public constant VAR6 = 18;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) VAR8;\nconstructor() public {\nVAR3=\"uTrade Trading Platform\";\nVAR4=\"UTP\";\nVAR5 = 1000000000*(10**VAR6);\nVAR7[msg.sender] = VAR5;\n}\nfunction VAR7(address VAR9)public constant returns (uint256 VAR10) {\nrequire(VAR9 != 0x0);\nreturn VAR7[VAR9];\n}\nfunction FUN3(address VAR11, address VAR12, uint256 VAR13) internal returns (bool) {\nrequire(VAR11 != 0x0);\nrequire(VAR12 != 0x0);\nrequire(VAR7[VAR11] >= VAR13);\nrequire(VAR7[VAR12].add(VAR13) >= VAR7[VAR12]);\nuint256 VAR14 = VAR7[VAR11].add(VAR7[VAR12]);\nVAR7[VAR11] = VAR7[VAR11].sub(VAR13);\nVAR7[VAR12] = VAR7[VAR12].add(VAR13);\nassert(VAR7[VAR11].add(VAR7[VAR12]) == VAR14);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR13) public returns (bool){\nreturn FUN3(msg.sender,VAR12,VAR13);\n}\nfunction ()public {\n}\nfunction FUN6(address VAR15, address VAR16)public constant returns (uint256 VAR17) {\nrequire(VAR15 != 0x0);\nrequire(VAR16 != 0x0);\nreturn VAR8[VAR15][VAR16];\n}\nfunction FUN7(address VAR16, uint256 VAR13)public returns (bool) {\nrequire(VAR16 != 0x0);\nrequire(VAR7[msg.sender] >= VAR13);\nVAR8[msg.sender][VAR16] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR11, address VAR12, uint256 VAR13)public returns (bool) {\nrequire(VAR11 != 0x0);\nrequire(VAR12 != 0x0);\nrequire(VAR13 > 0);\nrequire(VAR8[VAR11][msg.sender] >= VAR13);\nrequire(VAR7[VAR11] >= VAR13);\nrequire(VAR7[VAR12].add(VAR13) >= VAR7[VAR12]);\nVAR8[VAR11][msg.sender] = VAR8[VAR11][msg.sender].sub(VAR13);\nVAR7[VAR11] = VAR7[VAR11].sub(VAR13);\nVAR7[VAR12] = VAR7[VAR12].add(VAR13);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x3d4039bf409af774348aecd37da1bb649726f14a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 100000000 * (10**8);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Folexcoin\";\nstring constant public VAR14 = \"FLX\";\nuint8 constant public VAR15 = 8;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0x09a8501e22da800cb7a482fc5e2bf32c90a55995.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON1 {\nusing SafeERC20 for CON4;\nusing SafeMath for uint;\nstring public constant VAR3 = \"ClubTransferContract\";\nCON4 public VAR4 = CON4(0x9e85C5b1A66C0bb6ce2Ffb41ce0F918b19bf3c8D);\nfunction CON5() public {}\nfunction FUN3() constant public returns(uint256) {\nreturn VAR4.balanceOf(this);\n}\nfunction FUN4(address VAR5, uint VAR6) FUN1 public {\nrequire (VAR5 != 0x0);\nrequire(VAR4.balanceOf(this) >= VAR6);\nVAR4.safeTransfer(VAR5, VAR6);\n}\nfunction FUN5() FUN1 public {\nVAR4.safeTransfer(VAR1, VAR4.balanceOf(this));\n}\n}",
        "label": false,
        "name": "0x069e24b59aac4501119811ee14d276753b852017.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 2000000000000000000000000000;\nVAR6 = 2000000000000000000000000000;\nVAR3 = \"DreamTrip Thirteen\";\nVAR4 = \"DTT\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x76d376f1da5335b83d0d16870053b6533d1b18c8.sol"
    },
    {
        "source": "contract CON1 {\nusing SafeMath for uint256;\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping(address => uint256) public VAR5;\nmapping(address => mapping(address => uint256)) public VAR6;\nconstructor(uint256 VAR7, string memory VAR8, string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 > VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public {\nFUN1(msg.sender, VAR11, VAR12);\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns(bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns(bool VAR14) {\nif (FUN4(VAR15, VAR12)) {\nVAR15.call(abi.encodeWithSelector(bytes4(keccak256(\"receiveApproval(address,uint256,address,bytes)\")),msg.sender, VAR12, this, VAR16));\nreturn true;\n}\nelse\nreturn false;\n}\nfunction FUN6(uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns(bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xa08d1762538439848b71a39cfef7f0454f1176ed.sol"
    },
    {
        "source": "interface CON1 { }\ncontract CON2 {\nbytes32 public VAR1;\nbytes32 public VAR2;\nuint8 public VAR3 = 5;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nfunction CON2() public {\nVAR4 = 15800000000000; VAR5[msg.sender] = 15800000000000; VAR1 = \"Ferrum\"; VAR2 = \"FRM\"; }\nfunction FUN1(address VAR7, address VAR8, uint VAR9) internal {\nrequire(VAR8 != 0x0);\nrequire(VAR5[VAR7] >= VAR9);\nrequire(VAR5[VAR8] + VAR9 > VAR5[VAR8]);\nuint VAR10 = VAR5[VAR7] + VAR5[VAR8];\nVAR5[VAR7] -= VAR9;\nVAR5[VAR8] += VAR9;\nrequire(VAR5[VAR7] + VAR5[VAR8] == VAR10);\n}\nfunction FUN2(address VAR8, uint256 VAR9) public {\nFUN1(msg.sender, VAR8, VAR9);\n}\nfunction FUN3(address VAR7, address VAR8, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR9 <= VAR6[VAR7][msg.sender]); VAR6[VAR7][msg.sender] -= VAR9;\nFUN1(VAR7, VAR8, VAR9);\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR9) public\nreturns (bool VAR11) {\nVAR6[msg.sender][VAR12] = VAR9;\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR9, bytes VAR13)\npublic\nreturns (bool VAR11) {\nCON1 VAR14 = CON1(VAR12);\nif (FUN4(VAR12, VAR9)) {\nVAR14.receiveApproval(msg.sender, VAR9, this, VAR13);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[msg.sender] >= VAR9); VAR5[msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\nfunction FUN7(address VAR7, uint256 VAR9) public returns (bool VAR11) {\nrequire(VAR5[VAR7] >= VAR9); require(VAR9 <= VAR6[VAR7][msg.sender]); VAR5[VAR7] -= VAR9; VAR6[VAR7][msg.sender] -= VAR9; VAR4 -= VAR9;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x58b3cceb0575f5f193471e72f6b2287ab15cd660.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON4 {\n}\ncontract CON5 is CON4 {\n}\ncontract CON6 is CON1 {\nusing SafeMath for uint256;\nCON5 VAR3;\nuint256 public VAR4;\nmapping (address => StakeContract) public VAR5;\nstruct Stake {\nuint256 VAR6;\nuint256 VAR7;\naddress VAR8;\n}\nstruct StakeContract {\nuint256 VAR9;\nuint256 VAR10;\nStake[] VAR11;\nbool VAR12;\n}\nmodifier FUN5(address VAR13, uint256 VAR14) {\nrequire(VAR3.transferFrom(VAR13, this, VAR14),\"Stake required\");\n_;\n}\nconstructor(CON5 VAR15) public {\nVAR3 = VAR15;\n}\nfunction FUN6(uint256 VAR14, bytes VAR16) public {\nFUN9(msg.sender,VAR14,VAR4,VAR16);\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes VAR16) public {\nFUN9(VAR17,VAR14,VAR4,VAR16);\n}\nfunction FUN8(uint256 VAR14, bytes VAR16) public {\nFUN10(VAR14,VAR16);\n}\nfunction FUN9(address VAR13,uint256 VAR14,uint256 VAR18,bytes VAR16)\ninternal\nFUN5(msg.sender, VAR14)\n{\nif (!VAR5[msg.sender].VAR12) {\nVAR5[msg.sender].VAR12 = true;\n}\nVAR5[VAR13].VAR9 = VAR5[VAR13].VAR9.add(VAR14);\nVAR5[msg.sender].VAR11.push(\nStake(block.timestamp.add(VAR18),VAR14,VAR13)\n);\n}\nfunction FUN10(uint256 VAR14,bytes VAR16)\ninternal\n{\nStake storage VAR19 = VAR5[msg.sender].VAR11[VAR5[msg.sender].VAR10];\nrequire(VAR19.VAR6 <= block.timestamp,\"The current FUN6 hasn't unlocked yet\");\nrequire(VAR19.VAR7 == VAR14,\"The FUN8 amount does not match the current stake\");\nrequire(VAR3.transfer(msg.sender, VAR14),\"Unable to withdraw stake\");\nVAR5[VAR19.VAR8].VAR9 = VAR5[VAR19.VAR8]\n.VAR9.sub(VAR19.VAR7);\nVAR19.VAR7 = 0;\nVAR5[msg.sender].VAR10++;\n}\n}\ncontract CON7 is CON6, CON3 {\nmapping (address => uint256) public VAR20;\nfunction FUN11(address VAR17,uint256 VAR14)\npublic\nFUN1\n{\nrequire(VAR20[VAR17] >= VAR14,\"Insufficient balance\");\nVAR20[VAR17] = VAR20[VAR17].sub(VAR14);\n}\nfunction FUN6(uint256 VAR14,bytes VAR16)\npublic\n{\nsuper.FUN6(VAR14,VAR16);\nFUN13(msg.sender,VAR14,VAR4);\n}\nfunction FUN7(address VAR17,uint256 VAR14,bytes VAR16)\npublic\n{\nsuper.FUN7(VAR17,VAR14,VAR16);\nFUN13(VAR17,VAR14,VAR4);\n}\nfunction FUN12(address VAR17,uint256 VAR14,uint256 VAR18,bytes VAR16)\npublic\n{\nrequire(VAR18 >= VAR4,\"Insufficient FUN6 duration\");\nsuper.FUN9(VAR17,VAR14,VAR18,VAR16);\nFUN13(VAR17,VAR14,VAR18);\n}\nfunction FUN13(address VAR17,uint256 VAR14,uint256 VAR18)\ninternal\n{\nuint256 VAR21 = 1 ether;\nrequire(VAR14 >= VAR21,\"Insufficient amount\");\nuint256 VAR22 = VAR18 / VAR4;\nuint256 VAR23 = VAR14.mul(VAR22).div(VAR21);\nVAR20[VAR17] = VAR20[VAR17].add(VAR23);\n}\n}\ncontract CON8 is CON2, CON7 {\nconstructor(CON5 VAR15,uint256 VAR24)\npublic\nCON6(VAR15)\n{\nVAR4 = VAR24;\n}\nfunction FUN14(uint256 VAR24)\nexternal\nFUN1\n{\nVAR4 = VAR24;\n}\n}",
        "label": false,
        "name": "0xdea454c9c4ad408f324cc0ea382b2b7aad99640c.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 300000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"KENT\";\nstring constant public VAR14 = \"KENT\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xecaa77aaa4055cabe643caadbe11b924a3afa478.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON2, CON3, CON1{\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor() public {\nVAR7[msg.sender] = 30000000000000000000000000;\nVAR6 = 30000000000000000000000000;\nVAR3 = \"Data Chain\";\nVAR4 = \"DATA\";\nVAR5 = 18;\n}\nfunction FUN5(address VAR9, uint256 VAR10) public returns (bool) {\nrequire(VAR9 != address(0));\nrequire(VAR10 > 0);\nrequire(VAR7[msg.sender] >= VAR10);\nrequire(VAR7[VAR9] + VAR10 >= VAR7[VAR9]);\nuint VAR11 = VAR7[msg.sender] + VAR7[VAR9];\nVAR7[msg.sender] = CON3.safeSub(VAR7[msg.sender], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nassert(VAR7[msg.sender]+VAR7[VAR9]==VAR11);\nreturn true;\n}\nfunction FUN6(address VAR12, uint256 VAR10) public returns (bool VAR13) {\nrequire((VAR10 == 0) || (VAR8[msg.sender][VAR12] == 0));\nVAR8[msg.sender][VAR12] = VAR10;\nreturn true;\n}\nfunction FUN7(address VAR14, address VAR9, uint256 VAR10) public returns (bool VAR13) {\nrequire (VAR9 != address(0));\nrequire (VAR10 > 0);\nrequire (VAR7[VAR14] >= VAR10) ;\nrequire (VAR7[VAR9] + VAR10 > VAR7[VAR9]);\nrequire (VAR10 <= VAR8[VAR14][msg.sender]);\nVAR7[VAR14] = CON3.safeSub(VAR7[VAR14], VAR10);\nVAR7[VAR9] = CON3.safeAdd(VAR7[VAR9], VAR10);\nVAR8[VAR14][msg.sender] = CON3.safeSub(VAR8[VAR14][msg.sender], VAR10);\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9212d24bcfb04ea8d416010f2c91d7c0f1f9eb77.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{ using SafeMath for uint256;\nstring public constant VAR1 = \"SP Coin\";\nstring public constant VAR2 = \"SPS\";\nuint8 public constant VAR3 = 18;\nuint public VAR4 = 2500000000 *10 ** 18; address public VAR5;\nuint256 constant public VAR6 = 20000 ;\nuint256 VAR7;\nuint256 VAR8;\nuint256 VAR9;\nbool VAR10 = false;\nuint256 public VAR11;\nuint256 public VAR12;\nuint256 VAR13;\nuint256 VAR14;\nuint256 VAR15;\nuint256 VAR16;\nbool public VAR17 = true;\nmapping(address => uint) VAR18;\nmapping(address => mapping(address => uint)) VAR19;\naddress VAR20 = 0x649BbCF5625E78f8A1dE1AE07d9D5E3E0fDCa932;\nuint256 public VAR21;\nuint256 public VAR22;\nuint256 public VAR23;\nuint VAR24;\nuint public VAR25;\nuint VAR26 ;\nenum Stages {\nNOTSTARTED,\nPREICO,\nICO,\nENDED\n}\nStages public VAR27;\nmodifier FUN1(Stages VAR28) {\nif (VAR27 != VAR28)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nfunction CON2() public\n{\nVAR5 = msg.sender;\nVAR18[VAR5] = 1250000000 *10 ** 18; VAR27 = Stages.NOTSTARTED;\n}\nfunction () public payable\n{\nrequire(VAR27 != Stages.ENDED);\nrequire(!VAR10 && msg.sender != VAR5);\nif( VAR27 == Stages.PREICO && now <= VAR13 )\n{\nVAR7 =(msg.value).mul(VAR6);\nVAR23 = VAR23.add(msg.value);\nVAR25= FUN4();\nVAR8 = ((VAR7).mul(VAR25)).div(100); VAR9 = VAR7 + VAR8;\nVAR21= VAR21.add(VAR7);\nVAR22= VAR22.add(VAR8);\nFUN15(msg.sender,VAR9);\n}\nelse\nif(VAR27 == Stages.ICO && now <= VAR14 )\n{\nVAR7 =((msg.value).mul(VAR6));\nVAR23 = VAR23.add(msg.value);\nVAR25= FUN5(msg.value);\nVAR8 = ((VAR7).mul(VAR25)).div(100); VAR9 = VAR7 + VAR8;\nVAR21= VAR21.add(VAR7);\nVAR22= VAR22.add(VAR8);\nFUN15(msg.sender,VAR9);\n}\nelse {\nrevert();\n}\n}\nfunction FUN4() private returns (uint256 VAR29)\n{\nuint VAR30 = 30;\nVAR24 = (block.timestamp.sub(VAR11)).div(86400); if(VAR24 == 0)\n{\nVAR30 = 30;\n}\nelse if(VAR24 >= 15)\n{\nVAR30 = 2;\n}\nelse{\nVAR30 -= VAR24* 2;\n}\nreturn VAR30;\n}\nfunction FUN5(uint256 VAR31) private returns (uint256 VAR29){\nVAR26 = VAR31/(10**18);\nuint VAR30;\nif (VAR26>=2 && VAR26 <5){\nVAR30 = 1;\n}\nelse if (VAR26>=5 && VAR26 <15){\nVAR30 = 2;\n}\nelse if (VAR26>=15 && VAR26 <25){\nVAR30 = 3;\n}\nelse if (VAR26>=25 && VAR26 <40){\nVAR30 = 4;\n}\nelse if (VAR26>=40 && VAR26 <60){\nVAR30 = 5;\n}\nelse if (VAR26>=60 && VAR26 <70){\nVAR30 = 6;\n}\nelse if (VAR26>=70 && VAR26 <80){\nVAR30 = 7;\n}\nelse if (VAR26>=80 && VAR26 <90){\nVAR30 = 8;\n}\nelse if (VAR26>=90 && VAR26 <100){\nVAR30 = 9;\n}\nelse if (VAR26>=100){\nVAR30 = 10;\n}\nelse{\nVAR30 = 0;\n}\nreturn VAR30;\n}\nfunction FUN6() public FUN2 FUN1(Stages.NOTSTARTED)\n{\nVAR27 = Stages.PREICO;\nVAR10 = false;\nVAR15 = 350000000 * 10 ** 18; VAR18[address(this)] = VAR15;\nVAR11 = now;\nVAR13 = now + 20 days;\n}\nfunction FUN7() public FUN2 FUN1(Stages.PREICO)\n{\nVAR27 = Stages.ICO;\nVAR10 = false;\nVAR16 = 900000000 * 10 **18; VAR18[address(this)] = VAR18[address(this)].add(VAR16);\nVAR12 = now;\nVAR14 = now + 25 days;\n}\nfunction FUN8() external FUN2 {\nVAR10 = true;\n}\nfunction FUN9() external FUN2\n{\nVAR10 = false;\n}\nfunction FUN10() external FUN2 FUN1(Stages.ICO)\n{\nrequire(now > VAR14);\nVAR27 = Stages.ENDED;\nVAR17= false;\nVAR4 = (VAR4).sub(VAR18[address(this)]);\nVAR18[address(this)] = 0;\n}\nfunction FUN11(bool VAR32 ) external FUN2\n{\nVAR17 = VAR32;\n}\nfunction FUN12( address VAR33, address VAR34, uint256 VAR35 )public returns (bool VAR36) {\nrequire( VAR34 != 0x0);\nrequire(VAR18[VAR33] >= VAR35 && VAR19[VAR33][msg.sender] >= VAR35 && VAR35 >= 0);\nVAR18[VAR33] = (VAR18[VAR33]).sub(VAR35);\nVAR19[VAR33][msg.sender] = (VAR19[VAR33][msg.sender]).sub(VAR35);\nVAR18[VAR34] = (VAR18[VAR34]).add(VAR35);\nreturn true;\n}\nfunction FUN13(address VAR37, uint256 VAR35)public returns (bool VAR36) {\nrequire(!VAR17);\nrequire( VAR37 != 0x0);\nVAR19[msg.sender][VAR37] = VAR35;\nreturn true;\n}\nfunction FUN14(address VAR34, uint256 VAR35) public returns (bool VAR36) {\nif(VAR17 && msg.sender == VAR5)\n{\nrequire(VAR18[VAR5] >= VAR35 && VAR35 >= 0 && VAR18[VAR34] + VAR35 > VAR18[VAR34]);\nVAR18[VAR5] = (VAR18[VAR5]).sub(VAR35);\nVAR18[VAR34] = (VAR18[VAR34]).add(VAR35);\nreturn true;\n}\nelse if(!VAR17)\n{\nrequire(VAR18[msg.sender] >= VAR35 && VAR35 >= 0 && VAR18[VAR34] + VAR35 > VAR18[VAR34]);\nVAR18[msg.sender] = (VAR18[msg.sender]).sub(VAR35);\nVAR18[VAR34] = (VAR18[VAR34]).add(VAR35);\nreturn true;\n}\nelse\nrevert();\n}\nfunction FUN15(address VAR34, uint256 VAR35) private returns(bool VAR36) {\nrequire( VAR34 != 0x0);\nrequire(VAR18[address(this)] >= VAR35 && VAR35 > 0);\nVAR18[address(this)] = (VAR18[address(this)]).sub(VAR35);\nVAR18[VAR34] = (VAR18[VAR34]).add(VAR35);\nreturn true;\n}\nfunction FUN16(address VAR34,uint256 VAR35) external FUN2 returns(bool VAR36) {\nrequire( VAR34 != 0x0);\nrequire(VAR18[address(this)] >= VAR35 && VAR35 > 0);\nVAR18[address(this)] = (VAR18[address(this)]).sub(VAR35);\nVAR18[VAR34] = (VAR18[VAR34]).add(VAR35);\nreturn true;\n}\nfunction FUN17(address VAR38)public FUN2\n{\nVAR18[VAR38] = (VAR18[VAR38]).add(VAR18[VAR5]);\nVAR18[VAR5] = 0;\nVAR5 = VAR38;\n}\nfunction FUN18() external FUN2 {\nVAR20.FUN14(this.balance);\n}\n}",
        "label": false,
        "name": "0xcc77bfc17ec7ce8a91b16e6e79695f9bb4fbf708.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor(string VAR4, string VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN3(address VAR13,address VAR10,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR11 <= VAR8[VAR13][msg.sender]);\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR11);\nFUN6(VAR13, VAR10, VAR11);\nreturn true;\n}\nfunction FUN4(address VAR12,uint256 VAR14)\npublic\nreturns (bool)\n{\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = (VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12,uint256 VAR15)\npublic\nreturns (bool)\n{\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = (VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR11 <= VAR7[VAR13]);\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != 0);\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != 0);\nrequire(VAR11 <= VAR7[VAR16]);\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR16, uint256 VAR11) internal {\nrequire(VAR11 <= VAR8[VAR16][msg.sender]);\nVAR8[VAR16][msg.sender] = VAR8[VAR16][msg.sender].sub(VAR11);\nFUN8(VAR16, VAR11);\n}\n}\ncontract CON4 {\nusing Roles for Roles.Role;\nRoles.Role private VAR17;\nconstructor() internal {\nFUN13(msg.sender);\n}\nmodifier FUN10() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN11(address VAR16) public FUN10 {\nFUN13(VAR16);\n}\nfunction FUN12() public {\nFUN14(msg.sender);\n}\nfunction FUN13(address VAR16) internal {\nVAR17.add(VAR16);\n}\nfunction FUN14(address VAR16) internal {\nVAR17.remove(VAR16);\n}\n}\ncontract CON5 is CON4 {\nbool private VAR18;\nconstructor() internal {\nVAR18 = false;\n}\nmodifier FUN15() {\nrequire(!VAR18);\n_;\n}\nmodifier FUN16() {\nrequire(VAR18);\n_;\n}\nfunction FUN17() public FUN10 FUN15 {\nVAR18 = true;\n}\nfunction FUN18() public FUN10 FUN16 {\nVAR18 = false;\n}\n}\ncontract CON6 is CON3, CON5 {\nfunction FUN1(address VAR10,uint256 VAR11)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN1(VAR10, VAR11);\n}\nfunction FUN3(address VAR13,address VAR10,uint256 VAR11)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN3(VAR13, VAR10, VAR11);\n}\nfunction FUN2(address VAR12,uint256 VAR11)\npublic\nFUN15\nreturns (bool)\n{\nreturn super.FUN2(VAR12, VAR11);\n}\nfunction FUN4(address VAR12,uint VAR14)\npublic\nFUN15\nreturns (bool VAR19)\n{\nreturn super.FUN4(VAR12, VAR14);\n}\nfunction FUN5(address VAR12,uint VAR15)\npublic\nFUN15\nreturns (bool VAR19)\n{\nreturn super.FUN5(VAR12, VAR15);\n}\n}\ncontract CON7 is CON3 {\nfunction FUN19(uint256 VAR11) public {\nFUN8(msg.sender, VAR11);\n}\nfunction FUN20(address VAR13, uint256 VAR11) public {\nFUN9(VAR13, VAR11);\n}\n}\ncontract CON8 {\nusing Roles for Roles.Role;\nRoles.Role private VAR20;\nconstructor() internal {\nFUN24(msg.sender);\n}\nmodifier FUN21() {\nrequire(isMinter(msg.sender));\n_;\n}\nfunction FUN22(address VAR16) public FUN21 {\nFUN24(VAR16);\n}\nfunction FUN23() public {\nFUN25(msg.sender);\n}\nfunction FUN24(address VAR16) internal {\nVAR20.add(VAR16);\n}\nfunction FUN25(address VAR16) internal {\nVAR20.remove(VAR16);\n}\n}\ncontract CON9 is CON3, CON8 {\nfunction FUN26(address VAR10,uint256 VAR11)\npublic\nFUN21\nreturns (bool)\n{\nFUN7(VAR10, VAR11);\nreturn true;\n}\n}\ncontract CON10 is CON9 {\nuint256 private VAR21;\nconstructor(uint256 VAR22)\npublic\n{\nrequire(VAR22 > 0);\nVAR21 = VAR22;\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(totalSupply().add(VAR11) <= VAR21);\nsuper.FUN7(VAR16, VAR11);\n}\n}\ncontract CON11 {\naddress private VAR23;\nconstructor() internal {\nVAR23 = msg.sender;\n}\nmodifier FUN27() {\nrequire(isOwner());\n_;\n}\nfunction FUN28() public FUN27 {\nVAR23 = address(0);\n}\nfunction FUN29(address VAR24) public FUN27 {\nFUN30(VAR24);\n}\nfunction FUN30(address VAR24) internal {\nrequire(VAR24 != address(0));\nVAR23 = VAR24;\n}\n}\ncontract CON12 is CON11, CON2, CON6, CON7, CON9, CON10 {\nusing SafeERC20 for CON3;\nconstructor(string VAR4, string VAR5, uint8 VAR6, uint256 VAR22, address VAR24)\npublic\nCON2(VAR4, VAR5, VAR6)\nCON10(VAR22) {\nFUN32(VAR24);\n}\nfunction FUN31(CON3 VAR25) public FUN27 {\nuint256 VAR26 = VAR25.balanceOf(address(this));\nVAR25.safeTransfer(owner(), VAR26);\n}\nfunction FUN32(address VAR24) internal {\nFUN11(VAR24);\nFUN14(msg.sender);\nFUN22(VAR24);\nFUN25(msg.sender);\n}\n}",
        "label": false,
        "name": "0x72b509b59bbfe847a1d68eae96161adff8675064.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 public VAR1;\naddress public VAR2;\nbool public VAR3;\nmapping (address => bool) VAR4;\nfunction CON2(CON1 VAR5, address VAR6) {\nVAR1 = VAR5;\nVAR2 = VAR6;\nVAR3 = true;\n}\nfunction () external {\nFUN2();\n}\nfunction FUN2() public {\nrequire(!VAR4[msg.sender]);\nrequire(!VAR3);\nVAR4[msg.sender] = true;\nrequire(VAR1.generateTokens(msg.sender, 10 ** 18));\n}\nfunction FUN3(bool VAR7) public {\nrequire(msg.sender == VAR2);\nVAR3 = VAR7;\n}\nfunction FUN4() public {\nrequire(msg.sender == VAR2);\nVAR1.changeController(VAR2);\n}\n}",
        "label": false,
        "name": "0x103ba001256259fc25176edcba67a27b6663ee5a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 {\nusing SafeERC20 for CON1;\nCON1 public VAR1;\naddress public VAR2;\nuint256 public VAR3;\nfunction CON3()public {\nVAR1 = CON1(0xea5f88E54d982Cbb0c441cde4E79bC305e5b43Bc);\nVAR2 = 0x439f2cEe51F19BA158f1126eC3635587F7637718;\nVAR3 = now + 120 days;\n}\nfunction FUN1() public {\nrequire(now >= VAR3);\nuint256 VAR4 = VAR1.balanceOf(this);\nrequire(VAR4 > 0);\nVAR1.safeTransfer(VAR2, VAR4);\n}\n}",
        "label": false,
        "name": "0x2cc1d82c0bcc1028f792f56a930271ab00117ff8.sol"
    },
    {
        "source": "contract CON1 {\nusing Roles for Roles.Role;\nRoles.Role private VAR1;\nconstructor () internal {\nFUN4(msg.sender);\n}\nmodifier FUN1() {\nrequire(isPauser(msg.sender));\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN3() public {\nFUN5(msg.sender);\n}\nfunction FUN4(address VAR2) internal {\nVAR1.add(VAR2);\n}\nfunction FUN5(address VAR2) internal {\nVAR1.remove(VAR2);\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nstring private VAR3;\nstring private VAR4;\nuint8 private VAR5;\nconstructor (string memory VAR6, string memory VAR7, uint8 VAR8) public {\nVAR3 = VAR6;\nVAR4 = VAR7;\nVAR5 = VAR8;\n}\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR9;\nmapping (address => mapping (address => uint256)) private VAR10;\nuint256 private VAR11;\nfunction FUN6(address VAR12, uint256 VAR13) public returns (bool) {\nFUN11(msg.sender, VAR12, VAR13);\nreturn true;\n}\nfunction FUN7(address VAR14, uint256 VAR13) public returns (bool) {\nFUN14(msg.sender, VAR14, VAR13);\nreturn true;\n}\nfunction FUN8(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\nFUN11(VAR15, VAR12, VAR13);\nFUN14(VAR15, msg.sender, VAR10[VAR15][msg.sender].sub(VAR13));\nreturn true;\n}\nfunction FUN9(address VAR14, uint256 VAR16) public returns (bool) {\nFUN14(msg.sender, VAR14, VAR10[msg.sender][VAR14].add(VAR16));\nreturn true;\n}\nfunction FUN10(address VAR14, uint256 VAR17) public returns (bool) {\nFUN14(msg.sender, VAR14, VAR10[msg.sender][VAR14].sub(VAR17));\nreturn true;\n}\nfunction FUN11(address VAR15, address VAR12, uint256 VAR13) internal {\nrequire(VAR12 != address(0));\nVAR9[VAR15] = VAR9[VAR15].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\n}\nfunction FUN12(address VAR2, uint256 VAR13) internal {\nrequire(VAR2 != address(0));\nVAR11 = VAR11.add(VAR13);\nVAR9[VAR2] = VAR9[VAR2].add(VAR13);\n}\nfunction FUN13(address VAR2, uint256 VAR13) internal {\nrequire(VAR2 != address(0));\nVAR11 = VAR11.sub(VAR13);\nVAR9[VAR2] = VAR9[VAR2].sub(VAR13);\n}\nfunction FUN14(address VAR18, address VAR14, uint256 VAR13) internal {\nrequire(VAR14 != address(0));\nrequire(VAR18 != address(0));\nVAR10[VAR18][VAR14] = VAR13;\n}\nfunction FUN15(address VAR2, uint256 VAR13) internal {\nFUN13(VAR2, VAR13);\nFUN14(VAR2, msg.sender, VAR10[VAR2][msg.sender].sub(VAR13));\n}\n}\ncontract CON5 is CON1 {\nbool private VAR19;\nconstructor () internal {\nVAR19 = false;\n}\nmodifier FUN16() {\nrequire(!VAR19);\n_;\n}\nmodifier FUN17() {\nrequire(VAR19);\n_;\n}\nfunction FUN18() public FUN1 FUN16 {\nVAR19 = true;\n}\nfunction FUN19() public FUN1 FUN17 {\nVAR19 = false;\n}\n}\ncontract CON6 is CON4, CON5 {\nfunction FUN6(address VAR12, uint256 VAR13) public FUN16 returns (bool) {\nreturn super.FUN6(VAR12, VAR13);\n}\nfunction FUN8(address VAR15, address VAR12, uint256 VAR13) public FUN16 returns (bool) {\nreturn super.FUN8(VAR15, VAR12, VAR13);\n}\nfunction FUN7(address VAR14, uint256 VAR13) public FUN16 returns (bool) {\nreturn super.FUN7(VAR14, VAR13);\n}\nfunction FUN9(address VAR14, uint VAR16) public FUN16 returns (bool VAR20) {\nreturn super.FUN9(VAR14, VAR16);\n}\nfunction FUN10(address VAR14, uint VAR17) public FUN16 returns (bool VAR20) {\nreturn super.FUN10(VAR14, VAR17);\n}\n}\ncontract CON7 is CON6, CON3 {\nuint8 public constant VAR21 = 18;\nuint256 public constant VAR22 = 200000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR23 = 90000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR24 = 30000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR25 = 30000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR26 = 10000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR27 = 30000000 * (10 ** uint256(VAR21));\nuint256 public constant VAR28 = 10000000 * (10 ** uint256(VAR21));\nuint256 public VAR29 = 1623974399;\naddress private VAR30;\nuint256 private VAR31 = 0;\nuint256 private VAR32 = 0;\nuint256 private VAR33 = 0;\nuint256 private VAR34 = 0;\nuint256 private VAR35 = 0;\nuint256 private VAR36 = 0;\nmapping(address => bool) public VAR37;\nuint256[] VAR38 = [VAR23,VAR24,VAR25,VAR26,VAR27,VAR28];\nuint256[] VAR39 = [0,0,0,0,0,0];\nconstructor () public CON3(\"DeepCloud\", \"DEEP\", VAR21) {\nVAR30 = msg.sender;\nFUN12(msg.sender, VAR22);\n}\nfunction FUN20(uint VAR40,address VAR12, uint256 VAR13) public FUN22 returns (bool){\n_checkAvailableCap(VAR40, VAR13);\nFUN21(VAR40, VAR13);\nVAR37[VAR12] = true;\nFUN6(VAR12, VAR13);\nreturn true;\n}\nfunction FUN21(uint VAR40, uint256 VAR13) internal {\nVAR39[VAR40] += VAR13;\n}\nfunction FUN6(address VAR12, uint256 VAR13) public returns (bool) {\nrequire(checkLock());\nreturn super.FUN6(VAR12, VAR13);\n}\nfunction FUN8(address VAR15, address VAR12, uint256 VAR13) public returns (bool) {\ncheckLock();\nreturn super.FUN8(VAR15, VAR12, VAR13);\n}\nfunction FUN7(address VAR14, uint256 VAR13) public returns (bool) {\ncheckLock();\nreturn super.FUN7(VAR14, VAR13);\n}\nfunction FUN9(address VAR14, uint VAR16) public returns (bool) {\ncheckLock();\nreturn super.FUN9(VAR14, VAR16);\n}\nfunction FUN10(address VAR14, uint VAR17) public returns (bool) {\ncheckLock();\nreturn super.FUN10(VAR14, VAR17);\n}\nmodifier FUN22() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\n}",
        "label": false,
        "name": "0xa2dbb4808d9ec74dc548cae39d3660e57f189840.sol"
    },
    {
        "source": "contract CON1 {\nmapping(address => mapping(address => uint)) public VAR1;\nconstructor() public {}\nfunction FUN1(address VAR2, uint VAR3)\npublic\n{\nif (VAR2 != 0x0 && VAR3 > 0) {\nVAR1[msg.sender][VAR2] = VAR3;\n}\n}\nfunction FUN2()\npublic\n{\n}\n}",
        "label": false,
        "name": "0xe351455b23ea96ad0a8a1fc3594ddef1c4bb2479.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[msg.sender]);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\nfunction FUN2(address VAR5) public constant returns (uint256 VAR6) {\nreturn VAR2[VAR5];\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN3(address VAR8, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR2[VAR8]);\nrequire(VAR4 <= VAR7[VAR8][msg.sender]);\nVAR2[VAR8] = VAR2[VAR8].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR4) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR4;\nreturn true;\n}\nfunction FUN5(address VAR5, address VAR9) public constant returns (uint256 VAR10) {\nreturn VAR7[VAR5][VAR9];\n}\nfunction FUN6 (address VAR9, uint VAR11) public returns (bool VAR12) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR11);\nreturn true;\n}\nfunction FUN7 (address VAR9, uint VAR13) public returns (bool VAR12) {\nuint VAR14 = VAR7[msg.sender][VAR9];\nif (VAR13 > VAR14) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR14.sub(VAR13);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR15;\nfunction CON5() {\nVAR15 = msg.sender;\n}\nmodifier FUN8() {\nrequire(msg.sender == VAR15);\n_;\n}\nfunction FUN9(address VAR16) FUN8 {\nrequire(VAR16 != address(0));\nVAR15 = VAR16;\n}\n}\ncontract CON6 is CON4, CON5\n{\nstring public VAR17 = \"Bitcoin New\";\nstring public VAR18 = \"BTN\";\nuint public VAR19 = 8;\nuint private constant VAR20 = 21 * 10**(6+8);\nfunction CON6()\n{\nVAR15 = msg.sender;\nVAR1 = VAR20;\nVAR2[VAR15] = VAR20;\n}\n}",
        "label": false,
        "name": "0xcea5be202e170dc9b63a931036718c634a9babbd.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR17 = 18;\nuint256 public constant VAR18 = 10000000000 * (10 ** uint256(VAR17));\nconstructor () public CON3(\"SMC\", \"SMC\", VAR17) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x60bffda4a3409829dd23f34d496a043557c24db6.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1{\nusing SafeMath for uint256;\nmapping (address => uint256) VAR3;\nmapping (address => mapping (address => uint256)) VAR4;\nmapping (address => bool) public VAR5;\nmapping (address => bool) public VAR6;\nstring public VAR7 = \"Taylor\";\nstring public VAR8 = \"TAY\";\nuint8 public VAR9 = 18;\nuint256 constant internal VAR10 = 10**18;\nuint256 public VAR11 = 10**7 * VAR10;\nbool public VAR12 = false;\nmodifier FUN3(){\nif(!VAR5[msg.sender]){\nrequire(VAR12);\n}\n_;\n}\nfunction CON2()\nCON1()\npublic\n{\nVAR3[VAR1] = VAR3[VAR1].add(VAR11);\nVAR5[msg.sender] = true;\nVAR6[msg.sender] = true;\n}\nfunction FUN4()\npublic\nFUN1\n{\nVAR12 = true;\n}\nfunction FUN5(address VAR13)\npublic\nFUN1\n{\nVAR5[VAR13] = true;\n}\nfunction FUN6(address VAR14)\npublic\nFUN1\n{\nVAR5[VAR14] = true;\nFUN8(VAR14, VAR3[VAR1]);\n}\nfunction FUN7(address VAR13)\npublic\nFUN1\n{\nVAR6[VAR13] = true;\n}\nfunction FUN8(address VAR15, uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17)\n{\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR16);\nVAR3[VAR15] = VAR3[VAR15].add(VAR16);\nreturn true;\n}\nfunction FUN9\n(address VAR18,address VAR15,uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17) {\nrequire(VAR15 != address(0));\nrequire(VAR16 <= VAR3[VAR18]);\nrequire(VAR16 <= VAR4[VAR18][msg.sender]);\nVAR3[VAR18] = VAR3[VAR18].sub(VAR16);\nVAR3[VAR15] = VAR3[VAR15].add(VAR16);\nVAR4[VAR18][msg.sender] = VAR4[VAR18][msg.sender].sub(VAR16);\nreturn true;\n}\nfunction FUN10(address VAR19, uint256 VAR16)\npublic\nFUN3\nreturns (bool VAR17)\n{\nVAR4[msg.sender][VAR19] = VAR16;\nreturn true;\n}\nfunction FUN11(address VAR19, uint VAR20)\npublic\nreturns (bool)\n{\nVAR4[msg.sender][VAR19] = VAR4[msg.sender][VAR19].add(VAR20);\nreturn true;\n}\nfunction FUN12(address VAR19, uint VAR21)\npublic\nreturns (bool)\n{\nuint VAR22 = VAR4[msg.sender][VAR19];\nif (VAR21 > VAR22) {\nVAR4[msg.sender][VAR19] = 0;\n} else {\nVAR4[msg.sender][VAR19] = VAR22.sub(VAR21);\n}\nreturn true;\n}\nfunction FUN13(uint256 VAR23)\npublic\nreturns (bool VAR17)\n{\nrequire(VAR6[msg.sender]);\nrequire(VAR23 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR23);\nVAR11 = VAR11.sub(VAR23);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nuint256 constant internal VAR10 = 10**18;\nCON2 public VAR24;\nuint256 constant public VAR25 = 10**6 * VAR10;\nuint256 constant public VAR26 = 4 * 10**5 * VAR10;\nuint256 constant public VAR27 = 3 * 10**5 * VAR10;\nuint256 constant public VAR28 = 7 * 10**5 * VAR10;\nuint256 constant public VAR29 = 1190476 * VAR10;\nuint256 constant public VAR30 = 6409524 * VAR10;\naddress public VAR31;\naddress public VAR32;\naddress public VAR33;\naddress public VAR34;\naddress public VAR35;\naddress public VAR36;\nfunction FUN14(address VAR37, address VAR38, address VAR39, address VAR40, address VAR41, address VAR42, address VAR43) public FUN1{\nVAR24 = CON2(VAR37);\nVAR31 = VAR38;\nVAR32 = VAR39;\nVAR33 = VAR40;\nVAR34 = VAR41;\nVAR35 = VAR42;\nVAR36 = VAR43;\n}\nfunction FUN6() public FUN1 {\nuint256 VAR44 = VAR25.add(VAR26).add(VAR27).add(VAR28).add(VAR29).add(VAR30);\nrequire(VAR44 >= VAR24.balanceOf(this));\nVAR24.FUN8(VAR31, VAR25);\nVAR24.FUN8(VAR32, VAR26);\nVAR24.FUN8(VAR33, VAR27);\nVAR24.FUN8(VAR34, VAR28);\nVAR24.FUN8(VAR35, VAR29);\nVAR24.FUN8(VAR36, VAR30);\n}\n}",
        "label": false,
        "name": "0x0905a9844f41d1be68f99dd4bd51be6838892010.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 2;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x343e25cfb4d5417851abdce0395e49724444eed2.sol"
    },
    {
        "source": "contract RequiringFunds {\r\n    modifier NeedEth () {\r\n        if (msg.value <= 0 ) throw;\r\n        _\r\n    }\r\n}\r\n\r\ncontract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit is RequiringFunds {\r\n        address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;       \r\n        AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);\r\n\r\n        function split(address targetFork, address targetNoFork) NeedEth returns(bool) {\r\n                        if (targetFork == 0) throw;\r\n        if (targetNoFork == 0) throw;\r\n\r\n        if (amIOnTheFork.forked()                               && targetFork.send(msg.value)) {                    return true;\r\n        } else if (!amIOnTheFork.forked()                       && targetNoFork.send(msg.value)) {                  return true;\r\n        }\r\n\r\n        throw;                                          }\r\n\r\n        function() {\r\n        throw;\r\n    }\r\n}",
        "label": false,
        "name": "0xabbb6bebfa05aa13e908eaa492bd7a8343760477.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\n}\ncontract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0)); require (VAR7[VAR12] >= VAR14); require (VAR7[VAR13] + VAR14 >= VAR7[VAR13]); require(!VAR22[VAR12]); require(!VAR22[VAR13]); VAR7[VAR12] -= VAR14; VAR7[VAR13] += VAR14;\n}\nfunction FUN8(address VAR23, uint256 VAR24) FUN1 public {\nVAR7[VAR23] += VAR24;\nVAR6 += VAR24;\n}\nfunction FUN9(address VAR23, bool VAR25) FUN1 public {\nVAR22[VAR23] = VAR25;\n}\nfunction FUN10(uint256 VAR26, uint256 VAR27) FUN1 public {\nVAR20 = VAR26;\nVAR21 = VAR27;\n}\nfunction FUN11() payable public {\nuint VAR28 = msg.value / VAR21; FUN3(address(this), msg.sender, VAR28); }\nfunction FUN12(uint256 VAR28) public {\naddress VAR29 = address(this);\nrequire(VAR29.balance >= VAR28 * VAR20); FUN3(msg.sender, address(this), VAR28); msg.sender.FUN4(VAR28 * VAR20); }\n}",
        "label": false,
        "name": "0xb9581a458bd0e135f534fcb7a23441c7dc097ddc.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5 = 18;\nuint256 public VAR6;\nmapping (address => uint256) public VAR7;\nmapping (address => mapping (address => uint256)) public VAR8;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) public {\nVAR6 = VAR9 * 10 ** uint256(VAR5); VAR7[msg.sender] = VAR6; VAR3 = VAR10; VAR4 = VAR11; }\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire(VAR13 != address(0x0));\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR7[VAR13] + VAR14 > VAR7[VAR13]);\nuint VAR15 = VAR7[VAR12] + VAR7[VAR13];\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\nassert(VAR7[VAR12] + VAR7[VAR13] == VAR15);\n}\nfunction FUN4(address VAR13, uint256 VAR14) public returns (bool VAR16) {\nFUN3(msg.sender, VAR13, VAR14);\nreturn true;\n}\nfunction FUN5(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR14 <= VAR8[VAR12][msg.sender]); VAR8[VAR12][msg.sender] -= VAR14;\nFUN3(VAR12, VAR13, VAR14);\nreturn true;\n}\nfunction FUN6(address VAR17, uint256 VAR14) public\nreturns (bool VAR16) {\nVAR8[msg.sender][VAR17] = VAR14;\nreturn true;\n}\nfunction FUN7(address VAR17, uint256 VAR14, bytes memory VAR18)\npublic\nreturns (bool VAR16) {\nCON2 VAR19 = CON2(VAR17);\nif (FUN6(VAR17, VAR14)) {\nVAR19.receiveApproval(msg.sender, VAR14, address(this), VAR18);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[msg.sender] >= VAR14);\nVAR7[msg.sender] -= VAR14;\nVAR6 -= VAR14;\nreturn true;\n}\nfunction FUN9(address VAR12, uint256 VAR14) public returns (bool VAR16) {\nrequire(VAR7[VAR12] >= VAR14);\nrequire(VAR14 <= VAR8[VAR12][msg.sender]);\nVAR7[VAR12] -= VAR14;\nVAR8[VAR12][msg.sender] -= VAR14;\nVAR6 -= VAR14;\nreturn true;\n}\n}contract CON4 is CON1, CON3 {\nuint256 public VAR20;\nuint256 public VAR21;\nmapping (address => bool) public VAR22;\nconstructor(uint256 VAR9,string memory VAR10,string memory VAR11) CON3(VAR9, VAR10, VAR11) public {}\nfunction FUN3(address VAR12, address VAR13, uint VAR14) internal {\nrequire (VAR13 != address(0x0));\nrequire (VAR7[VAR12] >= VAR14);\nrequire (VAR7[VAR13] + VAR14 >= VAR7[VAR13]);\nrequire(!VAR22[VAR12]);\nrequire(!VAR22[VAR13]);\nVAR7[VAR12] -= VAR14;\nVAR7[VAR13] += VAR14;\n}function FUN10(address VAR23, bool VAR24) FUN1 public {\nVAR22[VAR23] = VAR24;\n}function FUN11(uint256 VAR25, uint256 VAR26) FUN1 public {\nVAR20 = VAR25;\nVAR21 = VAR26;\n} function FUN12() payable public {\nuint VAR27 = msg.value / VAR21;\nFUN3(address(this), msg.sender, VAR27);\n} function FUN13(uint256 VAR27) public {\naddress VAR28 = address(this);\nrequire(VAR28.balance >= VAR27 * VAR20);\nFUN3(msg.sender, address(this), VAR27);\nmsg.sender.FUN4(VAR27 * VAR20);\n}\n}",
        "label": false,
        "name": "0xdd8a513d11bd563e009f8e561c488ba7969470e1.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nfunction FUN1(address VAR2) public FUN2 {\nVAR1 = VAR2;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nmapping(address => bool) public VAR3;\nmapping(address => bool) public VAR4;\nbool public VAR5 = false;\nfunction FUN3(bool VAR6) public FUN2 {\nVAR5 = VAR6;\n}\nfunction FUN4(address VAR7, bool VAR8) public FUN2 {\nVAR4[VAR7] = VAR8;\n}\nfunction FUN5(address VAR7, address VAR9) public returns (bool) {\nrequire(VAR4[VAR7], \"sender must be approved\");\nrequire(VAR5, \"can't claim\");\nrequire(!VAR3[VAR9], \"one card back per user\");\nVAR3[VAR9] = true;\nreturn true;\n}\nfunction FUN6(address, address, uint256) public returns (bool) {\nreturn true;\n}\nfunction FUN7(address, address, bool) public returns (bool) {\nreturn true;\n}\nfunction FUN8(address, address, address, uint256) public returns (bool) {\nreturn true;\n}\nfunction FUN9(address, address, address, uint256) public returns (bool) {\nreturn true;\n}\nfunction FUN9(address, address, address, uint256, bytes memory) public returns (bool) {\nreturn true;\n}\n}",
        "label": false,
        "name": "0xe9813b3ac3fd938d21e47d10987f58914e6ff1fd.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\nCON1 VAR1;\nmodifier FUN1(bytes32 VAR2) {\nif (address(VAR1) != 0x0 && VAR1.hasRole(this, VAR2, msg.sender)) {\n_;\n}\n}\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON3 is CON2 {\nfunction FUN2(CON1 VAR3) returns(bool) {\nif (address(VAR1) != 0x0) {\nreturn false;\n}\nif (!VAR3.claimFor(this, msg.sender) && !VAR3.isOwner(this, msg.sender)) {\nreturn false;\n}\nVAR1 = VAR3;\nreturn true;\n}\n}\ncontract CON4 {\n}\ncontract CON5 {\n}\ncontract CON6 {\n}\ncontract CON7 is CON3 {\nCON5 public VAR4;\nCON6 public VAR5;\nfunction FUN3(address VAR6, string VAR7) internal returns(bool) {\nif (!VAR4.isActivated(VAR6)) {\nreturn false;\n}\nif (VAR5.getReputationProblems(VAR6, VAR7)) {\nreturn false;\n}\nreturn true;\n}\nfunction FUN4(CON5 VAR8) FUN1('admin') returns(bool) {\nVAR4 = CON5(VAR8);\nreturn true;\n}\nfunction FUN5(CON6 VAR9) FUN1('admin') returns(bool) {\nVAR5 = CON6(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR10, uint VAR11, string VAR7, address VAR6) returns(bool) {\nif (FUN3(VAR6, VAR7)) {\nreturn true;\n}\nreturn false;\n}\nfunction FUN7(bytes32 VAR12, uint VAR11, string VAR7, address VAR6) returns(bool) {\nif (FUN3(VAR6, VAR7)) {\nreturn true;\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0xc0c3e64a5821f6712179efaf3be6d2e0208c6b5f.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\naddress public VAR1;\naddress public VAR2;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON3 is CON2 {\nbool public VAR4 = false;\nmodifier FUN4() {\nrequire(!VAR4);\n_;\n}\nmodifier FUN5() {\nrequire(VAR4);\n_;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR4 = true;\n}\nfunction FUN7() FUN1 FUN5 public {\nVAR4 = false;\n}\n}\ncontract CON4 is CON1, CON2, CON3 {\nusing SafeMath for uint;\nstring public VAR5;\nstring public VAR6;\nuint8 public VAR7;\nuint VAR8;\nmapping(address => uint) VAR9;\nmapping(address => mapping(address => uint)) VAR10;\nconstructor() public {\nVAR5 = \"OXY\";\nVAR6 = \"Oxycoin\";\nVAR7 = 18;\nVAR8 = 1200000000 * 10 ** uint(VAR7);\nVAR9[VAR1] = VAR8;\n}\nmodifier FUN8(uint VAR11) {\nassert(msg.data.length >= VAR11 * 32 + 4);\n_;\n}\nfunction FUN9(address VAR12, uint VAR13) public FUN4 FUN8(2) returns (bool VAR14) {\nrequire(VAR12 != address(0));\nrequire(VAR13 > 0);\nrequire(VAR13 <= VAR9[msg.sender]);\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN10(address VAR15, uint VAR13) public FUN4 FUN8(2) returns (bool VAR14) {\nrequire(VAR15 != address(0));\nVAR10[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN11(address VAR16, address VAR12, uint VAR13) public FUN4 FUN8(3) returns (bool VAR14) {\nrequire(VAR13 > 0);\nrequire(VAR16 != address(0));\nrequire(VAR12 != address(0));\nrequire(VAR10[VAR16][msg.sender] > 0);\nrequire(VAR9[VAR16]>0);\nVAR9[VAR16] = VAR9[VAR16].sub(VAR13);\nVAR10[VAR16][msg.sender] = VAR10[VAR16][msg.sender].sub(VAR13);\nVAR9[VAR12] = VAR9[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN12(uint VAR17) public returns (bool VAR14) {\nrequire(VAR9[msg.sender] >= VAR17);\nVAR9[msg.sender] = VAR9[msg.sender].sub(VAR17);\nVAR8 =VAR8.sub(VAR17);\nreturn true;\n}\nfunction FUN13(address VAR16, uint VAR17) public returns (bool VAR14) {\nrequire(VAR9[VAR16] >= VAR17);\nrequire(VAR17 <= VAR10[VAR16][msg.sender]);\nVAR9[VAR16] = VAR9[VAR16].sub(VAR17);\nVAR10[VAR16][msg.sender] = VAR10[VAR16][msg.sender].sub(VAR17);\nVAR8 = VAR8.sub(VAR17);\nreturn true;\n}\nfunction FUN14(address VAR18, uint VAR19) FUN1 public returns (bool) {\nrequire(VAR19 > 0);\nrequire(VAR18 != address(0));\nVAR9[VAR18] = VAR9[VAR18].add(VAR19);\nVAR8 = VAR8.add(VAR19);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN16(address VAR20, uint VAR13) public FUN1 returns (bool VAR14) {\nrequire(VAR20 != address(0));\nrequire(isContract(VAR20));\nreturn CON1(VAR20).FUN9(VAR1, VAR13);\n}\n}",
        "label": false,
        "name": "0x869b1f57380ae501d387b19262efd3c0eb7501b0.sol"
    },
    {
        "source": "contract CON1 {\naddress internal VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner(), \"Ownable: caller is not the owner\");\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0), \"Ownable: new VAR14 is the zero address\");\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\naddress public VAR3;\nmodifier FUN5() {\nrequire(msg.sender == VAR3);\n_;\n}\nfunction FUN3(address VAR2) FUN1 public {\nVAR3 = VAR2;\n}\nfunction FUN6() FUN5 public {\nVAR1 = VAR3;\nVAR3 = address(0);\n}\n}\ninterface CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 private VAR6;\nfunction FUN7(address VAR7, uint256 VAR8) public returns (bool) {\nFUN12(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN8(address VAR9, uint256 VAR8) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN12(VAR10, VAR7, VAR8);\nFUN15(VAR10, msg.sender, VAR5[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN10(address VAR9, uint256 VAR11) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN11(address VAR9, uint256 VAR12) public returns (bool) {\nFUN15(msg.sender, VAR9, VAR5[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN12(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR7 != address(0), \"ERC20: FUN7 VAR7 the zero address\");\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\nfunction FUN13(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: mint VAR7 the zero address\");\nVAR6 = VAR6.add(VAR8);\nVAR4[VAR13] = VAR4[VAR13].add(VAR8);\n}\nfunction FUN14(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: FUN17 VAR10 the zero address\");\nVAR6 = VAR6.sub(VAR8);\nVAR4[VAR13] = VAR4[VAR13].sub(VAR8);\n}\nfunction FUN15(address VAR14, address VAR9, uint256 VAR8) internal {\nrequire(VAR14 != address(0), \"ERC20: FUN8 VAR10 the zero address\");\nrequire(VAR9 != address(0), \"ERC20: FUN8 VAR7 the zero address\");\nVAR5[VAR14][VAR9] = VAR8;\n}\nfunction FUN16(address VAR13, uint256 VAR8) internal {\nFUN14(VAR13, VAR8);\nFUN15(VAR13, msg.sender, VAR5[VAR13][msg.sender].sub(VAR8));\n}\n}\ncontract CON5 is CON4 {\nfunction FUN17(uint256 VAR8) public {\nFUN14(msg.sender, VAR8);\n}\nfunction FUN18(address VAR10, uint256 VAR8) public {\nFUN16(VAR10, VAR8);\n}\n}\ncontract CON6 is CON5, CON2 {\nstring public constant VAR15 = \"MOBU\";\nstring public constant VAR16 = \"MOBU\";\nuint8 public constant VAR17 = 18;\nuint256 constant VAR18 = 150000000e18;\naddress public VAR19;\naddress public VAR20;\naddress public VAR21;\naddress public VAR22;\nuint public VAR23 = 0;\nbool VAR24 = false;\nbool VAR25 = false;\nbool VAR26 = false;\nmodifier FUN19() {\nrequire (VAR23 != 0);\n_;\n}\nconstructor(address VAR27, address VAR28, address VAR29, address VAR30) public {\nVAR19 = VAR27;\nVAR20 = VAR28;\nVAR21 = VAR29;\nVAR22 = VAR30;\nFUN13(VAR27, 120000000e18);\nFUN13(address(this), 30000000e18);\n}\nfunction FUN20() public FUN1 {\nrequire (VAR23 == 0);\nVAR23 = now;\n}\nfunction FUN21() public FUN19 {\nrequire (now > VAR23 + 30 days);\nrequire (!VAR26);\nVAR26 = true;\nFUN12(address(this), VAR22, 6000000e18);\n}\nfunction FUN22() public FUN19 {\nrequire (now > VAR23 + 365 days);\nrequire (!VAR24);\nVAR24 = true;\nFUN12(address(this), VAR20, 18000000e18);\n}\nfunction FUN23() public FUN19 {\nrequire (now > VAR23 + 90 days);\nrequire (!VAR25);\nVAR25 = true;\nFUN12(address(this), VAR21, 6000000e18);\n}\nfunction FUN24(CON4 VAR31) public FUN1 {\nVAR31.FUN7(msg.sender, VAR31.balanceOf(address(this)));\n}\n}",
        "label": false,
        "name": "0x1cd2a911a28a034da2645fea802e280253c7f527.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1\n{using SafeMath for uint256;\nstring public constant VAR1 = \",000.TRY.TurkishLira\";\nstring public constant VAR2 = \"T\u00fcrkiye Cumhuriyet Merkez Bankas\u0131-Central Bank of the Republic of Turkey\";\nuint public constant VAR3 = 18;\nuint256 VAR4 = 999000000000000000000 * 10 ** 18;\naddress public VAR5;\nmapping(address => uint256) VAR6;\nmapping(address => mapping (address => uint256)) VAR7;\nmodifier FUN1() {\nif (msg.sender != VAR5) {\nrevert();\n}\n_;\n}\nconstructor () public {\nVAR5 = msg.sender;\nVAR6[VAR5] = VAR4;\n}\nfunction FUN2(uint256 VAR8) public FUN1 {\nVAR4 = (VAR4).sub(VAR8);\n}\nfunction FUN3(address VAR9, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[msg.sender] = (VAR6[msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN4( address VAR12, address VAR9, uint256 VAR10 )public returns (bool VAR11) {\nrequire( VAR9 != 0x0);\nrequire(VAR6[VAR12] >= VAR10 && VAR7[VAR12][msg.sender] >= VAR10 && VAR10 >= 0);\nVAR6[VAR12] = (VAR6[VAR12]).sub(VAR10);\nVAR7[VAR12][msg.sender] = (VAR7[VAR12][msg.sender]).sub(VAR10);\nVAR6[VAR9] = (VAR6[VAR9]).add(VAR10);\nreturn true;\n}\nfunction FUN5(address VAR13, uint256 VAR10)public returns (bool VAR11) {\nrequire( VAR13 != 0x0);\nVAR7[msg.sender][VAR13] = VAR10;\nreturn true;\n}\nfunction FUN6(address VAR14) external FUN1\n{\nuint256 VAR15 = VAR6[VAR5];\nrequire( VAR14 != 0x0);\nVAR6[VAR14] = (VAR6[VAR14]).add(VAR6[VAR5]);\nVAR6[VAR5] = 0;\nVAR5 = VAR14;\n}\n}",
        "label": false,
        "name": "0x264a504704a7098ab49d4f8c528423d509daf086.sol"
    },
    {
        "source": "contract CON1 {\nuint256 private VAR1;\n}\ncontract CON2 {\nfunction FUN1() public returns(address) {\nCON1 VAR2 = new CON1();\nreturn address(VAR2);\n}\n}",
        "label": false,
        "name": "0x96870071f10cd91825f6ba416a41a65359c6e3e2.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nreturns (bool)\n{\nuint VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 > VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN12(address VAR3,uint256 VAR14)\nFUN11\nFUN10\npublic\nreturns (bool)\n{\nVAR2 = VAR2.add(VAR14);\nVAR1[VAR3] = VAR1[VAR3].add(VAR14);\nreturn true;\n}\nfunction FUN13() FUN6 FUN10 public returns (bool) {\nVAR13 = true;\nreturn true;\n}\n}\ncontract CON7 is CON3 {\nstring public VAR15;\nstring public VAR16;\nuint8 public VAR17;\nconstructor(string VAR18, string VAR19, uint8 VAR20) public {\nVAR15 = VAR18;\nVAR16 = VAR19;\nVAR17 = VAR20;\n}\n}\ncontract CON8 is CON6, CON7{\nconstructor(string VAR18, string VAR19, uint8 VAR20)\nCON7(VAR18, VAR19, VAR20)\npublic\n{\n}\n}",
        "label": false,
        "name": "0x4a10061267a6bbb55e7a0ba9daa820ccdb38fb07.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4 {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 returns (bool) {\nVAR3 = true;\nreturn true;\n}\nfunction FUN6() FUN1 FUN4 returns (bool) {\nVAR3 = false;\nreturn true;\n}\n}\ncontract CON3 {\nuint256 public VAR4;\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) returns (bool) {\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN8(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR5[VAR8];\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) VAR10;\nfunction FUN9(address VAR11, address VAR6, uint256 VAR7) returns (bool) {\nvar VAR12 = VAR10[VAR11][msg.sender];\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nVAR5[VAR11] = VAR5[VAR11].sub(VAR7);\nVAR10[VAR11][msg.sender] = VAR12.sub(VAR7);\nreturn true;\n}\nfunction FUN10(address VAR13, uint256 VAR7) returns (bool) {\nrequire((VAR7 == 0) || (VAR10[msg.sender][VAR13] == 0));\nVAR10[msg.sender][VAR13] = VAR7;\nreturn true;\n}\nfunction FUN11(address VAR8, address VAR13) constant returns (uint256 VAR14) {\nreturn VAR10[VAR8][VAR13];\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6, uint VAR7) FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN9(address VAR11, address VAR6, uint VAR7) FUN3 returns (bool) {\nreturn super.FUN9(VAR11, VAR6, VAR7);\n}\n}\ncontract CON8 is CON7 {\nusing SafeMath for uint256;\nstring public constant VAR15 = 'CON8';\nstring public constant VAR16 = 'PLL';\nuint8 public constant VAR17 = 18;\nuint256 public VAR4 = 100e24;\nbool public VAR18 = false;\nuint256 public VAR19 = 0;\nuint256 public VAR20 = 0;\naddress public VAR21;\nuint256 public VAR22 = 40e24;\nuint256 public VAR23 = 10e24;\nuint256 public VAR24 = 50e24;\nmodifier FUN12() {\nrequire(msg.sender == VAR21);\n_;\n}\nfunction CON8() {\nVAR5[msg.sender] = VAR22; }\nfunction FUN13(address VAR25) external FUN1 FUN3 {\nrequire(VAR25 != address(0));\nVAR21 = VAR25;\n}\nfunction FUN14(address VAR26, uint VAR27) external FUN1 FUN3 {\nrequire(VAR26 != address(0));\nrequire(VAR27 > 0 && VAR27 <= VAR23);\nrequire(VAR19 < VAR23);\nrequire(VAR19.add(VAR27) < VAR23);\nVAR19 = VAR19.add(VAR27);\nVAR5[VAR26] = VAR5[VAR26].add(VAR27);\n}\nfunction FUN15(address VAR26, uint VAR27) external FUN12 FUN3 {\nrequire(VAR26 != address(0));\nrequire(VAR27 > 0);\nrequire(VAR20 < VAR24);\nrequire(VAR20.add(VAR27) <= VAR24);\nVAR20 = VAR20.add(VAR27);\nVAR5[VAR26] = VAR5[VAR26].add(VAR27);\n}\nfunction FUN16(address VAR26, uint256 VAR27) external FUN12 FUN3 {\nrequire(VAR26 != address(0));\nrequire(VAR27 > 0);\nrequire(VAR5[VAR26] >= VAR27);\nVAR5[VAR26] = VAR5[VAR26].sub(VAR27);\n}\nfunction FUN17() external FUN12 FUN3 {\nuint256 VAR28 = VAR24.sub(VAR20);\nif(VAR28 > 0 && !VAR18) {\nVAR18 = true;\nVAR24 = VAR24.sub(VAR28);\nVAR4 = VAR4.sub(VAR28);\n}\n}\n}",
        "label": false,
        "name": "0xd453540794c0f8fa2cfe4fa74c95dfc7318a3d3f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor(string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nrequire(VAR11 <= VAR7[msg.sender]);\nrequire(VAR10 != address(0));\nVAR7[msg.sender] = VAR7[msg.sender].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = VAR11;\nreturn true;\n}\nfunction FUN3(address VAR13,address VAR10,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR11 <= VAR7[VAR13]);\nrequire(VAR11 <= VAR8[VAR13][msg.sender]);\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\nVAR8[VAR13][msg.sender] = VAR8[VAR13][msg.sender].sub(VAR11);\nreturn true;\n}\nfunction FUN4(address VAR12,uint256 VAR14)\npublic\nreturns (bool)\n{\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = (VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12,uint256 VAR15)\npublic\nreturns (bool)\n{\nrequire(VAR12 != address(0));\nVAR8[msg.sender][VAR12] = (VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR16, uint256 VAR17) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR17);\nVAR7[VAR16] = VAR7[VAR16].add(VAR17);\n}\nfunction FUN7(address VAR16, uint256 VAR17) internal {\nrequire(VAR16 != address(0));\nrequire(VAR17 <= VAR7[VAR16]);\nVAR9 = VAR9.sub(VAR17);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR17);\n}\nfunction FUN8(address VAR16, uint256 VAR17) internal {\nrequire(VAR17 <= VAR8[VAR16][msg.sender]);\nVAR8[VAR16][msg.sender] = VAR8[VAR16][msg.sender].sub(VAR17);\nFUN7(VAR16, VAR17);\n}\n}\ncontract CON4 {\nmapping (address => string) public VAR18;\nmapping (address => string) public VAR19;\nmapping (address => string) public VAR20;\nmapping (address => string) public VAR21;\nmapping (address => string) public VAR22;\nfunction FUN9 (string memory VAR1, string memory VAR23, string memory VAR24, string memory VAR25, string memory VAR26) public {\nVAR18[msg.sender] = VAR1;\nVAR19[msg.sender] = VAR23;\nVAR20[msg.sender] = VAR24;\nVAR21[msg.sender] = VAR25;\nVAR22[msg.sender] = VAR26;\n}\n}\ncontract CON5 is CON3, CON2, CON4 {\nconstructor()\nCON2(\"Orientum Plus\", \"ORT+\", 18)\nCON3()\nCON4()\npublic\n{\nuint256 VAR27 = 40000000000;\nuint256 VAR28 = VAR27.mul(10 ** uint256(18));\nFUN6(msg.sender, VAR28);\n}\n}",
        "label": false,
        "name": "0xe02a471b2778b2d3a220e1ff82a0f8184fb73504.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nVAR1 = VAR2;\n}\n}\ninterface CON2 { }\ncontract CON3 {\nstring public VAR3 = \"Slidebits Token\";\nstring public VAR4 = \"SBT\";\nuint8 public VAR5 = 18;\nuint256 VAR6 = 100000000;\nuint256 public VAR7 = VAR6 * 10 ** uint256(VAR5);\nmapping (address => uint256) public VAR8;\nmapping (address => mapping (address => uint256)) public VAR9;\nconstructor() public {\nVAR8[msg.sender] = VAR7; }\nfunction FUN3(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR8[VAR10] >= VAR12);\nrequire(VAR8[VAR11] + VAR12 > VAR8[VAR11]);\nuint VAR13 = VAR8[VAR10] + VAR8[VAR11];\nVAR8[VAR10] -= VAR12;\nVAR8[VAR11] += VAR12;\nassert(VAR8[VAR10] + VAR8[VAR11] == VAR13);\n}\nfunction FUN4(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN3(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN5(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR9[VAR10][msg.sender]); VAR9[VAR10][msg.sender] -= VAR12;\nFUN3(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN6(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN7(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON2 VAR17 = CON2(VAR15);\nif (FUN6(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN8(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR8[msg.sender] >= VAR12); VAR8[msg.sender] -= VAR12; VAR7 -= VAR12;\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR8[VAR10] >= VAR12); require(VAR12 <= VAR9[VAR10][msg.sender]); VAR8[VAR10] -= VAR12; VAR9[VAR10][msg.sender] -= VAR12; VAR7 -= VAR12;\nreturn true;\n}\n}\ncontract CON4 is CON1, CON3 {\nmapping (address => bool) public VAR18;\nconstructor() CON3() public {}\nfunction FUN3(address VAR10, address VAR11, uint VAR12) internal {\nrequire (VAR11 != address(0x0)); require (VAR8[VAR10] >= VAR12); require (VAR8[VAR11] + VAR12 >= VAR8[VAR11]); require(!VAR18[VAR10]); require(!VAR18[VAR11]); VAR8[VAR10] -= VAR12; VAR8[VAR11] += VAR12;\n}\nfunction FUN10(address VAR19, uint256 VAR20) FUN1 public {\nVAR8[VAR19] += VAR20;\nVAR7 += VAR20;\n}\nfunction FUN11(address VAR19, bool VAR21) FUN1 public {\nVAR18[VAR19] = VAR21;\n}\n}",
        "label": false,
        "name": "0x46706c5e5b7df0afd54a7248f1e5788275b7fac6.sol"
    },
    {
        "source": "contract CON1 {\naddress private VAR1;\nconstructor() internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR3;\nmapping (address => mapping (address => uint256)) private VAR4;\nuint256 private VAR5;\nfunction FUN5(address VAR6, uint256 VAR7) public returns (bool) {\nFUN10(msg.sender, VAR6, VAR7);\nreturn true;\n}\nfunction FUN6(address VAR8, uint256 VAR7) public returns (bool) {\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = VAR7;\nreturn true;\n}\nfunction FUN7(address VAR9,address VAR6,uint256 VAR7)\npublic\nreturns (bool)\n{\nrequire(VAR7 <= VAR4[VAR9][msg.sender]);\nVAR4[VAR9][msg.sender] = VAR4[VAR9][msg.sender].sub(VAR7);\nFUN10(VAR9, VAR6, VAR7);\nreturn true;\n}\nfunction FUN8(address VAR8,uint256 VAR10)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].add(VAR10));\nreturn true;\n}\nfunction FUN9(address VAR8,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR8 != address(0));\nVAR4[msg.sender][VAR8] = (VAR4[msg.sender][VAR8].sub(VAR11));\nreturn true;\n}\nfunction FUN10(address VAR9, address VAR6, uint256 VAR7) internal {\nrequire(VAR7 <= VAR3[VAR9]);\nrequire(VAR6 != address(0));\nVAR3[VAR9] = VAR3[VAR9].sub(VAR7);\nVAR3[VAR6] = VAR3[VAR6].add(VAR7);\n}\nfunction FUN11(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != 0);\nVAR5 = VAR5.add(VAR7);\nVAR3[VAR12] = VAR3[VAR12].add(VAR7);\n}\nfunction FUN12(address VAR12, uint256 VAR7) internal {\nrequire(VAR12 != 0);\nrequire(VAR7 <= VAR3[VAR12]);\nVAR5 = VAR5.sub(VAR7);\nVAR3[VAR12] = VAR3[VAR12].sub(VAR7);\n}\nfunction FUN13(address VAR12, uint256 VAR7) internal {\nrequire(VAR7 <= VAR4[VAR12][msg.sender]);\nVAR4[VAR12][msg.sender] = VAR4[VAR12][msg.sender].sub(VAR7);\nFUN12(VAR12, VAR7);\n}\n}\ncontract CON4 is CON3 {\nfunction FUN14(uint256 VAR7) public {\nFUN12(msg.sender, VAR7);\n}\nfunction FUN15(address VAR9, uint256 VAR7) public {\nFUN13(VAR9, VAR7);\n}\n}\ncontract CON5 is CON4, CON1 {\nstring public constant VAR13 = \"Substratum\";\nstring public constant VAR14 = \"SUB\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 472000000000000000000000000;\nconstructor() public {\nCON3.FUN11(msg.sender, VAR16);\n}\nfunction FUN6(address VAR17, uint256 VAR18) public returns (bool) {\nrequire(VAR18 == 0 || allowance(msg.sender, VAR17) == 0, \"Use increaseApproval or decreaseApproval VAR6 prevent double-spend.\");\nreturn CON3.FUN6(VAR17, VAR18);\n}\n}",
        "label": false,
        "name": "0x8d75959f1e61ec2571aa72798237101f084de63a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nif (msg.sender != VAR1) {\nrevert();\n}\n_;\n}\nfunction FUN2(address VAR2) FUN1 public {\nif (VAR2 != address(0)) {\nVAR1 = VAR2;\n}\n}\n}\ncontract CON2 {\nuint256 public VAR3;\n}\ncontract CON3 is CON2 {\n}\ncontract CON4 is CON2 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nmodifier FUN3(uint VAR5) {\nif(msg.data.length < VAR5 + 4) {\nrevert();\n}\n_;\n}\nfunction FUN4(address VAR6, uint256 VAR7) FUN3(2 * 32) public {\nVAR4[msg.sender] = VAR4[msg.sender].sub256(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add256(VAR7);\n}\nfunction FUN5(address VAR8) constant public returns (uint256 VAR9) {\nreturn VAR4[VAR8];\n}\n}\ncontract CON5 is CON4, CON3 {\nmapping (address => mapping (address => uint256)) VAR10;\nfunction FUN6(address VAR11, address VAR6, uint256 VAR7) FUN3(3 * 32) public {\nvar VAR12 = VAR10[VAR11][msg.sender];\nVAR4[VAR6] = VAR4[VAR6].add256(VAR7);\nVAR4[VAR11] = VAR4[VAR11].sub256(VAR7);\nVAR10[VAR11][msg.sender] = VAR12.sub256(VAR7);\n}\nfunction FUN7(address VAR13, uint256 VAR7) public {\nif ((VAR7 != 0) && (VAR10[msg.sender][VAR13] != 0)) revert();\nVAR10[msg.sender][VAR13] = VAR7;\n}\nfunction FUN8(address VAR8, address VAR13) constant public returns (uint256 VAR14) {\nreturn VAR10[VAR8][VAR13];\n}\n}\ncontract CON6 is CON5, CON1{\nstring public VAR15 = \"20-footEqvUnit\";\nstring public VAR16 = \"TEU\";\nuint public VAR17 = 18;\nfunction CON6() public {\nVAR3 = (10 ** 8) * (10 ** VAR17);\nVAR4[msg.sender] = VAR3;\n}\nfunction FUN9(uint VAR7) FUN1 public {\nrequire(VAR4[msg.sender] >= VAR7);\nVAR4[msg.sender] = VAR4[msg.sender].sub256(VAR7);\nVAR3 = VAR3.sub256(VAR7);\n}\n}\ncontract CON7 is CON1 {\nbool public VAR18;\nmodifier FUN10 {\nif (VAR18) {\nrevert();\n}\n_;\n}\nmodifier FUN11 {\nif (!VAR18) {\nrevert();\n}\n_;\n}\nfunction FUN12() external FUN1 {\nVAR18 = true;\n}\nfunction FUN13() external FUN1 FUN11 {\nVAR18 = false;\n}\n}\ncontract CON8 is CON1, CON7 {\nusing SafeMath for uint256;\nCON6 private VAR19;\nfunction FUN14() FUN1 public {\nif (!VAR1.send(this.VAR9)) revert();\n}\nfunction () payable public {\nif (msg.value!=0) revert();\n}\nfunction FUN16(bytes32 VAR20, bytes32 VAR21, string VAR22, string VAR23) FUN1 FUN10 public {\n}\nfunction FUN17(bytes32 VAR20, string VAR24, bytes32 VAR25, bytes32 VAR26, uint256 VAR27, uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR31) FUN1 FUN10 public {\n}\nfunction FUN18(bytes32 VAR20, bytes32 VAR32, bytes32 VAR33, string VAR34, uint256 VAR35, string VAR36, uint256 VAR37) FUN1 FUN10 public {\n}\nfunction FUN19(bytes32 VAR38, address VAR39, bytes32 VAR40) FUN1 public {\n}\nfunction FUN20(string VAR38, uint256 VAR35, address VAR41) FUN10 public {\nrequire(VAR35 > 0);\nbytes32 VAR42 = stringToBytes32(VAR38);\nVAR19.FUN6(VAR41, this, VAR35);\n}\nfunction FUN21(bytes32 VAR38, bytes32 VAR43, address VAR44, uint256 VAR35) FUN1 FUN10 public {\nrequire(VAR35 > 0);\nVAR19.FUN4(VAR44, VAR35);\n}\nfunction FUN22(bytes32 VAR20, bytes32 VAR38, bytes32 VAR33, uint256 VAR35) FUN1 FUN10 public {\n}\nfunction FUN23(uint256 VAR35, bytes32 VAR43) FUN1 FUN10 public {\nVAR19.FUN4(msg.sender, VAR35);\n}\nfunction FUN24(bytes32 VAR20, bytes32 VAR33, uint256 VAR35) FUN1 FUN10 public {\n}\nfunction FUN25(bytes32 VAR20, bytes32 VAR38, uint256 VAR35) FUN1 FUN10 public {\n}\nfunction FUN26(bytes32 VAR20, string VAR24, bytes32 VAR25, bytes32 VAR26, uint256 VAR27, uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR45, uint256 VAR46, uint256 VAR47, uint256 VAR48) FUN1 FUN10 public {\n}\nfunction FUN27(bytes32 VAR20, string VAR24, bytes32 VAR25, bytes32 VAR26, uint256 VAR27, uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR31) FUN1 FUN10 public {\n}\nfunction FUN28() constant public FUN1 returns (address) {\nreturn VAR19;\n}\nfunction FUN29(address VAR49) public FUN1 FUN10 {\nrequire(VAR19 == address(0));\nVAR19 = CON6(VAR49);\n}\n}",
        "label": false,
        "name": "0x7c639dafe776aa02f24b90c9bca3dc4ff11b6b3d.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x8663cc2eaa2de00461fe4711f22e2076b19085cb.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 {\naddress public VAR1;\naddress public VAR2;\nfunction CON3() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR3) public FUN1 {\nVAR2 = VAR3;\n}\nfunction FUN3() public {\nrequire(msg.sender == VAR2);\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ncontract CON4 is CON1, CON3 {\nusing SafeMath for uint;\nstring public VAR4;\nstring public VAR5;\nuint8 public VAR6;\nuint public VAR7;\nmapping(address => uint) VAR8;\nmapping(address => mapping(address => uint)) VAR9;\nfunction CON4() public {\nVAR4 = \"CAM\";\nVAR5 = \"CamCoin\";\nVAR6 = 0;\nVAR7 = 31135181514;\nVAR8[VAR1] = VAR7;\n}\nfunction FUN4() public constant returns (uint) {\nreturn VAR7 - VAR8[address(0)];\n}\nfunction FUN5(address VAR10) public constant returns (uint VAR11) {\nreturn VAR8[VAR10];\n}\nfunction FUN6(address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[msg.sender] = VAR8[msg.sender].sub(VAR13);\nVAR8[VAR12] = VAR8[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN7(address VAR15, uint VAR13) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nreturn true;\n}\nfunction FUN8(address VAR16, address VAR12, uint VAR13) public returns (bool VAR14) {\nVAR8[VAR16] = VAR8[VAR16].sub(VAR13);\nVAR9[VAR16][msg.sender] = VAR9[VAR16][msg.sender].sub(VAR13);\nVAR8[VAR12] = VAR8[VAR12].add(VAR13);\nreturn true;\n}\nfunction FUN9(address VAR10, address VAR15) public constant returns (uint VAR17) {\nreturn VAR9[VAR10][VAR15];\n}\nfunction FUN10(address VAR15, uint VAR13, bytes VAR18) public returns (bool VAR14) {\nVAR9[msg.sender][VAR15] = VAR13;\nCON2(VAR15).receiveApproval(msg.sender, VAR13, this, VAR18);\nreturn true;\n}\nfunction () public payable {\nrevert();\n}\nfunction FUN12(address VAR19, uint VAR13) public FUN1 returns (bool VAR14) {\nreturn CON1(VAR19).FUN6(VAR1, VAR13);\n}\n}",
        "label": false,
        "name": "0xd451177ce7c4d7ebfe7109a239455d38aeb8c3d1.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, address VAR4, uint VAR5) internal {\nrequire(VAR4 != 0x0);\nrequire(VAR1[VAR3] >= VAR5);\nrequire(VAR1[VAR4] + VAR5 > VAR1[VAR4]);\nuint VAR6 = VAR1[VAR3] + VAR1[VAR4];\nVAR1[VAR3] = VAR1[VAR3].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nassert(VAR1[VAR3] + VAR1[VAR4] == VAR6);\n}\nfunction FUN2(address VAR4, uint256 VAR5) public returns (bool) {\nFUN1(msg.sender, VAR4, VAR5);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nstring public VAR8; uint8 public VAR9; string public VAR10; uint256 public VAR11;\nuint256 public VAR12;\nfunction CON4(uint256 VAR13,string VAR14,uint8 VAR15,string VAR16) public {\nVAR1[msg.sender] = VAR13 * 10 ** uint256(VAR15); VAR2 = VAR13 * 10 ** uint256(VAR15); VAR8 = VAR14; VAR9 = VAR15; VAR10 = VAR16; }\nfunction FUN3(address VAR3, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR1[VAR3]);\nrequire(VAR5 <= VAR7[VAR3][msg.sender]);\nVAR1[VAR3] = VAR1[VAR3].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\nVAR7[VAR3][msg.sender] = VAR7[VAR3][msg.sender].sub(VAR5);\nreturn true;\n}\nfunction FUN4(address VAR17, uint256 VAR5) public returns (bool) {\nVAR7[msg.sender][VAR17] = VAR5;\nreturn true;\n}\nfunction FUN5(uint256 VAR18, uint256 VAR19) public {\nVAR11 = VAR18;\nVAR12 = VAR19;\n}\nfunction FUN6() payable public {\nuint VAR20 = uint(msg.value) / uint(VAR12); FUN1(this, msg.sender, VAR20 * 10 ** uint256(VAR9)); }\nfunction() payable public{\nFUN6();\n}\nfunction FUN8(uint256 VAR20) public {\nrequire(this.balance >= VAR20 * VAR11); FUN1(msg.sender, this, VAR20 * 10 ** uint256(VAR9)); msg.sender.FUN2(VAR20 * VAR11); }\n}",
        "label": false,
        "name": "0x1fa2091397997788cbc04e11e73d6a30ac2adf54.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nfunction CON1() {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4 {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 returns (bool) {\nVAR3 = true;\nreturn true;\n}\nfunction FUN6() FUN1 FUN4 returns (bool) {\nVAR3 = false;\nreturn true;\n}\n}\ncontract CON3 {\nuint256 public VAR4;\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) returns (bool) {\nVAR5[msg.sender] = VAR5[msg.sender].sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN8(address VAR8) constant returns (uint256 VAR9) {\nreturn VAR5[VAR8];\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) VAR10;\nfunction FUN9(address VAR11, address VAR6, uint256 VAR7) returns (bool) {\nuint256 VAR12 = VAR10[VAR11][msg.sender];\nVAR5[VAR11] = VAR5[VAR11].sub(VAR7);\nVAR10[VAR11][msg.sender] = VAR12.sub(VAR7);\nVAR5[VAR6] = VAR5[VAR6].add(VAR7);\nreturn true;\n}\nfunction FUN10(address VAR13, uint256 VAR7) returns (bool) {\nrequire((VAR7 == 0) || (VAR10[msg.sender][VAR13] == 0));\nVAR10[msg.sender][VAR13] = VAR7;\nreturn true;\n}\nfunction FUN11(address VAR8, address VAR13) constant returns (uint256 VAR14) {\nreturn VAR10[VAR8][VAR13];\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN7(address VAR6, uint VAR7) FUN3 returns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN9(address VAR11, address VAR6, uint VAR7) FUN3 returns (bool) {\nreturn super.FUN9(VAR11, VAR6, VAR7);\n}\n}\ncontract CON8 is CON1 {\nusing SafeMath for uint256;\nenum State { Active, Refunding, Closed }\nmapping (address => uint256) public VAR15;\naddress public VAR16;\nState public VAR17;\nfunction CON8(address VAR18) {\nrequire(VAR18 != 0x0);\nVAR16 = VAR18;\nVAR17 = State.Active;\n}\nfunction FUN12(address VAR19) FUN1 payable {\nrequire(VAR17 == State.Active);\nVAR15[VAR19] = VAR15[VAR19].add(msg.value);\n}\nfunction FUN13() FUN1 {\nrequire(VAR17 == State.Active);\nVAR17 = State.Closed;\nVAR16.FUN7(this.VAR9);\n}\nfunction FUN14() FUN1 {\nrequire(VAR17 == State.Active);\nVAR17 = State.Refunding;\n}\nfunction FUN15(address VAR19) {\nrequire(VAR17 == State.Refunding);\nuint256 VAR20 = VAR15[VAR19];\nVAR15[VAR19] = 0;\nVAR19.FUN7(VAR20);\n}\n}\ncontract CON9 is CON7 {\nusing SafeMath for uint256;\nstring public constant VAR21 = 'CON9';\nstring public constant VAR22 = 'PLL';\nuint8 public constant VAR23 = 18;\nuint256 public VAR4 = 100e24;\nbool public VAR24 = false;\nuint256 public VAR25 = 0;\nuint256 public VAR26 = 0;\naddress public VAR27;\nuint256 public VAR28 = 40e24;\nuint256 public VAR29 = 10e24;\nuint256 public VAR30 = 50e24;\nmodifier FUN16() {\nrequire(msg.sender == VAR27);\n_;\n}\nfunction CON9() {\nVAR5[msg.sender] = VAR28; }\nfunction FUN17(address VAR31) external FUN1 FUN3 {\nrequire(VAR31 != address(0));\nVAR27 = VAR31;\n}\nfunction FUN18(address VAR32, uint VAR33) external FUN1 FUN3 {\nrequire(VAR32 != address(0));\nrequire(VAR33 > 0 && VAR33 <= VAR29);\nrequire(VAR25 < VAR29);\nrequire(VAR25.add(VAR33) < VAR29);\nVAR25 = VAR25.add(VAR33);\nVAR5[VAR32] = VAR5[VAR32].add(VAR33);\n}\nfunction FUN19(address VAR32, uint VAR33) external FUN16 FUN3 {\nrequire(VAR32 != address(0));\nrequire(VAR33 > 0);\nrequire(VAR26 < VAR30);\nrequire(VAR26.add(VAR33) <= VAR30);\nVAR26 = VAR26.add(VAR33);\nVAR5[VAR32] = VAR5[VAR32].add(VAR33);\n}\nfunction FUN20(address VAR32, uint256 VAR33) external FUN16 FUN3 {\nrequire(VAR32 != address(0));\nrequire(VAR33 > 0);\nrequire(VAR5[VAR32] >= VAR33);\nVAR5[VAR32] = VAR5[VAR32].sub(VAR33);\n}\nfunction FUN21() external FUN16 FUN3 {\nuint256 VAR34 = VAR30.sub(VAR26);\nif(VAR34 > 0 && !VAR24) {\nVAR24 = true;\nVAR30 = VAR30.sub(VAR34);\nVAR4 = VAR4.sub(VAR34);\n}\n}\n}\ncontract CON10 is CON2 {\nusing SafeMath for uint256;\nCON9 public VAR35;\nCON8 public VAR36;\nuint256 public VAR37 = 1511068829;\nuint256 public VAR38 = 1512021029;\naddress public VAR16;\naddress public VAR39;\nuint256 public VAR40;\nuint256 public VAR41;\nuint256 public VAR42;\nuint256 public VAR43;\nuint256 public VAR44 = 12.5e24;\nuint256 public VAR45 = 25e24;\nuint256 public VAR46 = 37.5e24;\nuint256 public VAR47 = 0;\nuint256 public VAR48 = 0;\nuint256 public constant VAR49 = 50e24;\nuint256 public constant VAR50 = 10 finney;\nuint256 public constant VAR51 = 2000 ether;\nuint256 public constant VAR52 = 4266e18;\nbool public VAR53 = false;\nbool public VAR54 = false;\nuint256 public VAR55;\nuint256 public VAR56 = 50000000000 wei;\nmapping(address => uint256) public VAR57;\nmapping(address => uint256) public VAR58;\nmodifier FUN22() {\nrequire(now < VAR37);\n_;\n}\nfunction CON10(address VAR18,address VAR59,address VAR60,uint256 VAR61,uint256 VAR62) public {\nrequire(VAR18 != address(0));\nrequire(VAR60 != address(0));\nrequire(VAR59 != address(0));\nif(VAR61 > 0 && VAR62 > 0)\nrequire(VAR61 < VAR62);\nVAR16 = VAR18;\nVAR39 = VAR59;\nVAR35 = CON9(VAR60);\nVAR36 = new CON8(VAR18);\nif(VAR61 > 0)\nVAR37 = VAR61;\nif(VAR62 > 0)\nVAR38 = VAR62;\n}\nfunction () payable {\nFUN24();\n}\nfunction FUN24() public payable FUN3 {\nrequire(FUN32());\nuint256 VAR33 = 0;\nuint256 VAR63 = FUN25();\nif(VAR48 < VAR44) {\nVAR33 = VAR63.mul(VAR40);\nif(VAR48.add(VAR33) > VAR44)\nVAR33 = FUN30(VAR63, VAR44, 1, VAR40);\n} else if(VAR48 >= VAR44 && VAR48 < VAR45) {\nVAR33 = VAR63.mul(VAR41);\nif(VAR48.add(VAR33) > VAR45)\nVAR33 = FUN30(VAR63, VAR45, 2, VAR41);\n} else if(VAR48 >= VAR45 && VAR48 < VAR46) {\nVAR33 = VAR63.mul(VAR42);\nif(VAR48.add(VAR33) > VAR46)\nVAR33 = FUN30(VAR63, VAR46, 3, VAR42);\n} else if(VAR48 >= VAR46) {\nVAR33 = VAR63.mul(VAR43);\n}\nVAR47 = VAR47.add(VAR63);\nuint256 VAR64 = VAR48;\nVAR48 = VAR48.add(VAR33);\nVAR35.FUN19(msg.sender, VAR33);\nVAR58[msg.sender] = VAR58[msg.sender].add(VAR33);\nVAR55 = VAR55.add(1);\nif(VAR64 > VAR52) {\nVAR39.FUN7(VAR63);\n} else {\nVAR36.FUN12.value(VAR63)(msg.sender);\nif(FUN33()) {\nVAR36.FUN13();\n}\n}\nFUN28();\n}\nfunction FUN25() internal FUN3 returns(uint256) {\nuint256 VAR63 = msg.value;\nuint256 VAR65 = 0;\nuint256 VAR66 = 0;\nif(VAR48 >= VAR46) {\nuint256 VAR67 = VAR48.add(VAR63.mul(VAR43));\nif(VAR67 > VAR49) {\nuint256 VAR68 = VAR67.sub(VAR49);\nVAR65 = VAR68.div(VAR43);\nVAR63 = VAR63.sub(VAR65);\n}\n}\nuint256 VAR69 = VAR57[msg.sender].add(VAR63);\nif(VAR69 <= VAR51) {\nVAR57[msg.sender] = VAR57[msg.sender].add(VAR63);\n} else {\nVAR66 = VAR69.sub(VAR51);\nVAR63 = VAR63.sub(VAR66);\nVAR57[msg.sender] = VAR57[msg.sender].add(VAR63);\n}\nif(VAR65 > 0)\nmsg.sender.FUN7(VAR65);\nif(VAR66 > 0) {\nmsg.sender.FUN7(VAR66);\n}\nreturn VAR63;\n}\nfunction FUN26(uint256 VAR70, uint256 VAR71, uint256 VAR72, uint256 VAR73)\nexternal FUN1 FUN3\n{\nrequire(VAR70 > 0 && VAR71 > 0 && VAR72 > 0 && VAR73 > 0);\nrequire(VAR70 > VAR71 && VAR71 > VAR72 && VAR72 > VAR73);\nVAR40 = VAR70;\nVAR41 = VAR71;\nVAR42 = VAR72;\nVAR43 = VAR73;\n}\nfunction FUN27(uint256 VAR62)\nexternal FUN1 FUN3\n{\nrequire(now <= VAR62);\nrequire(VAR37 < VAR62);\nVAR38 = VAR62;\n}\nfunction FUN28() public FUN3 {\nif(!VAR54) {\nif(FUN34() && !FUN33()){\nVAR36.FUN14();\nVAR53 = true;\nVAR54 = true;\n} else if(FUN34() && FUN33()) {\nVAR54 = true;\nif(VAR48 < VAR49) {\nVAR35.FUN21();\n}\n}\n}\n}\nfunction FUN29() public FUN3 {\nrequire(FUN34() && !FUN33() && VAR53);\nVAR36.FUN15(msg.sender);\nVAR35.FUN20(msg.sender, VAR58[msg.sender]);\n}\nfunction FUN30(uint256 VAR74,uint256 VAR75,uint256 VAR76,uint256 VAR77) public returns(uint256 VAR78) {\nrequire(VAR74 > 0 && VAR75 > 0 && VAR77 > 0);\nrequire(VAR76 >= 1 && VAR76 <= 4);\nuint VAR79 = VAR75.sub(VAR48).div(VAR77);\nuint VAR80 = VAR74.sub(VAR79);\nuint VAR81 = 0;\nbool VAR82 = false;\nif(VAR76 != 4)\nVAR81 = FUN31(VAR80, VAR76.add(1));\nelse\nVAR82 = true;\nVAR78 = VAR75.sub(VAR48).add(VAR81);\nif(VAR82) msg.sender.FUN7(VAR80);\n}\nfunction FUN31(uint256 VAR83, uint256 VAR76)\ninternal constant returns(uint256 VAR84)\n{\nrequire(VAR83 > 0);\nrequire(VAR76 >= 1 && VAR76 <= 4);\nif(VAR76 == 1)\nVAR84 = VAR83.mul(VAR40);\nelse if(VAR76 == 2)\nVAR84 = VAR83.mul(VAR41);\nelse if(VAR76 == 3)\nVAR84 = VAR83.mul(VAR42);\nelse\nVAR84 = VAR83.mul(VAR43);\n}\nfunction FUN32() internal constant returns(bool) {\nbool VAR85 = now >= VAR37 && now <= VAR38;\nbool VAR86 = msg.value > 0;\nbool VAR87 = VAR48 < VAR49;\nbool VAR88 = msg.value >= VAR50;\nbool VAR89 = VAR57[msg.sender] < VAR51;\nreturn VAR85 && VAR86 && VAR87 && VAR88 && VAR89;\n}\nfunction FUN33() public constant returns(bool) {\nreturn VAR48 >= VAR52;\n}\nfunction FUN34() public constant returns(bool) {\nreturn now > VAR38 || VAR48 >= VAR49;\n}\n}",
        "label": false,
        "name": "0x1105536cc57be95a126e05c80262252b8c9998db.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 {\n}\ncontract CON3 is CON2, CON1 {\nconstructor () public {\n}\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR6 [msg.sender] < VAR2) return false;\nif (VAR2 > 0 && msg.sender != VAR1) {\nVAR6 [msg.sender] = safeSub (VAR6 [msg.sender], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(VAR1 != address(0));\nif (VAR7 [VAR4][msg.sender] < VAR2) return false;\nif (VAR6 [VAR4] < VAR2) return false;\nif (VAR2 > 0 && VAR4 != VAR1) {\nVAR7 [VAR4][msg.sender] = safeSub (VAR7 [VAR4][msg.sender], VAR2);\nVAR6 [VAR4] = safeSub (VAR6 [VAR4], VAR2);\nVAR6 [VAR1] = safeAdd (VAR6 [VAR1], VAR2);\n}\nreturn true;\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public returns (bool VAR3) {\nVAR7 [msg.sender][VAR5] = VAR2;\nreturn true;\n}\nmapping (address => uint256) VAR6;\nmapping (address => mapping (address => uint256)) private VAR7;\n}\ncontract CON4 is CON3 {\nuint256 constant VAR8 = 100000000 * (10**18);\naddress private VAR9;\nmapping (address => bool) private VAR10;\nuint256 VAR11 = 0;\nbool VAR12 = false;\nconstructor () public {\nVAR9 = msg.sender;\n}\nstring constant public VAR13 = \"Krypto99\";\nstring constant public VAR14 = \"K99\";\nuint8 constant public VAR15 = 18;\nfunction FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {\nrequire(!VAR10[msg.sender]);\nif (VAR12) return false;\nelse return CON3.FUN1 (VAR1, VAR2);\n}\nfunction FUN2(address VAR4, address VAR1, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(!VAR10[VAR4]);\nif (VAR12) return false;\nelse return CON3.FUN2 (VAR4, VAR1, VAR2);\n}\nfunction FUN3 (address VAR5, uint256 VAR2) public\nreturns (bool VAR3) {\nrequire(allowance (msg.sender, VAR5) == 0 || VAR2 == 0);\nreturn CON3.FUN3 (VAR5, VAR2);\n}\nfunction FUN4(uint256 VAR2) public\nreturns (bool VAR3) {\nrequire (msg.sender == VAR9);\nif (VAR2 > 0) {\nif (VAR2 > safeSub (VAR8, VAR11)) return false;\nVAR6 [msg.sender] = safeAdd (VAR6 [msg.sender], VAR2);\nVAR11 = safeAdd (VAR11, VAR2);\nreturn true;\n}\nreturn false;\n}\nfunction FUN5(address VAR16) public {\nrequire (msg.sender == VAR9);\nVAR9 = VAR16;\n}\nfunction FUN6 () public {\nrequire (msg.sender == VAR9);\nif (!VAR12) {\nVAR12 = true;\n}\n}\nfunction FUN7 () public {\nrequire (msg.sender == VAR9);\nif (VAR12) {\nVAR12 = false;\n}\n}\nfunction FUN8(address VAR17, address VAR18, uint256 VAR2) public {\nrequire (msg.sender == VAR9);\nrequire(VAR17 != address(this));\nCON3 VAR19 = CON3(VAR17);\nVAR19.FUN1(VAR18, VAR2);\n}\nfunction FUN9(address VAR20, bool VAR21) public {\nrequire (msg.sender == VAR9);\nrequire (msg.sender != VAR20);\nVAR10[VAR20] = VAR21;\n}\n}",
        "label": false,
        "name": "0xe75ece96b0922803faa31cc9c043cc9481d83ebd.sol"
    },
    {
        "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract Owned{\r\n\r\n        address Owner;\r\n\r\n        modifier OnlyOwner{\r\n        if(msg.sender != Owner){\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n        function Owned(){\r\n        Owner = msg.sender;\r\n    }\r\n\r\n}\r\n\r\ncontract EtherTransfer is Owned{\r\n\r\n                uint constant Fee = 5;\r\n    uint constant Decs = 10000;\r\n\r\n    bool public IsEthereum = false; \r\n\r\n        event ETHTransfer(address indexed From,address indexed To, uint Value);\r\n    event ETCReturn(address indexed Return, uint Value);\r\n\r\n    event ETCTransfer(address indexed From,address indexed To, uint Value);\r\n    event ETHReturn(address indexed Return, uint Value);\r\n    \r\n        AmIOnTheFork IsHeOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n        function EtherTransfer(){\r\n        IsEthereum = IsHeOnTheFork.forked();\r\n    }\r\n\r\n        function SendETH(address ETHAddress) returns(bool){\r\n        uint Value = msg.value - (msg.value*Fee/Decs);\r\n                if(IsEthereum && ETHAddress.send(Value)){\r\n            ETHTransfer(msg.sender, ETHAddress, Value);\r\n            return true;\r\n        }else if(!IsEthereum && msg.sender.send(msg.value)){\r\n            ETCReturn(msg.sender, msg.value);\r\n            return true;\r\n        }\r\n                throw;\r\n    }\r\n\r\n        function SendETC(address ETCAddress) returns(bool){\r\n        uint Value = msg.value - (msg.value*Fee/Decs);\r\n                if(!IsEthereum && ETCAddress.send(Value)){\r\n            ETCTransfer(msg.sender, ETCAddress, Value);\r\n            return true;\r\n        } else if(IsEthereum && msg.sender.send(msg.value)){\r\n            ETHReturn(msg.sender, msg.value);\r\n            return true;\r\n        }\r\n                throw;\r\n    }\r\n\r\n        function (){\r\n        throw;\r\n    }\r\n\r\n        function WithDraw() OnlyOwner returns(bool){\r\n        if(this.balance > 0 && Owner.send(this.balance)){\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n}",
        "label": false,
        "name": "0xb6db69e99f7e3ccb352fabde7d98a8fae0de4297.sol"
    },
    {
        "source": "contract CON1 {\nuint VAR1;\nfunction FUN1(uint VAR2) {\nVAR1 = VAR2;\n}\nfunction FUN2() constant returns (uint VAR1) {\nreturn VAR1;\n}\n}",
        "label": false,
        "name": "0x9295ede03f6eab5c8f215d3ddcf7dca3a26ca087.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nmapping (address => uint256) public VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool VAR6) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[msg.sender]);\nrequire(VAR2[VAR4] + VAR5 > VAR2[VAR4]);\nVAR2[msg.sender] = SafeMath.safeSub(VAR2[msg.sender], VAR5);\nVAR2[VAR4] = SafeMath.safeAdd(VAR2[VAR4], VAR5);\nreturn true;\n}\nfunction FUN2(address VAR7, address VAR4, uint256 VAR5) public returns (bool VAR6) {\nrequire(VAR4 != address(0));\nrequire(VAR5 <= VAR2[VAR7]);\nrequire(VAR5 <= VAR3[VAR7][msg.sender]);\nrequire(VAR2[VAR4] + VAR5 > VAR2[VAR4]);\nVAR2[VAR4] = SafeMath.safeAdd(VAR2[VAR4], VAR5);\nVAR2[VAR7] = SafeMath.safeSub(VAR2[VAR7], VAR5);\nVAR3[VAR7][msg.sender] = SafeMath.safeSub(VAR3[VAR7][msg.sender], VAR5);\nreturn true;\n}\nfunction VAR2(address VAR8) constant public returns (uint256 VAR9) {\nreturn VAR2[VAR8];\n}\nfunction FUN3(address VAR10, uint256 VAR5) public returns (bool VAR6) {\nrequire((VAR5 == 0) || (VAR3[msg.sender][VAR10] == 0));\nVAR3[msg.sender][VAR10] = VAR5;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR10) constant public returns (uint256 VAR11) {\nreturn VAR3[VAR8][VAR10];\n}\n}\ncontract CON3 is CON2 {\nfunction () public {\nrevert();\n}\nstring public VAR12 = \"World Blockchain Future Token\";\nuint8 public VAR13 = 18;\nstring public VAR14 = \"WT\";\nuint256 public VAR1 = 3*10**26;\nconstructor() public {\nVAR2[msg.sender] = VAR1;\n}\n}",
        "label": false,
        "name": "0x09115c388da7e23c7884a8625a6a4dafac9b8706.sol"
    },
    {
        "source": "contract Assertive {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract Owned is Assertive {\r\n  address internal owner;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  function Owned () {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  function getOwner() returns (address out) {\r\n    return owner;\r\n  }\r\n}\r\n\r\ncontract StateTransferrable is Owned {\r\n  bool internal locked;\r\n  event Locked(address indexed from);\r\n  event PropertySet(address indexed from);\r\n  modifier onlyIfUnlocked {\r\n    assert(!locked);\r\n    _\r\n  }\r\n  modifier setter {\r\n    _\r\n    PropertySet(msg.sender);\r\n  }\r\n  modifier onlyOwnerUnlocked {\r\n    assert(!locked && msg.sender == owner);\r\n    _\r\n  }\r\n  function lock() onlyOwner onlyIfUnlocked {\r\n    locked = true;\r\n    Locked(msg.sender);\r\n  }\r\n  function isLocked() returns (bool status) {\r\n    return locked;\r\n  }\r\n}\r\n\r\ncontract TrustEvents {\r\n  event AuthInit(address indexed from);\r\n  event AuthComplete(address indexed from, address indexed with);\r\n  event AuthPending(address indexed from);\r\n  event Unauthorized(address indexed from);\r\n  event InitCancel(address indexed from);\r\n  event NothingToCancel(address indexed from);\r\n  event SetMasterKey(address indexed from);\r\n  event AuthCancel(address indexed from, address indexed with);\r\n  event NameRegistered(address indexed from, bytes32 indexed name);\r\n}\r\n\r\ncontract Trust is StateTransferrable, TrustEvents {\r\n  mapping (address => bool) public masterKeys;\r\n  mapping (address => bytes32) public nameRegistry;\r\n  address[] public masterKeyIndex;\r\n  mapping (address => bool) public masterKeyActive;\r\n  mapping (address => bool) public trustedClients;\r\n  mapping (bytes32 => address) public functionCalls;\r\n  mapping (address => bytes32) public functionCalling;\r\n  function activateMasterKey(address addr) internal {\r\n    if (!masterKeyActive[addr]) {\r\n      masterKeyActive[addr] = true;\r\n      masterKeyIndex.push(addr);\r\n    }\r\n  }\r\n  function setTrustedClient(address addr) onlyOwnerUnlocked setter {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function untrustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = false;\r\n  }\r\n  function trustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function setMasterKey(address addr) onlyOwnerUnlocked {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n    SetMasterKey(msg.sender);\r\n  }\r\n  modifier onlyMasterKey {\r\n    assert(masterKeys[msg.sender]);\r\n    _\r\n  }\r\n  function extractMasterKeyIndexLength() returns (uint256 length) {\r\n    return masterKeyIndex.length;\r\n  }\r\n  function resetAction(bytes32 hash) internal {\r\n    address addr = functionCalls[hash];\r\n    functionCalls[hash] = 0x0;\r\n    functionCalling[addr] = bytes32(0);\r\n  }\r\n  function authCancel(address from) external returns (uint8 status) {\r\n    if (!masterKeys[from] || !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    bytes32 call = functionCalling[from];\r\n    if (call == bytes32(0)) {\r\n      NothingToCancel(from);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(from, from);\r\n      functionCalling[from] = bytes32(0);\r\n      functionCalls[call] = 0x0;\r\n      return 2;\r\n    }\r\n  }\r\n  function cancel() returns (uint8 code) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n      return 0;\r\n    }\r\n    bytes32 call = functionCalling[msg.sender];\r\n    if (call == bytes32(0)) {\r\n      NothingToCancel(msg.sender);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(msg.sender, msg.sender);\r\n      bytes32 hash = functionCalling[msg.sender];\r\n      functionCalling[msg.sender] = 0x0;\r\n      functionCalls[hash] = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  function authCall(address from, bytes32 hash) external returns (uint8 code) {\r\n    if (!masterKeys[from] && !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    if (functionCalling[from] == 0) {\r\n      if (functionCalls[hash] == 0x0) {\r\n        functionCalls[hash] = from;\r\n        functionCalling[from] = hash;\r\n        AuthInit(from);\r\n        return 1;\r\n      } else { \r\n        AuthComplete(functionCalls[hash], from);\r\n        resetAction(hash);\r\n        return 2;\r\n      }\r\n    } else {\r\n      AuthPending(from);\r\n      return 3;\r\n    }\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n    } else if (functionCalling[msg.sender] == 0) {\r\n      if (functionCalls[hash] == 0x0) {\r\n        functionCalls[hash] = msg.sender;\r\n        functionCalling[msg.sender] = hash;\r\n        AuthInit(msg.sender);\r\n      } else { \r\n        AuthComplete(functionCalls[hash], msg.sender);\r\n        resetAction(hash);\r\n        _\r\n      }\r\n    } else {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(masterKeys[addr]);\r\n    masterKeys[addr] = false;\r\n  }\r\n  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n  }\r\n  function identify(bytes32 name) onlyMasterKey {\r\n    nameRegistry[msg.sender] = name;\r\n    NameRegistered(msg.sender, name);\r\n  }\r\n  function nameFor(address addr) returns (bytes32 name) {\r\n    return nameRegistry[addr];\r\n  }\r\n}\r\n\r\n\r\ncontract TrustClient is StateTransferrable, TrustEvents {\r\n  address public trustAddress;\r\n  function setTrust(address addr) setter onlyOwnerUnlocked {\r\n    trustAddress = addr;\r\n  }\r\n  function nameFor(address addr) constant returns (bytes32 name) {\r\n    return Trust(trustAddress).nameFor(addr);\r\n  }\r\n  function cancel() returns (uint8 status) {\r\n    assert(trustAddress != address(0x0));\r\n    uint8 code = Trust(trustAddress).authCancel(msg.sender);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) NothingToCancel(msg.sender);\r\n    else if (code == 2) AuthCancel(msg.sender, msg.sender);\r\n    return code;\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    assert(trustAddress != address(0x0));\r\n    address current = Trust(trustAddress).functionCalls(hash);\r\n    uint8 code = Trust(trustAddress).authCall(msg.sender, hash);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) AuthInit(msg.sender);\r\n    else if (code == 2) {\r\n      AuthComplete(current, msg.sender);\r\n      _\r\n    }\r\n    else if (code == 3) {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n}\r\ncontract Relay {\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\r\n}\r\ncontract TokenBase is Owned {\r\n    bytes32 public standard = 'Token 0.1';\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    bool public allowTransactions;\r\n\r\n    event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract Precision {\r\n  uint8 public decimals;\r\n}\r\ncontract Token is TokenBase, Precision {}\r\ncontract Util {\r\n  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a *= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function max(uint256 a, uint256 b) internal returns (uint256 res) {\r\n    if (a >= b) return a;\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\ncontract DVIP is Token, StateTransferrable, TrustClient, Util {\r\n\r\n  uint256 public totalSupply;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n  address public oversightAddress;\r\n  uint256 public expiry;\r\n\r\n  uint256 public treasuryBalance;\r\n\r\n  bool public isActive;\r\n  mapping (address => uint256) public exportFee;\r\n  address[] public exportFeeIndex;\r\n  mapping (address => bool) exportFeeActive;\r\n\r\n  mapping (address => uint256) public importFee;\r\n  address[] public importFeeIndex;\r\n  mapping (address => bool) importFeeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DVIP() {\r\n    isActive = true;\r\n    treasuryBalance = 0;\r\n    totalSupply = 0;\r\n    name = \"DVIP\";\r\n    symbol = \"DVIP\";\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n    expiry = 1514764800;   }\r\n\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n \r\n  \r\n  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(balanceOf[msg.sender] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(msg.sender);\r\n    activateAccount(_to);\r\n    balanceOf[msg.sender] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else balanceOf[_to] += _amount;\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][msg.sender]);\r\n    balanceOf[_from] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(msg.sender);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    spender.receiveApproval(msg.sender, _amount, this, _extraData);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n\r\n  \r\n  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {\r\n    expiry = ts;\r\n  }\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    treasuryBalance += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= destroyAmount);\r\n    treasuryBalance -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n\r\n    activateImportFeeChargeRecord(addr);\r\n  }\r\n\r\n  \r\n  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    assert(allow != allowTransactions);\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    treasuryBalance += amount;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from] + importFee[to];\r\n    if (fee == 0) return 0;\r\n    uint256 amountHeld;\r\n    bool discounted = true;\r\n    uint256 oneDVIPUnit;\r\n    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[from];\r\n    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[to];\r\n    } else discounted = false;\r\n    if (discounted) {\r\n      oneDVIPUnit = pow10(1, decimals);\r\n      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;\r\n      uint256 remaining = oneDVIPUnit - amountHeld;\r\n      return div10(amount*fee*remaining, decimals*2);\r\n    }\r\n    return div10(amount*fee, decimals);\r\n  }\r\n\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() constant returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n\r\n  function activateExportFeeChargeRecord(address addr) internal {\r\n    if (!exportFeeActive[addr]) {\r\n      exportFeeActive[addr] = true;\r\n      exportFeeIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateImportFeeChargeRecord(address addr) internal {\r\n    if (!importFeeActive[addr]) {\r\n\r\n\r\n    }\r\n  }\r\n  function extractImportFeeChargeLength() returns (uint256 length) {\r\n    return importFeeIndex.length;\r\n  }\r\n\r\n  function extractExportFeeChargeLength() returns (uint256 length) {\r\n    return exportFeeIndex.length;\r\n  }\r\n}\r\n\r\n\r\ncontract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {\r\n\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name;\r\n  bytes32 public symbol;\r\n\r\n  bool public allowTransactions;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  uint256 public totalSupply;\r\n\r\n  address public hotWalletAddress;\r\n  address public assetAddress;\r\n  address public oversightAddress;\r\n  address public membershipAddress;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n\r\n  bool public isActive;\r\n  uint256 public treasuryBalance;\r\n\r\n  mapping (address => uint256) public feeCharge;\r\n  address[] public feeChargeIndex;\r\n  mapping (address => bool) feeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  \r\n  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {\r\n    isActive = true;\r\n    name = tokenName;\r\n    symbol = tokenSymbol;\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  \r\n   modifier onlyAsset {\r\n    assert(msg.sender == assetAddress);\r\n    _\r\n   }\r\n\r\n  \r\n\r\n\r\n  \r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n    hotWalletAddress = addr;\r\n  }\r\n\r\n  \r\n  function setAsset(address addr) onlyOwnerUnlocked setter {\r\n    assetAddress = addr;\r\n  }\r\n\r\n  \r\n  function setMembership(address addr) onlyOwnerUnlocked setter {\r\n    membershipAddress = addr;\r\n  }\r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n  \r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  \r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  \r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  \r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  \r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  \r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  \r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  \r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(balanceOf[_caller] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(_caller);\r\n    activateAccount(_to);\r\n    balanceOf[_caller] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else {\r\n        uint256 fee = feeFor(_caller, _to, _amount);\r\n        balanceOf[_to] += _amount - fee;\r\n        treasuryBalance += fee;\r\n    }\r\n    Transfer(_caller, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][_caller]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 fee = feeFor(_from, _to, _amount);\r\n    balanceOf[_to] += _amount - fee;\r\n    treasuryBalance += fee;\r\n    allowance[_from][_caller] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(_caller);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n\r\n  \r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  \r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[hotWalletAddress] >= destroyAmount);\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  \r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    if (allow == allowTransactions) throw;\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  \r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  \r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  \r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    balanceOf[hotWalletAddress] += amount;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n\r\n  \r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {\r\n    if (membershipAddress == address(0x0)) return 0;\r\n    return DVIP(membershipAddress).feeFor(a, b, amount);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {\r\n\r\n   address public backendContract;\r\n\r\n   \r\n   function DCAsset(address _backendContract) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   function standard() constant returns (bytes32 std) {\r\n     return DCAssetBackend(backendContract).standard();\r\n   }\r\n\r\n   function name() constant returns (bytes32 nm) {\r\n     return DCAssetBackend(backendContract).name();\r\n   }\r\n\r\n   function symbol() constant returns (bytes32 sym) {\r\n     return DCAssetBackend(backendContract).symbol();\r\n   }\r\n\r\n   function decimals() constant returns (uint8 precision) {\r\n     return DCAssetBackend(backendContract).decimals();\r\n   }\r\n  \r\n   function allowance(address from, address to) constant returns (uint256 res) {\r\n     return DCAssetBackend(backendContract).allowance(from, to);\r\n   }\r\n\r\n\r\n   \r\n\r\n\r\n   \r\n   function setBackend(address _backendContract) multisig(sha3(msg.data)) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   \r\n\r\n   \r\n   function balanceOf(address _address) constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).balanceOf(_address);\r\n   }\r\n\r\n   \r\n   function totalSupply() constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).totalSupply();\r\n   }\r\n\r\n  \r\n   function transfer(address _to, uint256 _amount) returns (bool success)  {\r\n      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;\r\n      Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n   function approve(address _spender, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;\r\n      Transfer(_from, _to, _amount);\r\n      return true;\r\n  }\r\n\r\n  \r\n  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {\r\n      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);\r\n  }\r\n\r\n  \r\n\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n     assert(msg.sender == backendContract);\r\n     TokenRecipient spender = TokenRecipient(_spender);\r\n     spender.receiveApproval(_caller, _amount, this, _extraData);\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Oversight is StateTransferrable, TrustClient {\r\n\r\n  address public hotWalletAddress;\r\n\r\n  mapping (address => uint256) public approved;               address[] public approvedIndex;                           \r\n  mapping (address => uint256) public expiry;               \r\n  mapping (address => bool) public currencyActive;          \r\n  mapping (address => bool) public oversightAddresses;        address[] public oversightAddressesIndex;                 \r\n  mapping (address => bool) public oversightAddressActive;  \r\n  uint256 public timeWindow;                                \r\n  event TransactionsShutDown(address indexed from);\r\n\r\n  \r\n  function Oversight() {\r\n    timeWindow = 10 minutes;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  modifier onlyOverseer {\r\n    assert(oversightAddresses[msg.sender]);\r\n    _\r\n  }\r\n\r\n  \r\n  modifier onlyHotWallet {\r\n    assert(msg.sender == hotWalletAddress);\r\n    _\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n      hotWalletAddress = addr;\r\n  }\r\n\r\n  \r\n  function setupTimeWindow(uint256 secs) onlyOwnerUnlocked setter {\r\n    timeWindow = secs;\r\n  }\r\n\r\n  \r\n  function setApproved(address addr, uint256 amount) onlyOwnerUnlocked setter {\r\n    activateCurrency(addr);\r\n    approved[addr] = amount;\r\n  }\r\n\r\n  \r\n  function setExpiry(address addr, uint256 ts) onlyOwnerUnlocked setter {\r\n    activateCurrency(addr);\r\n    expiry[addr] = ts;\r\n  }\r\n\r\n  \r\n  function setOversightAddress(address addr, bool value) onlyOwnerUnlocked setter {\r\n    activateOversightAddress(addr);\r\n    oversightAddresses[addr] = value;\r\n  }\r\n\r\n\r\n\r\n  \r\n\r\n  \r\n  function setTimeWindow(uint256 secs) external multisig(sha3(msg.data)) {\r\n    timeWindow = secs;\r\n  }\r\n\r\n  \r\n  function addOversight(address addr) external multisig(sha3(msg.data)) {\r\n    activateOversightAddress(addr);\r\n    oversightAddresses[addr] = true;\r\n  }\r\n\r\n  \r\n  function removeOversight(address addr) external multisig(sha3(msg.data)) {\r\n    oversightAddresses[addr] = false;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function approve(address currency, uint256 amount) external multisig(sha3(msg.data)) {\r\n    activateCurrency(currency);\r\n    approved[currency] = amount;\r\n    expiry[currency] = now + timeWindow;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function validate(address currency, uint256 amount) external onlyHotWallet returns (bool) {\r\n    assert(approved[currency] >= amount);\r\n    approved[currency] -= amount;\r\n    return true;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function shutdownTransactions(address currency) onlyOverseer {\r\n    address backend = DCAsset(currency).backendContract();\r\n    DCAssetBackend(backend).shutdownTransactions();\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function extractApprovedIndexLength() returns (uint256) {\r\n    return approvedIndex.length;\r\n  }\r\n\r\n  \r\n  function extractOversightAddressesIndexLength() returns (uint256) {\r\n    return oversightAddressesIndex.length;\r\n  }\r\n\r\n  \r\n\r\n  function activateOversightAddress(address addr) internal {\r\n    if (!oversightAddressActive[addr]) {\r\n      oversightAddressActive[addr] = true;\r\n      oversightAddressesIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateCurrency(address addr) internal {\r\n    if (!currencyActive[addr]) {\r\n      currencyActive[addr] = true;\r\n          approvedIndex.push(addr);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract HotWallet is StateTransferrable, TrustClient {\r\n\r\n  address public oversightAddress;\r\n\r\n  mapping (address => uint256) public invoiced;\r\n  address[] public invoicedIndex;\r\n  mapping (address => bool) public invoicedActive;\r\n\r\n  event HotWalletDeposit(address indexed from, uint256 amount);\r\n  event PerformedTransfer(address indexed to, uint256 amount);\r\n  event PerformedTransferFrom(address indexed from, address indexed to, uint256 amount);\r\n  event PerformedApprove(address indexed spender, uint256 amount);\r\n  \r\n\r\n  \r\n  modifier onlyWithOversight {\r\n    assert(oversightAddress != 0x0);\r\n    _\r\n  }\r\n\r\n  \r\n  modifier spendControl(address currency, uint256 amount) {\r\n    assert(Oversight(oversightAddress).validate(currency, amount));\r\n    _\r\n  }\r\n\r\n  \r\n  modifier spendControlTargeted (address currency, address to, uint256 amount) {\r\n    if (to != address(this)) {\r\n      assert(Oversight(oversightAddress).validate(currency, amount));\r\n    }\r\n    _\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n  \r\n\r\n  \r\n  function transfer(address currency, address to, uint256 amount) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\r\n    Token(currency).transfer(to, amount);\r\n    PerformedTransfer(to, amount);\r\n  }\r\n\r\n  \r\n  function transferFrom(address currency, address from, address to, uint256 amount) multisig(sha3(msg.data)) spendControlTargeted(currency, to, amount) onlyWithOversight {\r\n    Token(currency).transferFrom(from, to, amount);\r\n    PerformedTransferFrom(from, to, amount);\r\n  }\r\n\r\n  \r\n  function approve(address currency, address spender, uint256 amount) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\r\n    Token(currency).approve(spender, amount);\r\n    PerformedApprove(spender, amount);\r\n  }\r\n\r\n  \r\n  function approveAndCall(address currency, address spender, uint256 amount, bytes extraData) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\r\n    Token(currency).approveAndCall(spender, amount, extraData);\r\n    PerformedApprove(spender, amount);\r\n  }\r\n\r\n  \r\n  function receiveApproval(address from, uint256 amount, address currency, bytes extraData) external {\r\n    Token(currency).transferFrom(from, this, amount);\r\n    HotWalletDeposit(from, amount);\r\n  }\r\n\r\n  \r\n\r\n  function activateInvoiced(address addr) internal {\r\n    if (!invoicedActive[addr]) {\r\n      invoicedActive[addr] = true;\r\n      invoicedIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function extractInvoicedLength() external returns (uint256 len) {\r\n    return invoicedIndex.length;\r\n  }\r\n}",
        "label": false,
        "name": "0x293c008e3060746f728ea59565b7a33dc68802be.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) internal VAR1;\nuint256 internal VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR4 <= VAR1[msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nreturns (bool)\n{\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nrequire(VAR3 != address(0));\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nVAR5[msg.sender][VAR7] = (VAR5[msg.sender][VAR7].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR7,uint256 VAR9)\npublic\nreturns (bool)\n{\nuint256 VAR10 = VAR5[msg.sender][VAR7];\nif (VAR9 >= VAR10) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR10.sub(VAR9);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN6() {\nrequire(msg.sender == VAR11);\n_;\n}\nfunction FUN7() public FUN6 {\nVAR11 = address(0);\n}\nfunction FUN8(address VAR12) public FUN6 {\nFUN9(VAR12);\n}\nfunction FUN9(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON6 is CON5 {\nbool public VAR13 = false;\nmodifier FUN10() {\nrequire(!VAR13);\n_;\n}\nmodifier FUN11() {\nrequire(VAR13);\n_;\n}\nfunction FUN12() public FUN6 FUN10 {\nVAR13 = true;\n}\nfunction FUN13() public FUN6 FUN11 {\nVAR13 = false;\n}\n}\ncontract CON7 is CON4, CON6 {\nfunction FUN1(address VAR3,uint256 VAR4)\npublic\nFUN10\nreturns (bool)\n{\nreturn super.FUN1(VAR3, VAR4);\n}\nfunction FUN2(address VAR6,address VAR3,uint256 VAR4)\npublic\nFUN10\nreturns (bool)\n{\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nfunction FUN3(address VAR7,uint256 VAR4)\npublic\nFUN10\nreturns (bool)\n{\nreturn super.FUN3(VAR7, VAR4);\n}\nfunction FUN4(address VAR7,uint VAR8)\npublic\nFUN10\nreturns (bool VAR14)\n{\nreturn super.FUN4(VAR7, VAR8);\n}\nfunction FUN5(address VAR7,uint VAR9)\npublic\nFUN10\nreturns (bool VAR14)\n{\nreturn super.FUN5(VAR7, VAR9);\n}\n}\ncontract CON8 is CON3 {\nstring public VAR15;\nstring public VAR16;\nuint8 public VAR17;\nconstructor(string VAR18, string VAR19, uint8 VAR20) public {\nVAR15 = VAR18;\nVAR16 = VAR19;\nVAR17 = VAR20;\n}\n}\ncontract CON9 is CON4, CON7\n{\nstring public constant VAR15 = \"DukunToken\";\nstring public constant VAR16 = \"DUKUN\";\nuint8 public constant VAR17 = 18;\nuint256 public constant VAR21 = 400000000 * (10 ** uint256(VAR17));\nconstructor() public {\nVAR2 = VAR21;\nVAR1[msg.sender] = VAR21;\n}\n}",
        "label": false,
        "name": "0x0f437f4bf7f41ff57ae5fee81bbec921ba0371b1.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].add(VAR8);\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR2[msg.sender][VAR6].sub(VAR9);\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 is CON1 {\nstring private VAR11;\nstring private VAR12;\nuint8 private VAR13;\nconstructor (string memory VAR14, string memory VAR15, uint8 VAR16) public {\nVAR11 = VAR14;\nVAR12 = VAR15;\nVAR13 = VAR16;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR17 = 0;\nuint256 public constant VAR18 = 369000000 * (10 ** uint256(VAR17));\nconstructor () public CON3(\"Max\", \"MVG\", VAR17) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0x71396a6410249725c5609646c4e449c6c4d41e27.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nuint256 VAR7 = VAR5[VAR6][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR5[VAR6][msg.sender] = VAR7.sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR4) public returns (bool) {\nrequire((VAR4 == 0) || (VAR5[msg.sender][VAR8] == 0));\nVAR5[msg.sender][VAR8] = VAR4;\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR9;\nconstructor () public {\nVAR9 = msg.sender;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR9);\n_;\n}\nfunction FUN5(address VAR10) public FUN4 {\nrequire(VAR10 != address(0));\nVAR9 = VAR10;\n}\n}\ncontract CON6 is CON4, CON5 {\nbool public VAR11 = false;\nmodifier FUN6() {\nrequire(!VAR11);\n_;\n}\nfunction FUN7(address VAR3, uint256 VAR12) public FUN4 FUN6 returns (bool) {\nVAR1 = VAR1.add(VAR12);\nVAR2[VAR3] = VAR2[VAR3].add(VAR12);\nreturn true;\n}\nfunction FUN8() public FUN4 returns (bool) {\nVAR11 = true;\nreturn true;\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR13 = \"Partner\";\nstring public constant VAR14 = \"PRC\";\nuint32 public constant VAR15 = 8;\n}",
        "label": false,
        "name": "0xcaa05e82bdcba9e25cd1a3bf1afb790c1758943d.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR2;\nfunction FUN1(address VAR3, uint256 VAR4)public returns (bool) {\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR4);\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON4 is CON2, CON3 {\nmapping (address => mapping (address => uint256)) VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4)public returns (bool) {\nuint VAR7 = VAR5[VAR6][msg.sender];\nVAR2[VAR3] = VAR2[VAR3].add(VAR4);\nVAR2[VAR6] = VAR2[VAR6].sub(VAR4);\nVAR5[VAR6][msg.sender] = VAR7.sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR8, uint256 VAR4)public returns (bool) {\nrequire((VAR4 == 0) || (VAR5[msg.sender][VAR8] == 0));\nVAR5[msg.sender][VAR8] = VAR4;\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR9;\nconstructor() public {\nVAR9 = msg.sender;\n}\nmodifier FUN4() {\nrequire(msg.sender == VAR9);\n_;\n}\nfunction FUN5(address VAR10)public FUN4 {\nrequire(VAR10 != address(0));\nVAR9 = VAR10;\n}\n}\ncontract CON6 is CON4 {\nfunction FUN6(uint VAR4) public {\nrequire(VAR4 > 0);\naddress VAR11 = msg.sender;\nVAR2[VAR11] = VAR2[VAR11].sub(VAR4);\nVAR1 = VAR1.sub(VAR4);\n}\n}\ncontract CON7 is CON6 {\nstring public constant VAR12 = \"advertisingcoin\";\nstring public constant VAR13 = \"ADVC\";\nuint8 public constant VAR14 = 8;\nuint256 public VAR15 = 6000000000000000;\nconstructor() public {\nVAR1 = VAR15;\nVAR2[0xaF4e19c0A13a359552c496aFA5Ce9deb4aaC0A53] = VAR15;\n}\n}\ncontract CON8 is CON5 {\nusing SafeMath for uint;\naddress payable VAR16;\nCON7 public VAR17 = new CON7 ();\nuint VAR18;\nfunction FUN7(uint VAR19) public FUN4 {\nVAR18 = VAR19;\n}\nuint VAR20;\nfunction FUN8(uint VAR21) public FUN4 {\nVAR20 = VAR21;\n}\nuint VAR22;\nfunction FUN9(uint VAR23)public FUN4 {\nVAR22 = VAR23 * (10**8);\n}\nconstructor() public {\nVAR16 = 0xaF4e19c0A13a359552c496aFA5Ce9deb4aaC0A53;\nVAR22 = 1200000000000000000000;\nVAR18 = 1517222833;\nVAR20 = 2000;\n}\nmodifier FUN10() {\nrequire(now > VAR18 && now < VAR18 + VAR20 * 1 days);\n_;\n}\nmodifier FUN11() {\nrequire(msg.value >= 10000000000000000);\n_;\n}\nfunction FUN12() public FUN11 FUN10 payable {\nVAR16.FUN1(msg.value);\nuint VAR24 = VAR22.mul(msg.value).div(1 ether);\nVAR17.FUN1(msg.sender, VAR24);\n}\nfunction() external payable {\nFUN12();\n}\n}",
        "label": false,
        "name": "0xf8d1254fc324d2e75a5a37f5bd4ca34a20ef460d.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1 = msg.sender;\naddress public VAR2;\nmodifier FUN1 {\nrequire(msg.sender == VAR1);\n_;\n}\nmodifier FUN2 {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3)\npublic\nFUN1\n{\nVAR2 = VAR3;\n}\nfunction FUN4()\npublic\nFUN2\n{\nVAR1 = VAR2;\nVAR2 = address(0);\n}\n}\ninterface CON2 {\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR4;\nmapping (address => mapping (address => uint256)) private VAR5;\nuint256 private VAR6;\nfunction FUN5(address VAR7, uint256 VAR8) public returns (bool) {\nFUN10(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN6(address VAR9, uint256 VAR8) public returns (bool) {\nrequire(VAR9 != address(0));\nVAR5[msg.sender][VAR9] = VAR8;\nreturn true;\n}\nfunction FUN7(address VAR10,address VAR7,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR8 <= VAR5[VAR10][msg.sender]);\nVAR5[VAR10][msg.sender] = VAR5[VAR10][msg.sender].sub(VAR8);\nFUN10(VAR10, VAR7, VAR8);\nreturn true;\n}\nfunction FUN8(address VAR9,uint256 VAR11)\npublic\nreturns (bool)\n{\nrequire(VAR9 != address(0));\nVAR5[msg.sender][VAR9] = (VAR5[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN9(address VAR9,uint256 VAR12)\npublic\nreturns (bool)\n{\nrequire(VAR9 != address(0));\nVAR5[msg.sender][VAR9] = (VAR5[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN10(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR8 <= VAR4[VAR10]);\nrequire(VAR7 != address(0));\nVAR4[VAR10] = VAR4[VAR10].sub(VAR8);\nVAR4[VAR7] = VAR4[VAR7].add(VAR8);\n}\nfunction FUN11(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0));\nVAR6 = VAR6.add(VAR8);\nVAR4[VAR13] = VAR4[VAR13].add(VAR8);\n}\nfunction FUN12(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0));\nrequire(VAR8 <= VAR4[VAR13]);\nVAR6 = VAR6.sub(VAR8);\nVAR4[VAR13] = VAR4[VAR13].sub(VAR8);\n}\nfunction FUN13(address VAR13, uint256 VAR8) internal {\nrequire(VAR8 <= VAR5[VAR13][msg.sender]);\nVAR5[VAR13][msg.sender] = VAR5[VAR13][msg.sender].sub(VAR8);\nFUN12(VAR13, VAR8);\n}\n}\ncontract CON4 is CON3 {\nfunction FUN14(uint256 VAR8) public {\nFUN12(msg.sender, VAR8);\n}\nfunction FUN15(address VAR10, uint256 VAR8) public {\nFUN13(VAR10, VAR8);\n}\n}\ninterface CON5 {\n}\ncontract CON6 is CON1 {\nusing SafeMath for uint256;\nmapping (address => bool) public VAR14;\nmapping (address => uint256) public VAR15;\nCON5 public VAR16;\nCON4 public VAR17;\nCON2 public VAR18;\nCON2 public VAR19;\nmodifier FUN16 {\nrequire(VAR14[msg.sender]);\n_;\n}\nconstructor(CON5 VAR20, CON4 VAR21, CON2 VAR22, CON2 VAR23) public {\nVAR16 = VAR20;\nVAR17 = VAR21;\nVAR18 = VAR22;\nVAR19 = VAR23;\n}\nfunction FUN17(address VAR24, bool VAR25) public FUN1 {\nrequire(VAR14[VAR24] != VAR25);\nVAR14[VAR24] = VAR25;\nif (VAR25)\nif (!VAR25)\n}\nfunction FUN18() public FUN16 {\nuint256 VAR26 = VAR17.allowance(msg.sender, address(this));\nrequire(VAR26 > 0);\nrequire(VAR17.FUN7(msg.sender, address(this), VAR26));\nVAR17.FUN14(VAR26);\nFUN20(msg.sender, VAR26);\n}\nfunction FUN19() public FUN16 {\nuint256 VAR27 = VAR18.balanceOf(msg.sender);\nuint256 VAR28 = VAR27 - totalReleased(msg.sender);\nrequire(VAR28 > 0);\nFUN20(msg.sender, VAR28);\nVAR15[msg.sender] = VAR28;\n}\nfunction FUN20(address VAR29, uint256 VAR30) internal {\nuint256 VAR31 = VAR19.balanceOf(VAR29);\nrequire(VAR19.FUN5(VAR29, VAR30));\nassert(VAR19.balanceOf(VAR29) == VAR31 + VAR30);\n}\n}",
        "label": false,
        "name": "0x2a2247140d1683fbeaefb22cef32d0b1982657bd.sol"
    },
    {
        "source": "contract CON1\n{\nusing SafeMath for uint256;\nmodifier FUN1()\n{\nrequire(myTokens() > 0);\n_;\n}\nmodifier FUN2()\n{\nrequire(myEthBank() > 0);\n_;\n}\nstring public VAR1 = \"SKY token\";\nstring public VAR2 = \"SKY\";\nuint256 constant public VAR3 = 18;\nuint256 constant internal VAR4 = 10;\nuint256 constant internal VAR5 = 10;\nmapping(address => uint256) public VAR6;\nmapping(address => uint256) public VAR7;\nuint256 public VAR8 = 0;\nuint256 public VAR9 = 0;\nuint256 public VAR10 = .001 ether;\nuint256 public VAR11 = 0;\naddress public VAR12;\nuint256 public VAR13 = now + 1 weeks;\nuint256 public VAR14 = 0;\nfunction()\nexternal\npayable\n{\nFUN4();\n}\nfunction FUN4()\npublic\npayable\n{\naddress VAR15 = msg.sender;\nuint256 VAR16 = msg.value;\nif(now>=VAR13){\nuint256 VAR17 = VAR11/2;\nVAR11 = 0;\nVAR7[VAR12] = VAR7[VAR12].add(VAR17);\nVAR14 += 1;\n}\nuint256 VAR18 = VAR16.mul(1e18)/buyingPrice();\nuint256 VAR19 = VAR16/VAR4;\nuint256 VAR20 = VAR19/2;\nVAR6[VAR15] = VAR6[VAR15].add(VAR18);\nVAR8 = VAR8.add(VAR18);\nVAR11 = VAR11.add(VAR20);\nVAR9 = VAR9.add(VAR16.sub(VAR20));\nif(msg.value >= buyingPrice()){\nVAR13 = now + 1 days;\nVAR12 = VAR15;\n}\nVAR10 = VAR9 / (VAR8 / 1e18);\n}\nfunction FUN5()\npublic\nFUN2\n{\naddress VAR15 = msg.sender;\nuint256 VAR16 = VAR7[VAR15];\nVAR7[VAR15] = 0;\nrequire(VAR16 >= buyingPrice());\nif(now>=VAR13){\nuint256 VAR17 = ((VAR11/2)/buyingPrice());\nVAR11 = 0;\nVAR7[VAR12] = VAR7[VAR12].add(VAR17);\n}\nuint256 VAR18 = VAR16.mul(1e18)/buyingPrice();\nuint256 VAR19 = VAR16/VAR4;\nuint256 VAR20 = VAR19/2;\nVAR6[VAR15] = VAR6[VAR15].add(VAR18);\nVAR8 = VAR8.add(VAR18);\nVAR11 = VAR11.add(VAR20);\nVAR9 = VAR9.add(VAR16.sub(VAR20));\nVAR10 = VAR9 / (VAR8 / 1e18);\nVAR13 = now + 1 days;\nVAR12 = VAR15;\n}\nfunction FUN6(uint256 VAR21)\npublic\nFUN1\n{\naddress VAR15 = msg.sender;\nrequire(VAR21 <= VAR6[VAR15]);\nuint256 VAR16 = VAR21.mul(VAR10);\nVAR16 = VAR16/(1e18);\nuint256 VAR22 = VAR16/VAR4;\nVAR16 = VAR16.sub(VAR22);\nVAR8 = VAR8.sub(VAR21);\nVAR6[VAR15] = VAR6[VAR15].sub(VAR21);\nuint256 VAR20 = VAR22/2;\nVAR11 = VAR11.add(VAR20);\nVAR7[VAR12] = VAR7[VAR12].add(VAR20/2);\nVAR9 = VAR9.sub(VAR16 + VAR20 + (VAR20/2));\nif(VAR8 > 0){\nVAR10 = VAR9.mul(1e18)/VAR8;\n}else{(VAR10 = buyingPrice().add(VAR9));}\nVAR7[VAR15] = VAR7[VAR15].add(VAR16);\n}\nfunction FUN7()\npublic\nFUN1\n{\nFUN6(VAR6[msg.sender]);\n}\nfunction FUN8()\npublic\npayable\nFUN2\n{\naddress payable VAR15 = msg.sender;\nuint256 VAR23 = VAR7[VAR15];\nVAR7[VAR15] = 0;\nVAR15.FUN10(VAR23);\n}\nfunction FUN9()\npublic\npayable\n{\nif (myTokens() > 0){\nFUN7();\n}\nFUN8();\n}\nfunction FUN10(address VAR24, uint256 VAR25)\npublic\nreturns(bool)\n{\naddress VAR15 = msg.sender;\nrequire( VAR25 <= VAR6[VAR15] );\nif (VAR25>0)\n{\n{\nVAR6[VAR15] = VAR6[VAR15].sub( VAR25 );\nVAR6[ VAR24] = VAR6[ VAR24].add( VAR25 );\n}\n}\nreturn true;\n}\n}",
        "label": false,
        "name": "0x657f73cb1877eb98ddd3381d825613336d8b8dbe.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR1;\nuint256 VAR2;\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[msg.sender]);\nVAR1[msg.sender] = VAR1[msg.sender].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nreturn true;\n}\n}\ncontract CON3 is CON1 {\n}\ncontract CON4 is CON3, CON2 {\nmapping (address => mapping (address => uint256)) internal VAR5;\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nrequire(VAR3 != address(0));\nrequire(VAR4 <= VAR1[VAR6]);\nrequire(VAR4 <= VAR5[VAR6][msg.sender]);\nVAR1[VAR6] = VAR1[VAR6].sub(VAR4);\nVAR1[VAR3] = VAR1[VAR3].add(VAR4);\nVAR5[VAR6][msg.sender] = VAR5[VAR6][msg.sender].sub(VAR4);\nreturn true;\n}\nfunction FUN3(address VAR7, uint256 VAR4) public returns (bool) {\nVAR5[msg.sender][VAR7] = VAR4;\nreturn true;\n}\nfunction FUN4(address VAR8, address VAR7) public constant returns (uint256 VAR9) {\nreturn VAR5[VAR8][VAR7];\n}\nfunction FUN5 (address VAR7, uint VAR10) public returns (bool VAR11) {\nVAR5[msg.sender][VAR7] = VAR5[msg.sender][VAR7].add(VAR10);\nreturn true;\n}\nfunction FUN6 (address VAR7, uint VAR12) public returns (bool VAR11) {\nuint VAR13 = VAR5[msg.sender][VAR7];\nif (VAR12 > VAR13) {\nVAR5[msg.sender][VAR7] = 0;\n} else {\nVAR5[msg.sender][VAR7] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON5 {\naddress public VAR14;\nconstructor() public {\nVAR14 = msg.sender;\n}\nmodifier FUN7 {\nrequire(msg.sender == VAR14);\n_;\n}\n}\ncontract CON6 is CON5 {\nusing SafeMath for uint256;\nusing SafeERC20 for CON1;\naddress public VAR15;\nuint256 public VAR16;\nuint256 public VAR17;\nuint256 public VAR18;\nbool public VAR19;\nmapping (address => uint256) public VAR20;\nmapping (address => bool) public VAR21;\nconstructor(address VAR22,uint256 VAR23,uint256 VAR24,uint256 VAR25,bool VAR26)\npublic\n{\nrequire(VAR22 != address(0));\nrequire(VAR24 <= VAR25);\nVAR15 = VAR22;\nVAR19 = VAR26;\nVAR18 = VAR25;\nVAR16 = VAR23.add(VAR24);\nVAR17 = VAR23;\n}\nfunction FUN8(CON1 VAR27) public {\nuint256 VAR28 = releasableAmount(VAR27);\nrequire(VAR28 > 0);\nVAR20[VAR27] = VAR20[VAR27].add(VAR28);\nVAR27.safeTransfer(VAR15, VAR28);\n}\nfunction FUN9(CON1 VAR27) public FUN7 {\nrequire(VAR19);\nrequire(!VAR21[VAR27]);\nuint256 VAR29 = VAR27.balanceOf(this);\nuint256 VAR28 = releasableAmount(VAR27);\nuint256 VAR30 = VAR29.sub(VAR28);\nVAR21[VAR27] = true;\nVAR27.safeTransfer(VAR14, VAR30);\n}\n}\ncontract CON7 is CON2 {\nfunction FUN10(uint256 VAR4) public {\nFUN11(msg.sender, VAR4);\n}\nfunction FUN11(address VAR31, uint256 VAR4) internal {\nrequire(VAR4 <= VAR1[VAR31]);\nVAR1[VAR31] = VAR1[VAR31].sub(VAR4);\nVAR2 = VAR2.sub(VAR4);\n}\n}\ncontract CON8 is CON7, CON4, CON5 {\nstring public constant VAR32 = \"AGATE\";\nstring public constant VAR33 = \"AGT\";\nuint8 public constant VAR34 = 18;\nuint256 public constant VAR35 = 490000000 * 10**uint256(VAR34);\naddress public VAR36;\naddress public VAR37;\naddress public VAR38;\nCON6 public VAR39;\naddress public VAR40;\naddress public VAR41;\nbool public VAR42 = false;\nbool public VAR43 = false;\nuint64 public constant VAR44 = 1542240000;\nmodifier FUN12 {\nrequire(!VAR42);\n_;\n}\nconstructor(address VAR45, address VAR46,address VAR47, address VAR48, address VAR49) public {\nrequire(VAR45 != address(0));\nrequire(VAR46 != address(0));\nrequire(VAR47 != address(0));\nrequire(VAR48 != address(0));\nrequire(VAR49 != address(0));\nVAR38 = VAR45;\nVAR41 = VAR46;\nVAR40 = VAR47;\nVAR36 = VAR48;\nVAR37 = VAR49;\nuint256 VAR50 = 318500000 * 10**uint256(VAR34);\nVAR2 = VAR50;\nVAR1[VAR36] = VAR50;\nuint256 VAR51 = 49000000 * 10**uint256(VAR34);\nVAR2 = VAR2.add(VAR51);\nVAR39 = new CON6(VAR38, VAR44, 92 days, 365 days, false);\nVAR1[address(VAR39)] = VAR51;\nuint256 VAR52 = 24500000 * 10**uint256(VAR34);\nVAR2 = VAR2.add(VAR52);\nVAR1[VAR37] = VAR52;\nuint256 VAR53 = 24500000 * 10**uint256(VAR34);\nVAR2 = VAR2.add(VAR53);\nVAR1[VAR40] = VAR53;\nuint256 VAR54 = 73500000 * 10**uint256(VAR34);\nVAR2 = VAR2.add(VAR54);\nVAR1[VAR41] = VAR54;\nrequire(VAR2 <= VAR35);\n}\nfunction FUN13() external FUN7 FUN12 {\nFUN11(VAR36, VAR1[VAR36]);\nVAR42 = true;\n}\nfunction FUN14() external FUN7 {\nVAR43 = true;\n}\nfunction FUN2(address VAR6, address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR43) {\nreturn super.FUN2(VAR6, VAR3, VAR4);\n}\nreturn false;\n}\nfunction FUN1(address VAR3, uint256 VAR4) public returns (bool) {\nif(VAR43 || msg.sender == VAR36 || msg.sender == VAR37|| msg.sender == VAR40) {\nreturn super.FUN1(VAR3, VAR4);\n}\nreturn false;\n}\n}",
        "label": false,
        "name": "0xb55283fb3a40ecdc33e32caeb8e56ed8cdbb31be.sol"
    },
    {
        "source": "contract CON1 {\nfunction CON1() {\n}\n}",
        "label": false,
        "name": "0xa918185d042016e2d87c5cb0c7d216b062f79559.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 3;\nuint256 public constant VAR19 = 420000;\nconstructor () public CON3(\"ExtistenzToken\", \"EXT\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0x521d47adbf9fa743c593219685cf19952d6a0601.sol"
    },
    {
        "source": "\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) throw;\r\n    _;\r\n  }\r\n\r\n    function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract PricingStrategy {\r\n\r\n  \r\n  function isPricingStrategy() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  \r\n  function isSane(address crowdsale) public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  \r\n  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\n}\r\n\r\n\r\n\r\ncontract FinalizeAgent {\r\n\r\n  function isFinalizeAgent() public constant returns(bool) {\r\n    return true;\r\n  }\r\n\r\n  \r\n  function isSane() public constant returns (bool);\r\n\r\n  \r\n  function finalizeCrowdsale();\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\ncontract FractionalERC20 is ERC20 {\r\n\r\n  uint public decimals;\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Crowdsale is Haltable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  \r\n  FractionalERC20 public token;\r\n\r\n  \r\n  PricingStrategy public pricingStrategy;\r\n\r\n  \r\n  FinalizeAgent public finalizeAgent;\r\n\r\n  \r\n  address public multisigWallet;\r\n\r\n  \r\n  uint public minimumFundingGoal;\r\n\r\n  \r\n  uint public startsAt;\r\n\r\n  \r\n  uint public endsAt;\r\n\r\n  \r\n  uint public tokensSold = 0;\r\n\r\n  \r\n  uint public weiRaised = 0;\r\n\r\n  \r\n  uint public investorCount = 0;\r\n\r\n  \r\n  uint public loadedRefund = 0;\r\n\r\n  \r\n  uint public weiRefunded = 0;\r\n\r\n  \r\n  bool public finalized;\r\n\r\n  \r\n  bool public requireCustomerId;\r\n\r\n  \r\n  bool public requiredSignedAddress;\r\n\r\n  \r\n  address public signerAddress;\r\n\r\n  \r\n  mapping (address => uint256) public investedAmountOf;\r\n\r\n  \r\n  mapping (address => uint256) public tokenAmountOf;\r\n\r\n  \r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\n\r\n  \r\n  uint public ownerTestValue;\r\n\r\n  \r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n\r\n    event Refund(address investor, uint weiAmount);\r\n\r\n    event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\n\r\n    event Whitelisted(address addr, bool status);\r\n\r\n    event EndsAtChanged(uint endsAt);\r\n\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\n\r\n    if(_minimumFundingGoal != 0) {\r\n          }\r\n\r\n    owner = msg.sender;\r\n\r\n    token = FractionalERC20(_token);\r\n\r\n    setPricingStrategy(_pricingStrategy);\r\n\r\n    multisigWallet = _multisigWallet;\r\n    if(multisigWallet == 0) {\r\n        throw;\r\n    }\r\n\r\n    if(_start == 0) {\r\n        throw;\r\n    }\r\n\r\n    startsAt = _start;\r\n\r\n    if(_end == 0) {\r\n        throw;\r\n    }\r\n\r\n    endsAt = _end;\r\n\r\n        if(startsAt >= endsAt) {\r\n        throw;\r\n    }\r\n\r\n  }\r\n\r\n  \r\n  function() payable {\r\n    throw;\r\n  }\r\n\r\n  \r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\n\r\n        if(getState() == State.PreFunding) {\r\n            if(!earlyParticipantWhitelist[receiver]) {\r\n        throw;\r\n      }\r\n    } else if(getState() == State.Funding) {\r\n                } else {\r\n            throw;\r\n    }\r\n\r\n    uint weiAmount = msg.value;\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\n\r\n    if(tokenAmount == 0) {\r\n            throw;\r\n    }\r\n\r\n    if(investedAmountOf[receiver] == 0) {\r\n              investorCount++;\r\n    }\r\n\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        if(isBreakingCap(tokenAmount, weiAmount, weiRaised, tokensSold)) {\r\n      throw;\r\n    }\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n\r\n        if(!multisigWallet.send(weiAmount)) throw;\r\n\r\n        Invested(receiver, weiAmount, tokenAmount, customerId);\r\n\r\n        onInvest();\r\n  }\r\n\r\n  \r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\n    if(requiredSignedAddress) throw;     if(customerId == 0) throw;      investInternal(addr, customerId);\r\n  }\r\n\r\n  \r\n  function invest(address addr) public payable {\r\n    if(requireCustomerId) throw;     if(requiredSignedAddress) throw;     investInternal(addr, 0);\r\n  }\r\n\r\n  \r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\n    investWithCustomerId(msg.sender, customerId);\r\n  }\r\n\r\n  \r\n  function buy() public payable {\r\n    invest(msg.sender);\r\n  }\r\n\r\n  \r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n\r\n        if(finalized) {\r\n      throw;\r\n    }\r\n\r\n        if(address(finalizeAgent) != 0) {\r\n      finalizeAgent.finalizeCrowdsale();\r\n    }\r\n\r\n    finalized = true;\r\n  }\r\n\r\n  \r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\n    finalizeAgent = addr;\r\n\r\n        if(!finalizeAgent.isFinalizeAgent()) {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  \r\n  function setRequireCustomerId(bool value) onlyOwner {\r\n    requireCustomerId = value;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n\r\n  \r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\n    earlyParticipantWhitelist[addr] = status;\r\n    Whitelisted(addr, status);\r\n  }\r\n\r\n  \r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\n    pricingStrategy = _pricingStrategy;\r\n\r\n        if(!pricingStrategy.isPricingStrategy()) {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  \r\n  function loadRefund() public payable inState(State.Failure) {\r\n    if(msg.value == 0) throw;\r\n    loadedRefund = loadedRefund.plus(msg.value);\r\n  }\r\n\r\n  \r\n  function refund() public inState(State.Refunding) {\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\n    if (weiValue == 0) throw;\r\n    investedAmountOf[msg.sender] = 0;\r\n    weiRefunded = weiRefunded.plus(weiValue);\r\n    Refund(msg.sender, weiValue);\r\n    if (!msg.sender.send(weiValue)) throw;\r\n  }\r\n\r\n  \r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\n    return weiRaised >= minimumFundingGoal;\r\n  }\r\n\r\n  \r\n  function isFinalizerSane() public constant returns (bool sane) {\r\n    return finalizeAgent.isSane();\r\n  }\r\n\r\n  \r\n  function isPricingSane() public constant returns (bool sane) {\r\n    return pricingStrategy.isSane(address(this));\r\n  }\r\n\r\n  \r\n  function getState() public constant returns (State) {\r\n    if(finalized) return State.Finalized;\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n    else if (isMinimumGoalReached()) return State.Success;\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\n    else return State.Failure;\r\n  }\r\n\r\n  \r\n  function setOwnerTestValue(uint val) onlyOwner {\r\n    ownerTestValue = val;\r\n  }\r\n\r\n  \r\n  function isCrowdsale() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n\r\n  \r\n  function onInvest() internal {\r\n\r\n  }\r\n\r\n      \r\n  \r\n  modifier inState(State state) {\r\n    if(getState() != state) throw;\r\n    _;\r\n  }\r\n\r\n  \r\n  function setEndsAt(uint time) onlyOwner {\r\n\r\n    if(now > time) {\r\n      throw;     }\r\n\r\n    endsAt = time;\r\n    EndsAtChanged(endsAt);\r\n  }\r\n\r\n      \r\n  \r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\n\r\n  \r\n  function isCrowdsaleFull() public constant returns (bool);\r\n\r\n  \r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \r\n  event Minted(address receiver, uint amount);\r\n\r\n  \r\n  mapping(address => uint) balances;\r\n\r\n  \r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length != size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n        \r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n                    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  \r\n  function addApproval(address _spender, uint _addedValue)\r\n  onlyPayloadSize(2 * 32)\r\n  returns (bool success) {\r\n      uint oldValue = allowed[msg.sender][_spender];\r\n      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n  }\r\n\r\n  \r\n  function subApproval(address _spender, uint _subtractedValue)\r\n  onlyPayloadSize(2 * 32)\r\n  returns (bool success) {\r\n\r\n      uint oldVal = allowed[msg.sender][_spender];\r\n\r\n      if (_subtractedValue > oldVal) {\r\n          allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\r\n      }\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \r\n  address public upgradeMaster;\r\n\r\n  \r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \r\n  uint256 public totalUpgraded;\r\n\r\n  \r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  \r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n                throw;\r\n      }\r\n\r\n            if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n            totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n            upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n                throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n            if (msg.sender != upgradeMaster) throw;\r\n            if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n            if(!upgradeAgent.isUpgradeAgent()) throw;\r\n            if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  \r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  \r\n  address public releaseAgent;\r\n\r\n  \r\n  bool public released = false;\r\n\r\n  \r\n  mapping (address => bool) public transferAgents;\r\n\r\n  \r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        if(!transferAgents[_sender]) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  \r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n        releaseAgent = addr;\r\n  }\r\n\r\n  \r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  \r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  \r\n  modifier inReleaseState(bool releaseState) {\r\n    if(releaseState != released) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \r\n  modifier onlyReleaseAgent() {\r\n    if(msg.sender != releaseAgent) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n       return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  \r\n  mapping (address => bool) public mintAgents;\r\n\r\n  \r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n\r\n    if(amount == 0) {\r\n      throw;\r\n    }\r\n\r\n    totalSupply = totalSupply.plus(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n    Minted(receiver, amount);\r\n  }\r\n\r\n  \r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n        if(!mintAgents[msg.sender]) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n\r\n  \r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n                owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n        balances[owner] = totalSupply;\r\n  }\r\n\r\n  \r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n  \r\n  function canUpgrade() public constant returns(bool) {\r\n    return released;\r\n  }\r\n\r\n  \r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MysteriumPricing is PricingStrategy, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n        uint public chfRate;\r\n\r\n  uint public chfScale = 10000;\r\n\r\n  \r\n  uint public hardCapPrice = 12000;  \r\n  uint public softCapPrice = 10000;  \r\n  uint public softCapCHF = 6000000 * 10000; \r\n    Crowdsale public crowdsale;\r\n\r\n  function MysteriumPricing(uint initialChfRate) {\r\n    chfRate = initialChfRate;\r\n  }\r\n\r\n      function setCrowdsale(Crowdsale _crowdsale) onlyOwner {\r\n\r\n    if(!_crowdsale.isCrowdsale()) {\r\n      throw;\r\n    }\r\n\r\n    crowdsale = _crowdsale;\r\n  }\r\n\r\n      function setConversionRate(uint _chfRate) onlyOwner {\r\n        if(now > crowdsale.startsAt())\r\n      throw;\r\n\r\n    chfRate = _chfRate;\r\n  }\r\n\r\n  \r\n  function setSoftCapCHF(uint _softCapCHF) onlyOwner {\r\n    softCapCHF = _softCapCHF;\r\n  }\r\n\r\n  \r\n  function getEthChfPrice() public constant returns (uint) {\r\n    return chfRate / chfScale;\r\n  }\r\n\r\n  \r\n  function convertToWei(uint chf) public constant returns(uint) {\r\n    return chf.times(10**18) / chfRate;\r\n  }\r\n\r\n    function getSoftCapInWeis() public returns (uint) {\r\n    return convertToWei(softCapCHF);\r\n  }\r\n\r\n  \r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\n\r\n    uint multiplier = 10 ** decimals;\r\n    if (weiRaised > getSoftCapInWeis()) {\r\n            return value.times(multiplier) / convertToWei(hardCapPrice);\r\n    } else {\r\n      return value.times(multiplier) / convertToWei(softCapPrice);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MysteriumTokenDistribution is FinalizeAgent, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  CrowdsaleToken public token;\r\n  Crowdsale public crowdsale;\r\n\r\n  MysteriumPricing public mysteriumPricing;\r\n\r\n    address futureRoundVault;\r\n  address foundationWallet;\r\n  address teamVault;\r\n  address seedVault1;   address seedVault2; \r\n    uint SOFT_CAP_CHF = 6000000;\r\n  uint MIN_SOFT_CAP_CHF = 2000000;\r\n  uint SEED_RAISED_ETH = 6000;\r\n  uint FOUNDATION_PERCENTAGE = 9;\r\n  uint TEAM_PERCENTAGE = 10;\r\n    uint REGULAR_PRICE_MULTIPLIER = 1;\r\n  uint multiplier = 10 ** 8;\r\n\r\n    uint public earlybird_coins;\r\n  uint public regular_coins;\r\n  uint public seed_coins;\r\n  uint public total_coins;\r\n  uint public future_round_coins;\r\n  uint public foundation_coins;\r\n  uint public team_coins;\r\n  uint public seed_coins_vault1;\r\n  uint public seed_coins_vault2;\r\n  uint public seed_multiplier;\r\n  uint public future_round_percentage;\r\n  uint public percentage_of_three;\r\n  uint public earlybird_percentage;\r\n\r\n  function MysteriumTokenDistribution(CrowdsaleToken _token, Crowdsale _crowdsale, MysteriumPricing _mysteriumPricing) {\r\n    token = _token;\r\n    crowdsale = _crowdsale;\r\n\r\n        if(!crowdsale.isCrowdsale()) {\r\n      throw;\r\n    }\r\n\r\n    mysteriumPricing = _mysteriumPricing;\r\n  }\r\n\r\n  \r\n  function distribute(uint amount_raised_chf, uint eth_chf_price) {\r\n\r\n        if(!(msg.sender == address(crowdsale) || msg.sender == owner)) {\r\n      throw;\r\n    }\r\n\r\n                \r\n        if (amount_raised_chf <= SOFT_CAP_CHF) {\r\n       earlybird_coins = amount_raised_chf.times(multiplier).plus(amount_raised_chf.times(multiplier)/5);\r\n    }\r\n    else {\r\n      earlybird_coins = SOFT_CAP_CHF.times(multiplier).plus(SOFT_CAP_CHF.times(multiplier)/5);\r\n    }\r\n\r\n        regular_coins = 0;\r\n    if (amount_raised_chf > SOFT_CAP_CHF) {\r\n      regular_coins = (amount_raised_chf.minus(SOFT_CAP_CHF)).times(multiplier).times(REGULAR_PRICE_MULTIPLIER);\r\n    }\r\n\r\n                if (amount_raised_chf <= MIN_SOFT_CAP_CHF) {\r\n        seed_multiplier = multiplier.times(1);\r\n    } else if (amount_raised_chf > MIN_SOFT_CAP_CHF && amount_raised_chf < SOFT_CAP_CHF) {\r\n        seed_multiplier = ((amount_raised_chf / 1000000).minus(1)).times(multiplier);\r\n\r\n    } else  {\r\n        seed_multiplier = multiplier.times(5);\r\n    }\r\n\r\n        seed_coins = SEED_RAISED_ETH.times(eth_chf_price).times(seed_multiplier);\r\n\r\n                if (amount_raised_chf <= MIN_SOFT_CAP_CHF) {\r\n        future_round_percentage = multiplier.times(50);\r\n    } else if (amount_raised_chf > MIN_SOFT_CAP_CHF && amount_raised_chf < SOFT_CAP_CHF) {\r\n       future_round_percentage = uint(6750000000).minus((amount_raised_chf / 1000000).times(875000000));\r\n    } else if (amount_raised_chf >= SOFT_CAP_CHF) {\r\n        future_round_percentage = multiplier.times(15);\r\n    }\r\n\r\n            percentage_of_three = multiplier.times(100).minus(multiplier.times(FOUNDATION_PERCENTAGE)).minus(multiplier.times(TEAM_PERCENTAGE)).minus(future_round_percentage);\r\n\r\n        earlybird_percentage = earlybird_coins.times(percentage_of_three) / (earlybird_coins.plus(regular_coins).plus(seed_coins));\r\n\r\n        total_coins = multiplier.times(100).times(earlybird_coins) / earlybird_percentage;\r\n\r\n\r\n        future_round_coins = future_round_percentage.times(total_coins) / 100 / multiplier;\r\n\r\n        foundation_coins = FOUNDATION_PERCENTAGE.times(total_coins) / 100;\r\n\r\n        team_coins = TEAM_PERCENTAGE.times(total_coins) / 100;\r\n\r\n    \r\n        seed_coins_vault1 = (seed_coins / seed_multiplier).times(multiplier);\r\n\r\n        seed_coins_vault2 = seed_coins.minus((seed_coins / seed_multiplier).times(multiplier));\r\n\r\n        \r\n\r\n    if(future_round_coins > 0) {\r\n      token.mint(futureRoundVault, future_round_coins);\r\n    }\r\n\r\n    if(foundation_coins > 0) {\r\n      token.mint(foundationWallet, foundation_coins);\r\n    }\r\n\r\n    if(team_coins > 0) {\r\n      token.mint(teamVault, team_coins);\r\n    }\r\n\r\n    if(seed_coins_vault1 > 0) {\r\n      token.mint(seedVault1, seed_coins_vault1);\r\n    }\r\n\r\n    if(seed_coins_vault2 > 0) {\r\n      token.mint(seedVault2, seed_coins_vault2);\r\n    }\r\n\r\n                                          }\r\n\r\n    function setVaults(\r\n    address _futureRoundVault,\r\n    address _foundationWallet,\r\n    address _teamVault,\r\n    address _seedVault1,\r\n    address _seedVault2\r\n  ) onlyOwner {\r\n    futureRoundVault = _futureRoundVault;\r\n    foundationWallet = _foundationWallet;\r\n    teamVault = _teamVault;\r\n    seedVault1 = _seedVault1;\r\n    seedVault2 = _seedVault2;\r\n  }\r\n\r\n  \r\n  function isSane() public constant returns (bool) {\r\n        return true;\r\n  }\r\n\r\n  function getDistributionFacts() public constant returns (uint chfRaised, uint chfRate) {\r\n    uint _chfRate = mysteriumPricing.getEthChfPrice();\r\n    return(crowdsale.weiRaised().times(_chfRate) / (10**18), _chfRate);\r\n  }\r\n\r\n  \r\n  function finalizeCrowdsale() public {\r\n\r\n    if(msg.sender == address(crowdsale) || msg.sender == owner) {\r\n                  var (chfRaised, chfRate) = getDistributionFacts();\r\n      distribute(chfRaised, chfRate);\r\n    } else {\r\n       throw;\r\n    }\r\n  }\r\n\r\n}",
        "label": false,
        "name": "0x1ce00ddca2854ff2ddc7962575c49d2ba9c1243a.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1 = msg.sender;\nmapping(bytes32 => uint256) public VAR2; mapping(bytes32 => uint256) public VAR3;\nfunction FUN1(bytes32 VAR4) external {\nassert(msg.sender == VAR1);\nassert(VAR2[VAR4] <= 0);\nVAR2[VAR4] = block.timestamp;\nVAR3[VAR4] = block.number;\n}\nfunction FUN2(address VAR5) external {\nassert(msg.sender == VAR1);\nVAR1 = VAR5;\n}\n}",
        "label": false,
        "name": "0x532d85bd4bd0233dfa0eed5b3fe8bcfbba0420a4.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3);\nVAR5[msg.sender] = VAR4;\nVAR1 = VAR8;\nVAR2 = VAR9;\n}\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12);\nVAR5[msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR12 <= VAR6[VAR10][msg.sender]);\nVAR5[VAR10] -= VAR12;\nVAR6[VAR10][msg.sender] -= VAR12;\nVAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0x9792e933c04f93182d3df61d0ae7e3425ecae3f4.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR5);\nreturn true;\n}\nfunction FUN3(address VAR7, address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(VAR7, VAR4, VAR5);\nFUN9(VAR7, msg.sender, VAR2[VAR7][msg.sender].sub(VAR5));\nreturn true;\n}\nfunction FUN4(address VAR6, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6, uint256 VAR9) public returns (bool) {\nFUN9(msg.sender, VAR6, VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != address(0));\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR11, address VAR6, uint256 VAR5) internal {\nrequire(VAR6 != address(0));\nrequire(VAR11 != address(0));\nVAR2[VAR11][VAR6] = VAR5;\n}\nfunction FUN10(address VAR10, uint256 VAR5) internal {\nFUN8(VAR10, VAR5);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR5));\n}\n}\ncontract CON3 is CON1 {\nstring private VAR12;\nstring private VAR13;\nuint8 private VAR14;\nconstructor (string memory VAR15, string memory VAR16, uint8 VAR17) public {\nVAR12 = VAR15;\nVAR13 = VAR16;\nVAR14 = VAR17;\n}\n}\ncontract CON4 is CON2, CON3 {\nuint8 public constant VAR18 = 18;\nuint256 public constant VAR19 = 10000 * (10 ** uint256(VAR18));\nconstructor () public CON3(\"ReallyFakeToken\", \"RFT\", VAR18) {\nFUN7(msg.sender, VAR19);\n}\n}",
        "label": false,
        "name": "0x1145b0c70dbba351c52a8d25db9c3dbe1aec08b5.sol"
    },
    {
        "source": "contract CON1 {\nmodifier FUN1(address VAR1) {\nrequire(VAR1 != address(0));\n_;\n}\n}\ncontract CON2 {\naddress public VAR2;\nfunction CON2() public {\nVAR2 = msg.sender;\n}\nmodifier FUN2() {\nrequire(msg.sender == VAR2);\n_;\n}\nfunction FUN3(address VAR3) FUN2 public {\nrequire(VAR3 != address(0));\nVAR2 = VAR3;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3, CON1, CON2 {\nbool public VAR4 = true;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nmodifier FUN4 {\nassert(VAR4);\n_;\n}\nfunction FUN5(bool VAR7) public FUN2 {\nVAR4 = !VAR7;\n}\nfunction FUN6(address VAR8, uint256 VAR9) public FUN1(VAR8) FUN4 returns (bool VAR10){\nrequire(VAR5[msg.sender] >= VAR9 && VAR5[VAR8] + VAR9 > VAR5[VAR8]);\nVAR5[msg.sender] = safeSub(VAR5[msg.sender], VAR9);\nVAR5[VAR8] = safeAdd(VAR5[VAR8], VAR9);\nreturn true;\n}\nfunction VAR5(address VAR11) public FUN1(VAR11) constant returns (uint256 VAR12) {\nreturn VAR5[VAR11];\n}\n}\ncontract CON5 is CON4 {\nstring public constant VAR13 = \"One Coin\";\nstring public constant VAR14 = \"ONEC\";\nuint8 public constant VAR15 = 18;\nuint256 public constant VAR16 = 5.2 * 10**26;\nfunction CON5(){\nVAR5[VAR2] = VAR16;\n}\n}",
        "label": false,
        "name": "0x07c34e089868da9fa16f505122f6e14680fd5ae4.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN2(address VAR2) public FUN1 {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR3 = false;\nmodifier FUN3() {\nrequire(!VAR3);\n_;\n}\nmodifier FUN4() {\nrequire(VAR3);\n_;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR3 = true;\n}\nfunction FUN6() FUN1 FUN4 public {\nVAR3 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\n}\ncontract CON5 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR4;\nuint256 VAR5;\nfunction FUN7(address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[msg.sender]);\nVAR4[msg.sender] = VAR4[msg.sender].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nreturn true;\n}\n}\ncontract CON6 is CON4, CON5 {\nmapping (address => mapping (address => uint256)) internal VAR8;\nfunction FUN8(address VAR9, address VAR6, uint256 VAR7) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR7 <= VAR4[VAR9]);\nrequire(VAR7 <= VAR8[VAR9][msg.sender]);\nVAR4[VAR9] = VAR4[VAR9].sub(VAR7);\nVAR4[VAR6] = VAR4[VAR6].add(VAR7);\nVAR8[VAR9][msg.sender] = VAR8[VAR9][msg.sender].sub(VAR7);\nreturn true;\n}\nfunction FUN9(address VAR10, uint256 VAR7) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR7;\nreturn true;\n}\nfunction FUN10(address VAR10, uint VAR11) public returns (bool) {\nVAR8[msg.sender][VAR10] = VAR8[msg.sender][VAR10].add(VAR11);\nreturn true;\n}\nfunction FUN11(address VAR10, uint VAR12) public returns (bool) {\nuint VAR13 = VAR8[msg.sender][VAR10];\nif (VAR12 > VAR13) {\nVAR8[msg.sender][VAR10] = 0;\n} else {\nVAR8[msg.sender][VAR10] = VAR13.sub(VAR12);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nstring public constant VAR14 = \"Frank Token\";\nstring public constant VAR15 = \"FT\";\nuint8 public constant VAR16 = 0;\nmodifier FUN12(address VAR17) {\nrequire(VAR17 != address(0x0));\nrequire(VAR17 != address(this));\n_;\n}\nconstructor(uint VAR18) public {\nVAR5 = VAR18;\nVAR4[msg.sender] = VAR18;\n}\nfunction FUN7(address VAR6, uint VAR7) public FUN3\nFUN12(VAR6)\nreturns (bool) {\nreturn super.FUN7(VAR6, VAR7);\n}\nfunction FUN8(address VAR9, address VAR6, uint VAR7) public FUN3\nFUN12(VAR6)\nreturns (bool) {\nreturn super.FUN8(VAR9, VAR6, VAR7);\n}\nfunction FUN9(address VAR10, uint256 VAR7) public FUN3\nreturns (bool) {\nreturn super.FUN9(VAR10, VAR7);\n}\nfunction FUN10(address VAR10, uint VAR11) public FUN3\nreturns (bool VAR19) {\nreturn super.FUN10(VAR10, VAR11);\n}\nfunction FUN11(address VAR10, uint VAR12) public FUN3\nreturns (bool VAR19) {\nreturn super.FUN11(VAR10, VAR12);\n}\n}",
        "label": false,
        "name": "0x20d11cb319552871969526f4c58b99c34df9e6ed.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nstring private VAR1;\nstring private VAR2;\nuint8 private VAR3;\nconstructor (string memory VAR4, string memory VAR5, uint8 VAR6) public {\nVAR1 = VAR4;\nVAR2 = VAR5;\nVAR3 = VAR6;\n}\n}\ncontract CON3 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR7;\nmapping (address => mapping (address => uint256)) private VAR8;\nuint256 private VAR9;\nfunction FUN1(address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(msg.sender, VAR10, VAR11);\nreturn true;\n}\nfunction FUN2(address VAR12, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR11);\nreturn true;\n}\nfunction FUN3(address VAR13, address VAR10, uint256 VAR11) public returns (bool) {\nFUN6(VAR13, VAR10, VAR11);\nFUN9(VAR13, msg.sender, VAR8[VAR13][msg.sender].sub(VAR11));\nreturn true;\n}\nfunction FUN4(address VAR12, uint256 VAR14) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].add(VAR14));\nreturn true;\n}\nfunction FUN5(address VAR12, uint256 VAR15) public returns (bool) {\nFUN9(msg.sender, VAR12, VAR8[msg.sender][VAR12].sub(VAR15));\nreturn true;\n}\nfunction FUN6(address VAR13, address VAR10, uint256 VAR11) internal {\nrequire(VAR10 != address(0));\nVAR7[VAR13] = VAR7[VAR13].sub(VAR11);\nVAR7[VAR10] = VAR7[VAR10].add(VAR11);\n}\nfunction FUN7(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.add(VAR11);\nVAR7[VAR16] = VAR7[VAR16].add(VAR11);\n}\nfunction FUN8(address VAR16, uint256 VAR11) internal {\nrequire(VAR16 != address(0));\nVAR9 = VAR9.sub(VAR11);\nVAR7[VAR16] = VAR7[VAR16].sub(VAR11);\n}\nfunction FUN9(address VAR17, address VAR12, uint256 VAR11) internal {\nrequire(VAR12 != address(0));\nrequire(VAR17 != address(0));\nVAR8[VAR17][VAR12] = VAR11;\n}\nfunction FUN10(address VAR16, uint256 VAR11) internal {\nFUN8(VAR16, VAR11);\nFUN9(VAR16, msg.sender, VAR8[VAR16][msg.sender].sub(VAR11));\n}\n}\ncontract CON4 is CON3, CON2 {\nuint256 public constant VAR18 = 500000000000 * (10 ** 18);\nconstructor () public CON2(\"Safuracoin\", \"EXCHANGE\", 8) {\nFUN7(msg.sender, VAR18);\n}\n}",
        "label": false,
        "name": "0xa5503c4227bf8c5fcbab84cece74009de5fc3e71.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\naddress private VAR1;\nconstructor () internal {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(isOwner());\n_;\n}\nfunction FUN2() public FUN1 {\nVAR1 = address(0);\n}\nfunction FUN3(address VAR2) public FUN1 {\nFUN4(VAR2);\n}\nfunction FUN4(address VAR2) internal {\nrequire(VAR2 != address(0));\nVAR1 = VAR2;\n}\n}\ncontract CON3 is CON2 {\nusing SafeMath for uint256;\naddress private VAR3;\nuint256 private VAR4;\nuint256 private VAR5;\nuint256 private VAR6;\nbool private VAR7;\nmapping (address => uint256) private VAR8;\nmapping (address => bool) private VAR9;\nconstructor (address VAR10, uint256 VAR11, uint256 VAR12, uint256 VAR13, bool VAR14) public {\nrequire(VAR10 != address(0));\nrequire(VAR12 <= VAR13);\nrequire(VAR13 > 0);\nrequire(VAR11.add(VAR13) > block.timestamp);\nVAR3 = VAR10;\nVAR7 = VAR14;\nVAR6 = VAR13;\nVAR4 = VAR11.add(VAR12);\nVAR5 = VAR11;\n}\nfunction FUN5(CON1 VAR15) public {\nuint256 VAR16 = _releasableAmount(VAR15);\nrequire(VAR16 > 0);\nVAR8[address(VAR15)] = VAR8[address(VAR15)].add(VAR16);\nVAR15.transfer(VAR3, VAR16);\n}\nfunction FUN6(CON1 VAR15) public FUN1 {\nrequire(VAR7);\nrequire(!VAR9[address(VAR15)]);\nuint256 VAR17 = VAR15.balanceOf(address(this));\nuint256 VAR16 = _releasableAmount(VAR15);\nuint256 VAR18 = VAR17.sub(VAR16);\nVAR9[address(VAR15)] = true;\nVAR15.transfer(owner(), VAR18);\n}\n}",
        "label": false,
        "name": "0xb44abfbc20d1b2488bda61441f649be3889266ae.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\n}\ncontract CON3 is CON2 {\nstring public VAR2;\nstring public VAR3;\nuint8 public VAR4;\nfunction CON3(string VAR5, string VAR6, uint8 VAR7) public {\nVAR2 = VAR5;\nVAR3 = VAR6;\nVAR4 = VAR7;\n}\n}\ncontract CON4 {\nstring public VAR2;\naddress private VAR8;\nuint public VAR9;\nuint public VAR10;\nuint public VAR11;\nuint public VAR12;\nuint public VAR13;\nuint private VAR14;\nuint public VAR15;\nuint public VAR16;\nuint public VAR17;\nuint public VAR18;\nuint public VAR19;\nuint public VAR20;\nuint public VAR21;\nCON3 private VAR22;\nuint VAR23;\naddress public VAR24;\nmapping(address => uint) public VAR25;\nfunction CON4(string VAR5,uint VAR26,uint VAR27,uint VAR28,uint VAR29,uint VAR30,uint VAR31,address VAR32,address VAR33) public {\nrequire(VAR27 > 0);\nrequire(now < VAR26 + VAR27); require(VAR30 > VAR29 || VAR30 == 0);\nrequire(VAR28 > 0);\nrequire(VAR32 != address(0));\nrequire(VAR33 != address(0));\nVAR2 = VAR5;\nVAR9 = VAR26;\nVAR10 = VAR27;\nVAR12 = VAR29;\nVAR13 = VAR30;\nVAR14 = VAR31;\nVAR11 = VAR28;\nVAR8 = msg.sender;\nVAR24 = VAR32;\nFUN5(VAR33);\n}\nfunction FUN1() public payable {\nassert(now >= VAR9 && now < VAR9 + VAR10); assert(VAR15 + VAR11 <= VAR13 || VAR13 == 0); require(msg.VAR36 >= VAR11);\naddress VAR34 = msg.sender;\nuint VAR35 = msg.VAR36 / VAR11;\nuint VAR36 = VAR35 * VAR11;\nif (VAR36 + VAR15 > VAR13 || VAR13 == 0) {\nVAR36 = VAR13 - VAR15;\nVAR35 = VAR36 / VAR11;\nVAR36 = VAR35 * VAR11;\n}\nVAR15 += VAR36;\nVAR18 += VAR35;\nFUN6(VAR34, VAR35);\nVAR34.transfer(msg.VAR36 - VAR36);\nif (VAR15 >= VAR12 && this.balance >= VAR14) {\nFUN8(this.balance);\n}\n}\nfunction FUN2() public payable {\nassert(now >= VAR9 + VAR10); assert(VAR15 < VAR12);\naddress VAR34 = msg.sender;\nuint VAR35 = __redeemAmount(VAR34);\nuint VAR37 = VAR35 * VAR11;\nrequire(VAR35 > 0);\nVAR17 += VAR37;\nVAR19 += VAR35;\nVAR21++;\nFUN7(VAR34, VAR35);\nVAR34.transfer(VAR37 + msg.VAR36);\n}\nfunction FUN3() public {\nassert(VAR8 == msg.sender || VAR24 == msg.sender); assert(VAR15 >= VAR12); assert(this.balance > 0);\nuint VAR36 = this.balance;\nFUN8(VAR36);\n}\nfunction() public payable {\nrequire(now >= VAR9);\nif(now < VAR9 + VAR10) {\nFUN1();\n}\nelse if(VAR15 < VAR12) {\nFUN2();\n}\nelse {\nFUN3();\n}\n}\nfunction FUN5(address VAR33) internal {\nVAR22 = CON3(VAR33);\nVAR23 = 10 ** uint(VAR22.VAR4());\n}\nfunction FUN6(address VAR34, uint VAR35) internal {\nif (VAR25[VAR34] == 0) {\nVAR16++;\n}\nVAR25[VAR34] += VAR35;\nVAR22.transferFrom(VAR8, VAR34, VAR35 * VAR23);\n}\nfunction FUN7(address VAR34, uint VAR35) internal {\nVAR25[VAR34] -= VAR35;\nVAR22.transferFrom(VAR34, VAR8, VAR35 * VAR23);\n}\nfunction FUN8(uint VAR36) internal {\nVAR24.transfer(VAR36);\n}\n}",
        "label": false,
        "name": "0xc3a9055c667f47b16e8ef552d09b01732802565a.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nstring public VAR3;\nstring public VAR4;\nuint8 public VAR5;\nuint VAR6;\nconstructor() public {\nVAR3 = \"BPK\";\nVAR4 = \"Bitpacket Token\";\nVAR5 = 18;\nVAR6 = 1000000000000 * 10**uint(VAR5);\nVAR1[msg.sender] = VAR6;\n}\nfunction FUN1(address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(msg.sender, VAR7, VAR8);\nreturn true;\n}\nfunction FUN2(address VAR9, uint256 VAR8) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR8);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR7, uint256 VAR8) public returns (bool) {\nFUN6(VAR10, VAR7, VAR8);\nFUN9(VAR10, msg.sender, VAR2[VAR10][msg.sender].sub(VAR8));\nreturn true;\n}\nfunction FUN4(address VAR9, uint256 VAR11) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR2[msg.sender][VAR9].add(VAR11));\nreturn true;\n}\nfunction FUN5(address VAR9, uint256 VAR12) public returns (bool) {\nFUN9(msg.sender, VAR9, VAR2[msg.sender][VAR9].sub(VAR12));\nreturn true;\n}\nfunction FUN6(address VAR10, address VAR7, uint256 VAR8) internal {\nrequire(VAR10 != address(0), \"ERC20: FUN1 VAR10 the zero address\");\nrequire(VAR7 != address(0), \"ERC20: FUN1 VAR7 the zero address\");\nVAR1[VAR10] = VAR1[VAR10].sub(VAR8);\nVAR1[VAR7] = VAR1[VAR7].add(VAR8);\n}\nfunction FUN7(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: mint VAR7 the zero address\");\nVAR6 = VAR6.add(VAR8);\nVAR1[VAR13] = VAR1[VAR13].add(VAR8);\n}\nfunction FUN8(address VAR13, uint256 VAR8) internal {\nrequire(VAR13 != address(0), \"ERC20: burn VAR10 the zero address\");\nVAR6 = VAR6.sub(VAR8);\nVAR1[VAR13] = VAR1[VAR13].sub(VAR8);\n}\nfunction FUN9(address VAR14, address VAR9, uint256 VAR8) internal {\nrequire(VAR14 != address(0), \"ERC20: FUN2 VAR10 the zero address\");\nrequire(VAR9 != address(0), \"ERC20: FUN2 VAR7 the zero address\");\nVAR2[VAR14][VAR9] = VAR8;\n}\nfunction FUN10(address VAR13, uint256 VAR8) internal {\nFUN8(VAR13, VAR8);\nFUN9(VAR13, msg.sender, VAR2[VAR13][msg.sender].sub(VAR8));\n}\n}",
        "label": false,
        "name": "0xb1a219e35ac1aab0ea8f7dae92b06142c1bff542.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) private VAR1;\nmapping (address => mapping (address => uint256)) private VAR2;\nuint256 private VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nFUN6(msg.sender, VAR4, VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = VAR5;\nreturn true;\n}\nfunction FUN3(address VAR7,address VAR4,uint256 VAR5)\npublic\nreturns (bool)\n{\nrequire(VAR5 <= VAR2[VAR7][msg.sender]);\nVAR2[VAR7][msg.sender] = VAR2[VAR7][msg.sender].sub(VAR5);\nFUN6(VAR7, VAR4, VAR5);\nreturn true;\n}\nfunction FUN4(address VAR6,uint256 VAR8)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].add(VAR8));\nreturn true;\n}\nfunction FUN5(address VAR6,uint256 VAR9)\npublic\nreturns (bool)\n{\nrequire(VAR6 != address(0));\nVAR2[msg.sender][VAR6] = (VAR2[msg.sender][VAR6].sub(VAR9));\nreturn true;\n}\nfunction FUN6(address VAR7, address VAR4, uint256 VAR5) internal {\nrequire(VAR5 <= VAR1[VAR7]);\nrequire(VAR4 != address(0));\nVAR1[VAR7] = VAR1[VAR7].sub(VAR5);\nVAR1[VAR4] = VAR1[VAR4].add(VAR5);\n}\nfunction FUN7(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nVAR3 = VAR3.add(VAR5);\nVAR1[VAR10] = VAR1[VAR10].add(VAR5);\n}\nfunction FUN8(address VAR10, uint256 VAR5) internal {\nrequire(VAR10 != 0);\nrequire(VAR5 <= VAR1[VAR10]);\nVAR3 = VAR3.sub(VAR5);\nVAR1[VAR10] = VAR1[VAR10].sub(VAR5);\n}\nfunction FUN9(address VAR10, uint256 VAR5) internal {\nrequire(VAR5 <= VAR2[VAR10][msg.sender]);\nVAR2[VAR10][msg.sender] = VAR2[VAR10][msg.sender].sub(VAR5);\nFUN8(VAR10, VAR5);\n}\n}\ncontract CON3 {\naddress private VAR11;\nconstructor() public {\nVAR11 = msg.sender;\n}\nmodifier FUN10() {\nrequire(isOwner());\n_;\n}\nfunction FUN11() public FUN10 {\nVAR11 = address(0);\n}\nfunction FUN12(address VAR12) public FUN10 {\nFUN13(VAR12);\n}\nfunction FUN13(address VAR12) internal {\nrequire(VAR12 != address(0));\nVAR11 = VAR12;\n}\n}\ncontract CON4 is CON2, CON3 {\nstring public constant VAR13 = \"PanterX\";\nstring public constant VAR14 = \"PANX\";\nuint32 public constant VAR15 = 0;\nuint256 private VAR16 = 1e9;\naddress public VAR17;\nbool public VAR18 = false;\nconstructor(address VAR12) public {\nrequire(VAR12 != address(0));\nFUN12(VAR12);\n}\nfunction FUN14(address VAR19) public FUN10 {\nrequire (VAR19 != address(0));\nrequire (!VAR18);\nVAR17 = VAR19;\nVAR18 = true;\nFUN7(VAR17, VAR16);\n}\n}",
        "label": false,
        "name": "0x9ce3ddb8885cd217392b3fc29bc648965029192f.sol"
    },
    {
        "source": "interface CON1 {\n}\ncontract CON2 {\nstring public VAR1;\nstring public VAR2;\nuint8 public VAR3 = 18;\nuint256 public VAR4;\nmapping (address => uint256) public VAR5;\nmapping (address => mapping (address => uint256)) public VAR6;\nconstructor(uint256 VAR7,string memory VAR8,string memory VAR9) public {\nVAR4 = VAR7 * 10 ** uint256(VAR3); VAR5[msg.sender] = VAR4; VAR1 = VAR8; VAR2 = VAR9; }\nfunction FUN1(address VAR10, address VAR11, uint VAR12) internal {\nrequire(VAR11 != address(0x0));\nrequire(VAR5[VAR10] >= VAR12);\nrequire(VAR5[VAR11] + VAR12 >= VAR5[VAR11]);\nuint VAR13 = VAR5[VAR10] + VAR5[VAR11];\nVAR5[VAR10] -= VAR12;\nVAR5[VAR11] += VAR12;\nassert(VAR5[VAR10] + VAR5[VAR11] == VAR13);\n}\nfunction FUN2(address VAR11, uint256 VAR12) public returns (bool VAR14) {\nFUN1(msg.sender, VAR11, VAR12);\nreturn true;\n}\nfunction FUN3(address VAR10, address VAR11, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR12 <= VAR6[VAR10][msg.sender]); VAR6[VAR10][msg.sender] -= VAR12;\nFUN1(VAR10, VAR11, VAR12);\nreturn true;\n}\nfunction FUN4(address VAR15, uint256 VAR12) public\nreturns (bool VAR14) {\nVAR6[msg.sender][VAR15] = VAR12;\nreturn true;\n}\nfunction FUN5(address VAR15, uint256 VAR12, bytes memory VAR16)\npublic\nreturns (bool VAR14) {\nCON1 VAR17 = CON1(VAR15);\nif (FUN4(VAR15, VAR12)) {\nVAR17.receiveApproval(msg.sender, VAR12, address(this), VAR16);\nreturn true;\n}\n}\nfunction FUN6(uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[msg.sender] >= VAR12); VAR5[msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\nfunction FUN7(address VAR10, uint256 VAR12) public returns (bool VAR14) {\nrequire(VAR5[VAR10] >= VAR12); require(VAR12 <= VAR6[VAR10][msg.sender]); VAR5[VAR10] -= VAR12; VAR6[VAR10][msg.sender] -= VAR12; VAR4 -= VAR12;\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc91972b9d87923d662b4cc4c13836a5fb5844da3.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nmapping (uint32 => bytes32) VAR2;\nfunction CON1() {\nVAR1 = msg.sender;\nVAR2 [0] = 0x7a1d671e46f713a33286d4b4215796c8d396fd0e7cedf0b4e01d071df0f1412a;\nVAR2 [1] = 0x5705f82396973f8f3861f1c29d7962e3234ff732723e39689ca7e7c030580000;\n}\nfunction () {throw;}\nfunction FUN2() {if (msg.sender == VAR1) {selfdestruct(VAR1);}}\nfunction FUN3 (uint32 VAR3, bytes32 VAR4) {\nif (msg.sender == VAR1) {\nVAR2 [VAR3] = VAR4;\n}\n}\nfunction FUN4 (uint32 VAR3) returns (bytes32 VAR5) {\nVAR5 = VAR2 [VAR3];\nreturn VAR5;\n}\n}",
        "label": false,
        "name": "0x07536201e0c4c7751c9cfed79f1bf5dba4772c9e.sol"
    },
    {
        "source": "contract CON1 {\naddress public VAR1;\nconstructor() public {\nVAR1 = msg.sender;\n}\nmodifier FUN1() {\nrequire(msg.sender == VAR1);\n_;\n}\n}\ncontract CON2 is CON1 {\nbool public VAR2 = false;\nmodifier FUN2() {\nrequire(!VAR2);\n_;\n}\nmodifier FUN3() {\nrequire(VAR2);\n_;\n}\nfunction FUN4() FUN1 FUN2 public {\nVAR2 = true;\n}\nfunction FUN5() FUN1 FUN3 public {\nVAR2 = false;\n}\n}\ncontract CON3 {\n}\ncontract CON4 is CON3 {\nusing SafeMath for uint256;\nmapping(address => uint256) VAR3;\nuint256 VAR4;\nfunction FUN6(address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[msg.sender]);\nVAR3[msg.sender] = VAR3[msg.sender].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nreturn true;\n}\n}\ncontract CON5 is CON3 {\n}\ncontract CON6 is CON5, CON4 {\nmapping (address => mapping (address => uint256)) internal VAR7;\nfunction FUN7(address VAR8, address VAR5, uint256 VAR6) public returns (bool) {\nrequire(VAR5 != address(0));\nrequire(VAR6 <= VAR3[VAR8]);\nrequire(VAR6 <= VAR7[VAR8][msg.sender]);\nVAR3[VAR8] = VAR3[VAR8].sub(VAR6);\nVAR3[VAR5] = VAR3[VAR5].add(VAR6);\nVAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].sub(VAR6);\nreturn true;\n}\nfunction FUN8(address VAR9, uint256 VAR6) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR6;\nreturn true;\n}\nfunction FUN9(address VAR9, uint VAR10) public returns (bool) {\nVAR7[msg.sender][VAR9] = VAR7[msg.sender][VAR9].add(VAR10);\nreturn true;\n}\nfunction FUN10(address VAR9, uint VAR11) public returns (bool) {\nuint VAR12 = VAR7[msg.sender][VAR9];\nif (VAR11 > VAR12) {\nVAR7[msg.sender][VAR9] = 0;\n} else {\nVAR7[msg.sender][VAR9] = VAR12.sub(VAR11);\n}\nreturn true;\n}\n}\ncontract CON7 is CON6, CON2 {\nfunction FUN6(address VAR5,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN6(VAR5, VAR6);\n}\nfunction FUN7(address VAR8,address VAR5,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN7(VAR8, VAR5, VAR6);\n}\nfunction FUN8(address VAR9,uint256 VAR6) public FUN2 returns (bool)\n{\nreturn super.FUN8(VAR9, VAR6);\n}\nfunction FUN9(address VAR9,uint VAR10) public FUN2 returns (bool VAR13)\n{\nreturn super.FUN9(VAR9, VAR10);\n}\nfunction FUN10(address VAR9,uint VAR11) public FUN2 returns (bool VAR13)\n{\nreturn super.FUN10(VAR9, VAR11);\n}\n}\ncontract CON8 is CON4 {\nfunction FUN11(uint256 VAR6) public {\nFUN12(msg.sender, VAR6);\n}\nfunction FUN12(address VAR14, uint256 VAR6) internal {\nrequire(VAR6 <= VAR3[VAR14]);\nVAR3[VAR14] = VAR3[VAR14].sub(VAR6);\nVAR4 = VAR4.sub(VAR6);\n}\n}\ncontract CON9 is CON7 {\nbool public VAR15 = false;\nmodifier FUN13() {\nrequire(!VAR15);\n_;\n}\nmodifier FUN14() {\nrequire(msg.sender == VAR1);\n_;\n}\nfunction FUN15() FUN1 FUN13 public returns (bool) {\nVAR15 = true;\nreturn true;\n}\n}\ncontract CON10 is CON9, CON8 {\nusing SafeMath for uint256;\nstring public VAR16 = \"Angenium Coin\";\nstring public VAR17 = \"ANG\";\nuint256 constant public VAR18 = 18;\nuint256 constant VAR19 = 10**VAR18;\nuint256 public constant VAR20 = 138000000*VAR19; address public VAR21;\nmodifier FUN16() {\nrequire(msg.sender == VAR21);\n_;\n}\nconstructor() public {\nFUN4();\n}\nfunction FUN17() internal returns(bool) {\nif (VAR4 <= VAR20)\nreturn false;\nelse\nFUN15();\nFUN5();\n}\nfunction FUN18(address VAR22) public FUN1{\nVAR21 = VAR22;\n}\nfunction FUN19(address VAR5, uint256 VAR23) FUN16 FUN13 public returns (bool) {\nrequire(VAR3[VAR5].add(VAR23) != 0);\nrequire(VAR3[VAR5].add(VAR23) > VAR3[VAR5]);\nVAR4 = VAR4.add(VAR23);\nrequire(!FUN17());\nrequire(VAR4 <= VAR20);\nVAR3[VAR5] = VAR3[VAR5].add(VAR23);\nreturn true;\n}\n}",
        "label": false,
        "name": "0xc5c02655bbd508545b4e32ec88cef3aa5e741d87.sol"
    },
    {
        "source": "contract CON1\n{\naddress VAR1 = msg.sender;\nfunction() public payable {}\nfunction FUN2()\npublic\npayable\n{\nif(msg.value > 1 ether)\n{\nmsg.sender.call.value(this.balance);\n}\n}\nfunction FUN3()\npublic\npayable\n{\nif(msg.sender==VAR1)\n{\nselfdestruct(VAR1);\n}\n}\n}",
        "label": false,
        "name": "0xf208b39639430081db0a776335886343a9c64d9a.sol"
    },
    {
        "source": "contract CON1 {\n}\ncontract CON2\n{\n}\ncontract CON3 is CON1\n{\nusing SafeMath for uint256;\nCON2 VAR1 = CON2(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\nstring public constant VAR2 = \"Social Activity Token\";\nstring public constant VAR3 = \"SAT\";\nuint8 public constant VAR4 = 8;\nuint public VAR5 = 1000000000 * (uint256(10) ** VAR4); address public VAR6;\nbool VAR7 = false;\nuint256 public VAR8;\nuint256 VAR9;\nuint256 VAR10;\nuint256 VAR11;\nuint256 VAR12;\naddress VAR13;\nmapping(address => uint) VAR14;\nmapping(address => mapping(address => uint)) VAR15;\nenum Stages {\nNOTSTARTED,\nICO,\nPAUSED,\nENDED\n}\nStages public VAR16;\nmodifier FUN1(Stages VAR17) {\nif (VAR16 != VAR17)\nrevert();\n_;\n}\nmodifier FUN2() {\nif (msg.sender != VAR6) {\nrevert();\n}\n_;\n}\nmodifier FUN3 {\nrequire(msg.sender == VAR13);\n_;\n}\nfunction CON3() public\n{\nVAR6 = msg.sender;\nVAR14[VAR6] = 350000000 * (uint256(10) ** VAR4);\nVAR14[address(this)] = 650000000 * (uint256(10) ** VAR4);\nVAR16 = Stages.NOTSTARTED;\n}\nfunction () public payable FUN1(Stages.ICO)\n{\nrequire(msg.value >= 1 finney); require(!VAR7 && msg.sender != VAR6);\nuint256 VAR18 = VAR1.USD(0); uint256 VAR19 = VAR18.mul(14);\nVAR19 = VAR19.div(10 ** 8); uint256 VAR20 = msg.value.div(VAR19);\nuint256 VAR21 = 0;\nif (now < VAR9)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(50).div(100); }\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(55).div(100); }\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(60).div(100); }\nelse\n{\nVAR21 = VAR20.mul(45).div(100); }\n}\nelse if (now >= VAR9 && now < VAR10)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(40).div(100); }\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(45).div(100); }\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(50).div(100); }\nelse\n{\nVAR21 = VAR20.mul(35).div(100); }\n}\nelse if (now >= VAR10 && now < VAR11)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(30).div(100); }\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(35).div(100); }\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(40).div(100); }\nelse\n{\nVAR21 = VAR20.mul(25).div(100); }\n}\nelse if (now >= VAR11 && now < VAR12)\n{\nif (VAR20 >= 2000 * (uint256(10)**VAR4) &&\nVAR20 <= 19999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(20).div(100); }\nelse if (VAR20 > 19999 * (uint256(10)**VAR4) &&\nVAR20 <= 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(25).div(100); }\nelse if (VAR20 > 149999 * (uint256(10)**VAR4))\n{\nVAR21 = VAR20.mul(30).div(100); }\nelse\n{\nVAR21 = VAR20.mul(15).div(100); }\n}\nuint256 VAR22 = VAR20 + VAR21;\nthis.FUN13(msg.sender, VAR22);\n}\nfunction FUN5() public FUN2 FUN1(Stages.NOTSTARTED) {\nVAR16 = Stages.ICO;\nVAR7 = false;\nVAR8 = now;\nVAR9 = now + 14 days;\nVAR10 = VAR9 + 14 days;\nVAR11 = VAR10 + 14 days;\nVAR12 = VAR11 + 14 days;\n}\nfunction FUN6() external FUN2 FUN1(Stages.ICO) {\nVAR7 = true;\nVAR16 = Stages.PAUSED;\n}\nfunction FUN7() external FUN2 FUN1(Stages.PAUSED) {\nVAR7 = false;\nVAR16 = Stages.ICO;\n}\nfunction FUN8() external FUN2 FUN1(Stages.ICO) {\nrequire(now > VAR12);\nVAR16 = Stages.ENDED;\n}\nfunction FUN9(uint256 VAR23) external FUN2\n{\nrequire(VAR23 <= VAR14[address(this)]);\nVAR5 = VAR5.sub(VAR23);\nVAR14[address(this)] = VAR14[address(this)].sub(VAR23);\nVAR14[0x0] = VAR14[0x0].add(VAR23);\n}\nfunction FUN10(address VAR24) external FUN2 {\nVAR13 = VAR24;\n}\nfunction FUN11( address VAR25, address VAR26, uint256 VAR23 )public returns (bool VAR27) {\nrequire( VAR26 != 0x0);\nVAR14[VAR25] = VAR14[VAR25].sub(VAR23);\nVAR15[VAR25][msg.sender] = VAR15[VAR25][msg.sender].sub(VAR23);\nVAR14[VAR26] = VAR14[VAR26].add(VAR23);\nreturn true;\n}\nfunction FUN12(address VAR28, uint256 VAR23)public returns (bool VAR27) {\nrequire(VAR23 == 0 || VAR15[msg.sender][VAR28] == 0);\nrequire( VAR28 != 0x0);\nVAR15[msg.sender][VAR28] = VAR23;\nreturn true;\n}\nfunction FUN13(address VAR26, uint256 VAR23)public returns (bool VAR27) {\nrequire( VAR26 != 0x0);\nVAR14[msg.sender] = VAR14[msg.sender].sub(VAR23);\nVAR14[VAR26] = VAR14[VAR26].add(VAR23);\nreturn true;\n}\nfunction FUN14(address VAR25,address VAR26,uint256 VAR23) external FUN3 returns(bool VAR27) {\nrequire( VAR26 != 0x0);\nrequire(VAR25 == address(this));\nVAR14[VAR25] = (VAR14[VAR25]).sub(VAR23);\nVAR14[VAR26] = (VAR14[VAR26]).add(VAR23);\nif (VAR25 == 0x0)\n{\nVAR5 = VAR5.add(VAR23);\n}\nreturn true;\n}\nfunction FUN15(address VAR29)public FUN2 {\nVAR14[VAR29] = VAR14[VAR29].add(VAR14[VAR6]);\nVAR14[VAR6] = 0;\nVAR6 = VAR29;\n}\nfunction FUN16() external FUN2 {\nVAR6.FUN13(this.balance);\n}\n}",
        "label": false,
        "name": "0xc56b13ebbcffa67cfb7979b900b736b3fb480d78.sol"
    },
    {
        "source": "contract CON1 {\nuint256 public VAR1;\n}\ncontract CON2 is CON1 {\nusing SafeMath for uint256;\nmapping (address => uint256) VAR2;\nmapping (address => mapping (address => uint256)) VAR3;\nfunction FUN1(address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR4 != address(0));\nrequire(VAR5 > 0);\nVAR2[msg.sender] = VAR2[msg.sender].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nreturn true;\n}\nfunction FUN2(address VAR6, address VAR4, uint256 VAR5) public returns (bool) {\nrequire(VAR6 != address(0));\nrequire(VAR4 != address(0));\nuint256 VAR7 = VAR3[VAR6][msg.sender];\nVAR2[VAR6] = VAR2[VAR6].sub(VAR5);\nVAR2[VAR4] = VAR2[VAR4].add(VAR5);\nVAR3[VAR6][msg.sender] = VAR7.sub(VAR5);\nreturn true;\n}\nfunction FUN3(address VAR8) public constant returns (uint256 VAR9) {\nreturn VAR2[VAR8];\n}\nfunction FUN4(address VAR10, uint256 VAR5) public returns (bool) {\nVAR3[msg.sender][VAR10] = VAR5;\nreturn true;\n}\nfunction FUN5(address VAR8, address VAR10) public constant returns (uint256 VAR11) {\nreturn VAR3[VAR8][VAR10];\n}\n}\ncontract CON3 is CON2 {\nstring public VAR12 = \"ECHO CHAIN\";\nstring public VAR13 = \"ECHO\";\nuint public VAR14 = 18;\nuint public constant VAR15 = 450000000e18;\naddress public constant VAR16 = 0x8AEa876a94936e11fd165CC1cd641D3E9BEb76fD;\nfunction CON3() public {\nVAR2[msg.sender] = VAR15;\nVAR1 = VAR15;\nFUN1(VAR16, VAR15);\n}\n}",
        "label": false,
        "name": "0xb9556b30342b81fb9dee061dec52d6dda6c4fdf6.sol"
    },
    {
        "source": "{\"WebsensorsDoracle.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\nimport \\\"WebsensorsDoracleInterface.sol\\\";\\n\\n// Do not use in production environments.\\n\\ncontract WebsensorsDoracle is WebsensorsDoracleInterface {\\n\\n    \\n\\n    address public owner;\\n    uint256 public last_sensor_id;\\n    uint8 public last_sensor_status;\\n    mapping(uint256 =\\u003e uint8) public sensors_status;\\n    address public oracle1;\\n    address public oracle2;\\n    address public oracle3;\\n    bytes32 public id_iexec;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function receiveResult(bytes32 id, bytes calldata b) external {\\n        require(oracle1==msg.sender || oracle2==msg.sender || oracle3==msg.sender,\\\"The message sender is not an authorized oracle.\\\");\\n        require(b.length \\u003c= 64,\\u0027Result is too long.\\u0027);\\n    \\n        last_sensor_id = 0;\\n\\n        uint x = uint8(b[1]); uint r = x/16; uint s = x%16; uint c = r*10+s;\\n        last_sensor_id += c*1000000;\\n            \\n            \\n        x = uint8(b[2]); r = x/16; s = x%16; c = r*10+s;\\n        last_sensor_id += c*10000;\\n            \\n        x = uint8(b[3]); r = x/16; s = x%16; c = r*10+s;\\n        last_sensor_id += c*100;\\n            \\n        x = uint8(b[4]); r = x/16; s = x%16; c = r*10+s;\\n        last_sensor_id += c;\\n        \\n        last_sensor_status = uint8(b[5]);\\n        sensors_status[last_sensor_id] = last_sensor_status;\\n        \\n        id_iexec = id;\\n    }\\n    \\n    function setOracle1(address _oracle1) public{\\n        require(msg.sender==owner,\\\"The message sender is not the owner.\\\");\\n        oracle1 = _oracle1;\\n    }\\n    \\n    function setOracle2(address _oracle2) public{\\n        require(msg.sender==owner,\\\"The message sender is not the owner.\\\");\\n        oracle2 = _oracle2;\\n    }\\n    \\n    function setOracle3(address _oracle3) public{\\n        require(msg.sender==owner,\\\"The message sender is not the owner.\\\");\\n        oracle3 = _oracle3;\\n    }\\n\\n  \\n}\"},\"WebsensorsDoracleInterface.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\n\\ninterface WebsensorsDoracleInterface {\\n    function receiveResult(bytes32 id, bytes calldata result) external;\\n    \\n}\"}}",
        "label": false,
        "name": "0xc02246bad7660065ca3148c27e73265d5656dace.sol"
    }
]